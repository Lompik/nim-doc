This is nim-ref-0.13.0.info, produced by texi2any version 6.0 from
nim-ref-0.13.0.texi.


File: nim-ref-0.13.0.info,  Node: Top,  Next: /system,  Up: (dir)

Nim info Manual
***************

* Menu:


* /system::
* /prelude::
* /nimrtl::
* /impure/nre::
* /impure/rdstdin::
* /impure/re::
* /impure/db_postgres::
* /impure/osinfo_posix::
* /impure/db_odbc::
* /impure/osinfo_win::
* /impure/db_mysql::
* /impure/ssl::
* /impure/db_sqlite::
* /impure/nre/private/util::
* /packages/docutils/rstast::
* /packages/docutils/highlite::
* /packages/docutils/rst::
* /packages/docutils/rstgen::
* /pure/future::
* /pure/fsmonitor::
* /pure/httpclient::
* /pure/marshal::
* /pure/pegs::
* /pure/parsesql::
* /pure/uri::
* /pure/complex::
* /pure/os::
* /pure/stats::
* /pure/typetraits::
* /pure/parsexml::
* /pure/unittest::
* /pure/nimprof::
* /pure/oswalkdir::
* /pure/asyncnet::
* /pure/xmldom::
* /pure/unicode::
* /pure/colors::
* /pure/md5::
* /pure/basic3d::
* /pure/oids::
* /pure/math::
* /pure/securehash::
* /pure/terminal::
* /pure/parseopt2::
* /pure/xmlparser::
* /pure/fenv::
* /pure/strutils::
* /pure/asyncdispatch::
* /pure/net::
* /pure/dynlib::
* /pure/romans::
* /pure/options::
* /pure/encodings::
* /pure/etcpriv::
* /pure/parsecsv::
* /pure/coro::
* /pure/numeric::
* /pure/parsecfg::
* /pure/times::
* /pure/events::
* /pure/basic2d::
* /pure/strtabs::
* /pure/db_common::
* /pure/lexbase::
* /pure/ropes::
* /pure/asyncftpclient::
* /pure/base64::
* /pure/smtp::
* /pure/xmltree::
* /pure/mimetypes::
* /pure/rationals::
* /pure/selectors::
* /pure/mersenne::
* /pure/browsers::
* /pure/parseopt::
* /pure/memfiles::
* /pure/asyncfile::
* /pure/osproc::
* /pure/endians::
* /pure/nativesockets::
* /pure/subexes::
* /pure/json::
* /pure/httpserver::
* /pure/cgi::
* /pure/htmlgen::
* /pure/ospaths::
* /pure/asynchttpserver::
* /pure/streams::
* /pure/htmlparser::
* /pure/gentabs::
* /pure/cookies::
* /pure/poly::
* /pure/matchers::
* /pure/parseutils::
* /pure/scgi::
* /pure/hashes::
* /pure/logging::
* /pure/xmldomparser::
* /pure/algorithm::
* /pure/concurrency/cpuinfo::
* /pure/concurrency/threadpool::
* /pure/concurrency/cpuload::
* /pure/unidecode/unidecode::
* /pure/collections/sequtils::
* /pure/collections/sharedtables::
* /pure/collections/rtarrays::
* /pure/collections/tables::
* /pure/collections/sharedstrings::
* /pure/collections/critbits::
* /pure/collections/intsets::
* /pure/collections/tableimpl::
* /pure/collections/queues::
* /pure/collections/sets::
* /pure/collections/sharedlist::
* /pure/collections/lists::
* /deprecated/pure/rawsockets::
* /deprecated/pure/sockets::
* /deprecated/pure/parseurl::
* /deprecated/pure/actors::
* /deprecated/pure/asyncio::
* /deprecated/pure/ftpclient::
* /deprecated/core/unsigned::
* /wrappers/libsvm::
* /wrappers/pcre::
* /wrappers/pdcurses::
* /wrappers/tinyc::
* /wrappers/iup::
* /wrappers/sqlite3::
* /wrappers/odbcsql::
* /wrappers/libuv::
* /wrappers/joyent_http_parser::
* /wrappers/openssl::
* /wrappers/postgres::
* /wrappers/mysql::
* /wrappers/linenoise/linenoise::
* /windows/winlean::
* /js/dom::
* /posix/inotify::
* /posix/linux::
* /posix/posix::
* /posix/termios::
* /posix/epoll::
* /posix/kqueue::
* /core/macros::
* /core/typeinfo::
* /core/locks::
* /system/avltree::
* /system/excpt::
* /system/gc_common::
* /system/assign::
* /system/sysspawn::
* /system/gc_ms::
* /system/cgprocs::
* /system/inclrtl::
* /system/repr::
* /system/gc::
* /system/dyncalls::
* /system/syslocks::
* /system/atomics::
* /system/sysio::
* /system/gc2::
* /system/jssys::
* /system/reprjs::
* /system/profiler::
* /system/nimscript::
* /system/sysstr::
* /system/timers::
* /system/deepcopy::
* /system/embedded::
* /system/cellsets::
* /system/arithm::
* /system/debugger::
* /system/widestrs::
* /system/sets::
* /system/endb::
* /system/hti::
* /system/mmdisp::
* /system/channels::
* /system/platforms::
* /system/chcks::
* /system/threads::
* /system/ansi_c::
* /system/alloc::


* Command and Function Index:: Functions
* Variable Index:: variables

hello!


File: nim-ref-0.13.0.info,  Node: /system,  Next: /prelude,  Prev: Top,  Up: Top

1 Constant variables
********************

   * off
          off* = false

     alias for 'false'

   * appType
          appType* {.magic: "AppType".}: string = ""

     a string that describes the application type.  Possible values:
     "console", "gui", "lib".

   * NoFakeVars
          NoFakeVars* = defined(nimscript)

     true if the backend doesn't support "fake variables" like 'var
     EBADF {.importc.}: cint'.

   * QuitFailure
          QuitFailure* = 1

     is the value that should be passed to quit (#quit) to indicate
     failure.

   * NimVersion
          NimVersion*: string = $ NimMajor & "." & $ NimMinor & "." & $ NimPatch

     is the version of Nim as a string.

2 Let variable
**************

   * nimvm
          nimvm* {.magic: "Nimvm".}: bool = false

     may be used only in "when" expression.  It is true in Nim VM
     context and false otherwise

3 Variables
***********

   * programResult
          programResult* {.exportc: "nim_program_result".}: int

     modify this variable to specify the exit code of the program under
     normal circumstances.  When the program is terminated prematurely
     using 'quit', this value is ignored.

   * outOfMemHook
          outOfMemHook*: proc () {.nimcall, tags: [], benign.}

     set this variable to provide a procedure that should be called in
     case of an out of memory event.  The standard handler writes an
     error message and terminates the program.  outOfMemHook can be used
     to raise an exception in case of OOM like so:
     var gOutOfMem: ref EOutOfMemory
     new(gOutOfMem) # need to be allocated *before* OOM really happened!
     gOutOfMem.msg = "out of memory"

     proc handleOOM() =
       raise gOutOfMem

     system.outOfMemHook = handleOOM

     If the handler does not raise an exception, ordinary control flow
     continues and the program is terminated.

   * stderr
          stderr* {.importc: "stderr", header: "<stdio.h>".}: File

     The standard error stream.

4 Types
*******

   * float64
          float64* {.magic: Float.}

     64 bit floating point type

   * bool false = 0, true = 1
          bool* {.magic: Bool.} = enum
            false = 0, true = 1

     built-in boolean type

   * pointer
          pointer* {.magic: Pointer.}

     built-in pointer type, use the 'addr' operator to get a pointer to
     a variable

   * SomeNumber
          SomeNumber* = SomeInteger | SomeReal

     type class matching all number types

   * set
          set* {.magic: "Set".}[T]

     Generic type to construct bit sets.

   * Slice a*, b*: T ## the bounds

          Slice*[T] = object
            a*, b*: T                     ## the bounds


     builtin slice type

   * guarded
          guarded* {.magic: "Guarded".}

   * TResult Failure, Success
          TResult* {.deprecated.} = enum
            Failure, Success

   * Endianness littleEndian, bigEndian
          Endianness* = enum
            littleEndian, bigEndian

     is a type describing the endianness of a processor.

   * TaintedString
          TaintedString* = distinct string

     a distinct string type that is tainted.  It is an alias for
     'string' if the taint mode is not turned on.  Use the
     '-d:taintMode' command line switch to turn the taint mode on.

   * BiggestFloat
          BiggestFloat* = float64

     is an alias for the biggest floating point type the Nim compiler
     supports.  Currently this is 'float64', but it is
     platform-dependant in general.

   * culong
          culong* {.importc: "unsigned long", nodecl.} = uint32

     This is the same as the type 'unsigned long' in _C_.

   * PInt32
          PInt32* = ptr int32

     an alias for 'ptr int32'

   * GC_Strategy gcThroughput, ## optimize for throughput
     gcResponsiveness, ## optimize for responsiveness (default)
     gcOptimizeTime, ## optimize for speed gcOptimizeSpace ## optimize
     for memory footprint
          GC_Strategy* = enum
            gcThroughput,               ## optimize for throughput
            gcResponsiveness,           ## optimize for responsiveness (default)
            gcOptimizeTime,             ## optimize for speed
            gcOptimizeSpace             ## optimize for memory footprint

     the strategy the GC should use for the application

   * TFrame prev*: PFrame ## previous frame; used for chaining the call
     stack procname*: cstring ## name of the proc that is currently
     executing line*: int ## line number of the proc that is currently
     executing filename*: cstring ## filename of the proc that is
     currently executing len*: int16 ## length of the inspectable slots
     calldepth*: int16 ## used for max call depth checking

          TFrame* {.importc, nodecl, final.} = object
            prev*: PFrame                ## previous frame; used for chaining the call stack
            procname*: cstring           ## name of the proc that is currently executing
            line*: int                   ## line number of the proc that is currently executing
            filename*: cstring           ## filename of the proc that is currently executing
            len*: int16                  ## length of the inspectable slots
            calldepth*: int16            ## used for max call depth checking


     the frame itself

   * FileHandle
          FileHandle* = cint

     type that represents an OS file handle; this is useful for
     low-level file access

   * NimNode
          NimNode* {.magic: "PNimrodNode".} = ref NimNodeObj

     represents a Nim AST node.  Macros operate on this type.

5 Procedures
************

   * defined
          proc defined*(x: expr): bool {.magic: "Defined", noSideEffect, compileTime.}

     Special compile-time procedure that checks whether x is defined.  x
     is an external symbol introduced through the compiler's -d:x switch
     (nimc.html#compile-time-symbols) to enable build time conditionals:
     when not defined(release):
       # Do here programmer friendly expensive sanity checks.
     # Put here the normal code

   * declared
          proc declared*(x: expr): bool {.magic: "Defined", noSideEffect, compileTime.}

     Special compile-time procedure that checks whether x is declared.
     x has to be an identifier or a qualified identifier.  This can be
     used to check whether a library provides a certain feature or not:
     when not declared(strutils.toUpper):
       # provide our own toUpper proc here, because strutils is
       # missing it.

   * definedInScope deprecated, compileTime.}
          proc definedInScope*(x: expr): bool {.magic: "DefinedInScope", noSideEffect,
                                            deprecated, compileTime.}

     *Deprecated since version 0.9.6*: Use 'declaredInScope' instead.

   * declaredInScope compileTime.}
          proc declaredInScope*(x: expr): bool {.magic: "DefinedInScope", noSideEffect,
                                             compileTime.}

     Special compile-time procedure that checks whether x is declared in
     the current scope.  x has to be an identifier.

   * 'addr'
          proc `addr`*[T](x: var T): ptr T {.magic: "Addr", noSideEffect.}

     Builtin 'addr' operator for taking the address of a memory
     location.  Cannot be overloaded.
     var
       buf: seq[char] = @['a','b','c']
       p: pointer = buf[1].addr
     echo cast[ptr char](p)[]    # b

   * unsafeAddr
          proc unsafeAddr*[T](x: var T): ptr T {.magic: "Addr", noSideEffect.}

     Builtin 'addr' operator for taking the address of a memory
     location.  This works even for 'let' variables or parameters for
     better interop with C and so it is considered even more unsafe than
     the ordinary 'addr'.  Cannot be overloaded.

   * 'type'
          proc `type`*(x: expr): typeDesc {.magic: "TypeOf", noSideEffect, compileTime.}

     Builtin 'type' operator for accessing the type of an expression.
     Cannot be overloaded.

   * 'not'
          proc `not`*(x: bool): bool {.magic: "Not", noSideEffect.}

     Boolean not; returns true iff 'x == false'.

   * 'and'
          proc `and`*(x, y: bool): bool {.magic: "And", noSideEffect.}

     Boolean 'and'; returns true iff 'x == y == true'.  Evaluation is
     lazy: if 'x' is false, 'y' will not even be evaluated.

   * 'or'
          proc `or`*(x, y: bool): bool {.magic: "Or", noSideEffect.}

     Boolean 'or'; returns true iff 'not (not x and not y)'.  Evaluation
     is lazy: if 'x' is true, 'y' will not even be evaluated.

   * 'xor'
          proc `xor`*(x, y: bool): bool {.magic: "Xor", noSideEffect.}

     Boolean exclusive or; returns true iff 'x != y'.

   * new
          proc new*[T](a: var ref T) {.magic: "New", noSideEffect.}

     creates a new object of type 'T' and returns a safe (traced)
     reference to it in 'a'.

   * new
          proc new*(T: typedesc): auto

     creates a new object of type 'T' and returns a safe (traced)
     reference to it as result value.

     When 'T' is a ref type then the resulting type will be 'T',
     otherwise it will be 'ref T'.

   * internalNew
          proc internalNew*[T](a: var ref T) {.magic: "New", noSideEffect.}

     leaked implementation detail.  Do not use.

   * new noSideEffect.}
          proc new*[T](a: var ref T; finalizer: proc (x: ref T) {.nimcall.}) {.magic: "NewFinalize",
              noSideEffect.}

     creates a new object of type 'T' and returns a safe (traced)
     reference to it in 'a'.  When the garbage collector frees the
     object, finalizer is called.  The finalizer may not keep a
     reference to the object pointed to by x.  The finalizer cannot
     prevent the GC from freeing the object.  Note: The finalizer refers
     to the type T, not to the object!  This means that for each object
     of type T the finalizer will be called!

   * reset
          proc reset*[T](obj: var T) {.magic: "Reset", noSideEffect.}

     resets an object obj to its initial (binary zero) value.  This
     needs to be called before any possible object branch transition.

   * high
          proc high*[T](x: T): T {.magic: "High", noSideEffect.}

     returns the highest possible index of an array, a sequence, a
     string or the highest possible value of an ordinal value x.  As a
     special semantic rule, x may also be a type identifier.
     'high(int)' is Nim's way of writing INT_MAX or MAX_INT.
     var arr = [1,2,3,4,5,6,7]
     high(arr) #=> 6
     high(2) #=> 9223372036854775807

   * low
          proc low*[T](x: T): T {.magic: "Low", noSideEffect.}

     returns the lowest possible index of an array, a sequence, a string
     or the lowest possible value of an ordinal value x.  As a special
     semantic rule, x may also be a type identifier.
     var arr = [1,2,3,4,5,6,7]
     low(arr) #=> 0
     low(2) #=> -9223372036854775808

   * '[]'
          proc `[]`*[I: Ordinal, T](a: T; i: I): T {.noSideEffect, magic: "ArrGet".}

   * '[]='
          proc `[]=`*[I: Ordinal, T, S](a: T; i: I; x: S) {.noSideEffect, magic: "ArrPut".}

   * '='
          proc `=`*[T](dest: var T; src: T) {.noSideEffect, magic: "Asgn".}

   * '..'
          proc `..`*[T](a, b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".}

     slice operator that constructs an interval '[a, b]', both a and b
     are inclusive.  Slices can also be used in the set constructor and
     in ordinal case statements, but then they are special-cased by the
     compiler.

   * '..'
          proc `..`*[T](b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".}

     slice operator that constructs an interval '[default(T), b]'

   * '=='
          proc `==`*[Enum: enum](x, y: Enum): bool {.magic: "EqEnum", noSideEffect.}

     Checks whether values within the _same enum_ have the same
     underlying value
     type
       Enum1 = enum
         Field1 = 3, Field2
       Enum2 = enum
         Place1, Place2 = 3
     var
       e1 = Field1
       e2 = Enum1(Place2)
     echo (e1 == e2) # true
     echo (e1 == Place2) # raises error

   * '=='
          proc `==`*(x, y: pointer): bool {.magic: "EqRef", noSideEffect.}

     var # this is a wildly dangerous example
       a = cast[pointer](0)
       b = cast[pointer](nil)
     echo (a == b) # true due to the special meaning of `nil`/0 as a pointer

   * '=='
          proc `==`*(x, y: string): bool {.magic: "EqStr", noSideEffect.}

     Checks for equality between two string variables

   * '=='
          proc `==`*(x, y: cstring): bool {.magic: "EqCString", noSideEffect.}

     Checks for equality between two cstring variables

   * '=='
          proc `==`*(x, y: char): bool {.magic: "EqCh", noSideEffect.}

     Checks for equality between two char variables

   * '=='
          proc `==`*(x, y: bool): bool {.magic: "EqB", noSideEffect.}

     Checks for equality between two bool variables

   * '=='
          proc `==`*[T](x, y: set[T]): bool {.magic: "EqSet", noSideEffect.}

     Checks for equality between two variables of type set
     var a = {1, 2, 2, 3} # duplication in sets is ignored
     var b = {1, 2, 3}
     echo (a == b) # true

   * '=='
          proc `==`*[T](x, y: ref T): bool {.magic: "EqRef", noSideEffect.}

     Checks that two ref variables refer to the same item

   * '=='
          proc `==`*[T](x, y: ptr T): bool {.magic: "EqRef", noSideEffect.}

     Checks that two ptr variables refer to the same item

   * '=='
          proc `==`*[T: proc](x, y: T): bool {.magic: "EqProc", noSideEffect.}

     Checks that two proc variables refer to the same procedure

   * '&lt;='
          proc `<=`*[Enum: enum](x, y: Enum): bool {.magic: "LeEnum", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: string): bool {.magic: "LeStr", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: char): bool {.magic: "LeCh", noSideEffect.}

   * '&lt;='
          proc `<=`*[T](x, y: set[T]): bool {.magic: "LeSet", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: bool): bool {.magic: "LeB", noSideEffect.}

   * '&lt;='
          proc `<=`*[T](x, y: ref T): bool {.magic: "LePtr", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: pointer): bool {.magic: "LePtr", noSideEffect.}

   * '&lt;'
          proc `<`*[Enum: enum](x, y: Enum): bool {.magic: "LtEnum", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: string): bool {.magic: "LtStr", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: char): bool {.magic: "LtCh", noSideEffect.}

   * '&lt;'
          proc `<`*[T](x, y: set[T]): bool {.magic: "LtSet", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: bool): bool {.magic: "LtB", noSideEffect.}

   * '&lt;'
          proc `<`*[T](x, y: ref T): bool {.magic: "LtPtr", noSideEffect.}

   * '&lt;'
          proc `<`*[T](x, y: ptr T): bool {.magic: "LtPtr", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: pointer): bool {.magic: "LtPtr", noSideEffect.}

   * unsafeNew
          proc unsafeNew*[T](a: var ref T; size: Natural) {.magic: "New", noSideEffect.}

     creates a new object of type 'T' and returns a safe (traced)
     reference to it in 'a'.  This is *unsafe* as it allocates an object
     of the passed 'size'.  This should only be used for optimization
     purposes when you know what you're doing!

   * sizeof
          proc sizeof*[T](x: T): int {.magic: "SizeOf", noSideEffect.}

     returns the size of 'x' in bytes.  Since this is a low-level proc,
     its usage is discouraged - using 'new' for the most cases suffices
     that one never needs to know 'x''s size.  As a special semantic
     rule, 'x' may also be a type identifier ('sizeof(int)' is valid).
     sizeof('A') #=> 1
     sizeof(2) #=> 8

   * sizeof
          proc sizeof*(x: typedesc): int {.magic: "SizeOf", noSideEffect.}

   * '&lt;'
          proc `<`*[T](x: Ordinal[T]): T {.magic: "UnaryLt", noSideEffect.}

     unary '<' that can be used for nice looking excluding ranges:
     for i in 0 .. <10: echo i

     Semantically this is the same as 'pred'.

   * succ
          proc succ*[T](x: Ordinal[T]; y = 1): T {.magic: "Succ", noSideEffect.}

     returns the 'y'-th successor of the value 'x'.  'T' has to be an
     ordinal type.  If such a value does not exist, 'EOutOfRange' is
     raised or a compile time error occurs.

   * pred
          proc pred*[T](x: Ordinal[T]; y = 1): T {.magic: "Pred", noSideEffect.}

     returns the 'y'-th predecessor of the value 'x'.  'T' has to be an
     ordinal type.  If such a value does not exist, 'EOutOfRange' is
     raised or a compile time error occurs.

   * inc
          proc inc*[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: "Inc", noSideEffect.}

     increments the ordinal 'x' by 'y'.  If such a value does not exist,
     'EOutOfRange' is raised or a compile time error occurs.  This is a
     short notation for: 'x = succ(x, y)'.
     var i = 2
     inc(i) #=> 3
     inc(i, 3) #=> 6

   * dec
          proc dec*[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: "Dec", noSideEffect.}

     decrements the ordinal 'x' by 'y'.  If such a value does not exist,
     'EOutOfRange' is raised or a compile time error occurs.  This is a
     short notation for: 'x = pred(x, y)'.
     var i = 2
     dec(i) #=> 1
     dec(i, 3) #=> -2

   * newSeq
          proc newSeq*[T](s: var seq[T]; len: Natural) {.magic: "NewSeq", noSideEffect.}

     creates a new sequence of type 'seq[T]' with length 'len'.  This is
     equivalent to 's = @[]; setlen(s, len)', but more efficient since
     no reallocation is needed.

     Note that the sequence will be filled with zeroed entries, which
     can be a problem for sequences containing strings since their value
     will be 'nil'.  After the creation of the sequence you should
     assign entries to the sequence instead of adding them.  Example:
     var inputStrings : seq[string]
     newSeq(inputStrings, 3)
     inputStrings[0] = "The fourth"
     inputStrings[1] = "assignment"
     inputStrings[2] = "would crash"
     #inputStrings[3] = "out of bounds"

   * newSeq
          proc newSeq*[T](len = 0.Natural): seq[T]

     creates a new sequence of type 'seq[T]' with length 'len'.

     Note that the sequence will be filled with zeroed entries, which
     can be a problem for sequences containing strings since their value
     will be 'nil'.  After the creation of the sequence you should
     assign entries to the sequence instead of adding them.  Example:
     var inputStrings = newSeq[string](3)
     inputStrings[0] = "The fourth"
     inputStrings[1] = "assignment"
     inputStrings[2] = "would crash"
     #inputStrings[3] = "out of bounds"

   * len magic: "LengthOpenArray", noSideEffect.}
          proc len*[TOpenArray: openArray | varargs](x: TOpenArray): int {.
              magic: "LengthOpenArray", noSideEffect.}

   * len
          proc len*(x: string): int {.magic: "LengthStr", noSideEffect.}

   * len
          proc len*(x: cstring): int {.magic: "LengthStr", noSideEffect.}

   * len
          proc len*[I, T](x: array[I, T]): int {.magic: "LengthArray", noSideEffect.}

   * len
          proc len*[T](x: seq[T]): int {.magic: "LengthSeq", noSideEffect.}

     returns the length of an array, an openarray, a sequence or a
     string.  This is roughly the same as 'high(T)-low(T)+1', but its
     resulting type is always an int.
     var arr = [1,1,1,1,1]
     len(arr) #=> 5
     for i in 0..<arr.len:
       echo arr[i] #=> 1,1,1,1,1

   * incl
          proc incl*[T](x: var set[T]; y: T) {.magic: "Incl", noSideEffect.}

     includes element 'y' to the set 'x'.  This is the same as 'x = x +
     {y}', but it might be more efficient.
     var a = initSet[int](4)
     a.incl(2) #=> {2}
     a.incl(3) #=> {2, 3}

   * excl
          proc excl*[T](x: var set[T]; y: T) {.magic: "Excl", noSideEffect.}

     excludes element 'y' to the set 'x'.  This is the same as 'x = x -
     {y}', but it might be more efficient.
     var b = {2,3,5,6,12,545}
     b.excl(5)  #=> {2,3,6,12,545}

   * card
          proc card*[T](x: set[T]): int {.magic: "Card", noSideEffect.}

     returns the cardinality of the set 'x', i.e.  the number of
     elements in the set.
     var i = {1,2,3,4}
     card(i) #=> 4

   * ord
          proc ord*[T](x: T): int {.magic: "Ord", noSideEffect.}

     returns the internal int value of an ordinal value 'x'.
     ord('A') #=> 65

   * chr
          proc chr*(u: range[0 .. 255]): char {.magic: "Chr", noSideEffect.}

     converts an int in the range 0..255 to a character.
     chr(65) #=> A

   * ze
          proc ze*(x: int8): int {.magic: "Ze8ToI", noSideEffect.}

     zero extends a smaller integer type to 'int'.  This treats x as
     unsigned.

   * ze
          proc ze*(x: int16): int {.magic: "Ze16ToI", noSideEffect.}

     zero extends a smaller integer type to 'int'.  This treats x as
     unsigned.

   * ze64
          proc ze64*(x: int8): int64 {.magic: "Ze8ToI64", noSideEffect.}

     zero extends a smaller integer type to 'int64'.  This treats x as
     unsigned.

   * ze64
          proc ze64*(x: int16): int64 {.magic: "Ze16ToI64", noSideEffect.}

     zero extends a smaller integer type to 'int64'.  This treats x as
     unsigned.

   * ze64
          proc ze64*(x: int32): int64 {.magic: "Ze32ToI64", noSideEffect.}

     zero extends a smaller integer type to 'int64'.  This treats x as
     unsigned.

   * ze64
          proc ze64*(x: int): int64 {.magic: "ZeIToI64", noSideEffect.}

     zero extends a smaller integer type to 'int64'.  This treats x as
     unsigned.  Does nothing if the size of an 'int' is the same as
     'int64'.  (This is the case on 64 bit processors.)

   * toU8
          proc toU8*(x: int): int8 {.magic: "ToU8", noSideEffect.}

     treats x as unsigned and converts it to a byte by taking the last 8
     bits from x.

   * toU16
          proc toU16*(x: int): int16 {.magic: "ToU16", noSideEffect.}

     treats x as unsigned and converts it to an 'int16' by taking the
     last 16 bits from x.

   * toU32
          proc toU32*(x: int64): int32 {.magic: "ToU32", noSideEffect.}

     treats x as unsigned and converts it to an 'int32' by taking the
     last 32 bits from x.

   * '+'
          proc `+`*(x: int): int {.magic: "UnaryPlusI", noSideEffect.}

   * '+'
          proc `+`*(x: int8): int8 {.magic: "UnaryPlusI", noSideEffect.}

   * '+'
          proc `+`*(x: int16): int16 {.magic: "UnaryPlusI", noSideEffect.}

   * '+'
          proc `+`*(x: int32): int32 {.magic: "UnaryPlusI", noSideEffect.}

   * '+'
          proc `+`*(x: int64): int64 {.magic: "UnaryPlusI", noSideEffect.}

     Unary + operator for an integer.  Has no effect.

   * '-'
          proc `-`*(x: int): int {.magic: "UnaryMinusI", noSideEffect.}

   * '-'
          proc `-`*(x: int8): int8 {.magic: "UnaryMinusI", noSideEffect.}

   * '-'
          proc `-`*(x: int16): int16 {.magic: "UnaryMinusI", noSideEffect.}

   * '-'
          proc `-`*(x: int32): int32 {.magic: "UnaryMinusI", noSideEffect.}

   * '-'
          proc `-`*(x: int64): int64 {.magic: "UnaryMinusI64", noSideEffect.}

     Unary - operator for an integer.  Negates x.

   * 'not'
          proc `not`*(x: int): int {.magic: "BitnotI", noSideEffect.}

   * 'not'
          proc `not`*(x: int8): int8 {.magic: "BitnotI", noSideEffect.}

   * 'not'
          proc `not`*(x: int16): int16 {.magic: "BitnotI", noSideEffect.}

   * 'not'
          proc `not`*(x: int32): int32 {.magic: "BitnotI", noSideEffect.}

     computes the bitwise complement of the integer x.

   * 'not'
          proc `not`*(x: int64): int64 {.magic: "BitnotI", noSideEffect.}

   * '+'
          proc `+`*(x, y: int): int {.magic: "AddI", noSideEffect.}

   * '+'
          proc `+`*(x, y: int8): int8 {.magic: "AddI", noSideEffect.}

   * '+'
          proc `+`*(x, y: int16): int16 {.magic: "AddI", noSideEffect.}

   * '+'
          proc `+`*(x, y: int32): int32 {.magic: "AddI", noSideEffect.}

     Binary + operator for an integer.

   * '+'
          proc `+`*(x, y: int64): int64 {.magic: "AddI", noSideEffect.}

   * '-'
          proc `-`*(x, y: int): int {.magic: "SubI", noSideEffect.}

   * '-'
          proc `-`*(x, y: int8): int8 {.magic: "SubI", noSideEffect.}

   * '-'
          proc `-`*(x, y: int16): int16 {.magic: "SubI", noSideEffect.}

   * '-'
          proc `-`*(x, y: int32): int32 {.magic: "SubI", noSideEffect.}

     Binary - operator for an integer.

   * '-'
          proc `-`*(x, y: int64): int64 {.magic: "SubI", noSideEffect.}

   * '*'
          proc `*`*(x, y: int): int {.magic: "MulI", noSideEffect.}

   * '*'
          proc `*`*(x, y: int8): int8 {.magic: "MulI", noSideEffect.}

   * '*'
          proc `*`*(x, y: int16): int16 {.magic: "MulI", noSideEffect.}

   * '*'
          proc `*`*(x, y: int32): int32 {.magic: "MulI", noSideEffect.}

     Binary * operator for an integer.

   * '*'
          proc `*`*(x, y: int64): int64 {.magic: "MulI", noSideEffect.}

   * 'div'
          proc `div`*(x, y: int): int {.magic: "DivI", noSideEffect.}

   * 'div'
          proc `div`*(x, y: int8): int8 {.magic: "DivI", noSideEffect.}

   * 'div'
          proc `div`*(x, y: int16): int16 {.magic: "DivI", noSideEffect.}

   * 'div'
          proc `div`*(x, y: int32): int32 {.magic: "DivI", noSideEffect.}

     computes the integer division.  This is roughly the same as
     'floor(x/y)'.
     1 div 2 == 0
     2 div 2 == 1
     3 div 2 == 1
     7 div 5 == 1

   * 'div'
          proc `div`*(x, y: int64): int64 {.magic: "DivI", noSideEffect.}

   * 'mod'
          proc `mod`*(x, y: int): int {.magic: "ModI", noSideEffect.}

   * 'mod'
          proc `mod`*(x, y: int8): int8 {.magic: "ModI", noSideEffect.}

   * 'mod'
          proc `mod`*(x, y: int16): int16 {.magic: "ModI", noSideEffect.}

   * 'mod'
          proc `mod`*(x, y: int32): int32 {.magic: "ModI", noSideEffect.}

     computes the integer modulo operation (remainder).  This is the
     same as 'x - (x div y) * y'.
     (7 mod 5) == 2

   * 'mod'
          proc `mod`*(x, y: int64): int64 {.magic: "ModI", noSideEffect.}

   * 'shr'
          proc `shr`*(x, y: int): int {.magic: "ShrI", noSideEffect.}

   * 'shr'
          proc `shr`*(x, y: int8): int8 {.magic: "ShrI", noSideEffect.}

   * 'shr'
          proc `shr`*(x, y: int16): int16 {.magic: "ShrI", noSideEffect.}

   * 'shr'
          proc `shr`*(x, y: int32): int32 {.magic: "ShrI", noSideEffect.}

   * 'shr'
          proc `shr`*(x, y: int64): int64 {.magic: "ShrI", noSideEffect.}

     computes the shift right operation of x and y, filling vacant bit
     positions with zeros.

   * 'shl'
          proc `shl`*(x, y: int): int {.magic: "ShlI", noSideEffect.}

   * 'shl'
          proc `shl`*(x, y: int8): int8 {.magic: "ShlI", noSideEffect.}

   * 'shl'
          proc `shl`*(x, y: int16): int16 {.magic: "ShlI", noSideEffect.}

   * 'shl'
          proc `shl`*(x, y: int32): int32 {.magic: "ShlI", noSideEffect.}

   * 'shl'
          proc `shl`*(x, y: int64): int64 {.magic: "ShlI", noSideEffect.}

     computes the shift left operation of x and y.
     1'i32 shl 4  == 0x0000_0010
     1'i64 shl 4  == 0x0000_0000_0000_0010

   * 'and'
          proc `and`*(x, y: int): int {.magic: "BitandI", noSideEffect.}

   * 'and'
          proc `and`*(x, y: int8): int8 {.magic: "BitandI", noSideEffect.}

   * 'and'
          proc `and`*(x, y: int16): int16 {.magic: "BitandI", noSideEffect.}

   * 'and'
          proc `and`*(x, y: int32): int32 {.magic: "BitandI", noSideEffect.}

   * 'and'
          proc `and`*(x, y: int64): int64 {.magic: "BitandI", noSideEffect.}

     computes the bitwise and of numbers x and y.
     (0xffff'i16 and 0x0010'i16) == 0x0010

   * 'or'
          proc `or`*(x, y: int): int {.magic: "BitorI", noSideEffect.}

   * 'or'
          proc `or`*(x, y: int8): int8 {.magic: "BitorI", noSideEffect.}

   * 'or'
          proc `or`*(x, y: int16): int16 {.magic: "BitorI", noSideEffect.}

   * 'or'
          proc `or`*(x, y: int32): int32 {.magic: "BitorI", noSideEffect.}

   * 'or'
          proc `or`*(x, y: int64): int64 {.magic: "BitorI", noSideEffect.}

     computes the bitwise or of numbers x and y.
     (0x0005'i16 or 0x0010'i16) == 0x0015

   * 'xor'
          proc `xor`*(x, y: int): int {.magic: "BitxorI", noSideEffect.}

   * 'xor'
          proc `xor`*(x, y: int8): int8 {.magic: "BitxorI", noSideEffect.}

   * 'xor'
          proc `xor`*(x, y: int16): int16 {.magic: "BitxorI", noSideEffect.}

   * 'xor'
          proc `xor`*(x, y: int32): int32 {.magic: "BitxorI", noSideEffect.}

   * 'xor'
          proc `xor`*(x, y: int64): int64 {.magic: "BitxorI", noSideEffect.}

     computes the bitwise xor of numbers x and y.
     (0x1011'i16 xor 0x0101'i16) == 0x1110

   * '=='
          proc `==`*(x, y: int): bool {.magic: "EqI", noSideEffect.}

   * '=='
          proc `==`*(x, y: int8): bool {.magic: "EqI", noSideEffect.}

   * '=='
          proc `==`*(x, y: int16): bool {.magic: "EqI", noSideEffect.}

   * '=='
          proc `==`*(x, y: int32): bool {.magic: "EqI", noSideEffect.}

   * '=='
          proc `==`*(x, y: int64): bool {.magic: "EqI", noSideEffect.}

     Compares two integers for equality.

   * '&lt;='
          proc `<=`*(x, y: int): bool {.magic: "LeI", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: int8): bool {.magic: "LeI", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: int16): bool {.magic: "LeI", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: int32): bool {.magic: "LeI", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: int64): bool {.magic: "LeI", noSideEffect.}

     Returns true iff x is less than or equal to y.

   * '&lt;'
          proc `<`*(x, y: int): bool {.magic: "LtI", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: int8): bool {.magic: "LtI", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: int16): bool {.magic: "LtI", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: int32): bool {.magic: "LtI", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: int64): bool {.magic: "LtI", noSideEffect.}

     Returns true iff x is less than y.

   * '+%'
          proc `+%`*(x, y: IntMax32): IntMax32 {.magic: "AddU", noSideEffect.}

   * '+%'
          proc `+%`*(x, y: int64): int64 {.magic: "AddU", noSideEffect.}

     treats x and y as unsigned and adds them.  The result is truncated
     to fit into the result.  This implements modulo arithmetic.  No
     overflow errors are possible.

   * '-%'
          proc `-%`*(x, y: IntMax32): IntMax32 {.magic: "SubU", noSideEffect.}

   * '-%'
          proc `-%`*(x, y: int64): int64 {.magic: "SubU", noSideEffect.}

     treats x and y as unsigned and subtracts them.  The result is
     truncated to fit into the result.  This implements modulo
     arithmetic.  No overflow errors are possible.

   * '*%'
          proc `*%`*(x, y: IntMax32): IntMax32 {.magic: "MulU", noSideEffect.}

   * '*%'
          proc `*%`*(x, y: int64): int64 {.magic: "MulU", noSideEffect.}

     treats x and y as unsigned and multiplies them.  The result is
     truncated to fit into the result.  This implements modulo
     arithmetic.  No overflow errors are possible.

   * '/%'
          proc `/%`*(x, y: IntMax32): IntMax32 {.magic: "DivU", noSideEffect.}

   * '/%'
          proc `/%`*(x, y: int64): int64 {.magic: "DivU", noSideEffect.}

     treats x and y as unsigned and divides them.  The result is
     truncated to fit into the result.  This implements modulo
     arithmetic.  No overflow errors are possible.

   * '%%'
          proc `%%`*(x, y: IntMax32): IntMax32 {.magic: "ModU", noSideEffect.}

   * '%%'
          proc `%%`*(x, y: int64): int64 {.magic: "ModU", noSideEffect.}

     treats x and y as unsigned and compute the modulo of x and y.  The
     result is truncated to fit into the result.  This implements modulo
     arithmetic.  No overflow errors are possible.

   * '&lt;=%'
          proc `<=%`*(x, y: IntMax32): bool {.magic: "LeU", noSideEffect.}

   * '&lt;=%'
          proc `<=%`*(x, y: int64): bool {.magic: "LeU64", noSideEffect.}

     treats x and y as unsigned and compares them.  Returns true iff
     'unsigned(x) <= unsigned(y)'.

   * '&lt;%'
          proc `<%`*(x, y: IntMax32): bool {.magic: "LtU", noSideEffect.}

   * '&lt;%'
          proc `<%`*(x, y: int64): bool {.magic: "LtU64", noSideEffect.}

     treats x and y as unsigned and compares them.  Returns true iff
     'unsigned(x) < unsigned(y)'.

   * 'not'
          proc `not`*[T: SomeUnsignedInt](x: T): T {.magic: "BitnotI", noSideEffect.}

     computes the bitwise complement of the integer x.

   * 'shr'
          proc `shr`*[T: SomeUnsignedInt](x, y: T): T {.magic: "ShrI", noSideEffect.}

     computes the shift right operation of x and y.

   * 'shl'
          proc `shl`*[T: SomeUnsignedInt](x, y: T): T {.magic: "ShlI", noSideEffect.}

     computes the shift left operation of x and y.

   * 'and'
          proc `and`*[T: SomeUnsignedInt](x, y: T): T {.magic: "BitandI", noSideEffect.}

     computes the bitwise and of numbers x and y.

   * 'or'
          proc `or`*[T: SomeUnsignedInt](x, y: T): T {.magic: "BitorI", noSideEffect.}

     computes the bitwise or of numbers x and y.

   * 'xor'
          proc `xor`*[T: SomeUnsignedInt](x, y: T): T {.magic: "BitxorI", noSideEffect.}

     computes the bitwise xor of numbers x and y.

   * '=='
          proc `==`*[T: SomeUnsignedInt](x, y: T): bool {.magic: "EqI", noSideEffect.}

     Compares two unsigned integers for equality.

   * '+'
          proc `+`*[T: SomeUnsignedInt](x, y: T): T {.magic: "AddU", noSideEffect.}

     Binary + operator for unsigned integers.

   * '-'
          proc `-`*[T: SomeUnsignedInt](x, y: T): T {.magic: "SubU", noSideEffect.}

     Binary - operator for unsigned integers.

   * '*'
          proc `*`*[T: SomeUnsignedInt](x, y: T): T {.magic: "MulU", noSideEffect.}

     Binary * operator for unsigned integers.

   * 'div'
          proc `div`*[T: SomeUnsignedInt](x, y: T): T {.magic: "DivU", noSideEffect.}

     computes the integer division.  This is roughly the same as
     'floor(x/y)'.
     (7 div 5) == 2

   * 'mod'
          proc `mod`*[T: SomeUnsignedInt](x, y: T): T {.magic: "ModU", noSideEffect.}

     computes the integer modulo operation (remainder).  This is the
     same as 'x - (x div y) * y'.
     (7 mod 5) == 2

   * '&lt;='
          proc `<=`*[T: SomeUnsignedInt](x, y: T): bool {.magic: "LeU", noSideEffect.}

     Returns true iff 'x <= y'.

   * '&lt;'
          proc `<`*[T: SomeUnsignedInt](x, y: T): bool {.magic: "LtU", noSideEffect.}

     Returns true iff 'unsigned(x) < unsigned(y)'.

   * '+'
          proc `+`*(x: float32): float32 {.magic: "UnaryPlusF64", noSideEffect.}

   * '-'
          proc `-`*(x: float32): float32 {.magic: "UnaryMinusF64", noSideEffect.}

   * '+'
          proc `+`*(x, y: float32): float32 {.magic: "AddF64", noSideEffect.}

   * '-'
          proc `-`*(x, y: float32): float32 {.magic: "SubF64", noSideEffect.}

   * '*'
          proc `*`*(x, y: float32): float32 {.magic: "MulF64", noSideEffect.}

   * '/'
          proc `/`*(x, y: float32): float32 {.magic: "DivF64", noSideEffect.}

   * '+'
          proc `+`*(x: float): float {.magic: "UnaryPlusF64", noSideEffect.}

   * '-'
          proc `-`*(x: float): float {.magic: "UnaryMinusF64", noSideEffect.}

   * '+'
          proc `+`*(x, y: float): float {.magic: "AddF64", noSideEffect.}

   * '-'
          proc `-`*(x, y: float): float {.magic: "SubF64", noSideEffect.}

   * '*'
          proc `*`*(x, y: float): float {.magic: "MulF64", noSideEffect.}

   * '/'
          proc `/`*(x, y: float): float {.magic: "DivF64", noSideEffect.}

     computes the floating point division

   * '=='
          proc `==`*(x, y: float32): bool {.magic: "EqF64", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: float32): bool {.magic: "LeF64", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: float32): bool {.magic: "LtF64", noSideEffect.}

   * '=='
          proc `==`*(x, y: float): bool {.magic: "EqF64", noSideEffect.}

   * '&lt;='
          proc `<=`*(x, y: float): bool {.magic: "LeF64", noSideEffect.}

   * '&lt;'
          proc `<`*(x, y: float): bool {.magic: "LtF64", noSideEffect.}

   * '*'
          proc `*`*[T](x, y: set[T]): set[T] {.magic: "MulSet", noSideEffect.}

     This operator computes the intersection of two sets.

   * '+'
          proc `+`*[T](x, y: set[T]): set[T] {.magic: "PlusSet", noSideEffect.}

     This operator computes the union of two sets.

   * '-'
          proc `-`*[T](x, y: set[T]): set[T] {.magic: "MinusSet", noSideEffect.}

     This operator computes the difference of two sets.

   * contains
          proc contains*[T](x: set[T]; y: T): bool {.magic: "InSet", noSideEffect.}

     One should overload this proc if one wants to overload the 'in'
     operator.  The parameters are in reverse order!  'a in b' is a
     template for 'contains(b, a)'.  This is because the unification
     algorithm that Nim uses for overload resolution works from left to
     right.  But for the 'in' operator that would be the wrong direction
     for this piece of code:
     var s: set[range['a'..'z']] = {'a'..'c'}
     writeLine(stdout, 'b' in s)

     If 'in' had been declared as '[T](elem: T, s: set[T])' then 'T'
     would have been bound to 'char'.  But 's' is not compatible to type
     'set[char]'!  The solution is to bind 'T' to 'range['a'..'z']'.
     This is achieved by reversing the parameters for 'contains'; 'in'
     then passes its arguments in reverse order.

   * contains
          proc contains*[T](s: Slice[T]; value: T): bool {.noSideEffect, inline.}

     Checks if value is within the range of s; returns true iff value >=
     s.a and value <= s.b
     assert((1..3).contains(1) == true)
     assert((1..3).contains(2) == true)
     assert((1..3).contains(4) == false)

   * 'is'
          proc `is`*[T, S](x: T; y: S): bool {.magic: "Is", noSideEffect.}

     Checks if T is of the same type as S
     proc test[T](a: T): int =
       when (T is int):
         return a
       else:
         return 0

     assert(test[int](3) == 3)
     assert(test[string]("xyz") == 0)

   * 'of'
          proc `of`*[T, S](x: T; y: S): bool {.magic: "Of", noSideEffect.}

     Checks if x has a type of y
     assert(FloatingPointError of Exception)
     assert(DivByZeroError of Exception)

   * cmp
          proc cmp*[T](x, y: T): int {.procvar.}

     Generic compare proc.  Returns a value < 0 iff x < y, a value > 0
     iff x > y and 0 iff x == y.  This is useful for writing generic
     algorithms without performance loss.  This generic implementation
     uses the == and < operators.
     import algorithm
     echo sorted(@[4,2,6,5,8,7], cmp[int])

   * cmp
          proc cmp*(x, y: string): int {.noSideEffect, procvar.}

     Compare proc for strings.  More efficient than the generic version.

   * '@'
          proc `@`*[IDX, T](a: array[IDX, T]): seq[T] {.magic: "ArrToSeq", nosideeffect.}

     turns an array into a sequence.  This most often useful for
     constructing sequences with the array constructor: '@[1, 2, 3]' has
     the type 'seq[int]', while '[1, 2, 3]' has the type 'array[0..2,
     int]'.

   * setLen
          proc setLen*[T](s: var seq[T]; newlen: Natural) {.magic: "SetLengthSeq", noSideEffect.}

     sets the length of s to newlen.  'T' may be any sequence type.  If
     the current length is greater than the new length, 's' will be
     truncated.  s cannot be nil!  To initialize a sequence with a size,
     use 'newSeq' instead.

   * setLen
          proc setLen*(s: var string; newlen: Natural) {.magic: "SetLengthStr", noSideEffect.}

     sets the length of s to newlen.  If the current length is greater
     than the new length, 's' will be truncated.  s cannot be nil!  To
     initialize a string with a size, use 'newString' instead.
     var myS = "Nim is great!!"
     myS.setLen(3)
     echo myS, " is fantastic!!"

   * newString noSideEffect.}
          proc newString*(len: Natural): string {.magic: "NewString", importc: "mnewString",
                                              noSideEffect.}

     returns a new string of length 'len' but with uninitialized
     content.  One needs to fill the string character after character
     with the index operator 's[i]'.  This procedure exists only for
     optimization purposes; the same effect can be achieved with the '&'
     operator or with 'add'.

   * newStringOfCap importc: "rawNewString", noSideEffect.}
          proc newStringOfCap*(cap: Natural): string {.magic: "NewStringOfCap",
              importc: "rawNewString", noSideEffect.}

     returns a new string of length '0' but with capacity cap.This
     procedure exists only for optimization purposes; the same effect
     can be achieved with the '&' operator or with 'add'.

   * '&amp;'
          proc `&`*(x: string; y: char): string {.magic: "ConStrStr", noSideEffect, merge.}

     Concatenates x with y
     assert("ab" & 'c' == "abc")

   * '&amp;'
          proc `&`*(x, y: char): string {.magic: "ConStrStr", noSideEffect, merge.}

     Concatenates x and y into a string
     assert('a' & 'b' == "ab")

   * '&amp;'
          proc `&`*(x, y: string): string {.magic: "ConStrStr", noSideEffect, merge.}

     Concatenates x and y
     assert("ab" & "cd" == "abcd")

   * '&amp;'
          proc `&`*(x: char; y: string): string {.magic: "ConStrStr", noSideEffect, merge.}

     Concatenates x with y
     assert('a' & "bc" == "abc")

   * add
          proc add*(x: var string; y: char) {.magic: "AppendStrCh", noSideEffect.}

     Appends y to x in place
     var tmp = ""
     tmp.add('a')
     tmp.add('b')
     assert(tmp == "ab")

   * add
          proc add*(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect.}

     Concatenates x and y in place
     var tmp = ""
     tmp.add("ab")
     tmp.add("cd")
     assert(tmp == "abcd")

   * compileOption
          proc compileOption*(option: string): bool {.magic: "CompileOption", noSideEffect.}

     can be used to determine an on|off compile-time option.  Example:
     when compileOption("floatchecks"):
       echo "compiled with floating point NaN and Inf checks"

   * compileOption noSideEffect.}
          proc compileOption*(option, arg: string): bool {.magic: "CompileOptionArg",
              noSideEffect.}

     can be used to determine an enum compile-time option.  Example:
     when compileOption("opt", "size") and compileOption("gc", "boehm"):
       echo "compiled with optimization for size and uses Boehm's GC"

   * len
          proc len*(s: TaintedString): int {.borrow.}

   * quit header: "<stdlib.h>", noreturn.}
          proc quit*(errorcode: int = QuitSuccess) {.magic: "Exit", importc: "exit",
                                                header: "<stdlib.h>", noreturn.}

     Stops the program immediately with an exit code.

     Before stopping the program the "quit procedures" are called in the
     opposite order they were added with addQuitProc (#addQuitProc).
     'quit' never returns and ignores any exception that may have been
     raised by the quit procedures.  It does _not_ call the garbage
     collector to free all the memory, unless a quit procedure calls
     GC_fullCollect (#GC_fullCollect).

     The proc 'quit(QuitSuccess)' is called implicitly when your nim
     program finishes without incident.  A raised unhandled exception is
     equivalent to calling 'quit(QuitFailure)'.

     Note that this is a _runtime_ call and using 'quit' inside a macro
     won't have any compile time effect.  If you need to stop the
     compiler inside a macro, use the error (manual.html#error-pragma)
     or fatal (manual.html#fatal-pragma) pragmas.

   * add
          proc add*[T](x: var seq[T]; y: T) {.magic: "AppendSeqElem", noSideEffect.}

   * add
          proc add*[T](x: var seq[T]; y: openArray[T]) {.noSideEffect.}

     Generic proc for adding a data item y to a container x.  For
     containers that have an order, add means _append_.  New generic
     containers should also call their adding proc add for consistency.
     Generic code becomes much easier to write if the Nim naming scheme
     is respected.
     var s: seq[string] = @["test2","test2"]
     s.add("test") #=> @[test2, test2, test]

   * shallowCopy
          proc shallowCopy*[T](x: var T; y: T) {.noSideEffect, magic: "ShallowCopy".}

     use this instead of = for a shallow copy.  The shallow copy only
     changes the semantics for sequences and strings (and types which
     contain those).  Be careful with the changed semantics though!
     There is a reason why the default assignment does a deep copy of
     sequences and strings.

   * del
          proc del*[T](x: var seq[T]; i: Natural) {.noSideEffect.}

     deletes the item at index i by putting 'x[high(x)]' into position
     i.  This is an O(1) operation.
     var i = @[1,2,3,4,5]
     i.del(2) #=> @[1, 2, 5, 4]

   * delete
          proc delete*[T](x: var seq[T]; i: Natural) {.noSideEffect.}

     deletes the item at index i by moving 'x[i+1..]' by one position.
     This is an O(n) operation.
     var i = @[1,2,3,4,5]
     i.delete(2) #=> @[1, 2, 4, 5]

   * insert
          proc insert*[T](x: var seq[T]; item: T; i = 0.Natural) {.noSideEffect.}

     inserts item into x at position i.
     var i = @[1,2,3,4,5]
     i.insert(2,4) #=> @[1, 2, 3, 4, 2, 5]

   * repr
          proc repr*[T](x: T): string {.magic: "Repr", noSideEffect.}

     takes any Nim variable and returns its string representation.  It
     works even for complex data graphs with cycles.  This is a great
     debugging tool.
     var s: seq[string] = @["test2","test2"]
     var i = @[1,2,3,4,5]
     repr(s) #=> 0x1055eb050[0x1055ec050"test2", 0x1055ec078"test2"]
     repr(i) #=> 0x1055ed050[1, 2, 3, 4, 5]

   * toFloat
          proc toFloat*(i: int): float {.magic: "ToFloat", noSideEffect, importc: "toFloat".}

     converts an integer i into a 'float'.  If the conversion fails,
     EInvalidValue is raised.  However, on most platforms the conversion
     cannot fail.

   * toBiggestFloat noSideEffect, importc: "toBiggestFloat".}
          proc toBiggestFloat*(i: BiggestInt): BiggestFloat {.magic: "ToBiggestFloat",
              noSideEffect, importc: "toBiggestFloat".}

     converts an biggestint i into a 'biggestfloat'.  If the conversion
     fails, EInvalidValue is raised.  However, on most platforms the
     conversion cannot fail.

   * toInt
          proc toInt*(f: float): int {.magic: "ToInt", noSideEffect, importc: "toInt".}

     converts a floating point number f into an 'int'.  Conversion
     rounds f if it does not contain an integer value.  If the
     conversion fails (because f is infinite for example), EInvalidValue
     is raised.

   * toBiggestInt importc: "toBiggestInt".}
          proc toBiggestInt*(f: BiggestFloat): BiggestInt {.magic: "ToBiggestInt", noSideEffect,
              importc: "toBiggestInt".}

     converts a biggestfloat f into a 'biggestint'.  Conversion rounds f
     if it does not contain an integer value.  If the conversion fails
     (because f is infinite for example), EInvalidValue is raised.

   * addQuitProc header: "<stdlib.h>".}
          proc addQuitProc*(QuitProc: proc () {.noconv.}) {.importc: "atexit",
              header: "<stdlib.h>".}

     Adds/registers a quit procedure.

     Each call to 'addQuitProc' registers another quit procedure.  Up to
     30 procedures can be registered.  They are executed on a last-in,
     first-out basis (that is, the last function registered is the first
     to be executed).  'addQuitProc' raises an EOutOfIndex exception if
     'QuitProc' cannot be registered.

   * copy noSideEffect, deprecated.}
          proc copy*(s: string; first = 0): string {.magic: "CopyStr", importc: "copyStr",
                                              noSideEffect, deprecated.}

   * copy importc: "copyStrLast", noSideEffect, deprecated.}
          proc copy*(s: string; first, last: int): string {.magic: "CopyStrLast",
              importc: "copyStrLast", noSideEffect, deprecated.}

     copies a slice of s into a new string and returns this new string.
     The bounds first and last denote the indices of the first and last
     characters that shall be copied.  If 'last' is omitted, it is
     treated as 'high(s)'.  *Deprecated since version 0.8.12*: Use
     'substr' instead.

   * substr noSideEffect.}
          proc substr*(s: string; first = 0): string {.magic: "CopyStr", importc: "copyStr",
                                                noSideEffect.}

   * substr importc: "copyStrLast", noSideEffect.}
          proc substr*(s: string; first, last: int): string {.magic: "CopyStrLast",
              importc: "copyStrLast", noSideEffect.}

     copies a slice of s into a new string and returns this new string.
     The bounds first and last denote the indices of the first and last
     characters that shall be copied.  If 'last' is omitted, it is
     treated as 'high(s)'.  If 'last >= s.len', 's.len' is used instead:
     This means 'substr' can also be used to cut or limit a string's
     length.

   * zeroMem
          proc zeroMem*(p: pointer; size: Natural) {.importc, noDecl, benign.}

     overwrites the contents of the memory at 'p' with the value 0.
     Exactly 'size' bytes will be overwritten.  Like any procedure
     dealing with raw memory this is _unsafe_.

   * copyMem header: "<string.h>", benign.}
          proc copyMem*(dest, source: pointer; size: Natural) {.importc: "memcpy",
              header: "<string.h>", benign.}

     copies the contents from the memory at 'source' to the memory at
     'dest'.  Exactly 'size' bytes will be copied.  The memory regions
     may not overlap.  Like any procedure dealing with raw memory this
     is _unsafe_.

   * moveMem header: "<string.h>", benign.}
          proc moveMem*(dest, source: pointer; size: Natural) {.importc: "memmove",
              header: "<string.h>", benign.}

     copies the contents from the memory at 'source' to the memory at
     'dest'.  Exactly 'size' bytes will be copied.  The memory regions
     may overlap, 'moveMem' handles this case appropriately and is thus
     somewhat more safe than 'copyMem'.  Like any procedure dealing with
     raw memory this is still _unsafe_, though.

   * equalMem noSideEffect.}
          proc equalMem*(a, b: pointer; size: Natural): bool {.importc: "equalMem", noDecl,
              noSideEffect.}

     compares the memory blocks 'a' and 'b'.  'size' bytes will be
     compared.  If the blocks are equal, true is returned, false
     otherwise.  Like any procedure dealing with raw memory this is
     _unsafe_.

   * alloc
          proc alloc*(size: Natural): pointer {.noconv, rtl, tags: [], benign.}

     allocates a new memory block with at least 'size' bytes.  The block
     has to be freed with 'realloc(block, 0)' or 'dealloc(block)'.  The
     block is not initialized, so reading from it before writing to it
     is undefined behaviour!  The allocated memory belongs to its
     allocating thread!  Use allocShared to allocate from a shared heap.

   * createU
          proc createU*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}

     allocates a new memory block with at least 'T.sizeof * size' bytes.
     The block has to be freed with 'resize(block, 0)' or 'free(block)'.
     The block is not initialized, so reading from it before writing to
     it is undefined behaviour!  The allocated memory belongs to its
     allocating thread!  Use createSharedU to allocate from a shared
     heap.

   * alloc0
          proc alloc0*(size: Natural): pointer {.noconv, rtl, tags: [], benign.}

     allocates a new memory block with at least 'size' bytes.  The block
     has to be freed with 'realloc(block, 0)' or 'dealloc(block)'.  The
     block is initialized with all bytes containing zero, so it is
     somewhat safer than 'alloc'.  The allocated memory belongs to its
     allocating thread!  Use allocShared0 to allocate from a shared
     heap.

   * create
          proc create*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}

     allocates a new memory block with at least 'T.sizeof * size' bytes.
     The block has to be freed with 'resize(block, 0)' or 'free(block)'.
     The block is initialized with all bytes containing zero, so it is
     somewhat safer than 'createU'.  The allocated memory belongs to its
     allocating thread!  Use createShared to allocate from a shared
     heap.

   * realloc
          proc realloc*(p: pointer; newSize: Natural): pointer {.noconv, rtl, tags: [], benign.}

     grows or shrinks a given memory block.  If p is *nil* then a new
     memory block is returned.  In either way the block has at least
     'newSize' bytes.  If 'newSize == 0' and p is not *nil* 'realloc'
     calls 'dealloc(p)'.  In other cases the block has to be freed with
     'dealloc'.  The allocated memory belongs to its allocating thread!
     Use reallocShared to reallocate from a shared heap.

   * resize
          proc resize*[T](p: ptr T; newSize: Natural): ptr T {.inline, benign.}

     grows or shrinks a given memory block.  If p is *nil* then a new
     memory block is returned.  In either way the block has at least
     'T.sizeof * newSize' bytes.  If 'newSize == 0' and p is not *nil*
     'resize' calls 'free(p)'.  In other cases the block has to be freed
     with 'free'.  The allocated memory belongs to its allocating
     thread!  Use resizeShared to reallocate from a shared heap.

   * dealloc
          proc dealloc*(p: pointer) {.noconv, rtl, tags: [], benign.}

     frees the memory allocated with 'alloc', 'alloc0' or 'realloc'.
     This procedure is dangerous!  If one forgets to free the memory a
     leak occurs; if one tries to access freed memory (or just freeing
     it twice!)  a core dump may happen or other memory may be
     corrupted.  The freed memory must belong to its allocating thread!
     Use deallocShared to deallocate from a shared heap.

   * allocShared
          proc allocShared*(size: Natural): pointer {.noconv, rtl, benign.}

     allocates a new memory block on the shared heap with at least
     'size' bytes.  The block has to be freed with 'reallocShared(block,
     0)' or 'deallocShared(block)'.  The block is not initialized, so
     reading from it before writing to it is undefined behaviour!

   * createSharedU
          proc createSharedU*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}

     allocates a new memory block on the shared heap with at least
     'T.sizeof * size' bytes.  The block has to be freed with
     'resizeShared(block, 0)' or 'freeShared(block)'.  The block is not
     initialized, so reading from it before writing to it is undefined
     behaviour!

   * allocShared0
          proc allocShared0*(size: Natural): pointer {.noconv, rtl, benign.}

     allocates a new memory block on the shared heap with at least
     'size' bytes.  The block has to be freed with 'reallocShared(block,
     0)' or 'deallocShared(block)'.  The block is initialized with all
     bytes containing zero, so it is somewhat safer than 'allocShared'.

   * createShared
          proc createShared*(T: typedesc; size = 1.Positive): ptr T {.inline.}

     allocates a new memory block on the shared heap with at least
     'T.sizeof * size' bytes.  The block has to be freed with
     'resizeShared(block, 0)' or 'freeShared(block)'.  The block is
     initialized with all bytes containing zero, so it is somewhat safer
     than 'createSharedU'.

   * reallocShared
          proc reallocShared*(p: pointer; newSize: Natural): pointer {.noconv, rtl, benign.}

     grows or shrinks a given memory block on the heap.  If p is *nil*
     then a new memory block is returned.  In either way the block has
     at least 'newSize' bytes.  If 'newSize == 0' and p is not *nil*
     'reallocShared' calls 'deallocShared(p)'.  In other cases the block
     has to be freed with 'deallocShared'.

   * resizeShared
          proc resizeShared*[T](p: ptr T; newSize: Natural): ptr T {.inline.}

     grows or shrinks a given memory block on the heap.  If p is *nil*
     then a new memory block is returned.  In either way the block has
     at least 'T.sizeof * newSize' bytes.  If 'newSize == 0' and p is
     not *nil* 'resizeShared' calls 'freeShared(p)'.  In other cases the
     block has to be freed with 'freeShared'.

   * deallocShared
          proc deallocShared*(p: pointer) {.noconv, rtl, benign.}

     frees the memory allocated with 'allocShared', 'allocShared0' or
     'reallocShared'.  This procedure is dangerous!  If one forgets to
     free the memory a leak occurs; if one tries to access freed memory
     (or just freeing it twice!)  a core dump may happen or other memory
     may be corrupted.

   * freeShared
          proc freeShared*[T](p: ptr T) {.inline, benign.}

     frees the memory allocated with 'createShared', 'createSharedU' or
     'resizeShared'.  This procedure is dangerous!  If one forgets to
     free the memory a leak occurs; if one tries to access freed memory
     (or just freeing it twice!)  a core dump may happen or other memory
     may be corrupted.

   * swap
          proc swap*[T](a, b: var T) {.magic: "Swap", noSideEffect.}

     swaps the values a and b.  This is often more efficient than 'tmp =
     a; a = b; b = tmp'.  Particularly useful for sorting algorithms.

   * '$'
          proc `$`*(x: int): string {.magic: "IntToStr", noSideEffect.}

     The stringify operator for an integer argument.  Returns x
     converted to a decimal string.  '$' is Nim's general way of
     spelling toString.

   * '$'
          proc `$`*(x: int64): string {.magic: "Int64ToStr", noSideEffect.}

     The stringify operator for an integer argument.  Returns x
     converted to a decimal string.

   * '$'
          proc `$`*(x: uint64): string {.noSideEffect.}

     The stringify operator for an unsigned integer argument.  Returns x
     converted to a decimal string.

   * '$'
          proc `$`*(x: float): string {.magic: "FloatToStr", noSideEffect.}

     The stringify operator for a float argument.  Returns x converted
     to a decimal string.

   * '$'
          proc `$`*(x: bool): string {.magic: "BoolToStr", noSideEffect.}

     The stringify operator for a boolean argument.  Returns x converted
     to the string "false" or "true".

   * '$'
          proc `$`*(x: char): string {.magic: "CharToStr", noSideEffect.}

     The stringify operator for a character argument.  Returns x
     converted to a string.

   * '$'
          proc `$`*(x: cstring): string {.magic: "CStrToStr", noSideEffect.}

     The stringify operator for a CString argument.  Returns x converted
     to a string.

   * '$'
          proc `$`*(x: string): string {.magic: "StrToStr", noSideEffect.}

     The stringify operator for a string argument.  Returns x as it is.
     This operator is useful for generic code, so that '$expr' also
     works if 'expr' is already a string.

   * '$'
          proc `$`*[Enum: enum](x: Enum): string {.magic: "EnumToStr", noSideEffect.}

     The stringify operator for an enumeration argument.  This works for
     any enumeration type thanks to compiler magic.  If a '$' operator
     for a concrete enumeration is provided, this is used instead.  (In
     other words: _Overwriting_ is possible.)

   * getRefcount
          proc getRefcount*[T](x: ref T): int {.importc: "getRefcount", noSideEffect.}

   * getRefcount
          proc getRefcount*(x: string): int {.importc: "getRefcount", noSideEffect.}

   * getRefcount
          proc getRefcount*[T](x: seq[T]): int {.importc: "getRefcount", noSideEffect.}

     retrieves the reference count of an heap-allocated object.  The
     value is implementation-dependent.

   * getOccupiedMem
          proc getOccupiedMem*(): int {.rtl.}

     returns the number of bytes that are owned by the process and hold
     data.

   * getFreeMem
          proc getFreeMem*(): int {.rtl.}

     returns the number of bytes that are owned by the process, but do
     not hold any meaningful data.

   * getTotalMem
          proc getTotalMem*(): int {.rtl.}

     returns the number of bytes that are owned by the process.

   * getOccupiedSharedMem
          proc getOccupiedSharedMem*(): int {.rtl.}

     returns the number of bytes that are owned by the process on the
     shared heap and hold data.  This is only available when threads are
     enabled.

   * getFreeSharedMem
          proc getFreeSharedMem*(): int {.rtl.}

     returns the number of bytes that are owned by the process on the
     shared heap, but do not hold any meaningful data.  This is only
     available when threads are enabled.

   * getTotalSharedMem
          proc getTotalSharedMem*(): int {.rtl.}

     returns the number of bytes on the shared heap that are owned by
     the process.  This is only available when threads are enabled.

   * min
          proc min*(x, y: int): int {.magic: "MinI", noSideEffect.}

   * min
          proc min*(x, y: int8): int8 {.magic: "MinI", noSideEffect.}

   * min
          proc min*(x, y: int16): int16 {.magic: "MinI", noSideEffect.}

   * min
          proc min*(x, y: int32): int32 {.magic: "MinI", noSideEffect.}

   * min
          proc min*(x, y: int64): int64 {.magic: "MinI", noSideEffect.}

     The minimum value of two integers.

   * min
          proc min*[T](x: varargs[T]): T

     The minimum value of x.  'T' needs to have a '<' operator.

   * max
          proc max*(x, y: int): int {.magic: "MaxI", noSideEffect.}

   * max
          proc max*(x, y: int8): int8 {.magic: "MaxI", noSideEffect.}

   * max
          proc max*(x, y: int16): int16 {.magic: "MaxI", noSideEffect.}

   * max
          proc max*(x, y: int32): int32 {.magic: "MaxI", noSideEffect.}

   * max
          proc max*(x, y: int64): int64 {.magic: "MaxI", noSideEffect.}

     The maximum value of two integers.

   * max
          proc max*[T](x: varargs[T]): T

     The maximum value of x.  'T' needs to have a '<' operator.

   * abs
          proc abs*(x: float): float {.magic: "AbsF64", noSideEffect.}

   * min
          proc min*(x, y: float): float {.magic: "MinF64", noSideEffect.}

   * max
          proc max*(x, y: float): float {.magic: "MaxF64", noSideEffect.}

   * clamp
          proc clamp*[T](x, a, b: T): T

     limits the value 'x' within the interval [a, b]
     assert((1.4).clamp(0.0, 1.0) == 1.0)
     assert((0.5).clamp(0.0, 1.0) == 0.5)

   * isNil
          proc isNil*[T](x: seq[T]): bool {.noSideEffect, magic: "IsNil".}

   * isNil
          proc isNil*[T](x: ref T): bool {.noSideEffect, magic: "IsNil".}

   * isNil
          proc isNil*(x: string): bool {.noSideEffect, magic: "IsNil".}

   * isNil
          proc isNil*[T](x: ptr T): bool {.noSideEffect, magic: "IsNil".}

   * isNil
          proc isNil*(x: pointer): bool {.noSideEffect, magic: "IsNil".}

   * isNil
          proc isNil*(x: cstring): bool {.noSideEffect, magic: "IsNil".}

   * isNil
          proc isNil*[T: proc](x: T): bool {.noSideEffect, magic: "IsNil".}

     Fast check whether x is nil.  This is sometimes more efficient than
     '== nil'.

   * '=='
          proc `==`*[I, T](x, y: array[I, T]): bool

   * '@'
          proc `@`*[T](a: openArray[T]): seq[T]

     turns an openarray into a sequence.  This is not as efficient as
     turning a fixed length array into a sequence as it always copies
     every element of a.

   * '&amp;'
          proc `&`*[T](x, y: seq[T]): seq[T] {.noSideEffect.}

     Concatenates two sequences.  Requires copying of the sequences.
     assert(@[1, 2, 3, 4] & @[5, 6] == @[1, 2, 3, 4, 5, 6])

   * '&amp;'
          proc `&`*[T](x: seq[T]; y: T): seq[T] {.noSideEffect.}

     Appends element y to the end of the sequence.  Requires copying of
     the sequence
     assert(@[1, 2, 3] & 4 == @[1, 2, 3, 4])

   * '&amp;'
          proc `&`*[T](x: T; y: seq[T]): seq[T] {.noSideEffect.}

     Prepends the element x to the beginning of the sequence.  Requires
     copying of the sequence
     assert(1 & @[2, 3, 4] == @[1, 2, 3, 4])

   * '=='
          proc `==`*[T](x, y: seq[T]): bool {.noSideEffect.}

     Generic equals operator for sequences: relies on a equals operator
     for the element type T.

   * find
          proc find*[T, S](a: T; item: S): int {.inline.}

     Returns the first index of item in a or -1 if not found.  This
     requires appropriate items and == operations to work.

   * contains
          proc contains*[T](a: openArray[T]; item: T): bool {.inline.}

     Returns true if item is in a or false if not found.  This is a
     shortcut for 'find(a, item) >= 0'.

   * pop
          proc pop*[T](s: var seq[T]): T {.inline, noSideEffect.}

     returns the last item of s and decreases 's.len' by one.  This
     treats s as a stack and implements the common _pop_ operation.

   * '==' object](x, y: T): bool
          proc `==`*[T: tuple |
              object](x, y: T): bool

     generic '==' operator for tuples that is lifted from the components
     of x and y.

   * '&lt;='
          proc `<=`*[T: tuple](x, y: T): bool

     generic '<=' operator for tuples that is lifted from the components
     of x and y.  This implementation uses cmp.

   * '&lt;'
          proc `<`*[T: tuple](x, y: T): bool

     generic '<' operator for tuples that is lifted from the components
     of x and y.  This implementation uses cmp.

   * '$' object](x: T): string
          proc `$`*[T: tuple |
              object](x: T): string

     generic '$' operator for tuples that is lifted from the components
     of x.  Example:
     $(23, 45) == "(23, 45)"
     $() == "()"

   * '$'
          proc `$`*[T](x: set[T]): string

     generic '$' operator for sets that is lifted from the components of
     x.  Example:
     ${23, 45} == "{23, 45}"

   * '$'
          proc `$`*[T](x: seq[T]): string

     generic '$' operator for seqs that is lifted from the components of
     x.  Example:
     $(@[23, 45]) == "@[23, 45]"

   * GC_disable
          proc GC_disable*() {.rtl, inl, benign.}

     disables the GC. If called n-times, n calls to GC_enable are needed
     to reactivate the GC. Note that in most circumstances one should
     only disable the mark and sweep phase with GC_disableMarkAndSweep.

   * GC_enable
          proc GC_enable*() {.rtl, inl, benign.}

     enables the GC again.

   * GC_fullCollect
          proc GC_fullCollect*() {.rtl, benign.}

     forces a full garbage collection pass.  Ordinary code does not need
     to call this (and should not).

   * GC_setStrategy
          proc GC_setStrategy*(strategy: GC_Strategy) {.rtl, deprecated, benign.}

     tells the GC the desired strategy for the application.
     *Deprecated* since version 0.8.14.  This has always been a nop.

   * GC_enableMarkAndSweep
          proc GC_enableMarkAndSweep*() {.rtl, benign.}

   * GC_disableMarkAndSweep
          proc GC_disableMarkAndSweep*() {.rtl, benign.}

     the current implementation uses a reference counting garbage
     collector with a seldomly run mark and sweep phase to free cycles.
     The mark and sweep phase may take a long time and is not needed if
     the application does not create cycles.  Thus the mark and sweep
     phase can be deactivated and activated separately from the rest of
     the GC.

   * GC_getStatistics
          proc GC_getStatistics*(): string {.rtl, benign.}

     returns an informative string about the GC's activity.  This may be
     useful for tweaking.

   * GC_ref
          proc GC_ref*[T](x: ref T) {.magic: "GCref", benign.}

   * GC_ref
          proc GC_ref*[T](x: seq[T]) {.magic: "GCref", benign.}

   * GC_ref
          proc GC_ref*(x: string) {.magic: "GCref", benign.}

     marks the object x as referenced, so that it will not be freed
     until it is unmarked via GC_unref.  If called n-times for the same
     object x, n calls to GC_unref are needed to unmark x.

   * GC_unref
          proc GC_unref*[T](x: ref T) {.magic: "GCunref", benign.}

   * GC_unref
          proc GC_unref*[T](x: seq[T]) {.magic: "GCunref", benign.}

   * GC_unref
          proc GC_unref*(x: string) {.magic: "GCunref", benign.}

     see the documentation of GC_ref.

   * add
          proc add*(x: var string; y: cstring) {.asmNoStackFrame.}

   * add
          proc add*(x: var cstring; y: cstring) {.magic: "AppendStrStr".}

   * echo sideEffect.}
          proc echo*(x: varargs[typed, `$`]) {.magic: "Echo", tags: [WriteIOEffect], benign,
                                           sideEffect.}

     Writes and flushes the parameters to the standard output.

     Special built-in that takes a variable number of arguments.  Each
     argument is converted to a string via '$', so it works for
     user-defined types that have an overloaded '$' operator.  It is
     roughly equivalent to 'writeLine(stdout, x); flushFile(stdout)',
     but available for the JavaScript target too.

     Unlike other IO operations this is guaranteed to be thread-safe as
     'echo' is very often used for debugging convenience.  If you want
     to use 'echo' inside a proc without side effects
     (manual.html#pragmas-nosideeffect-pragma) you can use debugEcho
     (#debugEcho) instead.

   * debugEcho raises: [].}
          proc debugEcho*(x: varargs[typed, `$`]) {.magic: "Echo", noSideEffect, tags: [],
                                                raises: [].}

     Same as echo (#echo), but as a special semantic rule, 'debugEcho'
     pretends to be free of side effects, so that it can be used for
     debugging routines marked as noSideEffect
     (manual.html#pragmas-nosideeffect-pragma).

   * getTypeInfo
          proc getTypeInfo*[T](x: T): pointer {.magic: "GetTypeInfo", benign.}

     get type information for x.  Ordinary code should not use this, but
     the typeinfo module instead.

   * abs
          proc abs*(x: int): int {.magic: "AbsI", noSideEffect.}

   * abs
          proc abs*(x: int8): int8 {.magic: "AbsI", noSideEffect.}

   * abs
          proc abs*(x: int16): int16 {.magic: "AbsI", noSideEffect.}

   * abs
          proc abs*(x: int32): int32 {.magic: "AbsI", noSideEffect.}

   * abs
          proc abs*(x: int64): int64 {.magic: "AbsI", noSideEffect.}

     returns the absolute value of x.  If x is 'low(x)' (that is -MININT
     for its type), an overflow exception is thrown (if overflow
     checking is turned on).

   * open tags: [], benign.}
          proc open*(f: var File; filename: string; mode: FileMode = fmRead; bufSize: int = - 1): bool {.
              tags: [], benign.}

     Opens a file named filename with given mode.

     Default mode is readonly.  Returns true iff the file could be
     opened.  This throws no exception if the file could not be opened.

   * open benign.}
          proc open*(f: var File; filehandle: FileHandle; mode: FileMode = fmRead): bool {.tags: [],
              benign.}

     Creates a 'File' from a filehandle with given mode.

     Default mode is readonly.  Returns true iff the file could be
     opened.

   * open
          proc open*(filename: string; mode: FileMode = fmRead; bufSize: int = - 1): File

     Opens a file named filename with given mode.

     Default mode is readonly.  Raises an 'IO' exception if the file
     could not be opened.

   * reopen
          proc reopen*(f: File; filename: string; mode: FileMode = fmRead): bool {.tags: [], benign.}

     reopens the file f with given filename and mode.  This is often
     used to redirect the stdin, stdout or stderr file variables.

     Default mode is readonly.  Returns true iff the file could be
     reopened.

   * close
          proc close*(f: File) {.importc: "fclose", header: "<stdio.h>", tags: [].}

     Closes the file.

   * endOfFile
          proc endOfFile*(f: File): bool {.tags: [], benign.}

     Returns true iff f is at the end.

   * readChar tags: [ReadIOEffect].}
          proc readChar*(f: File): char {.importc: "fgetc", header: "<stdio.h>",
                                      tags: [ReadIOEffect].}

     Reads a single character from the stream f.

   * flushFile tags: [WriteIOEffect].}
          proc flushFile*(f: File) {.importc: "fflush", header: "<stdio.h>",
                                  tags: [WriteIOEffect].}

     Flushes f's buffer.

   * readAll
          proc readAll*(file: File): TaintedString {.tags: [ReadIOEffect], benign.}

     Reads all data from the stream file.

     Raises an IO exception in case of an error.  It is an error if the
     current file position is not at the beginning of the file.

   * readFile
          proc readFile*(filename: string): TaintedString {.tags: [ReadIOEffect], benign.}

     Opens a file named filename for reading.

     Then calls readAll (#readAll) and closes the file afterwards.
     Returns the string.  Raises an IO exception in case of an error.
     If you need to call this inside a compile time macro you can use
     staticRead (#staticRead).

   * writeFile
          proc writeFile*(filename, content: string) {.tags: [WriteIOEffect], benign.}

     Opens a file named filename for writing.  Then writes the content
     completely to the file and closes the file afterwards.  Raises an
     IO exception in case of an error.

   * write
          proc write*(f: File; r: float32) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; i: int) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; i: BiggestInt) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; r: BiggestFloat) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; s: string) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; b: bool) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; c: char) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; c: cstring) {.tags: [WriteIOEffect], benign.}

   * write
          proc write*(f: File; a: varargs[string, `$`]) {.tags: [WriteIOEffect], benign.}

     Writes a value to the file f.  May throw an IO exception.

   * readLine
          proc readLine*(f: File): TaintedString {.tags: [ReadIOEffect], benign.}

     reads a line of text from the file f.  May throw an IO exception.
     A line of text may be delimited by 'LF' or 'CRLF'.  The newline
     character(s) are not part of the returned string.

   * readLine
          proc readLine*(f: File; line: var TaintedString): bool {.tags: [ReadIOEffect], benign.}

     reads a line of text from the file f into line.  line must not be
     'nil'!  May throw an IO exception.  A line of text may be delimited
     by 'LF' or 'CRLF'.  The newline character(s) are not part of the
     returned string.  Returns 'false' if the end of the file has been
     reached, 'true' otherwise.  If 'false' is returned line contains no
     new data.

   * writeLn deprecated.}
          proc writeLn*[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect], benign,
              deprecated.}

     *Deprecated since version 0.11.4:* Use *writeLine* instead.

   * writeLine
          proc writeLine*[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect], benign.}

     writes the values x to f and then writes "n".  May throw an IO
     exception.

   * getFileSize
          proc getFileSize*(f: File): int64 {.tags: [ReadIOEffect], benign.}

     retrieves the file size (in bytes) of f.

   * readBytes tags: [ReadIOEffect], benign.}
          proc readBytes*(f: File; a: var openArray[int8 | uint8]; start, len: Natural): int {.
              tags: [ReadIOEffect], benign.}

     reads len bytes into the buffer a starting at 'a[start]'.  Returns
     the actual number of bytes that have been read which may be less
     than len (if not as many bytes are remaining), but not greater.

   * readChars tags: [ReadIOEffect], benign.}
          proc readChars*(f: File; a: var openArray[char]; start, len: Natural): int {.
              tags: [ReadIOEffect], benign.}

     reads len bytes into the buffer a starting at 'a[start]'.  Returns
     the actual number of bytes that have been read which may be less
     than len (if not as many bytes are remaining), but not greater.

   * readBuffer benign.}
          proc readBuffer*(f: File; buffer: pointer; len: Natural): int {.tags: [ReadIOEffect],
              benign.}

     reads len bytes into the buffer pointed to by buffer.  Returns the
     actual number of bytes that have been read which may be less than
     len (if not as many bytes are remaining), but not greater.

   * writeBytes tags: [WriteIOEffect], benign.}
          proc writeBytes*(f: File; a: openArray[int8 | uint8]; start, len: Natural): int {.
              tags: [WriteIOEffect], benign.}

     writes the bytes of 'a[start..start+len-1]' to the file f.  Returns
     the number of actual written bytes, which may be less than len in
     case of an error.

   * writeChars tags: [WriteIOEffect], benign.}
          proc writeChars*(f: File; a: openArray[char]; start, len: Natural): int {.
              tags: [WriteIOEffect], benign.}

     writes the bytes of 'a[start..start+len-1]' to the file f.  Returns
     the number of actual written bytes, which may be less than len in
     case of an error.

   * writeBuffer benign.}
          proc writeBuffer*(f: File; buffer: pointer; len: Natural): int {.tags: [WriteIOEffect],
              benign.}

     writes the bytes of buffer pointed to by the parameter buffer to
     the file f.  Returns the number of actual written bytes, which may
     be less than len in case of an error.

   * setFilePos
          proc setFilePos*(f: File; pos: int64) {.benign.}

     sets the position of the file pointer that is used for read/write
     operations.  The file's first byte has the index zero.

   * getFilePos
          proc getFilePos*(f: File): int64 {.benign.}

     retrieves the current position of the file pointer that is used to
     read from the file f.  The file's first byte has the index zero.

   * getFileHandle
          proc getFileHandle*(f: File): FileHandle {.importc: "fileno", header: "<stdio.h>".}

     returns the OS file handle of the file 'f'.  This is only useful
     for platform specific programming.

   * cstringArrayToSeq
          proc cstringArrayToSeq*(a: cstringArray; len: Natural): seq[string]

     converts a 'cstringArray' to a 'seq[string]'.  a is supposed to be
     of length 'len'.

   * cstringArrayToSeq
          proc cstringArrayToSeq*(a: cstringArray): seq[string]

     converts a 'cstringArray' to a 'seq[string]'.  a is supposed to be
     terminated by 'nil'.

   * allocCStringArray
          proc allocCStringArray*(a: openArray[string]): cstringArray

     creates a NULL terminated cstringArray from a.  The result has to
     be freed with deallocCStringArray after it's not needed anymore.

   * deallocCStringArray
          proc deallocCStringArray*(a: cstringArray)

     frees a NULL terminated cstringArray.

   * atomicInc
          proc atomicInc*(memLoc: var int; x: int = 1): int {.inline, discardable, benign.}

     atomic increment of memLoc.  Returns the value after the operation.

   * atomicDec
          proc atomicDec*(memLoc: var int; x: int = 1): int {.inline, discardable, benign.}

     atomic decrement of memLoc.  Returns the value after the operation.

   * setControlCHook
          proc setControlCHook*(hook: proc () {.noconv.} not nil)

     allows you to override the behaviour of your application when
     CTRL+C is pressed.  Only one such hook is supported.

   * writeStackTrace
          proc writeStackTrace*() {.tags: [WriteIOEffect].}

     writes the current stack trace to 'stderr'.  This is only works for
     debug builds.

   * getStackTrace
          proc getStackTrace*(): string

     gets the current stack trace.  This only works for debug builds.

   * getStackTrace
          proc getStackTrace*(e: ref Exception): string

     gets the stack trace associated with e, which is the stack that
     lead to the 'raise' statement.  This only works for debug builds.

   * getCurrentException
          proc getCurrentException*(): ref Exception {.compilerRtl, inl, benign.}

     retrieves the current exception; if there is none, nil is returned.

   * getCurrentExceptionMsg
          proc getCurrentExceptionMsg*(): string {.inline, benign.}

     retrieves the error message that was attached to the current
     exception; if there is none, "" is returned.

   * onRaise
          proc onRaise*(action: proc (e: ref Exception): bool {.closure.})

     can be used in a 'try' statement to setup a Lisp-like condition
     system: This prevents the 'raise' statement to raise an exception
     but instead calls 'action'.  If 'action' returns false, the
     exception has been handled and does not propagate further through
     the call stack.

   * setCurrentException
          proc setCurrentException*(exc: ref Exception) {.inline, benign.}

     sets the current exception.

     *Warning*: Only use this if you know what you are doing.

   * likely
          proc likely*(val: bool): bool {.importc: "likely", nodecl, nosideeffect.}

     Hints the optimizer that val is likely going to be true.

     You can use this proc to decorate a branch condition.  On certain
     platforms this can help the processor predict better which branch
     is going to be run.  Example:
     for value in inputValues:
       if likely(value <= 100):
         process(value)
       else:
         echo "Value too big!"

   * unlikely
          proc unlikely*(val: bool): bool {.importc: "unlikely", nodecl, nosideeffect.}

     Hints the optimizer that val is likely going to be false.

     You can use this proc to decorate a branch condition.  On certain
     platforms this can help the processor predict better which branch
     is going to be run.  Example:
     for value in inputValues:
       if unlikely(value > 100):
         echo "Value too big!"
       else:
         process(value)

   * rawProc
          proc rawProc*[T: proc](x: T): pointer {.noSideEffect, inline.}

     retrieves the raw proc pointer of the closure x.  This is useful
     for interfacing closures with C.

   * rawEnv
          proc rawEnv*[T: proc](x: T): pointer {.noSideEffect, inline.}

     retrieves the raw environment pointer of the closure x.  This is
     useful for interfacing closures with C.

   * finished
          proc finished*[T: proc](x: T): bool {.noSideEffect, inline.}

     can be used to determine if a first class iterator has finished.

   * quit
          proc quit*(errormsg: string; errorcode = QuitFailure) {.noReturn.}

     a shorthand for 'echo(errormsg); quit(errorcode)'.

   * '/'
          proc `/`*(x, y: int): float {.inline, noSideEffect.}

     integer division that results in a float.

   * '[]'
          proc `[]`*(s: string; x: Slice[int]): string {.inline.}

     slice operation for strings.

   * '[]='
          proc `[]=`*(s: var string; x: Slice[int]; b: string)

     slice assignment for strings.  If 'b.len' is not exactly the number
     of elements that are referred to by x, a splice is performed:
     var s = "abcdef"
     s[1 .. ^2] = "xyz"
     assert s == "axyzf"

   * '[]'
          proc `[]`*[Idx, T](a: array[Idx, T]; x: Slice[int]): seq[T]

     slice operation for arrays.

   * '[]='
          proc `[]=`*[Idx, T](a: var array[Idx, T]; x: Slice[int]; b: openArray[T])

     slice assignment for arrays.

   * '[]'
          proc `[]`*[Idx, T](a: array[Idx, T]; x: Slice[Idx]): seq[T]

     slice operation for arrays.

   * '[]='
          proc `[]=`*[Idx, T](a: var array[Idx, T]; x: Slice[Idx]; b: openArray[T])

     slice assignment for arrays.

   * '[]'
          proc `[]`*[T](s: seq[T]; x: Slice[int]): seq[T]

     slice operation for sequences.

   * '[]='
          proc `[]=`*[T](s: var seq[T]; x: Slice[int]; b: openArray[T])

     slice assignment for sequences.  If 'b.len' is not exactly the
     number of elements that are referred to by x, a splice is
     performed.

   * slurp
          proc slurp*(filename: string): string {.magic: "Slurp".}

     This is an alias for staticRead (#staticRead).

   * staticRead
          proc staticRead*(filename: string): string {.magic: "Slurp".}

     Compile-time readFile (#readFile) proc for easy resource embedding:
     const myResource = staticRead"mydatafile.bin"

     slurp (#slurp) is an alias for 'staticRead'.

   * gorge
          proc gorge*(command: string; input = ""; cache = ""): string {.magic: "StaticExec".}

     This is an alias for staticExec (#staticExec).

   * staticExec
          proc staticExec*(command: string; input = ""; cache = ""): string {.magic: "StaticExec".}

     Executes an external process at compile-time.  if input is not an
     empty string, it will be passed as a standard input to the executed
     program.
     const buildInfo = "Revision " & staticExec("git rev-parse HEAD") &
                       "\nCompiled on " & staticExec("uname -v")

     gorge (#gorge) is an alias for 'staticExec'.  Note that you can use
     this proc inside a pragma like passC (nimc.html#passc-pragma) or
     passL (nimc.html#passl-pragma).

     If 'cache' is not empty, the results of 'staticExec' are cached
     within the 'nimcache' directory.  Use '--forceBuild' to get rid of
     this caching behaviour then.  'command & input & cache' (the
     concatenated string) is used to determine wether the entry in the
     cache is still valid.  You can use versioning information for
     'cache':
     const stateMachine = staticExec("dfaoptimizer", "input", "0.8.0")

   * '+='
          proc `+=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: "Inc", noSideEffect.}

     Increments an ordinal

   * '-='
          proc `-=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: "Dec", noSideEffect.}

     Decrements an ordinal

   * '*='
          proc `*=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.inline, noSideEffect.}

     Binary *= operator for ordinals

   * '+='
          proc `+=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}

     Increments in placee a floating point number

   * '-='
          proc `-=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}

     Decrements in place a floating point number

   * '*='
          proc `*=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}

     Multiplies in place a floating point number

   * '/='
          proc `/=`*(x: var float64; y: float64) {.inline, noSideEffect.}

     Divides in place a floating point number

   * '/='
          proc `/=`*[T: float | float32](x: var T; y: T) {.inline, noSideEffect.}

     Divides in place a floating point number

   * '&amp;='
          proc `&=`*(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect.}

   * astToStr
          proc astToStr*[T](x: T): string {.magic: "AstToStr", noSideEffect.}

     converts the AST of x into a string representation.  This is very
     useful for debugging.

   * instantiationInfo magic: "InstantiationInfo", noSideEffect.}
          proc instantiationInfo*(index = - 1; fullPaths = false): tuple[filename: string, line: int] {.
              magic: "InstantiationInfo", noSideEffect.}

     provides access to the compiler's instantiation stack line
     information.

     This proc is mostly useful for meta programming (eg.  'assert'
     template) to retrieve information about the current filename and
     line number.  Example:
     import strutils

     template testException(exception, code: expr): stmt =
       try:
         let pos = instantiationInfo()
         discard(code)
         echo "Test failure at $1:$2 with '$3'" % [pos.filename,
           $pos.line, astToStr(code)]
         assert false, "A test expecting failure succeeded?"
       except exception:
         discard

     proc tester(pos: int): int =
       let
         a = @[1, 2, 3]
       result = a[pos]

     when isMainModule:
       testException(IndexError, tester(30))
       testException(IndexError, tester(1))
       # --> Test failure at example.nim:20 with 'tester(1)'

   * raiseAssert
          proc raiseAssert*(msg: string) {.noinline.}

   * failedAssertImpl
          proc failedAssertImpl*(msg: string) {.raises: [], tags: [].}

   * shallow
          proc shallow*[T](s: var seq[T]) {.noSideEffect, inline.}

     marks a sequence s as shallow.  Subsequent assignments will not
     perform deep copies of s.  This is only useful for optimization
     purposes.

   * shallow
          proc shallow*(s: var string) {.noSideEffect, inline.}

     marks a string s as shallow.  Subsequent assignments will not
     perform deep copies of s.  This is only useful for optimization
     purposes.

   * insert
          proc insert*(x: var string; item: string; i = 0.Natural) {.noSideEffect.}

     inserts item into x at position i.

   * compiles
          proc compiles*(x: expr): bool {.magic: "Compiles", noSideEffect, compileTime.}

     Special compile-time procedure that checks whether x can be
     compiled without any semantic error.  This can be used to check
     whether a type supports some operation:
     when not compiles(3 + 4):
       echo "'+' for integers is available"

   * safeAdd
          proc safeAdd*[T](x: var seq[T]; y: T) {.noSideEffect.}

     Adds 'y' to 'x' unless 'x' is not yet initialized; in that case,
     'x' becomes '@[y]'

   * safeAdd
          proc safeAdd*(x: var string; y: char)

     Adds 'y' to 'x'.  If 'x' is 'nil' it is initialized to '""'

   * safeAdd
          proc safeAdd*(x: var string; y: string)

     Adds 'y' to 'x' unless 'x' is not yet initalized; in that case, 'x'
     becomes 'y'

   * locals
          proc locals*(): RootObj {.magic: "Plugin", noSideEffect.}

     generates a tuple constructor expression listing all the local
     variables in the current scope.  This is quite fast as it does not
     rely on any debug or runtime information.  Note that in constrast
     to what the official signature says, the return type is not
     'RootObj' but a tuple of a structure that depends on the current
     scope.  Example:
     proc testLocals() =
       var
         a = "something"
         b = 4
         c = locals()
         d = "super!"

       b = 1
       for name, value in fieldPairs(c):
         echo "name ", name, " with value ", value
       echo "B is ", b
     # -> name a with value something
     # -> name b with value 4
     # -> B is 1

   * deepCopy
          proc deepCopy*[T](x: var T; y: T) {.noSideEffect, magic: "DeepCopy".}

     performs a deep copy of x.  This is also used by the code generator
     for the implementation of 'spawn'.

   * procCall
          proc procCall*(x: expr) {.magic: "ProcCall", compileTime.}

     special magic to prohibit dynamic binding for method calls.  This
     is similar to super in ordinary OO languages.
     # 'someMethod' will be resolved fully statically:
     procCall someMethod(a, b)

   * '^'
          proc `^`*[T](x: int; y: openArray[T]): int {.noSideEffect, magic: "Roof".}

   * '^'
          proc `^`*(x: int): int {.noSideEffect, magic: "Roof".}

     builtin roof operator that can be used for convenient array access.
     'a[^x]' is rewritten to 'a[a.len-x]'.  However currently the 'a'
     expression must not have side effects for this to compile.  Note
     that since this is a builtin, it automatically works for all kinds
     of overloaded '[]' or '[]=' accessors.

   * xlen
          proc xlen*(x: string): int {.magic: "XLenStr", noSideEffect.}

   * xlen
          proc xlen*[T](x: seq[T]): int {.magic: "XLenSeq", noSideEffect.}

     returns the length of a sequence or a string without testing for
     'nil'.  This is an optimization that rarely makes sense.

6 Templates
***********

   * '!='
          template `!=`*(x, y: expr): expr {.immediate.}

     unequals operator.  This is a shorthand for 'not (x == y)'.

   * '&gt;='
          template `>=`*(x, y: expr): expr {.immediate.}

     "is greater or equals" operator.  This is the same as 'y <= x'.

   * '&gt;'
          template `>`*(x, y: expr): expr {.immediate.}

     "is greater" operator.  This is the same as 'y < x'.

   * incl
          template incl*[T](s: var set[T]; flags: set[T])

     includes the set of flags to the set 'x'.

   * excl
          template excl*[T](s: var set[T]; flags: set[T])

     excludes the set of flags to 'x'.

   * 'in'
          template `in`*(x, y: expr): expr {.immediate, dirty.}

     Sugar for contains
     assert(1 in (1..3) == true)
     assert(5 in (1..3) == false)

   * 'notin'
          template `notin`*(x, y: expr): expr {.immediate, dirty.}

     Sugar for not containing
     assert(1 notin (1..3) == false)
     assert(5 notin (1..3) == true)

   * 'isnot'
          template `isnot`*(x, y: expr): expr {.immediate.}

     Negated version of is.  Equivalent to 'not(x is y)'.

   * '&gt;=%'
          template `>=%`*(x, y: expr): expr {.immediate.}

     treats x and y as unsigned and compares them.  Returns true iff
     'unsigned(x) >= unsigned(y)'.

   * '&gt;%'
          template `>%`*(x, y: expr): expr {.immediate.}

     treats x and y as unsigned and compares them.  Returns true iff
     'unsigned(x) > unsigned(y)'.

   * accumulateResult
          template accumulateResult*(iter: expr)

     helps to convert an iterator to a proc.

   * newException
          template newException*(exceptn: typedesc; message: string): expr

     creates an exception object of type 'exceptn' and sets its 'msg'
     field to message.  Returns the new exception object.

   * stdmsg
          template stdmsg*(): File

   * currentSourcePath
          template currentSourcePath*(): string

     returns the full file-system path of the current source

   * assert
          template assert*(cond: bool; msg = "")

     Raises 'AssertionError' with msg if cond is false.  Note that
     'AssertionError' is hidden from the effect system, so it doesn't
     produce '{.raises: [AssertionError].}'.  This exception is only
     supposed to be caught by unit testing frameworks.  The compiler may
     not generate any code at all for 'assert' if it is advised to do so
     through the '-d:release' or '--assertions:off' command line
     switches (nimc.html#command-line-switches).

   * doAssert
          template doAssert*(cond: bool; msg = "")

     same as assert but is always turned on and not affected by the
     '--assertions' command line switch.

   * onFailedAssert
          template onFailedAssert*(msg: expr; code: stmt): stmt {.dirty, immediate.}

     Sets an assertion failure handler that will intercept any assert
     statements following onFailedAssert in the current module scope.
     # module-wide policy to change the failed assert
     # exception type in order to include a lineinfo
     onFailedAssert(msg):
       var e = new(TMyError)
       e.msg = msg
       e.lineinfo = instantiationInfo(-2)
       raise e

   * '..^'
          template `..^`*(a, b: expr): expr

     a shortcut for '..  ^' to avoid the common gotcha that a space
     between '..'  and '^' is required.

   * '..&lt;'
          template `..<`*(a, b: expr): expr

     a shortcut for '..  <' to avoid the common gotcha that a space
     between '..'  and '<' is required.

7 Iterators
***********

   * countdown
          iterator countdown*[T](a, b: T; step = 1): T {.inline.}

     Counts from ordinal value a down to b (inclusive) with the given
     step count.  T may be any ordinal type, step may only be positive.
     *Note*: This fails to count to 'low(int)' if T = int for efficiency
     reasons.

   * countup
          iterator countup*[S, T](a: S; b: T; step = 1): T {.inline.}

     Counts from ordinal value a up to b (inclusive) with the given step
     count.  S, T may be any ordinal type, step may only be positive.
     *Note*: This fails to count to 'high(int)' if T = int for
     efficiency reasons.

   * '..'
          iterator `..`*[S, T](a: S; b: T): T {.inline.}

     An alias for countup.

   * '||'
          iterator `||`*[S, T](a: S; b: T; annotation = ""): T {.inline, magic: "OmpParFor", sideEffect.}

     parallel loop iterator.  Same as ..  but the loop may run in
     parallel.  annotation is an additional annotation for the code
     generator to use.  Note that the compiler maps that to the '#pragma
     omp parallel for' construct of OpenMP and as such isn't aware of
     the parallelism in your code!  Be careful!  Later versions of '||'
     will get proper support by Nim's code generator and GC.

   * items
          iterator items*[T](a: openArray[T]): T {.inline.}

     iterates over each item of a.

   * mitems
          iterator mitems*[T](a: var openArray[T]): var T {.inline.}

     iterates over each item of a so that you can modify the yielded
     value.

   * items
          iterator items*[IX, T](a: array[IX, T]): T {.inline.}

     iterates over each item of a.

   * mitems
          iterator mitems*[IX, T](a: var array[IX, T]): var T {.inline.}

     iterates over each item of a so that you can modify the yielded
     value.

   * items
          iterator items*[T](a: set[T]): T {.inline.}

     iterates over each element of a.  items iterates only over the
     elements that are really in the set (and not over the ones the set
     is able to hold).

   * items
          iterator items*(a: cstring): char {.inline.}

     iterates over each item of a.

   * mitems
          iterator mitems*(a: var cstring): var char {.inline.}

     iterates over each item of a so that you can modify the yielded
     value.

   * items
          iterator items*(E: typedesc[enum]): E

     iterates over the values of the enum 'E'.

   * items
          iterator items*[T](s: Slice[T]): T

     iterates over the slice s, yielding each value between s.a and s.b
     (inclusively).

   * pairs
          iterator pairs*[T](a: openArray[T]): tuple[key: int, val: T] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.

   * mpairs
          iterator mpairs*[T](a: var openArray[T]): tuple[key: int, val: var T] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.
     'a[index]' can be modified.

   * pairs
          iterator pairs*[IX, T](a: array[IX, T]): tuple[key: IX, val: T] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.

   * mpairs
          iterator mpairs*[IX, T](a: var array[IX, T]): tuple[key: IX, val: var T] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.
     'a[index]' can be modified.

   * pairs
          iterator pairs*[T](a: seq[T]): tuple[key: int, val: T] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.

   * mpairs
          iterator mpairs*[T](a: var seq[T]): tuple[key: int, val: var T] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.
     'a[index]' can be modified.

   * pairs
          iterator pairs*(a: string): tuple[key: int, val: char] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.

   * mpairs
          iterator mpairs*(a: var string): tuple[key: int, val: var char] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.
     'a[index]' can be modified.

   * pairs
          iterator pairs*(a: cstring): tuple[key: int, val: char] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.

   * mpairs
          iterator mpairs*(a: var cstring): tuple[key: int, val: var char] {.inline.}

     iterates over each item of a.  Yields '(index, a[index])' pairs.
     'a[index]' can be modified.

   * fields object](x: T): RootObj {.magic: "Fields", noSideEffect.}
          iterator fields*[T: tuple |
              object](x: T): RootObj {.magic: "Fields", noSideEffect.}

     iterates over every field of x.  Warning: This really transforms
     the 'for' and unrolls the loop.  The current implementation also
     has a bug that affects symbol binding in the loop body.

   * fields object, T: tuple | object](x: S; y: T): tuple[a, b: expr]
     {.magic: "Fields", noSideEffect.}
          iterator fields*[S: tuple |
              object, T: tuple |
              object](x: S; y: T): tuple[a, b: expr] {.magic: "Fields", noSideEffect.}

     iterates over every field of x and y.  Warning: This is really
     transforms the 'for' and unrolls the loop.  The current
     implementation also has a bug that affects symbol binding in the
     loop body.

   * fieldPairs object](x: T): RootObj {.magic: "FieldPairs",
     noSideEffect.}
          iterator fieldPairs*[T: tuple |
              object](x: T): RootObj {.magic: "FieldPairs", noSideEffect.}

     Iterates over every field of x returning their name and value.

     When you iterate over objects with different field types you have
     to use the compile time 'when' instead of a runtime 'if' to select
     the code you want to run for each type.  To perform the comparison
     use the is operator (manual.html#is-operator).  Example:
     type
       Custom = object
         foo: string
         bar: bool

     proc `$`(x: Custom): string =
       result = "Custom:"
       for name, value in x.fieldPairs:
         when value is bool:
           result.add("\n\t" & name & " is " & $value)
         else:
           if value.isNil:
             result.add("\n\t" & name & " (nil)")
           else:
             result.add("\n\t" & name & " '" & value & "'")

     Another way to do the same without 'when' is to leave the task of
     picking the appropriate code to a secondary proc which you overload
     for each field type and pass the value to.

     Warning: This really transforms the 'for' and unrolls the loop.
     The current implementation also has a bug that affects symbol
     binding in the loop body.

   * fieldPairs object, T: tuple | object](x: S; y: T): tuple[a, b:
     expr] {.magic: "FieldPairs", noSideEffect.}
          iterator fieldPairs*[S: tuple |
              object, T: tuple |
              object](x: S; y: T): tuple[a, b: expr] {.magic: "FieldPairs", noSideEffect.}

     iterates over every field of x and y.  Warning: This really
     transforms the 'for' and unrolls the loop.  The current
     implementation also has a bug that affects symbol binding in the
     loop body.

   * lines
          iterator lines*(filename: string): TaintedString {.tags: [ReadIOEffect].}

     Iterates over any line in the file named filename.

     If the file does not exist EIO is raised.  The trailing newline
     character(s) are removed from the iterated lines.  Example:
     import strutils

     proc transformLetters(filename: string) =
       var buffer = ""
       for line in filename.lines:
         buffer.add(line.replace("a", "0") & '\x0A')
       writeFile(filename, buffer)

   * lines
          iterator lines*(f: File): TaintedString {.tags: [ReadIOEffect].}

     Iterate over any line in the file f.

     The trailing newline character(s) are removed from the iterated
     lines.  Example:
     proc countZeros(filename: File): tuple[lines, zeros: int] =
       for line in filename.lines:
         for letter in line:
           if letter == '0':
             result.zeros += 1
         result.lines += 1

   * items
          iterator items*[T](a: seq[T]): T {.inline.}

     iterates over each item of a.

   * mitems
          iterator mitems*[T](a: var seq[T]): var T {.inline.}

     iterates over each item of a so that you can modify the yielded
     value.

   * items
          iterator items*(a: string): char {.inline.}

     iterates over each item of a.

   * mitems
          iterator mitems*(a: var string): var char {.inline.}

     iterates over each item of a so that you can modify the yielded
     value.


File: nim-ref-0.13.0.info,  Node: /prelude,  Next: /nimrtl,  Prev: /system,  Up: Top


File: nim-ref-0.13.0.info,  Node: /nimrtl,  Next: /impure/nre,  Prev: /prelude,  Up: Top


File: nim-ref-0.13.0.info,  Node: /impure/nre,  Next: /impure/rdstdin,  Prev: /nimrtl,  Up: Top

8 Types
*******

   * StudyError

          StudyError* = ref object of RegexError


     Thrown when studying the regular expression failes for whatever
     reason.  The message contains the error code.

9 Procedures
************

   * captureCount
          proc captureCount*(pattern: Regex): int

   * captureNameId
          proc captureNameId*(pattern: Regex): Table[string, int]

   * captureBounds
          proc captureBounds*(pattern: RegexMatch): CaptureBounds

   * captures
          proc captures*(pattern: RegexMatch): Captures

   * '[]'
          proc `[]`*(pattern: CaptureBounds; i: int): Option[Slice[int]]

   * '[]'
          proc `[]`*(pattern: Captures; i: int): string

   * match
          proc match*(pattern: RegexMatch): string

   * matchBounds
          proc matchBounds*(pattern: RegexMatch): Slice[int]

   * '[]'
          proc `[]`*(pattern: CaptureBounds; name: string): Option[Slice[int]]

   * '[]'
          proc `[]`*(pattern: Captures; name: string): string

   * toTable
          proc toTable*(pattern: Captures; default: string = nil): Table[string, string]

   * toTable Option[Slice[int]]]
          proc toTable*(pattern: CaptureBounds; default = none(Slice[int])): Table[string,
              Option[Slice[int]]]

   * toSeq Option[Slice[int]]]
          proc toSeq*(pattern: CaptureBounds; default = none(Slice[int])): seq[
              Option[Slice[int]]]

   * toSeq
          proc toSeq*(pattern: Captures; default: string = nil): seq[string]

   * '$'
          proc `$`*(pattern: RegexMatch): string

   * '=='
          proc `==`*(a, b: Regex): bool

   * '=='
          proc `==`*(a, b: RegexMatch): bool

   * re
          proc re*(pattern: string): Regex

   * match
          proc match*(str: string; pattern: Regex; start = 0; endpos = int.high): Option[RegexMatch]

     Like "'find(...)"  <#proc-find>'__, but anchored to the start of
     the string.  This means that '"foo".match(re"f") == true', but
     '"foo".match(re"o") == false'.

   * find
          proc find*(str: string; pattern: Regex; start = 0; endpos = int.high): Option[RegexMatch]

     Finds the given pattern in the string between the end and start
     positions.

     'start'

          The start point at which to start matching.  '|abc' is '0';
          'a|bc' is '1'
     'endpos'

          The maximum index for a match; 'int.high' means the end of the
          string, otherwise it's an inclusive upper bound.

   * findAll
          proc findAll*(str: string; pattern: Regex; start = 0; endpos = int.high): seq[string]

   * split
          proc split*(str: string; pattern: Regex; maxSplit = - 1; start = 0): seq[string]

     Splits the string with the given regex.  This works according to
     the rules that Perl and Javascript use:

        * If the match is zero-width, then the string is still split:
          '"123".split(r"") == @["1", "2", "3"]'.
        * If the pattern has a capture in it, it is added after the
          string split: '"12".split(re"(\d)") == @["", "1", "", "2",
          ""]'.
        * If 'maxsplit != -1', then the string will only be split
          'maxsplit - 1' times.  This means that there will be
          'maxsplit' strings in the output seq.  '"1.2.3".split(re"\.",
          maxsplit = 2) == @["1", "2.3"]'

     'start' behaves the same as in "'find(...)"  <#proc-find>'__.

   * replace
          proc replace*(str: string; pattern: Regex; subproc: proc (match: RegexMatch): string): string

     Replaces each match of Regex in the string with 'sub', which should
     never be or return 'nil'.

     If 'sub' is a 'proc (RegexMatch): string', then it is executed with
     each match and the return value is the replacement value.

     If 'sub' is a 'proc (string): string', then it is executed with the
     full text of the match and and the return value is the replacement
     value.

     If 'sub' is a string, the syntax is as follows:

        * '$$' - literal '$'
        * '$123' - capture number '123'
        * '$foo' - named capture 'foo'
        * '${foo}' - same as above
        * '$1$#' - first and second captures
        * '$#' - first capture
        * '$0' - full match

     If a given capture is missing, a 'ValueError' exception is thrown.

   * replace
          proc replace*(str: string; pattern: Regex; subproc: proc (match: string): string): string

   * replace
          proc replace*(str: string; pattern: Regex; sub: string): string

   * escapeRe
          proc escapeRe*(str: string): string

     Escapes the string so it doesn't match any special characters.
     Incompatible with the Extra flag ('X').

10 Iterators
************

   * items
          iterator items*(pattern: CaptureBounds; default = none(Slice[int])): Option[Slice[int]]

   * items
          iterator items*(pattern: Captures; default: string = nil): string

   * findIter
          iterator findIter*(str: string; pattern: Regex; start = 0; endpos = int.high): RegexMatch

     Works the same as "'find(...)"  <#proc-find>'__, but finds every
     non-overlapping match.  '"2222".find(re"22")' is '"22", "22"', not
     '"22", "22", "22"'.

     Arguments are the same as "'find(...)"  <#proc-find>'__

     Variants:

        * 'proc findAll(...)' returns a 'seq[string]'


File: nim-ref-0.13.0.info,  Node: /impure/rdstdin,  Next: /impure/re,  Prev: /impure/nre,  Up: Top

11 Constant variables
*********************

   * KEY_EVENT
          KEY_EVENT* = 1

12 Procedures
*************

   * readLineFromStdin tags: [ReadIOEffect, WriteIOEffect].}
          proc readLineFromStdin*(prompt: string): TaintedString {.
              tags: [ReadIOEffect, WriteIOEffect].}

     Reads a line from stdin.

   * readLineFromStdin tags: [ReadIOEffect, WriteIOEffect].}
          proc readLineFromStdin*(prompt: string; line: var TaintedString): bool {.
              tags: [ReadIOEffect, WriteIOEffect].}

     Reads a line from stdin.  line must not be 'nil'!  May throw an IO
     exception.  A line of text may be delimited by 'CR', 'LF' or
     'CRLF'.  The newline character(s) are not part of the returned
     string.  Returns 'false' if the end of the file has been reached,
     'true' otherwise.  If 'false' is returned line contains no new
     data.

   * readConsoleInputW nLength: uint32; lpNumberOfEventsRead: var
     uint32): WINBOOL {.  stdcall, dynlib: "kernel32", importc:
     "ReadConsoleInputW".}
          proc readConsoleInputW*(hConsoleInput: THANDLE; lpBuffer: var INPUTRECORD;
                                 nLength: uint32; lpNumberOfEventsRead: var uint32): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "ReadConsoleInputW".}

   * readPasswordFromStdin tags: [ReadIOEffect, WriteIOEffect].}
          proc readPasswordFromStdin*(prompt: string; password: var TaintedString): bool {.
              tags: [ReadIOEffect, WriteIOEffect].}

     Reads a password from stdin without printing it.  password must not
     be 'nil'!  Returns 'false' if the end of the file has been reached,
     'true' otherwise.

   * readPasswordFromStdin
          proc readPasswordFromStdin*(prompt: string): TaintedString

     Reads a password from stdin without printing it.


File: nim-ref-0.13.0.info,  Node: /impure/re,  Next: /impure/db_postgres,  Prev: /impure/rdstdin,  Up: Top

13 Constant variables
*********************

   * MaxSubpatterns
          MaxSubpatterns* = 20

     defines the maximum number of subpatterns that can be captured.
     This limit still exists for 'replacef' and 'parallelReplace'.

   * reURL r":((//)|(\\\\))+[\w\d:#@%/;$()~_?\+\-\=\\\.\&]*\b"
          reURL* {.deprecated.} = r"\b(http(s)?|ftp|gopher|telnet|file|notes|ms-help)" &
              r":((//)|(\\\\))+[\w\d:#@%/;$()~_?\+\-\=\\\.\&]*\b"

     describes an URL

14 Types
********

   * RegexError

          RegexError* = object of ValueError


     is raised if the pattern is no valid regular expression.

15 Procedures
*************

   * re
          proc re*(s: string; flags = {reExtended, reStudy}): Regex {.deprecated.}

     Constructor of regular expressions.  Note that Nim's extended raw
     string literals support this syntax 're"[abc]"' as a short form for
     're(r"[abc]")'.

   * findBounds first, last: int]
          proc findBounds*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): tuple[
              first, last: int]

     returns the starting position and end position of pattern in s and
     the captured substrings in the array matches.  If it does not
     match, nothing is written into matches and '(-1,0)' is returned.

   * findBounds matches: var openArray[tuple[first, last: int]]; start =
     0): tuple[ first, last: int]
          proc findBounds*(s: string; pattern: Regex;
                          matches: var openArray[tuple[first, last: int]]; start = 0): tuple[
              first, last: int]

     returns the starting position and end position of 'pattern' in 's'
     and the captured substrings in the array matches.  If it does not
     match, nothing is written into matches and '(-1,0)' is returned.

   * findBounds
          proc findBounds*(s: string; pattern: Regex; start = 0): tuple[first, last: int]

     returns the starting position and end position of 'pattern' in 's'.
     If it does not match, '(-1,0)' is returned.

   * matchLen
          proc matchLen*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int

     the same as 'match', but it returns the length of the match, if
     there is no match, -1 is returned.  Note that a match length of
     zero can happen.

   * matchLen
          proc matchLen*(s: string; pattern: Regex; start = 0): int

     the same as 'match', but it returns the length of the match, if
     there is no match, -1 is returned.  Note that a match length of
     zero can happen.

   * match
          proc match*(s: string; pattern: Regex; start = 0): bool

     returns 'true' if 's[start..]' matches the 'pattern'.

   * match
          proc match*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool

     returns 'true' if 's[start..]' matches the 'pattern' and the
     captured substrings in the array 'matches'.  If it does not match,
     nothing is written into 'matches' and 'false' is returned.

   * find
          proc find*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int

     returns the starting position of 'pattern' in 's' and the captured
     substrings in the array 'matches'.  If it does not match, nothing
     is written into 'matches' and -1 is returned.

   * find
          proc find*(s: string; pattern: Regex; start = 0): int

     returns the starting position of 'pattern' in 's'.  If it does not
     match, -1 is returned.

   * findAll
          proc findAll*(s: string; pattern: Regex; start = 0): seq[string]

     returns all matching _substrings_ of s that match pattern.  If it
     does not match, @[] is returned.

   * contains
          proc contains*(s: string; pattern: Regex; start = 0): bool

     same as 'find(s, pattern, start) >= 0'

   * contains
          proc contains*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool

     same as 'find(s, pattern, matches, start) >= 0'

   * startsWith
          proc startsWith*(s: string; prefix: Regex): bool

     returns true if s starts with the pattern prefix

   * endsWith
          proc endsWith*(s: string; suffix: Regex): bool

     returns true if s ends with the pattern prefix

   * replace
          proc replace*(s: string; sub: Regex; by = ""): string

     Replaces sub in s by the string by.  Captures cannot be accessed in
     by.  Examples:
     "var1=key; var2=key2".replace(re"(\w+)=(\w+)")

     Results in:
     "; "

   * replacef
          proc replacef*(s: string; sub: Regex; by: string): string

     Replaces sub in s by the string by.  Captures can be accessed in by
     with the notation '$i' and '$#' (see strutils.'%').  Examples:
     "var1=key; var2=key2".replacef(re"(\w+)=(\w+)", "$1<-$2$2")

     Results in:

     "var1<-keykey; val2<-key2key2"

   * parallelReplace subs: openArray[tuple[pattern: Regex, repl:
     string]]): string
          proc parallelReplace*(s: string;
                               subs: openArray[tuple[pattern: Regex, repl: string]]): string

     Returns a modified copy of s with the substitutions in subs applied
     in parallel.

   * transformFile subs: openArray[tuple[pattern: Regex, repl: string]])
          proc transformFile*(infile, outfile: string;
                             subs: openArray[tuple[pattern: Regex, repl: string]])

     reads in the file infile, performs a parallel replacement (calls
     parallelReplace) and writes back to outfile.  Raises 'EIO' if an
     error occurs.  This is supposed to be used for quick scripting.

   * split
          proc split*(s: string; sep: Regex): seq[string]

     Splits the string s into substrings.

   * escapeRe
          proc escapeRe*(s: string): string

     escapes s so that it is matched verbatim when used as a regular
     expression.

16 Templates
************

   * '=~'
          template `=~`*(s: string; pattern: Regex): expr

     This calls 'match' with an implicit declared 'matches' array that
     can be used in the scope of the '=~' call:
     if line =~ re"\s*(\w+)\s*\=\s*(\w+)":
       # matches a key=value pair:
       echo("Key: ", matches[0])
       echo("Value: ", matches[1])
     elif line =~ re"\s*(\#.*)":
       # matches a comment
       # note that the implicit ``matches`` array is different from the
       # ``matches`` array of the first branch
       echo("comment: ", matches[0])
     else:
       echo("syntax error")

17 Iterators
************

   * findAll
          iterator findAll*(s: string; pattern: Regex; start = 0): string

     Yields all matching _substrings_ of s that match pattern.

     Note that since this is an iterator you should not modify the
     string you are iterating over: bad things could happen.

   * split
          iterator split*(s: string; sep: Regex): string

     Splits the string s into substrings.

     Substrings are separated by the regular expression sep.  Examples:
     for word in split("00232this02939is39an22example111", re"\d+"):
       writeLine(stdout, word)

     Results in:
     ""
     "this"
     "is"
     "an"
     "example"
     ""


File: nim-ref-0.13.0.info,  Node: /impure/db_postgres,  Next: /impure/osinfo_posix,  Prev: /impure/re,  Up: Top

18 Types
********

   * SqlPrepared
          SqlPrepared* = distinct string

     a identifier for the prepared queries

19 Procedures
*************

   * dbError
          proc dbError*(db: DbConn) {.noreturn.}

     raises a DbError exception.

   * dbQuote
          proc dbQuote*(s: string): string

     DB quotes the string.

   * tryExec tags: [ReadDbEffect, WriteDbEffect].}
          proc tryExec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
              tags: [ReadDbEffect, WriteDbEffect].}

     tries to execute the query and returns true if successful, false
     otherwise.

   * tryExec tags: [ReadDbEffect, WriteDbEffect].}
          proc tryExec*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): bool {.
              tags: [ReadDbEffect, WriteDbEffect].}

     tries to execute the query and returns true if successful, false
     otherwise.

   * exec tags: [ReadDbEffect, WriteDbEffect].}
          proc exec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
              tags: [ReadDbEffect, WriteDbEffect].}

     executes the query and raises EDB if not successful.

   * exec tags: [ReadDbEffect, WriteDbEffect].}
          proc exec*(db: DbConn; stmtName: SqlPrepared; args: varargs[string]) {.
              tags: [ReadDbEffect, WriteDbEffect].}

   * prepare
          proc prepare*(db: DbConn; stmtName: string; query: SqlQuery; nParams: int): SqlPrepared

     Creates a new 'SqlPrepared' statement.  Parameter substitution is
     done via '$1', '$2', '$3', etc.

   * '[]'
          proc `[]`*(row: InstantRow; col: int32): string {.inline.}

     returns text for given column of the row

   * len
          proc len*(row: InstantRow): int32 {.inline.}

     returns number of columns in the row

   * getRow tags: [ReadDbEffect].}
          proc getRow*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     retrieves a single row.  If the query doesn't return any rows, this
     proc will return a Row with empty strings for each column.

   * getRow tags: [ReadDbEffect].}
          proc getRow*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

   * getAllRows tags: [ReadDbEffect].}
          proc getAllRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {.
              tags: [ReadDbEffect].}

     executes the query and returns the whole result dataset.

   * getAllRows tags: [ReadDbEffect].}
          proc getAllRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): seq[Row] {.
              tags: [ReadDbEffect].}

     executes the prepared query and returns the whole result dataset.

   * getValue tags: [ReadDbEffect].}
          proc getValue*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
              tags: [ReadDbEffect].}

     executes the query and returns the first column of the first row of
     the result dataset.  Returns "" if the dataset contains no rows or
     the database value is NULL.

   * getValue tags: [ReadDbEffect].}
          proc getValue*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): string {.
              tags: [ReadDbEffect].}

     executes the query and returns the first column of the first row of
     the result dataset.  Returns "" if the dataset contains no rows or
     the database value is NULL.

   * tryInsertID tags: [WriteDbEffect].}
          proc tryInsertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [WriteDbEffect].}

     executes the query (typically "INSERT") and returns the generated
     ID for the row or -1 in case of an error.  For Postgre this adds
     'RETURNING id' to the query, so it only works if your primary key
     is named 'id'.

   * insertID tags: [WriteDbEffect].}
          proc insertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [WriteDbEffect].}

     executes the query (typically "INSERT") and returns the generated
     ID for the row.  For Postgre this adds 'RETURNING id' to the query,
     so it only works if your primary key is named 'id'.

   * execAffectedRows tags: [ReadDbEffect, WriteDbEffect].}
          proc execAffectedRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [ReadDbEffect, WriteDbEffect].}

     executes the query (typically "UPDATE") and returns the number of
     affected rows.

   * execAffectedRows tags: [ReadDbEffect, WriteDbEffect].}
          proc execAffectedRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): int64 {.
              tags: [ReadDbEffect, WriteDbEffect].}

     executes the query (typically "UPDATE") and returns the number of
     affected rows.

   * close
          proc close*(db: DbConn) {.tags: [DbEffect].}

     closes the database connection.

   * open
          proc open*(connection, user, password, database: string): DbConn {.tags: [DbEffect].}

     opens a database connection.  Raises EDb if the connection could
     not be established.

     Clients can also use Postgres keyword/value connection strings to
     connect.

     Example:
     con = open("", "", "", "host=localhost port=5432 dbname=mydb")

     See
     http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING
     (http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING)
     for more information.

     Note that the connection parameter is not used but exists to
     maintain the nim db api.

   * setEncoding
          proc setEncoding*(connection: DbConn; encoding: string): bool {.tags: [DbEffect].}

     sets the encoding of a database connection, returns true for
     success, false for failure.

20 Iterators
************

   * fastRows tags: [ReadDbEffect].}
          iterator fastRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     executes the query and iterates over the result dataset.  This is
     very fast, but potenially dangerous: If the for-loop-body executes
     another query, the results can be undefined.  For Postgres it is
     safe though.

   * fastRows tags: [ReadDbEffect].}
          iterator fastRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     executes the prepared query and iterates over the result dataset.

   * instantRows tags: [ReadDbEffect].}
          iterator instantRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
              tags: [ReadDbEffect].}

     same as fastRows but returns a handle that can be used to get
     column text on demand using [].  Returned handle is valid only
     within iterator body.

   * instantRows tags: [ReadDbEffect].}
          iterator instantRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): InstantRow {.
              tags: [ReadDbEffect].}

     same as fastRows but returns a handle that can be used to get
     column text on demand using [].  Returned handle is valid only
     within iterator body.

   * rows tags: [ReadDbEffect].}
          iterator rows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     same as fastRows, but slower and safe.

   * rows tags: [ReadDbEffect].}
          iterator rows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     same as fastRows, but slower and safe.


File: nim-ref-0.13.0.info,  Node: /impure/osinfo_posix,  Next: /impure/db_odbc,  Prev: /impure/db_postgres,  Up: Top


File: nim-ref-0.13.0.info,  Node: /impure/db_odbc,  Next: /impure/osinfo_win,  Prev: /impure/osinfo_posix,  Up: Top

21 Types
********

   * InstantRow
          InstantRow* = tuple[row: seq[string], len: int]

     a handle that can be used to get a row's column text on demand

22 Procedures
*************

   * dbError
          proc dbError*(db: var DbConn) {.tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Raises an [DbError] exception with ODBC error information

   * dbQuote
          proc dbQuote*(s: string): string {.noSideEffect.}

     DB quotes the string.

   * tryExec tags: [ReadDbEffect, WriteDbEffect], raises: [].}
          proc tryExec*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [].}

     Tries to execute the query and returns true if successful, false
     otherwise.

   * exec tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}
          proc exec*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Executes the query and raises EDB if not successful.

   * '[]'
          proc `[]`*(row: InstantRow; col: int): string {.inline.}

     Returns text for given column of the row

   * len
          proc len*(row: InstantRow): int {.inline.}

     Returns number of columns in the row

   * getRow tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}
          proc getRow*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Retrieves a single row.  If the query doesn't return any rows, this
     proc will return a Row with empty strings for each column.

   * getAllRows tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}
          proc getAllRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Executes the query and returns the whole result dataset.

   * getValue tags: [ReadDbEffect, WriteDbEffect], raises: [].}
          proc getValue*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [].}

     Executes the query and returns the first column of the first row of
     the result dataset.  Returns "" if the dataset contains no rows or
     the database value is NULL.

   * tryInsertId tags: [ReadDbEffect, WriteDbEffect], raises: [].}
          proc tryInsertId*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [].}

     Executes the query (typically "INSERT") and returns the generated
     ID for the row or -1 in case of an error.

   * insertId tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}
          proc insertId*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Executes the query (typically "INSERT") and returns the generated
     ID for the row.

   * execAffectedRows tags: [ReadDbEffect, WriteDbEffect], raises:
     [DbError].}
          proc execAffectedRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Runs the query (typically "UPDATE") and returns the number of
     affected rows

   * close
          proc close*(db: var DbConn) {.tags: [WriteDbEffect], raises: [].}

     Closes the database connection.

   * open tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}
          proc open*(connection, user, password, database: string): DbConn {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Opens a database connection.

     Raises EDb if the connection could not be established.

     Currently the database parameter is ignored, but included to match
     'open()' in the other db_xxxxx library modules.

   * setEncoding tags: [ReadDbEffect, WriteDbEffect], raises:
     [DbError].}
          proc setEncoding*(connection: DbConn; encoding: string): bool {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Currently not implemented for ODBC.

     Sets the encoding of a database connection, returns true for
     success, false for failure.

23 Iterators
************

   * fastRows tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}
          iterator fastRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Executes the query and iterates over the result dataset.

     This is very fast, but potentially dangerous.  Use this iterator
     only if you require *ALL* the rows.

     Breaking the fastRows() iterator during a loop may cause a driver
     error for subsequenct queries

     Rows are retrieved from the server at each iteration.

   * instantRows tags: [ReadDbEffect, WriteDbEffect].}
          iterator instantRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
              tags: [ReadDbEffect, WriteDbEffect].}

     Same as fastRows but returns a handle that can be used to get
     column text on demand using [].  Returned handle is valid only
     within the interator body.

   * rows tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}
          iterator rows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}

     Same as fastRows, but slower and safe.

     This retrieves ALL rows into memory before iterating through the
     rows.  Large dataset queries will impact on memory usage.


File: nim-ref-0.13.0.info,  Node: /impure/osinfo_win,  Next: /impure/db_mysql,  Prev: /impure/db_odbc,  Up: Top


File: nim-ref-0.13.0.info,  Node: /impure/db_mysql,  Next: /impure/ssl,  Prev: /impure/osinfo_win,  Up: Top

24 Types
********

   * InstantRow row: cstringArray len: int

          InstantRow* = object
            row: cstringArray
            len: int


     a handle that can be used to get a row's column text on demand

25 Procedures
*************

   * dbError
          proc dbError*(db: DbConn) {.noreturn.}

     raises a DbError exception.

   * dbQuote
          proc dbQuote*(s: string): string

     DB quotes the string.

   * tryExec tags: [ReadDbEffect, WriteDbEffect].}
          proc tryExec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
              tags: [ReadDbEffect, WriteDbEffect].}

     tries to execute the query and returns true if successful, false
     otherwise.

   * exec tags: [ReadDbEffect, WriteDbEffect].}
          proc exec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
              tags: [ReadDbEffect, WriteDbEffect].}

     executes the query and raises EDB if not successful.

   * '[]'
          proc `[]`*(row: InstantRow; col: int): string {.inline.}

     Returns text for given column of the row.

   * len
          proc len*(row: InstantRow): int {.inline.}

     Returns number of columns in the row.

   * getRow tags: [ReadDbEffect].}
          proc getRow*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     Retrieves a single row.  If the query doesn't return any rows, this
     proc will return a Row with empty strings for each column.

   * getAllRows tags: [ReadDbEffect].}
          proc getAllRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {.
              tags: [ReadDbEffect].}

     executes the query and returns the whole result dataset.

   * getValue tags: [ReadDbEffect].}
          proc getValue*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
              tags: [ReadDbEffect].}

     executes the query and returns the first column of the first row of
     the result dataset.  Returns "" if the dataset contains no rows or
     the database value is NULL.

   * tryInsertId tags: [WriteDbEffect].}
          proc tryInsertId*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [WriteDbEffect].}

     executes the query (typically "INSERT") and returns the generated
     ID for the row or -1 in case of an error.

   * insertId tags: [WriteDbEffect].}
          proc insertId*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [WriteDbEffect].}

     executes the query (typically "INSERT") and returns the generated
     ID for the row.

   * execAffectedRows tags: [ReadDbEffect, WriteDbEffect].}
          proc execAffectedRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [ReadDbEffect, WriteDbEffect].}

     runs the query (typically "UPDATE") and returns the number of
     affected rows

   * close
          proc close*(db: DbConn) {.tags: [DbEffect].}

     closes the database connection.

   * open
          proc open*(connection, user, password, database: string): DbConn {.tags: [DbEffect].}

     opens a database connection.  Raises EDb if the connection could
     not be established.

   * setEncoding
          proc setEncoding*(connection: DbConn; encoding: string): bool {.tags: [DbEffect].}

     sets the encoding of a database connection, returns true for
     success, false for failure.

26 Iterators
************

   * fastRows tags: [ReadDbEffect].}
          iterator fastRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     executes the query and iterates over the result dataset.

     This is very fast, but potentially dangerous.  Use this iterator
     only if you require *ALL* the rows.

     Breaking the fastRows() iterator during a loop will cause the next
     database query to raise an [EDb] exception 'Commands out of sync'.

   * instantRows tags: [ReadDbEffect].}
          iterator instantRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
              tags: [ReadDbEffect].}

     Same as fastRows but returns a handle that can be used to get
     column text on demand using [].  Returned handle is valid only
     within the iterator body.

   * instantRows args: varargs[string, '$']): InstantRow
          iterator instantRows*(db: DbConn; columns: var DbColumns; query: SqlQuery;
                               args: varargs[string, `$`]): InstantRow

     Same as fastRows but returns a handle that can be used to get
     column text on demand using [].  Returned handle is valid only
     within the iterator body.

   * rows tags: [ReadDbEffect].}
          iterator rows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     same as fastRows, but slower and safe.


File: nim-ref-0.13.0.info,  Node: /impure/ssl,  Next: /impure/db_sqlite,  Prev: /impure/db_mysql,  Up: Top

27 Types
********

   * SecureSocket ssl: SslPtr bio: BIO

          SecureSocket* = object
            ssl: SslPtr
            bio: BIO


28 Procedures
*************

   * connect
          proc connect*(sock: var SecureSocket; address: string; port: int): int

     Connects to the specified address on the specified port.  Returns
     the result of the certificate validation.

   * recvLine
          proc recvLine*(sock: SecureSocket; line: var TaintedString): bool

     Acts in a similar fashion to the recvLine in the sockets module.
     Returns false when no data is available to be read.  Line must be
     initialized and not nil!

   * send
          proc send*(sock: SecureSocket; data: string)

     Writes data to the socket.

   * close
          proc close*(sock: SecureSocket)

     Closes the socket


File: nim-ref-0.13.0.info,  Node: /impure/db_sqlite,  Next: /impure/nre/private/util,  Prev: /impure/ssl,  Up: Top

29 Types
********

   * InstantRow
          InstantRow* = Pstmt

     a handle that can be used to get a row's column text on demand

30 Procedures
*************

   * dbError
          proc dbError*(db: DbConn) {.noreturn.}

     raises a DbError exception.

   * dbQuote
          proc dbQuote*(s: string): string

     DB quotes the string.

   * tryExec tags: [ReadDbEffect, WriteDbEffect].}
          proc tryExec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.
              tags: [ReadDbEffect, WriteDbEffect].}

     tries to execute the query and returns true if successful, false
     otherwise.

   * exec tags: [ReadDbEffect, WriteDbEffect].}
          proc exec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {.
              tags: [ReadDbEffect, WriteDbEffect].}

     executes the query and raises DbError if not successful.

   * '[]'
          proc `[]`*(row: InstantRow; col: int32): string {.inline.}

     returns text for given column of the row

   * len
          proc len*(row: InstantRow): int32 {.inline.}

     returns number of columns in the row

   * getRow tags: [ReadDbEffect].}
          proc getRow*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     retrieves a single row.  If the query doesn't return any rows, this
     proc will return a Row with empty strings for each column.

   * getAllRows tags: [ReadDbEffect].}
          proc getAllRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {.
              tags: [ReadDbEffect].}

     executes the query and returns the whole result dataset.

   * getValue tags: [ReadDbEffect].}
          proc getValue*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.
              tags: [ReadDbEffect].}

     executes the query and returns the first column of the first row of
     the result dataset.  Returns "" if the dataset contains no rows or
     the database value is NULL.

   * tryInsertID tags: [WriteDbEffect], raises: [].}
          proc tryInsertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [WriteDbEffect], raises: [].}

     executes the query (typically "INSERT") and returns the generated
     ID for the row or -1 in case of an error.

   * insertID tags: [WriteDbEffect].}
          proc insertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [WriteDbEffect].}

     executes the query (typically "INSERT") and returns the generated
     ID for the row.  For Postgre this adds 'RETURNING id' to the query,
     so it only works if your primary key is named 'id'.

   * execAffectedRows tags: [ReadDbEffect, WriteDbEffect].}
          proc execAffectedRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.
              tags: [ReadDbEffect, WriteDbEffect].}

     executes the query (typically "UPDATE") and returns the number of
     affected rows.

   * close
          proc close*(db: DbConn) {.tags: [DbEffect].}

     closes the database connection.

   * open
          proc open*(connection, user, password, database: string): DbConn {.tags: [DbEffect].}

     opens a database connection.  Raises EDb if the connection could
     not be established.  Only the 'connection' parameter is used for
     'sqlite'.

   * setEncoding
          proc setEncoding*(connection: DbConn; encoding: string): bool {.tags: [DbEffect].}

     sets the encoding of a database connection, returns true for
     success, false for failure.

     Note that the encoding cannot be changed once it's been set.
     According to SQLite3 documentation, any attempt to change the
     encoding after the database is created will be silently ignored.

31 Iterators
************

   * fastRows tags: [ReadDbEffect].}
          iterator fastRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     Executes the query and iterates over the result dataset.

     This is very fast, but potentially dangerous.  Use this iterator
     only if you require *ALL* the rows.

     Breaking the fastRows() iterator during a loop will cause the next
     database query to raise a DbError exception 'unable to close due to
     ...'.

   * instantRows tags: [ReadDbEffect].}
          iterator instantRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.
              tags: [ReadDbEffect].}

     same as fastRows but returns a handle that can be used to get
     column text on demand using [].  Returned handle is valid only
     within the iterator body.

   * instantRows args: varargs[string, '$']): InstantRow {.tags:
     [ReadDbEffect].}
          iterator instantRows*(db: DbConn; columns: var DbColumns; query: SqlQuery;
                               args: varargs[string, `$`]): InstantRow {.tags: [ReadDbEffect].}

     same as fastRows but returns a handle that can be used to get
     column text on demand using [].  Returned handle is valid only
     within the iterator body.

   * rows tags: [ReadDbEffect].}
          iterator rows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.
              tags: [ReadDbEffect].}

     same as FastRows, but slower and safe.


File: nim-ref-0.13.0.info,  Node: /impure/nre/private/util,  Next: /packages/docutils/rstast,  Prev: /impure/db_sqlite,  Up: Top

32 Procedures
*************

   * fget
          proc fget*[K, V](self: Table[K, V]; key: K): V

33 Templates
************

   * formatStr
          template formatStr*(howExpr, namegetter, idgetter: expr): expr


File: nim-ref-0.13.0.info,  Node: /packages/docutils/rstast,  Next: /packages/docutils/highlite,  Prev: /impure/nre/private/util,  Up: Top

34 Types
********

   * RstNode kind*: RstNodeKind ## the node's kind text*: string ##
     valid for leafs in the AST; and the title of ## the document or the
     section level*: int ## valid for some node kinds sons*: RstNodeSeq
     ## the node's sons

          RstNode* {.acyclic, final.} = object
            kind*: RstNodeKind           ## the node's kind
            text*: string                ## valid for leafs in the AST; and the title of
                        ## the document or the section
            level*: int                  ## valid for some node kinds
            sons*: RstNodeSeq            ## the node's sons


     an RST node's description

35 Procedures
*************

   * len
          proc len*(n: PRstNode): int

   * newRstNode
          proc newRstNode*(kind: RstNodeKind): PRstNode

   * newRstNode
          proc newRstNode*(kind: RstNodeKind; s: string): PRstNode

   * lastSon
          proc lastSon*(n: PRstNode): PRstNode

   * add
          proc add*(father, son: PRstNode)

   * addIfNotNil
          proc addIfNotNil*(father, son: PRstNode)

   * renderRstToRst
          proc renderRstToRst*(n: PRstNode; result: var string)

     renders n into its string representation and appends to result.

   * renderRstToJson
          proc renderRstToJson*(node: PRstNode): string

     Writes the given RST node as JSON that is in the form
     {
       "kind":string node.kind,
       "text":optional string node.text,
       "level":optional int node.level,
       "sons":optional node array
     }


File: nim-ref-0.13.0.info,  Node: /packages/docutils/highlite,  Next: /packages/docutils/rst,  Prev: /packages/docutils/rstast,  Up: Top

36 Types
********

   * SourceLanguage langNone, langNim, langNimrod, langCpp, langCsharp,
     langC, langJava
          SourceLanguage* = enum
            langNone, langNim, langNimrod, langCpp, langCsharp, langC, langJava

37 Procedures
*************

   * getSourceLanguage
          proc getSourceLanguage*(name: string): SourceLanguage

   * initGeneralTokenizer
          proc initGeneralTokenizer*(g: var GeneralTokenizer; buf: cstring)

   * initGeneralTokenizer
          proc initGeneralTokenizer*(g: var GeneralTokenizer; buf: string)

   * deinitGeneralTokenizer
          proc deinitGeneralTokenizer*(g: var GeneralTokenizer)

   * getNextToken
          proc getNextToken*(g: var GeneralTokenizer; lang: SourceLanguage)


File: nim-ref-0.13.0.info,  Node: /packages/docutils/rst,  Next: /packages/docutils/rstgen,  Prev: /packages/docutils/highlite,  Up: Top

38 Types
********

   * FindFileHandler
          FindFileHandler* = proc (filename: string): string {.nimcall.}

   * EParseError
          EParseError* = object of ValueError

39 Procedures
*************

   * rstnodeToRefname
          proc rstnodeToRefname*(n: PRstNode): string

   * addNodes
          proc addNodes*(n: PRstNode): string

   * getFieldValue
          proc getFieldValue*(n: PRstNode; fieldname: string): string

   * getArgument
          proc getArgument*(n: PRstNode): string

   * whichMsgClass
          proc whichMsgClass*(k: MsgKind): MsgClass

     returns which message class k belongs to.

   * defaultMsgHandler procvar.}
          proc defaultMsgHandler*(filename: string; line, col: int; msgkind: MsgKind; arg: string) {.
              procvar.}

   * defaultFindFile
          proc defaultFindFile*(filename: string): string {.procvar.}

   * getFieldValue
          proc getFieldValue*(n: PRstNode): string

     Returns the value of a specific 'rnField' node.

     This proc will assert if the node is not of the expected type.  The
     empty string will be returned as a minimum.  Any value in the rst
     will be stripped form leading/trailing whitespace.

   * rstParse options: RstParseOptions; findFile: FindFileHandler = nil;
     msgHandler: MsgHandler = nil): PRstNode
          proc rstParse*(text, filename: string; line, column: int; hasToc: var bool;
                        options: RstParseOptions; findFile: FindFileHandler = nil;
                        msgHandler: MsgHandler = nil): PRstNode


File: nim-ref-0.13.0.info,  Node: /packages/docutils/rstgen,  Next: /pure/future,  Prev: /packages/docutils/rst,  Up: Top

40 Constant variables
*********************

   * IndexExt
          IndexExt* = ".idx"

41 Variables
************

   * splitter
          splitter*: string = "<wbr />"

42 Procedures
*************

   * initRstGenerator config: StringTableRef; filename: string; options:
     RstParseOptions; findFile: FindFileHandler = nil; msgHandler:
     MsgHandler = nil)
          proc initRstGenerator*(g: var RstGenerator; target: OutputTarget;
                                config: StringTableRef; filename: string;
                                options: RstParseOptions; findFile: FindFileHandler = nil;
                                msgHandler: MsgHandler = nil)

     Initializes a 'RstGenerator'.

     You need to call this before using a 'RstGenerator' with any other
     procs in this module.  Pass a non 'nil' 'StringTableRef' value as
     config with parameters used by the HTML output generator.  If you
     don't know what to use, pass the results of the defaultConfig()
     <#defaultConfig>_ proc.

     The filename parameter will be used for error reporting and
     creating index hyperlinks to the file, but you can pass an empty
     string here if you are parsing a stream in memory.  If filename
     ends with the '.nim' extension, the title for the document will be
     set by default to 'Module filename'.  This default title can be
     overriden by the embedded rst, but it helps to prettify the
     generated index if no title is found.

     The 'RstParseOptions', 'FindFileHandler' and 'MsgHandler' types are
     defined in the the packages/docutils/rst module (rst.html).
     'options' selects the behaviour of the rst parser.

     'findFile' is a proc used by the rst 'include' directive among
     others.  The purpose of this proc is to mangle or filter paths.  It
     receives paths specified in the rst document and has to return a
     valid path to existing files or the empty string otherwise.  If you
     pass 'nil', a default proc will be used which given a path returns
     the input path only if the file exists.  One use for this proc is
     to transform relative paths found in the document to absolute path,
     useful if the rst file and the resources it references are not in
     the same directory as the current working directory.

     The 'msgHandler' is a proc used for user error reporting.  It will
     be called with the filename, line, col, and type of any error found
     during parsing.  If you pass 'nil', a default message handler will
     be used which writes the messages to the standard output.

     Example:
     import packages/docutils/rstgen

     var gen: RstGenerator
     gen.initRstGenerator(outHtml, defaultConfig(), "filename", {})

   * writeIndexFile
          proc writeIndexFile*(g: var RstGenerator; outfile: string)

     Writes the current index buffer to the specified output file.

     You previously need to add entries to the index with the
     setIndexTerm() (#setIndexTerm) proc.  If the index is empty the
     file won't be created.

   * escChar
          proc escChar*(target: OutputTarget; dest: var string; c: char) {.inline.}

   * nextSplitPoint
          proc nextSplitPoint*(s: string; start: int): int

   * esc
          proc esc*(target: OutputTarget; s: string; splitAfter = - 1): string

   * renderRstToOut
          proc renderRstToOut*(d: var RstGenerator; n: PRstNode; result: var string)

     Writes into 'result' the rst ast 'n' using the 'd' configuration.

     Before using this proc you need to initialise a 'RstGenerator' with
     'initRstGenerator' and parse a rst file with 'rstParse' from the
     packages/docutils/rst module (rst.html).  Example:
     # ...configure gen and rst vars...
     var generatedHTML = ""
     renderRstToOut(gen, rst, generatedHTML)
     echo generatedHTML

   * setIndexTerm
          proc setIndexTerm*(d: var RstGenerator; id, term: string; linkTitle, linkDesc = "")

     Adds a term to the index using the specified hyperlink identifier.

     A new entry will be added to the index using the format
     'term<tab>file#id'.  The file part will come from the filename
     parameter used in a previous call to the initRstGenerator()
     (#initRstGenerator) proc.

     The id will be appended with a hash character only if its length is
     not zero, otherwise no specific anchor will be generated.  In
     general you should only pass an empty id value for the title of
     standalone rst documents (they are special for the mergeIndexes()
     (#mergeIndexes) proc, see Index (idx) file format
     (docgen.html#index-idx-file-format) for more information).  Unlike
     other index terms, title entries are inserted at the beginning of
     the accumulated buffer to maintain a logical order of entries.

     If linkTitle or linkDesc are not the empty string, two additional
     columns with their contents will be added.

     The index won't be written to disk unless you call writeIndexFile()
     (#writeIndexFile).  The purpose of the index is documented in the
     docgen tools guide (docgen.html#index-switch).

   * renderIndexTerm
          proc renderIndexTerm*(d: PDoc; n: PRstNode; result: var string)

     Renders the string decorated within 'foobar':idx: markers.

     Additionally adds the encosed text to the index as a term.  Since
     we are interested in different instances of the same term to have
     different entries, a table is used to keep track of the amount of
     times a term has previously appeared to give a different identifier
     value for each.

   * mergeIndexes
          proc mergeIndexes*(dir: string): string

     Merges all index files in dir and returns the generated index as
     HTML.

     This proc will first scan dir for index files with the '.idx'
     extension previously created by commands like 'nim doc|rst2html'
     which use the '--index:on' switch.  These index files are the
     result of calls to setIndexTerm() (#setIndexTerm) and
     writeIndexFile() (#writeIndexFile), so they are simple tab
     separated files.

     As convention this proc will split index files into two categories:
     documentation and API. API indices will be all joined together into
     a single big sorted index, making the bulk of the final index.
     This is good for API documentation because many symbols are repated
     in different modules.  On the other hand, documentation indices are
     essentially table of contents plus a few special markers.  These
     documents will be rendered in a separate section which tries to
     maintain the order and hierarchy of the symbols in the index file.

     To differentiate between a documentation and API file a convention
     is used: indices which contain one entry without the HTML hash
     character (#) will be considered documentation, since this
     hash-less entry is the explicit title of the document.  Indices
     without this explicit entry will be considered generated API
     extracted out of a source '.nim' file.

     Returns the merged and sorted indices into a single HTML block
     which can be further embedded into nimdoc templates.

   * renderTocEntries
          proc renderTocEntries*(d: var RstGenerator; j: var int; lvl: int; result: var string)

   * formatNamedVars varvalues: openArray[string]): string
          proc formatNamedVars*(frmt: string; varnames: openArray[string];
                               varvalues: openArray[string]): string

   * defaultConfig
          proc defaultConfig*(): StringTableRef

     Returns a default configuration for embedded HTML generation.

     The returned 'StringTableRef' contains the parameters used by the
     HTML engine to build the final output.  For information on what
     these parameters are and their purpose, please look up the file
     'config/nimdoc.cfg' bundled with the compiler.

     The only difference between the contents of that file and the
     values provided by this proc is the 'doc.file' variable.  The
     'doc.file' variable of the configuration file contains HTML to
     build standalone pages, while this proc returns just the content
     for procs like 'rstToHtml' to generate the bare minimum HTML.

   * rstToHtml
          proc rstToHtml*(s: string; options: RstParseOptions; config: StringTableRef): string

     Converts an input rst string into embeddable HTML.

     This convenience proc parses any input string using rst markup (it
     doesn't have to be a full document!)  and returns an embeddable
     piece of HTML. The proc is meant to be used in _online_
     environments without access to a meaningful filesystem, and
     therefore rst 'include' like directives won't work.  For an
     explanation of the 'config' parameter see the 'initRstGenerator'
     proc.  Example:
     import packages/docutils/rstgen, strtabs

     echo rstToHtml("*Hello* **world**!", {},
       newStringTable(modeStyleInsensitive))
     # --> <em>Hello</em> <strong>world</strong>!

     If you need to allow the rst 'include' directive or tweak the
     generated output you have to create your own 'RstGenerator' with
     'initRstGenerator' and related procs.


File: nim-ref-0.13.0.info,  Node: /pure/future,  Next: /pure/fsmonitor,  Prev: /packages/docutils/rstgen,  Up: Top

43 Variables
************

   * lc
          lc*: ListComprehension

44 Macros
*********

   * '=&gt;'
          macro `=>`*(p, b: expr): expr {.immediate.}

     Syntax sugar for anonymous procedures.
     proc passTwoAndTwo(f: (int, int) -> int): int =
       f(2, 2)

     passTwoAndTwo((x, y) => x + y) # 4

   * '-&gt;'
          macro `->`*(p, b: expr): expr {.immediate.}

     Syntax sugar for procedure types.
     proc pass2(f: (float, float) -> float): float =
       f(2, 2)

     # is the same as:

     proc pass2(f: proc (x, y: float): float): float =
       f(2, 2)

   * '[]'
          macro `[]`*(lc: ListComprehension; comp, typ: expr): expr

     List comprehension, returns a sequence.  comp is the actual list
     comprehension, for example 'x | (x <- 1..10, x mod 2 == 0)'.  typ
     is the type that will be stored inside the result seq.
     echo lc[x | (x <- 1..10, x mod 2 == 0), int]

     const n = 20
     echo lc[(x,y,z) | (x <- 1..n, y <- x..n, z <- y..n, x*x + y*y == z*z),
             tuple[a,b,c: int]]


File: nim-ref-0.13.0.info,  Node: /pure/fsmonitor,  Next: /pure/httpclient,  Prev: /pure/future,  Up: Top

45 Types
********

   * MonitorEvent case kind*: MonitorEventType of MonitorMoveSelf,
     MonitorMoved: oldPath*: string ## Old absolute location newPath*:
     string ## New absolute location

     else: fullname*: string ## Absolute filename of the file/directory
     affected.

     name*: string ## Non absolute filepath of the file/directory ##
     affected relative to the directory watched.  ## "" if this event
     refers to the file/directory ## watched.  wd*: cint ## Watch
     descriptor.

          MonitorEvent* = object
            case kind*: MonitorEventType
            of MonitorMoveSelf, MonitorMoved:
                oldPath*: string         ## Old absolute location
                newPath*: string         ## New absolute location

            else:
                fullname*: string        ## Absolute filename of the file/directory affected.

            name*: string                ## Non absolute filepath of the file/directory
                        ## affected relative to the directory watched.
                        ## "" if this event refers to the file/directory
                        ## watched.
            wd*: cint                    ## Watch descriptor.


     Type of the event.

46 Procedures
*************

   * newMonitor
          proc newMonitor*(): FSMonitor

     Creates a new file system monitor.

   * add
          proc add*(monitor: FSMonitor; target: string; filters = {MonitorAll}): cint {.discardable.}

     Adds 'target' which may be a directory or a file to the list of
     watched paths of 'monitor'.  You can specify the events to report
     using the 'filters' parameter.

   * del
          proc del*(monitor: FSMonitor; wd: cint)

     Removes watched directory or file as specified by 'wd' from
     'monitor'.

     If 'wd' is not a part of 'monitor' an EOS error is raised.

   * register handleEvent: proc (m: FSMonitor; ev: MonitorEvent)
     {.closure.})
          proc register*(d: Dispatcher; monitor: FSMonitor;
                        handleEvent: proc (m: FSMonitor; ev: MonitorEvent) {.closure.})

     Registers 'monitor' with dispatcher 'd'.


File: nim-ref-0.13.0.info,  Node: /pure/httpclient,  Next: /pure/marshal,  Prev: /pure/fsmonitor,  Up: Top

47 Constant variables
*********************

   * defUserAgent
          defUserAgent* = "Nim httpclient/" & NimVersion

48 Types
********

   * HttpRequestError
          HttpRequestError* = object of IOError

     Thrown in the 'getContent' proc and 'postContent' proc, when the
     server returns an error

   * HttpMethod httpHEAD, ## Asks for the response identical to the one
     that would ## correspond to a GET request, but without the response
     ## body.  httpGET, ## Retrieves the specified resource.  httpPOST,
     ## Submits data to be processed to the identified ## resource.  The
     data is included in the body of the ## request.  httpPUT, ##
     Uploads a representation of the specified resource.  httpDELETE, ##
     Deletes the specified resource.  httpTRACE, ## Echoes back the
     received request, so that a client ## can see what intermediate
     servers are adding or ## changing in the request.  httpOPTIONS, ##
     Returns the HTTP methods that the server supports ## for specified
     address.  httpCONNECT ## Converts the request connection to a
     transparent ## TCP/IP tunnel, usually used for proxies.
          HttpMethod* = enum
            httpHEAD, ## Asks for the response identical to the one that would
                     ## correspond to a GET request, but without the response
                     ## body.
            httpGET,                    ## Retrieves the specified resource.
            httpPOST,                   ## Submits data to be processed to the identified
                     ## resource. The data is included in the body of the
                     ## request.
            httpPUT,                    ## Uploads a representation of the specified resource.
            httpDELETE,                 ## Deletes the specified resource.
            httpTRACE,                  ## Echoes back the received request, so that a client
                      ## can see what intermediate servers are adding or
                      ## changing in the request.
            httpOPTIONS,                ## Returns the HTTP methods that the server supports
                        ## for specified address.
            httpCONNECT                 ## Converts the request connection to a transparent
                       ## TCP/IP tunnel, usually used for proxies.

     the requested HttpMethod

   * AsyncHttpClient socket: AsyncSocket connected: bool currentURL: Uri
     headers*: StringTableRef maxRedirects: int userAgent: string when
     defined(ssl): sslContext: net.SslContext

          AsyncHttpClient* = ref object
            socket: AsyncSocket
            connected: bool
            currentURL: Uri
            headers*: StringTableRef
            maxRedirects: int
            userAgent: string
            when defined(ssl):
                sslContext: net.SslContext



     Where we are currently connected.

49 Procedures
*************

   * newProxy
          proc newProxy*(url: string; auth = ""): Proxy

     Constructs a new 'TProxy' object.

   * newMultipartData
          proc newMultipartData*(): MultipartData

     Constructs a new 'MultipartData' object.

   * add contentType: string = nil)
          proc add*(p: var MultipartData; name, content: string; filename: string = nil;
                   contentType: string = nil)

     Add a value to the multipart data.  Raises a ValueError exception
     if name, filename or contentType contain newline characters.

   * add
          proc add*(p: var MultipartData; xs: MultipartEntries): MultipartData {.discardable.}

     Add a list of multipart entries to the multipart data p.  All
     values are added without a filename and without a content type.
     data.add({"action": "login", "format": "json"})

   * newMultipartData
          proc newMultipartData*(xs: MultipartEntries): MultipartData

     Create a new multipart data object and fill it with the entries xs
     directly.
     var data = newMultipartData({"action": "login", "format": "json"})

   * addFiles discardable.}
          proc addFiles*(p: var MultipartData; xs: openarray[tuple[name, file: string]]): MultipartData {.
              discardable.}

     Add files to a multipart data object.  The file will be opened from
     your disk, read and sent with the automatically determined MIME
     type.  Raises an IOError if the file cannot be opened or reading
     fails.  To manually specify file content, filename and MIME type,
     use []= instead.
     data.addFiles({"uploaded_file": "public/test.html"})

   * '[]='
          proc `[]=`*(p: var MultipartData; name, content: string)

     Add a multipart entry to the multipart data p.  The value is added
     without a filename and without a content type.
     data["username"] = "NimUser"

   * '[]=' file: tuple[name, contentType, content: string])
          proc `[]=`*(p: var MultipartData; name: string;
                     file: tuple[name, contentType, content: string])

     Add a file to the multipart data p, specifying filename,
     contentType and content manually.
     data["uploaded_file"] = ("test.html", "text/html",
       "<html><head></head><body><p>test</p></body></html>")

   * request sslContext = defaultSSLContext; timeout = - 1; userAgent =
     defUserAgent; proxy: Proxy = nil): Response
          proc request*(url: string; httpMethod: string; extraHeaders = ""; body = "";
                       sslContext = defaultSSLContext; timeout = - 1; userAgent = defUserAgent;
                       proxy: Proxy = nil): Response

     Requests 'url' with the custom method string specified by the
     'httpMethod' parameter.
     Extra headers can be specified and must be separated by '\c\L'
     An optional timeout can be specified in milliseconds, if reading
     from the

     server takes longer than specified an ETimeout exception will be
     raised.

   * request sslContext = defaultSSLContext; timeout = - 1; userAgent =
     defUserAgent; proxy: Proxy = nil): Response
          proc request*(url: string; httpMethod = httpGET; extraHeaders = ""; body = "";
                       sslContext = defaultSSLContext; timeout = - 1; userAgent = defUserAgent;
                       proxy: Proxy = nil): Response

     Requests 'url' with the specified 'httpMethod'.
     Extra headers can be specified and must be separated by '\c\L'
     An optional timeout can be specified in milliseconds, if reading
     from the

     server takes longer than specified an ETimeout exception will be
     raised.

   * get sslContext: SSLContext = defaultSSLContext; timeout = - 1;
     userAgent = defUserAgent; proxy: Proxy = nil): Response
          proc get*(url: string; extraHeaders = ""; maxRedirects = 5;
                   sslContext: SSLContext = defaultSSLContext; timeout = - 1;
                   userAgent = defUserAgent; proxy: Proxy = nil): Response

     GETs the 'url' and returns a 'Response' object
     This proc also handles redirection
     Extra headers can be specified and must be separated by '\c\L'.
     An optional timeout can be specified in milliseconds, if reading
     from the

     server takes longer than specified an ETimeout exception will be
     raised.

   * getContent sslContext: SSLContext = defaultSSLContext; timeout = -
     1; userAgent = defUserAgent; proxy: Proxy = nil): string
          proc getContent*(url: string; extraHeaders = ""; maxRedirects = 5;
                          sslContext: SSLContext = defaultSSLContext; timeout = - 1;
                          userAgent = defUserAgent; proxy: Proxy = nil): string

     GETs the body and returns it as a string.
     Raises exceptions for the status codes '4xx' and '5xx'
     Extra headers can be specified and must be separated by '\c\L'.
     An optional timeout can be specified in milliseconds, if reading
     from the

     server takes longer than specified an ETimeout exception will be
     raised.

   * post sslContext: SSLContext = defaultSSLContext; timeout = - 1;
     userAgent = defUserAgent; proxy: Proxy = nil; multipart:
     MultipartData = nil): Response
          proc post*(url: string; extraHeaders = ""; body = ""; maxRedirects = 5;
                    sslContext: SSLContext = defaultSSLContext; timeout = - 1;
                    userAgent = defUserAgent; proxy: Proxy = nil; multipart: MultipartData = nil): Response

     POSTs 'body' to the 'url' and returns a 'Response' object.
     This proc adds the necessary Content-Length header.
     This proc also handles redirection.
     Extra headers can be specified and must be separated by '\c\L'.
     An optional timeout can be specified in milliseconds, if reading
     from the

     server takes longer than specified an ETimeout exception will be
     raised.  | The optional 'multipart' parameter can be used to create
     'multipart/form-data' POSTs comfortably.

   * postContent sslContext: SSLContext = defaultSSLContext; timeout = -
     1; userAgent = defUserAgent; proxy: Proxy = nil; multipart:
     MultipartData = nil): string
          proc postContent*(url: string; extraHeaders = ""; body = ""; maxRedirects = 5;
                           sslContext: SSLContext = defaultSSLContext; timeout = - 1;
                           userAgent = defUserAgent; proxy: Proxy = nil;
                           multipart: MultipartData = nil): string

     POSTs 'body' to 'url' and returns the response's body as a string
     Raises exceptions for the status codes '4xx' and '5xx'
     Extra headers can be specified and must be separated by '\c\L'.
     An optional timeout can be specified in milliseconds, if reading
     from the

     server takes longer than specified an ETimeout exception will be
     raised.  | The optional 'multipart' parameter can be used to create
     'multipart/form-data' POSTs comfortably.

   * downloadFile sslContext: SSLContext = defaultSSLContext; timeout =
     - 1; userAgent = defUserAgent; proxy: Proxy = nil)
          proc downloadFile*(url: string; outputFilename: string;
                            sslContext: SSLContext = defaultSSLContext; timeout = - 1;
                            userAgent = defUserAgent; proxy: Proxy = nil)

     Downloads 'url' and saves it to 'outputFilename'
     An optional timeout can be specified in milliseconds, if reading
     from the

     server takes longer than specified an ETimeout exception will be
     raised.

   * newAsyncHttpClient sslContext = defaultSslContext): AsyncHttpClient
          proc newAsyncHttpClient*(userAgent = defUserAgent; maxRedirects = 5;
                                  sslContext = defaultSslContext): AsyncHttpClient

     Creates a new AsyncHttpClient instance.

     'userAgent' specifies the user agent that will be used when making
     requests.

     'maxRedirects' specifies the maximum amount of redirects to follow,
     default is 5.

     'sslContext' specifies the SSL context to use for HTTPS requests.

   * close
          proc close*(client: AsyncHttpClient)

     Closes any connections held by the HTTP client.

   * request Response] {.async.}
          proc request*(client: AsyncHttpClient; url: string; httpMethod: string; body = ""): Future[
              Response] {.async.}

     Connects to the hostname specified by the URL and performs a
     request using the custom method string specified by 'httpMethod'.

     Connection will kept alive.  Further requests on the same 'client'
     to the same hostname will not require a new connection to be made.
     The connection can be closed by using the 'close' procedure.

     The returned future will complete once the request is completed.

   * request Response]
          proc request*(client: AsyncHttpClient; url: string; httpMethod = httpGET; body = ""): Future[
              Response]

     Connects to the hostname specified by the URL and performs a
     request using the method specified.

     Connection will kept alive.  Further requests on the same 'client'
     to the same hostname will not require a new connection to be made.
     The connection can be closed by using the 'close' procedure.

     The returned future will complete once the request is completed.

   * get
          proc get*(client: AsyncHttpClient; url: string): Future[Response] {.async.}

     Connects to the hostname specified by the URL and performs a GET
     request.

     This procedure will follow redirects up to a maximum number of
     redirects specified in 'newAsyncHttpClient'.

   * post multipart: MultipartData = nil): Future[Response] {.async.}
          proc post*(client: AsyncHttpClient; url: string; body = "";
                    multipart: MultipartData = nil): Future[Response] {.async.}

     Connects to the hostname specified by the URL and performs a POST
     request.

     This procedure will follow redirects up to a maximum number of
     redirects specified in 'newAsyncHttpClient'.


File: nim-ref-0.13.0.info,  Node: /pure/marshal,  Next: /pure/pegs,  Prev: /pure/httpclient,  Up: Top

50 Procedures
*************

   * load
          proc load*[T](s: Stream; data: var T)

     loads data from the stream s.  Raises EIO in case of an error.

   * store
          proc store*[T](s: Stream; data: T)

     stores data into the stream s.  Raises EIO in case of an error.

   * '$$'
          proc `$$`*[T](x: T): string

     returns a string representation of x.

   * to
          proc to*[T](data: string): T

     reads data and transforms it to a 'T'.


File: nim-ref-0.13.0.info,  Node: /pure/pegs,  Next: /pure/parsesql,  Prev: /pure/marshal,  Up: Top

51 Constant variables
*********************

   * MaxSubpatterns
          MaxSubpatterns* = 20

     defines the maximum number of subpatterns that can be captured.
     More subpatterns cannot be captured!

52 Types
********

   * Peg
          Peg* = Node

     type that represents a PEG

   * Captures matches: array[0 ..  MaxSubpatterns - 1, tuple[first,
     last: int]] ml: int origStart: int

          Captures* = object
            matches: array[0 .. MaxSubpatterns - 1, tuple[first, last: int]]
            ml: int
            origStart: int


     contains the captured substrings.

53 Procedures
*************

   * term
          proc term*(t: string): Peg {.nosideEffect, rtl, extern: "npegs$1Str".}

     constructs a PEG from a terminal string

   * termIgnoreCase
          proc termIgnoreCase*(t: string): Peg {.nosideEffect, rtl, extern: "npegs$1".}

     constructs a PEG from a terminal string; ignore case for matching

   * termIgnoreStyle
          proc termIgnoreStyle*(t: string): Peg {.nosideEffect, rtl, extern: "npegs$1".}

     constructs a PEG from a terminal string; ignore style for matching

   * term
          proc term*(t: char): Peg {.nosideEffect, rtl, extern: "npegs$1Char".}

     constructs a PEG from a terminal char

   * charSet
          proc charSet*(s: set[char]): Peg {.nosideEffect, rtl, extern: "npegs$1".}

     constructs a PEG from a character set s

   * '/'
          proc `/`*(a: varargs[Peg]): Peg {.nosideEffect, rtl, extern: "npegsOrderedChoice".}

     constructs an ordered choice with the PEGs in a

   * sequence
          proc sequence*(a: varargs[Peg]): Peg {.nosideEffect, rtl, extern: "npegs$1".}

     constructs a sequence with all the PEGs from a

   * '?'
          proc `?`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsOptional".}

     constructs an optional for the PEG a

   * '*'
          proc `*`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsGreedyRep".}

     constructs a "greedy repetition" for the PEG a

   * '!*'
          proc `!*`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsSearch".}

     constructs a "search" for the PEG a

   * '!*\'
          proc `!*\`*(a: Peg): Peg {.noSideEffect, rtl, extern: "npgegsCapturedSearch".}

     constructs a "captured search" for the PEG a

   * '+'
          proc `+`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsGreedyPosRep".}

     constructs a "greedy positive repetition" with the PEG a

   * '&amp;'
          proc `&`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsAndPredicate".}

     constructs an "and predicate" with the PEG a

   * '!'
          proc `!`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsNotPredicate".}

     constructs a "not predicate" with the PEG a

   * any
          proc any*(): Peg {.inline.}

     constructs the PEG any character ('.')

   * anyRune
          proc anyRune*(): Peg {.inline.}

     constructs the PEG any rune ('_')

   * newLine
          proc newLine*(): Peg {.inline.}

     constructs the PEG newline ('\n')

   * unicodeLetter
          proc unicodeLetter*(): Peg {.inline.}

     constructs the PEG '\letter' which matches any Unicode letter.

   * unicodeLower
          proc unicodeLower*(): Peg {.inline.}

     constructs the PEG '\lower' which matches any Unicode lowercase
     letter.

   * unicodeUpper
          proc unicodeUpper*(): Peg {.inline.}

     constructs the PEG '\upper' which matches any Unicode uppercase
     letter.

   * unicodeTitle
          proc unicodeTitle*(): Peg {.inline.}

     constructs the PEG '\title' which matches any Unicode title letter.

   * unicodeWhitespace
          proc unicodeWhitespace*(): Peg {.inline.}

     constructs the PEG '\white' which matches any Unicode whitespace
     character.

   * startAnchor
          proc startAnchor*(): Peg {.inline.}

     constructs the PEG '^' which matches the start of the input.

   * endAnchor
          proc endAnchor*(): Peg {.inline.}

     constructs the PEG '$' which matches the end of the input.

   * capture
          proc capture*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsCapture".}

     constructs a capture with the PEG a

   * backref extern: "npegs$1".}
          proc backref*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, rtl,
              extern: "npegs$1".}

     constructs a back reference of the given index.  index starts
     counting from 1.

   * backrefIgnoreCase extern: "npegs$1".}
          proc backrefIgnoreCase*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, rtl,
              extern: "npegs$1".}

     constructs a back reference of the given index.  index starts
     counting from 1.  Ignores case for matching.

   * backrefIgnoreStyle extern: "npegs$1".}
          proc backrefIgnoreStyle*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, rtl,
              extern: "npegs$1".}

     constructs a back reference of the given index.  index starts
     counting from 1.  Ignores style for matching.

   * nonterminal
          proc nonterminal*(n: NonTerminal): Peg {.nosideEffect, rtl, extern: "npegs$1".}

     constructs a PEG that consists of the nonterminal symbol

   * newNonTerminal extern: "npegs$1".}
          proc newNonTerminal*(name: string; line, column: int): NonTerminal {.nosideEffect, rtl,
              extern: "npegs$1".}

     constructs a nonterminal symbol

   * '$'
          proc `$`*(r: Peg): string {.nosideEffect, rtl, extern: "npegsToString".}

     converts a PEG to its string representation

   * bounds
          proc bounds*(c: Captures; i: range[0 .. MaxSubpatterns - 1]): tuple[first, last: int]

     returns the bounds '[first..last]' of the i'th capture.

   * rawMatch extern: "npegs$1".}
          proc rawMatch*(s: string; p: Peg; start: int; c: var Captures): int {.nosideEffect, rtl,
              extern: "npegs$1".}

     low-level matching proc that implements the PEG interpreter.  Use
     this for maximum efficiency (every other PEG operation ends up
     calling this proc).  Returns -1 if it does not match, else the
     length of the match

   * matchLen nosideEffect, rtl, extern: "npegs$1Capture".}
          proc matchLen*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {.
              nosideEffect, rtl, extern: "npegs$1Capture".}

     the same as 'match', but it returns the length of the match, if
     there is no match, -1 is returned.  Note that a match length of
     zero can happen.  It's possible that a suffix of s remains that
     does not belong to the match.

   * matchLen extern: "npegs$1".}
          proc matchLen*(s: string; pattern: Peg; start = 0): int {.nosideEffect, rtl,
              extern: "npegs$1".}

     the same as 'match', but it returns the length of the match, if
     there is no match, -1 is returned.  Note that a match length of
     zero can happen.  It's possible that a suffix of s remains that
     does not belong to the match.

   * match nosideEffect, rtl, extern: "npegs$1Capture".}
          proc match*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {.
              nosideEffect, rtl, extern: "npegs$1Capture".}

     returns 'true' if 's[start..]' matches the 'pattern' and the
     captured substrings in the array 'matches'.  If it does not match,
     nothing is written into 'matches' and 'false' is returned.

   * match extern: "npegs$1".}
          proc match*(s: string; pattern: Peg; start = 0): bool {.nosideEffect, rtl,
              extern: "npegs$1".}

     returns 'true' if 's' matches the 'pattern' beginning from 'start'.

   * find nosideEffect, rtl, extern: "npegs$1Capture".}
          proc find*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {.
              nosideEffect, rtl, extern: "npegs$1Capture".}

     returns the starting position of 'pattern' in 's' and the captured
     substrings in the array 'matches'.  If it does not match, nothing
     is written into 'matches' and -1 is returned.

   * findBounds first, last: int] {.nosideEffect, rtl, extern:
     "npegs$1Capture".}
          proc findBounds*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): tuple[
              first, last: int] {.nosideEffect, rtl, extern: "npegs$1Capture".}

     returns the starting position and end position of 'pattern' in 's'
     and the captured substrings in the array 'matches'.  If it does not
     match, nothing is written into 'matches' and (-1,0) is returned.

   * find
          proc find*(s: string; pattern: Peg; start = 0): int {.nosideEffect, rtl, extern: "npegs$1".}

     returns the starting position of 'pattern' in 's'.  If it does not
     match, -1 is returned.

   * findAll extern: "npegs$1".}
          proc findAll*(s: string; pattern: Peg; start = 0): seq[string] {.nosideEffect, rtl,
              extern: "npegs$1".}

     returns all matching _substrings_ of s that match pattern.  If it
     does not match, @[] is returned.

   * contains extern: "npegs$1".}
          proc contains*(s: string; pattern: Peg; start = 0): bool {.nosideEffect, rtl,
              extern: "npegs$1".}

     same as 'find(s, pattern, start) >= 0'

   * contains nosideEffect, rtl, extern: "npegs$1Capture".}
          proc contains*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {.
              nosideEffect, rtl, extern: "npegs$1Capture".}

     same as 'find(s, pattern, matches, start) >= 0'

   * startsWith extern: "npegs$1".}
          proc startsWith*(s: string; prefix: Peg; start = 0): bool {.nosideEffect, rtl,
              extern: "npegs$1".}

     returns true if s starts with the pattern prefix

   * endsWith extern: "npegs$1".}
          proc endsWith*(s: string; suffix: Peg; start = 0): bool {.nosideEffect, rtl,
              extern: "npegs$1".}

     returns true if s ends with the pattern suffix

   * replacef extern: "npegs$1".}
          proc replacef*(s: string; sub: Peg; by: string): string {.nosideEffect, rtl,
              extern: "npegs$1".}

     Replaces sub in s by the string by.  Captures can be accessed in by
     with the notation '$i' and '$#' (see strutils.'%').  Examples:
     "var1=key; var2=key2".replacef(peg"{\ident}'='{\ident}", "$1<-$2$2")

     Results in:
     "var1<-keykey; val2<-key2key2"

   * replace
          proc replace*(s: string; sub: Peg; by = ""): string {.nosideEffect, rtl, extern: "npegs$1".}

     Replaces sub in s by the string by.  Captures cannot be accessed in
     by.

   * parallelReplace nosideEffect, rtl, extern: "npegs$1".}
          proc parallelReplace*(s: string; subs: varargs[tuple[pattern: Peg, repl: string]]): string {.
              nosideEffect, rtl, extern: "npegs$1".}

     Returns a modified copy of s with the substitutions in subs applied
     in parallel.

   * transformFile subs: varargs[tuple[pattern: Peg, repl: string]])
     {.rtl, extern: "npegs$1".}
          proc transformFile*(infile, outfile: string;
                             subs: varargs[tuple[pattern: Peg, repl: string]]) {.rtl,
              extern: "npegs$1".}

     reads in the file infile, performs a parallel replacement (calls
     parallelReplace) and writes back to outfile.  Raises 'EIO' if an
     error occurs.  This is supposed to be used for quick scripting.

   * split
          proc split*(s: string; sep: Peg): seq[string] {.nosideEffect, rtl, extern: "npegs$1".}

     Splits the string s into substrings.

   * parsePeg
          proc parsePeg*(pattern: string; filename = "pattern"; line = 1; col = 0): Peg

     constructs a Peg object from pattern.  filename, line, col are used
     for error messages, but they only provide start offsets.  parsePeg
     keeps track of line and column numbers within pattern.

   * peg
          proc peg*(pattern: string): Peg

     constructs a Peg object from the pattern.  The short name has been
     chosen to encourage its use as a raw string modifier:
     peg"{\ident} \s* '=' \s* {.*}"

   * escapePeg
          proc escapePeg*(s: string): string

     escapes s so that it is matched verbatim when used as a peg.

54 Templates
************

   * letters
          template letters*(): expr

     expands to 'charset({'A'..'Z', 'a'..'z'})'

   * digits
          template digits*(): expr

     expands to 'charset({'0'..'9'})'

   * whitespace
          template whitespace*(): expr

     expands to 'charset({' ', '\9'..'\13'})'

   * identChars
          template identChars*(): expr

     expands to 'charset({'a'..'z', 'A'..'Z', '0'..'9', '_'})'

   * identStartChars
          template identStartChars*(): expr

     expands to 'charset({'A'..'Z', 'a'..'z', '_'})'

   * ident
          template ident*(): expr

     same as '[a-zA-Z_][a-zA-z_0-9]*'; standard identifier

   * natural
          template natural*(): expr

     same as '\d+'

   * '=~'
          template `=~`*(s: string; pattern: Peg): bool

     This calls 'match' with an implicit declared 'matches' array that
     can be used in the scope of the '=~' call:
     if line =~ peg"\s* {\w+} \s* '=' \s* {\w+}":
       # matches a key=value pair:
       echo("Key: ", matches[0])
       echo("Value: ", matches[1])
     elif line =~ peg"\s*{'#'.*}":
       # matches a comment
       # note that the implicit ``matches`` array is different from the
       # ``matches`` array of the first branch
       echo("comment: ", matches[0])
     else:
       echo("syntax error")

55 Iterators
************

   * findAll
          iterator findAll*(s: string; pattern: Peg; start = 0): string

     yields all matching _substrings_ of s that match pattern.

   * split
          iterator split*(s: string; sep: Peg): string

     Splits the string s into substrings.

     Substrings are separated by the PEG sep.  Examples:
     for word in split("00232this02939is39an22example111", peg"\d+"):
       writeLine(stdout, word)

     Results in:
     "this"
     "is"
     "an"
     "example"


File: nim-ref-0.13.0.info,  Node: /pure/parsesql,  Next: /pure/uri,  Prev: /pure/pegs,  Up: Top

56 Types
********

   * SqlLexer filename: string

          SqlLexer* = object of BaseLexer
            filename: string


     the parser object.

   * SqlNodeKind nkNone, nkIdent, nkStringLit, nkBitStringLit,
     nkHexStringLit, nkIntegerLit, nkNumericLit, nkPrimaryKey,
     nkForeignKey, nkNotNull, nkStmtList, nkDot, nkDotDot, nkPrefix,
     nkInfix, nkCall, nkColumnReference, nkReferences, nkDefault,
     nkCheck, nkConstraint, nkUnique, nkIdentity, nkColumnDef, ## name,
     datatype, constraints nkInsert, nkUpdate, nkDelete, nkSelect,
     nkSelectDistinct, nkSelectColumns, nkAsgn, nkFrom, nkGroup,
     nkHaving, nkOrder, nkDesc, nkUnion, nkIntersect, nkExcept,
     nkColumnList, nkValueList, nkWhere, nkCreateTable,
     nkCreateTableIfNotExists, nkCreateType, nkCreateTypeIfNotExists,
     nkCreateIndex, nkCreateIndexIfNotExists, nkEnumDef
          SqlNodeKind* = enum
            nkNone, nkIdent, nkStringLit, nkBitStringLit, nkHexStringLit, nkIntegerLit,
            nkNumericLit, nkPrimaryKey, nkForeignKey, nkNotNull, nkStmtList, nkDot, nkDotDot,
            nkPrefix, nkInfix, nkCall, nkColumnReference, nkReferences, nkDefault, nkCheck,
            nkConstraint, nkUnique, nkIdentity, nkColumnDef, ## name, datatype, constraints
            nkInsert, nkUpdate, nkDelete, nkSelect, nkSelectDistinct, nkSelectColumns, nkAsgn,
            nkFrom, nkGroup, nkHaving, nkOrder, nkDesc, nkUnion, nkIntersect, nkExcept,
            nkColumnList, nkValueList, nkWhere, nkCreateTable, nkCreateTableIfNotExists,
            nkCreateType, nkCreateTypeIfNotExists, nkCreateIndex, nkCreateIndexIfNotExists,
            nkEnumDef

     kind of SQL abstract syntax tree

   * SqlParser tok: Token

          SqlParser* = object of SqlLexer
            tok: Token


     SQL parser object

57 Procedures
*************

   * len
          proc len*(n: SqlNode): int

   * add
          proc add*(father, n: SqlNode)

   * parseSQL
          proc parseSQL*(input: Stream; filename: string): SqlNode

     parses the SQL from input into an AST and returns the AST. filename
     is only used for error messages.  Syntax errors raise an
     EInvalidSql exception.

   * renderSQL
          proc renderSQL*(n: SqlNode): string

     Converts an SQL abstract syntax tree to its string representation.


File: nim-ref-0.13.0.info,  Node: /pure/uri,  Next: /pure/complex,  Prev: /pure/parsesql,  Up: Top

58 Types
********

   * Uri scheme*, username*, password*: string hostname*, port*, path*,
     query*, anchor*: string opaque*: bool

          Uri* = object
            scheme*, username*, password*: string
            hostname*, port*, path*, query*, anchor*: string
            opaque*: bool


59 Procedures
*************

   * '$'
          proc `$`*(url: Url): string {.deprecated.}

     *Deprecated since 0.9.6*: Use 'Uri' instead.

   * '/'
          proc `/`*(a, b: Url): Url {.deprecated.}

     Joins two URLs together, separating them with / if needed.

     *Deprecated since 0.9.6*: Use 'Uri' instead.

   * add
          proc add*(url: var Url; a: Url) {.deprecated.}

     Appends url to url.

     *Deprecated since 0.9.6*: Use 'Uri' instead.

   * initUri
          proc initUri*(): Uri

     Initializes a URI.

   * parseUri
          proc parseUri*(uri: string; result: var Uri)

     Parses a URI. The result variable will be cleared before.

   * parseUri
          proc parseUri*(uri: string): Uri

     Parses a URI and returns it.

   * combine
          proc combine*(base: Uri; reference: Uri): Uri

     Combines a base URI with a reference URI.

     This uses the algorithm specified in section 5.2.2 of RFC 3986
     (http://tools.ietf.org/html/rfc3986#section-5.2.2).

     This means that the slashes inside the base URI's path as well as
     reference URI's path affect the resulting URI.

     For building URIs you may wish to use '/' instead.

     Examples:
     let foo = combine(parseUri("http://example.com/foo/bar"), parseUri("/baz"))
     assert foo.path == "/baz"

     let bar = combine(parseUri("http://example.com/foo/bar"), parseUri("baz"))
     assert bar.path == "/foo/baz"

     let bar = combine(parseUri("http://example.com/foo/bar/"), parseUri("baz"))
     assert bar.path == "/foo/bar/baz"

   * combine
          proc combine*(uris: varargs[Uri]): Uri

     Combines multiple URIs together.

   * '/'
          proc `/`*(x: Uri; path: string): Uri

     Concatenates the path specified to the specified URI's path.

     Contrary to the 'combine' procedure you do not have to worry about
     the slashes at the beginning and end of the path and URI's path
     respectively.

     Examples:
     let foo = parseUri("http://example.com/foo/bar") / parseUri("/baz")
     assert foo.path == "/foo/bar/baz"

     let bar = parseUri("http://example.com/foo/bar") / parseUri("baz")
     assert bar.path == "/foo/bar/baz"

     let bar = parseUri("http://example.com/foo/bar/") / parseUri("baz")
     assert bar.path == "/foo/bar/baz"

   * '$'
          proc `$`*(u: Uri): string

     Returns the string representation of the specified URI object.


File: nim-ref-0.13.0.info,  Node: /pure/complex,  Next: /pure/os,  Prev: /pure/uri,  Up: Top

60 Types
********

   * Complex
          Complex* = tuple[re, im: float]

     a complex number, consisting of a real and an imaginary part

61 Procedures
*************

   * toComplex
          proc toComplex*(x: SomeInteger): Complex

     Convert some integer 'x' to a complex number.

   * '=='
          proc `==`*(x, y: Complex): bool

     Compare two complex numbers x and y for equality.

   * '=~'
          proc `=~`*(x, y: Complex): bool

     Compare two complex numbers x and y approximately.

   * '+'
          proc `+`*(x, y: Complex): Complex

     Add two complex numbers.

   * '+'
          proc `+`*(x: Complex; y: float): Complex

     Add complex x to float y.

   * '+'
          proc `+`*(x: float; y: Complex): Complex

     Add float x to complex y.

   * '-'
          proc `-`*(z: Complex): Complex

     Unary minus for complex numbers.

   * '-'
          proc `-`*(x, y: Complex): Complex

     Subtract two complex numbers.

   * '-'
          proc `-`*(x: Complex; y: float): Complex

     Subtracts float y from complex x.

   * '-'
          proc `-`*(x: float; y: Complex): Complex

     Subtracts complex y from float x.

   * '/'
          proc `/`*(x, y: Complex): Complex

     Divide x by y.

   * '/'
          proc `/`*(x: Complex; y: float): Complex

     Divide complex x by float y.

   * '/'
          proc `/`*(x: float; y: Complex): Complex

     Divide float x by complex y.

   * '*'
          proc `*`*(x, y: Complex): Complex

     Multiply x with y.

   * '*'
          proc `*`*(x: float; y: Complex): Complex

     Multiply float x with complex y.

   * '*'
          proc `*`*(x: Complex; y: float): Complex

     Multiply complex x with float y.

   * '+='
          proc `+=`*(x: var Complex; y: Complex)

     Add y to x.

   * '+='
          proc `+=`*(x: var Complex; y: float)

     Add y to the complex number x.

   * '-='
          proc `-=`*(x: var Complex; y: Complex)

     Subtract y from x.

   * '-='
          proc `-=`*(x: var Complex; y: float)

     Subtract y from the complex number x.

   * '*='
          proc `*=`*(x: var Complex; y: Complex)

     Multiply y to x.

   * '*='
          proc `*=`*(x: var Complex; y: float)

     Multiply y to the complex number x.

   * '/='
          proc `/=`*(x: var Complex; y: Complex)

     Divide x by y in place.

   * '/='
          proc `/=`*(x: var Complex; y: float)

     Divide complex x by float y in place.

   * abs
          proc abs*(z: Complex): float

     Return the distance from (0,0) to z.

   * conjugate
          proc conjugate*(z: Complex): Complex

     Conjugate of complex number z.

   * sqrt
          proc sqrt*(z: Complex): Complex

     Square root for a complex number z.

   * exp
          proc exp*(z: Complex): Complex

     e raised to the power z.

   * ln
          proc ln*(z: Complex): Complex

     Returns the natural log of z.

   * log10
          proc log10*(z: Complex): Complex

     Returns the log base 10 of z.

   * log2
          proc log2*(z: Complex): Complex

     Returns the log base 2 of z.

   * pow
          proc pow*(x, y: Complex): Complex

     x raised to the power y.

   * sin
          proc sin*(z: Complex): Complex

     Returns the sine of z.

   * arcsin
          proc arcsin*(z: Complex): Complex

     Returns the inverse sine of z.

   * cos
          proc cos*(z: Complex): Complex

     Returns the cosine of z.

   * arccos
          proc arccos*(z: Complex): Complex

     Returns the inverse cosine of z.

   * tan
          proc tan*(z: Complex): Complex

     Returns the tangent of z.

   * arctan
          proc arctan*(z: Complex): Complex

     Returns the inverse tangent of z.

   * cot
          proc cot*(z: Complex): Complex

     Returns the cotangent of z.

   * arccot
          proc arccot*(z: Complex): Complex

     Returns the inverse cotangent of z.

   * sec
          proc sec*(z: Complex): Complex

     Returns the secant of z.

   * arcsec
          proc arcsec*(z: Complex): Complex

     Returns the inverse secant of z.

   * csc
          proc csc*(z: Complex): Complex

     Returns the cosecant of z.

   * arccsc
          proc arccsc*(z: Complex): Complex

     Returns the inverse cosecant of z.

   * sinh
          proc sinh*(z: Complex): Complex

     Returns the hyperbolic sine of z.

   * arcsinh
          proc arcsinh*(z: Complex): Complex

     Returns the inverse hyperbolic sine of z.

   * cosh
          proc cosh*(z: Complex): Complex

     Returns the hyperbolic cosine of z.

   * arccosh
          proc arccosh*(z: Complex): Complex

     Returns the inverse hyperbolic cosine of z.

   * tanh
          proc tanh*(z: Complex): Complex

     Returns the hyperbolic tangent of z.

   * arctanh
          proc arctanh*(z: Complex): Complex

     Returns the inverse hyperbolic tangent of z.

   * sech
          proc sech*(z: Complex): Complex

     Returns the hyperbolic secant of z.

   * arcsech
          proc arcsech*(z: Complex): Complex

     Returns the inverse hyperbolic secant of z.

   * csch
          proc csch*(z: Complex): Complex

     Returns the hyperbolic cosecant of z.

   * arccsch
          proc arccsch*(z: Complex): Complex

     Returns the inverse hyperbolic cosecant of z.

   * coth
          proc coth*(z: Complex): Complex

     Returns the hyperbolic cotangent of z.

   * arccoth
          proc arccoth*(z: Complex): Complex

     Returns the inverse hyperbolic cotangent of z.

   * phase
          proc phase*(z: Complex): float

     Returns the phase of z.

   * polar
          proc polar*(z: Complex): tuple[r, phi: float]

     Returns z in polar coordinates.

   * rect
          proc rect*(r: float; phi: float): Complex

     Returns the complex number with polar coordinates r and phi.

   * '$'
          proc `$`*(z: Complex): string

     Returns z's string representation as '"(re, im)"'.


File: nim-ref-0.13.0.info,  Node: /pure/os,  Next: /pure/stats,  Prev: /pure/complex,  Up: Top

62 Types
********

   * FilePermission fpUserExec, ## execute access for the file owner
     fpUserWrite, ## write access for the file owner fpUserRead, ## read
     access for the file owner fpGroupExec, ## execute access for the
     group fpGroupWrite, ## write access for the group fpGroupRead, ##
     read access for the group fpOthersExec, ## execute access for
     others fpOthersWrite, ## write access for others fpOthersRead ##
     read access for others
          FilePermission* = enum
            fpUserExec,                 ## execute access for the file owner
            fpUserWrite,                ## write access for the file owner
            fpUserRead,                 ## read access for the file owner
            fpGroupExec,                ## execute access for the group
            fpGroupWrite,               ## write access for the group
            fpGroupRead,                ## read access for the group
            fpOthersExec,               ## execute access for others
            fpOthersWrite,              ## write access for others
            fpOthersRead                ## read access for others

     file access permission; modelled after UNIX

   * PathComponent pcFile, ## path refers to a file pcLinkToFile, ##
     path refers to a symbolic link to a file pcDir, ## path refers to a
     directory pcLinkToDir ## path refers to a symbolic link to a
     directory
          PathComponent* = enum
            pcFile,                     ## path refers to a file
            pcLinkToFile,               ## path refers to a symbolic link to a file
            pcDir,                      ## path refers to a directory
            pcLinkToDir                 ## path refers to a symbolic link to a directory

     Enumeration specifying a path component.

   * cuint32
          cuint32* {.importc: "unsigned int", nodecl.} = int

   * FileId
          FileId* = int64

   * FileInfo id*: tuple[device: DeviceId, file: FileId] kind*:
     PathComponent size*: BiggestInt permissions*: set[FilePermission]
     linkCount*: BiggestInt lastAccessTime*: Time lastWriteTime*: Time
     creationTime*: Time

          FileInfo* = object
            id*: tuple[device: DeviceId, file: FileId]
            kind*: PathComponent
            size*: BiggestInt
            permissions*: set[FilePermission]
            linkCount*: BiggestInt
            lastAccessTime*: Time
            lastWriteTime*: Time
            creationTime*: Time


     Contains information associated with a file object.

63 Procedures
*************

   * osErrorMsg
          proc osErrorMsg*(): string {.rtl, extern: "nos$1", deprecated.}

     Retrieves the operating system's error flag, 'errno'.  On Windows
     'GetLastError' is checked before 'errno'.  Returns "" if no error
     occurred.

     *Deprecated since version 0.9.4*: use the other 'osErrorMsg' proc.

   * raiseOSError
          proc raiseOSError*(msg: string = "") {.noinline, rtl, extern: "nos$1", deprecated.}

     raises an OSError exception with the given message 'msg'.  If 'msg
     == ""', the operating system's error flag ('errno') is converted to
     a readable error message.  On Windows 'GetLastError' is checked
     before 'errno'.  If no error flag is set, the message 'unknown OS
     error' is used.

     *Deprecated since version 0.9.4*: use the other 'raiseOSError'
     proc.

   * '=='
          proc `==`*(err1, err2: OSErrorCode): bool {.borrow.}

   * '$'
          proc `$`*(err: OSErrorCode): string {.borrow.}

   * osErrorMsg
          proc osErrorMsg*(errorCode: OSErrorCode): string

     Converts an OS error code into a human readable string.

     The error code can be retrieved using the 'osLastError' proc.

     If conversion fails, or 'errorCode' is '0' then '""' will be
     returned.

     On Windows, the '-d:useWinAnsi' compilation flag can be used to
     make this procedure use the non-unicode Win API calls to retrieve
     the message.

   * raiseOSError
          proc raiseOSError*(errorCode: OSErrorCode; additionalInfo = "") {.noinline.}

     Raises an 'OSError' exception.  The 'errorCode' will determine the
     message, 'osErrorMsg' will be used to get this message.

     The error code can be retrieved using the 'osLastError' proc.

     If the error code is '0' or an error message could not be
     retrieved, the message 'unknown OS error' will be used.

   * osLastError
          proc osLastError*(): OSErrorCode

     Retrieves the last operating system error code.

     This procedure is useful in the event when an OS call fails.  In
     that case this procedure will return the error code describing the
     reason why the OS call failed.  The 'OSErrorMsg' procedure can then
     be used to convert this code into a string.

     *Warning*: The behaviour of this procedure varies between Windows
     and POSIX systems.  On Windows some OS calls can reset the error
     code to '0' causing this procedure to return '0'.  It is therefore
     advised to call this procedure immediately after an OS call fails.
     On POSIX systems this is not a problem.

   * existsFile
          proc existsFile*(filename: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}

     Returns true if the file exists, false otherwise.

   * existsDir
          proc existsDir*(dir: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}

     Returns true iff the directory dir exists.  If dir is a file, false
     is returned.

   * symlinkExists
          proc symlinkExists*(link: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}

     Returns true iff the symlink link exists.  Will return true
     regardless of whether the link points to a directory or file.

   * fileExists
          proc fileExists*(filename: string): bool {.inline.}

     Synonym for existsFile

   * dirExists
          proc dirExists*(dir: string): bool {.inline.}

     Synonym for existsDir

   * getLastModificationTime
          proc getLastModificationTime*(file: string): Time {.rtl, extern: "nos$1".}

     Returns the file's last modification time.

   * getLastAccessTime
          proc getLastAccessTime*(file: string): Time {.rtl, extern: "nos$1".}

     Returns the file's last read or write access time.

   * getCreationTime
          proc getCreationTime*(file: string): Time {.rtl, extern: "nos$1".}

     Returns the file's creation time.

     *Note:* Under POSIX OS's, the returned time may actually be the
     time at which the file's attribute's were last modified.  See here
     (https://github.com/nim-lang/Nim/issues/1058) for details.

   * fileNewer
          proc fileNewer*(a, b: string): bool {.rtl, extern: "nos$1".}

     Returns true if the file a is newer than file b, i.e.  if a's
     modification time is later than b's.

   * getCurrentDir
          proc getCurrentDir*(): string {.rtl, extern: "nos$1", tags: [].}

     Returns the current working directory.

   * setCurrentDir
          proc setCurrentDir*(newDir: string) {.inline, tags: [].}

     Sets the current working directory; OSError is raised if newDir
     cannot been set.

   * expandFilename tags: [ReadDirEffect].}
          proc expandFilename*(filename: string): string {.rtl, extern: "nos$1",
              tags: [ReadDirEffect].}

     Returns the full path of filename, raises OSError in case of an
     error.

   * sameFile
          proc sameFile*(path1, path2: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}

     Returns true if both pathname arguments refer to the same physical
     file or directory.  Raises an exception if any of the files does
     not exist or information about it can not be obtained.

     This proc will return true if given two alternative hard-linked or
     sym-linked paths to the same file or directory.

   * sameFileContent tags: [ReadIOEffect].}
          proc sameFileContent*(path1, path2: string): bool {.rtl, extern: "nos$1",
              tags: [ReadIOEffect].}

     Returns true if both pathname arguments refer to files with
     identical binary content.

   * getFilePermissions extern: "nos$1", tags: [ReadDirEffect].}
          proc getFilePermissions*(filename: string): set[FilePermission] {.rtl,
              extern: "nos$1", tags: [ReadDirEffect].}

     retrieves file permissions for filename.  OSError is raised in case
     of an error.  On Windows, only the 'readonly' flag is checked,
     every other permission is available in any case.

   * setFilePermissions extern: "nos$1", tags: [WriteDirEffect].}
          proc setFilePermissions*(filename: string; permissions: set[FilePermission]) {.rtl,
              extern: "nos$1", tags: [WriteDirEffect].}

     sets the file permissions for filename.  OSError is raised in case
     of an error.  On Windows, only the 'readonly' flag is changed,
     depending on 'fpUserWrite'.

   * copyFile tags: [ReadIOEffect, WriteIOEffect].}
          proc copyFile*(source, dest: string) {.rtl, extern: "nos$1",
                                             tags: [ReadIOEffect, WriteIOEffect].}

     Copies a file from source to dest.

     If this fails, OSError is raised.  On the Windows platform this
     proc will copy the source file's attributes into dest.  On other
     platforms you need to use getFilePermissions()
     (#getFilePermissions) and setFilePermissions()
     (#setFilePermissions) to copy them by hand (or use the convenience
     copyFileWithPermissions() (#copyFileWithPermissions) proc),
     otherwise dest will inherit the default permissions of a newly
     created file for the user.  If dest already exists, the file
     attributes will be preserved and the content overwritten.

   * moveFile tags: [ReadIOEffect, WriteIOEffect].}
          proc moveFile*(source, dest: string) {.rtl, extern: "nos$1",
                                             tags: [ReadIOEffect, WriteIOEffect].}

     Moves a file from source to dest.  If this fails, OSError is
     raised.

   * removeFile
          proc removeFile*(file: string) {.rtl, extern: "nos$1", tags: [WriteDirEffect].}

     Removes the file.  If this fails, OSError is raised.  This does not
     fail if the file never existed in the first place.  On Windows,
     ignores the read-only attribute.

   * execShellCmd
          proc execShellCmd*(command: string): int {.rtl, extern: "nos$1", tags: [ExecIOEffect].}

     Executes a shell command.

     Command has the form 'program args' where args are the command line
     arguments given to program.  The proc returns the error code of the
     shell when it has finished.  The proc does not return until the
     process has finished.  To execute a program without having a shell
     involved, use the execProcess proc of the osproc module.

   * getEnv
          proc getEnv*(key: string): TaintedString {.tags: [ReadEnvEffect].}

     Returns the value of the environment variable named key.

     If the variable does not exist, "" is returned.  To distinguish
     whether a variable exists or it's value is just "", call
     existsEnv(key).

   * existsEnv
          proc existsEnv*(key: string): bool {.tags: [ReadEnvEffect].}

     Checks whether the environment variable named key exists.  Returns
     true if it exists, false otherwise.

   * putEnv
          proc putEnv*(key, val: string) {.tags: [WriteEnvEffect].}

     Sets the value of the environment variable named key to val.  If an
     error occurs, EInvalidEnvVar is raised.

   * removeDir tags: [WriteDirEffect, ReadDirEffect], benign.}
          proc removeDir*(dir: string) {.rtl, extern: "nos$1",
                                      tags: [WriteDirEffect, ReadDirEffect], benign.}

     Removes the directory dir including all subdirectories and files in
     dir (recursively).

     If this fails, OSError is raised.  This does not fail if the
     directory never existed in the first place.

   * createDir
          proc createDir*(dir: string) {.rtl, extern: "nos$1", tags: [WriteDirEffect].}

     Creates the directory dir.

     The directory may contain several subdirectories that do not exist
     yet.  The full path is created.  If this fails, OSError is raised.
     It does *not* fail if the path already exists because for most
     usages this does not indicate an error.

   * copyDir tags: [WriteIOEffect, ReadIOEffect], benign.}
          proc copyDir*(source, dest: string) {.rtl, extern: "nos$1",
                                            tags: [WriteIOEffect, ReadIOEffect], benign.}

     Copies a directory from source to dest.

     If this fails, OSError is raised.  On the Windows platform this
     proc will copy the attributes from source into dest.  On other
     platforms created files and directories will inherit the default
     permissions of a newly created file/directory for the user.  To
     preserve attributes recursively on these platforms use
     copyDirWithPermissions() (#copyDirWithPermissions).

   * createSymlink
          proc createSymlink*(src, dest: string)

     Create a symbolic link at dest which points to the item specified
     by src.  On most operating systems, will fail if a lonk

     *Warning*: Some OS's (such as Microsoft Windows) restrict the
     creation of symlinks to root users (administrators).

   * createHardlink
          proc createHardlink*(src, dest: string)

     Create a hard link at dest which points to the item specified by
     src.

     *Warning*: Most OS's restrict the creation of hard links to root
     users (administrators) .

   * parseCmdLine
          proc parseCmdLine*(c: string): seq[string] {.noSideEffect, rtl, extern: "nos$1".}

     Splits a command line into several components; This proc is only
     occasionally useful, better use the parseopt module.

     On Windows, it uses the following parsing rules (see
     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
     (http://msdn.microsoft.com/en-us/library/17w5ykft.aspx) ):

        * Arguments are delimited by white space, which is either a
          space or a tab.
        * The caret character (^) is not recognized as an escape
          character or delimiter.  The character is handled completely
          by the command-line parser in the operating system before
          being passed to the argv array in the program.
        * A string surrounded by double quotation marks ("string") is
          interpreted as a single argument, regardless of white space
          contained within.  A quoted string can be embedded in an
          argument.
        * A double quotation mark preceded by a backslash (") is
          interpreted as a literal double quotation mark character (").
        * Backslashes are interpreted literally, unless they immediately
          precede a double quotation mark.
        * If an even number of backslashes is followed by a double
          quotation mark, one backslash is placed in the argv array for
          every pair of backslashes, and the double quotation mark is
          interpreted as a string delimiter.
        * If an odd number of backslashes is followed by a double
          quotation mark, one backslash is placed in the argv array for
          every pair of backslashes, and the double quotation mark is
          "escaped" by the remaining backslash, causing a literal double
          quotation mark (") to be placed in argv.

     On Posix systems, it uses the following parsing rules: Components
     are separated by whitespace unless the whitespace occurs within '"'
     or ''' quotes.

   * copyFileWithPermissions
          proc copyFileWithPermissions*(source, dest: string; ignorePermissionErrors = true)

     Copies a file from source to dest preserving file permissions.

     This is a wrapper proc around copyFile() (#copyFile),
     getFilePermissions() (#getFilePermissions) and setFilePermissions()
     (#setFilePermissions) on non Windows platform.  On Windows this
     proc is just a wrapper for copyFile() (#copyFile) since that proc
     already copies attributes.

     On non Windows systems permissions are copied after the file itself
     has been copied, which won't happen atomically and could lead to a
     race condition.  If ignorePermissionErrors is true, errors while
     reading/setting file attributes will be ignored, otherwise will
     raise OSError.

   * copyDirWithPermissions rtl, extern: "nos$1", tags: [WriteIOEffect,
     ReadIOEffect], benign.}
          proc copyDirWithPermissions*(source, dest: string; ignorePermissionErrors = true) {.
              rtl, extern: "nos$1", tags: [WriteIOEffect, ReadIOEffect], benign.}

     Copies a directory from source to dest preserving file permissions.

     If this fails, OSError is raised.  This is a wrapper proc around
     copyDir() (#copyDir) and copyFileWithPermissions()
     (#copyFileWithPermissions) on non Windows platforms.  On Windows
     this proc is just a wrapper for copyDir() (#copyDir) since that
     proc already copies attributes.

     On non Windows systems permissions are copied after the file or
     directory itself has been copied, which won't happen atomically and
     could lead to a race condition.  If ignorePermissionErrors is true,
     errors while reading/setting file attributes will be ignored,
     otherwise will raise OSError.

   * inclFilePermissions extern: "nos$1", tags: [ReadDirEffect,
     WriteDirEffect].}
          proc inclFilePermissions*(filename: string; permissions: set[FilePermission]) {.rtl,
              extern: "nos$1", tags: [ReadDirEffect, WriteDirEffect].}

     a convenience procedure for:
     setFilePermissions(filename, getFilePermissions(filename)+permissions)

   * exclFilePermissions extern: "nos$1", tags: [ReadDirEffect,
     WriteDirEffect].}
          proc exclFilePermissions*(filename: string; permissions: set[FilePermission]) {.rtl,
              extern: "nos$1", tags: [ReadDirEffect, WriteDirEffect].}

     a convenience procedure for:
     setFilePermissions(filename, getFilePermissions(filename)-permissions)

   * expandSymlink
          proc expandSymlink*(symlinkPath: string): string

     Returns a string representing the path to which the symbolic link
     points.

     On Windows this is a noop, 'symlinkPath' is simply returned.

   * paramCount
          proc paramCount*(): int {.tags: [ReadIOEffect].}

     Returns the number of command line arguments given to the
     application.

     If your binary was called without parameters this will return zero.
     You can later query each individual paramater with paramStr()
     (#paramStr) or retrieve all of them in one go with
     commandLineParams() (#commandLineParams).

     *Availability*: On Posix there is no portable way to get the
     command line from a DLL and thus the proc isn't defined in this
     environment.  You can test for its availability with declared()
     (system.html#declared).  Example:
     when declared(paramCount):
       # Use paramCount() here
     else:
       # Do something else!

   * paramStr
          proc paramStr*(i: int): TaintedString {.tags: [ReadIOEffect].}

     Returns the i-th command line argument given to the application.

     i should be in the range 1..paramCount(), the EInvalidIndex
     exception will be raised for invalid values.  Instead of iterating
     over paramCount() (#paramCount) with this proc you can call the
     convenience commandLineParams() (#commandLineParams).

     It is possible to call 'paramStr(0)' but this will return OS
     specific contents (usually the name of the invoked executable).
     You should avoid this and call getAppFilename() (#getAppFilename)
     instead.

     *Availability*: On Posix there is no portable way to get the
     command line from a DLL and thus the proc isn't defined in this
     environment.  You can test for its availability with declared()
     (system.html#declared).  Example:
     when declared(paramStr):
       # Use paramStr() here
     else:
       # Do something else!

   * commandLineParams
          proc commandLineParams*(): seq[TaintedString]

     Convenience proc which returns the command line parameters.

     This returns *only* the parameters.  If you want to get the
     application executable filename, call getAppFilename()
     (#getAppFilename).

     *Availability*: On Posix there is no portable way to get the
     command line from a DLL and thus the proc isn't defined in this
     environment.  You can test for its availability with declared()
     (system.html#declared).  Example:
     when declared(commandLineParams):
       # Use commandLineParams() here
     else:
       # Do something else!

   * getAppFilename
          proc getAppFilename*(): string {.rtl, extern: "nos$1", tags: [ReadIOEffect].}

     Returns the filename of the application's executable.

     This procedure will resolve symlinks.

     *Note*: This does not work reliably on BSD.

   * getApplicationFilename
          proc getApplicationFilename*(): string {.rtl, extern: "nos$1", deprecated.}

     Returns the filename of the application's executable.  *Deprecated
     since version 0.8.12*: use 'getAppFilename' instead.

   * getApplicationDir
          proc getApplicationDir*(): string {.rtl, extern: "nos$1", deprecated.}

     Returns the directory of the application's executable.  *Deprecated
     since version 0.8.12*: use 'getAppDir' instead.

   * getAppDir
          proc getAppDir*(): string {.rtl, extern: "nos$1", tags: [ReadIOEffect].}

     Returns the directory of the application's executable.  *Note*:
     This does not work reliably on BSD.

   * sleep
          proc sleep*(milsecs: int) {.rtl, extern: "nos$1", tags: [TimeEffect].}

     sleeps milsecs milliseconds.

   * getFileSize tags: [ReadIOEffect].}
          proc getFileSize*(file: string): BiggestInt {.rtl, extern: "nos$1",
              tags: [ReadIOEffect].}

     returns the file size of file.  Can raise 'OSError'.

   * getFileInfo
          proc getFileInfo*(handle: FileHandle): FileInfo

     Retrieves file information for the file object represented by the
     given handle.

     If the information cannot be retrieved, such as when the file
     handle is invalid, an error will be thrown.

   * getFileInfo
          proc getFileInfo*(file: File): FileInfo

   * getFileInfo
          proc getFileInfo*(path: string; followSymlink = true): FileInfo

     Retrieves file information for the file object pointed to by path.

     Due to intrinsic differences between operating systems, the
     information contained by the returned FileInfo structure will be
     slightly different across platforms, and in some cases, incomplete
     or inaccurate.

     When followSymlink is true, symlinks are followed and the
     information retrieved is information related to the symlink's
     target.  Otherwise, information on the symlink itself is retrieved.

     If the information cannot be retrieved, such as when the path
     doesn't exist, or when permission restrictions prevent the program
     from retrieving file information, an error will be thrown.

   * isHidden
          proc isHidden*(path: string): bool

     Determines whether a given path is hidden or not.  Returns false if
     the file doesn't exist.  The given path must be accessible from the
     current working directory of the program.

     On Windows, a file is hidden if the file's 'hidden' attribute is
     set.  On Unix-like systems, a file is hidden if it starts with a
     '.'  (period) and is not _just_ '.'  or '..'  ' ."

64 Iterators
************

   * envPairs
          iterator envPairs*(): tuple[key, value: TaintedString] {.tags: [ReadEnvEffect].}

     Iterate over all environments variables.  In the first component of
     the tuple is the name of the current variable stored, in the second
     its value.

   * walkFiles
          iterator walkFiles*(pattern: string): string {.tags: [ReadDirEffect].}

     Iterate over all the files that match the pattern.  On POSIX this
     uses the glob call.

     pattern is OS dependent, but at least the "*.ext" notation is
     supported.

   * walkDir path: string] {.tags: [ReadDirEffect].}
          iterator walkDir*(dir: string; relative = false): tuple[kind: PathComponent,
              path: string] {.tags: [ReadDirEffect].}

     walks over the directory dir and yields for each directory or file
     in dir.  The component type and full path for each item is
     returned.  Walking is not recursive.  If 'relative' is true the
     resulting path is shortened to be relative to 'dir'.  Example: This
     directory structure:
     dirA / dirB / fileB1.txt
          / dirC
          / fileA1.txt
          / fileA2.txt

     and this code:
     for kind, path in walkDir("dirA"):
       echo(path)

     produces this output (but not necessarily in this order!):
     dirA/dirB
     dirA/dirC
     dirA/fileA1.txt
     dirA/fileA2.txt

   * walkDirRec tags: [ReadDirEffect].}
          iterator walkDirRec*(dir: string; filter = {pcFile, pcDir}): string {.
              tags: [ReadDirEffect].}

     walks over the directory dir and yields for each file in dir.  The
     full path for each file is returned.  *Warning*: Modifying the
     directory structure while the iterator is traversing may result in
     undefined behavior!

     Walking is recursive.  filter controls the behaviour of the
     iterator:

     filter           meaning
     --------------------------------------------------------
     'pcFile'         yield real files
     'pcLinkToFile'   yield symbolic links to files
     'pcDir'          follow real directories
     'pcLinkToDir'    follow symbolic links to directories


File: nim-ref-0.13.0.info,  Node: /pure/stats,  Next: /pure/typetraits,  Prev: /pure/os,  Up: Top

65 Types
********

   * RunningRegress n*: int ## number of pushed data x_stats*:
     RunningStat ## stats for first set of data y_stats*: RunningStat ##
     stats for second set of data s_xy: float ## accumulated data for
     combined xy

          RunningRegress* = object
            n*: int                      ## number of pushed data
            x_stats*: RunningStat        ## stats for first set of data
            y_stats*: RunningStat        ## stats for second set of data
            s_xy: float                  ## accumulated data for combined xy


     an accumulator for regression calculations

66 Procedures
*************

   * clear
          proc clear*(s: var RunningStat)

     reset s

   * push
          proc push*(s: var RunningStat; x: float)

     pushes a value x for processing

   * push
          proc push*(s: var RunningStat; x: int)

     pushes a value x for processing.

     x is simply converted to 'float' and the other push operation is
     called.

   * push
          proc push*(s: var RunningStat; x: openarray[float | int])

     pushes all values of x for processing.

     Int values of x are simply converted to 'float' and the other push
     operation is called.

   * mean
          proc mean*(s: RunningStat): float

     computes the current mean of s

   * variance
          proc variance*(s: RunningStat): float

     computes the current population variance of s

   * varianceS
          proc varianceS*(s: RunningStat): float

     computes the current sample variance of s

   * standardDeviation
          proc standardDeviation*(s: RunningStat): float

     computes the current population standard deviation of s

   * standardDeviationS
          proc standardDeviationS*(s: RunningStat): float

     computes the current sample standard deviation of s

   * skewness
          proc skewness*(s: RunningStat): float

     computes the current population skewness of s

   * skewnessS
          proc skewnessS*(s: RunningStat): float

     computes the current sample skewness of s

   * kurtosis
          proc kurtosis*(s: RunningStat): float

     computes the current population kurtosis of s

   * kurtosisS
          proc kurtosisS*(s: RunningStat): float

     computes the current sample kurtosis of s

   * '+'
          proc `+`*(a, b: RunningStat): RunningStat

     combine two RunningStats.

     Useful if performing parallel analysis of data series and need to
     re-combine parallel result sets

   * '+='
          proc `+=`*(a: var RunningStat; b: RunningStat) {.inline.}

     add a second RunningStats b to a

   * mean
          proc mean*[T](x: openArray[T]): float

     computes the mean of x

   * variance
          proc variance*[T](x: openArray[T]): float

     computes the population variance of x

   * varianceS
          proc varianceS*[T](x: openArray[T]): float

     computes the sample variance of x

   * standardDeviation
          proc standardDeviation*[T](x: openArray[T]): float

     computes the population standardDeviation of x

   * standardDeviationS
          proc standardDeviationS*[T](x: openArray[T]): float

     computes the sanple standardDeviation of x

   * skewness
          proc skewness*[T](x: openArray[T]): float

     computes the population skewness of x

   * skewnessS
          proc skewnessS*[T](x: openArray[T]): float

     computes the sample skewness of x

   * kurtosis
          proc kurtosis*[T](x: openArray[T]): float

     computes the population kurtosis of x

   * kurtosisS
          proc kurtosisS*[T](x: openArray[T]): float

     computes the sample kurtosis of x

   * clear
          proc clear*(r: var RunningRegress)

     reset r

   * push
          proc push*(r: var RunningRegress; x, y: float)

     pushes two values x and y for processing

   * push
          proc push*(r: var RunningRegress; x, y: int) {.inline.}

     pushes two values x and y for processing.

     x and y are converted to 'float' and the other push operation is
     called.

   * push
          proc push*(r: var RunningRegress; x, y: openarray[float | int])

     pushes two sets of values x and y for processing.

   * slope
          proc slope*(r: RunningRegress): float

     computes the current slope of r

   * intercept
          proc intercept*(r: RunningRegress): float

     computes the current intercept of r

   * correlation
          proc correlation*(r: RunningRegress): float

     computes the current correlation of the two data sets pushed into r

   * '+'
          proc `+`*(a, b: RunningRegress): RunningRegress

     combine two RunningRegress objects.

     Useful if performing parallel analysis of data series and need to
     re-combine parallel result sets

   * '+='
          proc `+=`*(a: var RunningRegress; b: RunningRegress)

     add RunningRegress b to a


File: nim-ref-0.13.0.info,  Node: /pure/typetraits,  Next: /pure/parsexml,  Prev: /pure/stats,  Up: Top

67 Procedures
*************

   * name
          proc name*(t: typedesc): string {.magic: "TypeTrait".}

     Returns the name of the given type.

     Example:
     import typetraits

     proc `$`*[T](some:typedesc[T]): string = name(T)

     template test(x): stmt =
       echo "type: ", type(x), ", value: ", x

     test 42
     # --> type: int, value: 42
     test "Foo"
     # --> type: string, value: Foo
     test(@['A','B'])
     # --> type: seq[char], value: @[A, B]

   * arity
          proc arity*(t: typedesc): int {.magic: "TypeTrait".}

     Returns the arity of the given type


File: nim-ref-0.13.0.info,  Node: /pure/parsexml,  Next: /pure/unittest,  Prev: /pure/typetraits,  Up: Top

68 Types
********

   * XmlParser a, b, c: string kind: XmlEventKind err: XmlErrorKind
     state: ParserState filename: string options: set[XmlParseOption]

          XmlParser* = object of BaseLexer
            a, b, c: string
            kind: XmlEventKind
            err: XmlErrorKind
            state: ParserState
            filename: string
            options: set[XmlParseOption]


     the parser object.

69 Procedures
*************

   * open options: set[XmlParseOption] = {})
          proc open*(my: var XmlParser; input: Stream; filename: string;
                    options: set[XmlParseOption] = {})

     initializes the parser with an input stream.  Filename is only used
     for nice error messages.  The parser's behaviour can be controlled
     by the options parameter: If options contains 'reportWhitespace' a
     whitespace token is reported as an 'xmlWhitespace' event.  If
     options contains 'reportComments' a comment token is reported as an
     'xmlComment' event.

   * close
          proc close*(my: var XmlParser) {.inline.}

     closes the parser my and its associated input stream.

   * kind
          proc kind*(my: XmlParser): XmlEventKind {.inline.}

     returns the current event type for the XML parser

   * rawData
          proc rawData*(my: XmlParser): string {.inline.}

     returns the underlying 'data' string by reference.  This is only
     used for speed hacks.

   * rawData2
          proc rawData2*(my: XmlParser): string {.inline.}

     returns the underlying second 'data' string by reference.  This is
     only used for speed hacks.

   * getColumn
          proc getColumn*(my: XmlParser): int {.inline.}

     get the current column the parser has arrived at.

   * getLine
          proc getLine*(my: XmlParser): int {.inline.}

     get the current line the parser has arrived at.

   * getFilename
          proc getFilename*(my: XmlParser): string {.inline.}

     get the filename of the file that the parser processes.

   * errorMsg
          proc errorMsg*(my: XmlParser): string

     returns a helpful error message for the event 'xmlError'

   * errorMsgExpected
          proc errorMsgExpected*(my: XmlParser; tag: string): string

     returns an error message "<tag> expected" in the same format as the
     other error messages

   * errorMsg
          proc errorMsg*(my: XmlParser; msg: string): string

     returns an error message with text msg in the same format as the
     other error messages

   * next
          proc next*(my: var XmlParser)

     retrieves the first/next event.  This controls the parser.

70 Templates
************

   * charData
          template charData*(my: XmlParser): string

     returns the character data for the events: 'xmlCharData',
     'xmlWhitespace', 'xmlComment', 'xmlCData', 'xmlSpecial'

   * elementName
          template elementName*(my: XmlParser): string

     returns the element name for the events: 'xmlElementStart',
     'xmlElementEnd', 'xmlElementOpen'

   * entityName
          template entityName*(my: XmlParser): string

     returns the entity name for the event: 'xmlEntity'

   * attrKey
          template attrKey*(my: XmlParser): string

     returns the attribute key for the event 'xmlAttribute'

   * attrValue
          template attrValue*(my: XmlParser): string

     returns the attribute value for the event 'xmlAttribute'

   * piName
          template piName*(my: XmlParser): string

     returns the processing instruction name for the event 'xmlPI'

   * piRest
          template piRest*(my: XmlParser): string

     returns the rest of the processing instruction for the event
     'xmlPI'


File: nim-ref-0.13.0.info,  Node: /pure/unittest,  Next: /pure/nimprof,  Prev: /pure/parsexml,  Up: Top

71 Types
********

   * OutputLevel PRINT_ALL, ## Print as much as possible.
     PRINT_FAILURES, ## Print only the failed tests.  PRINT_NONE ##
     Print nothing.
          OutputLevel* = enum
            PRINT_ALL,                  ## Print as much as possible.
            PRINT_FAILURES,             ## Print only the failed tests.
            PRINT_NONE                  ## Print nothing.

     The output verbosity of the tests.

72 Procedures
*************

   * checkpoint
          proc checkpoint*(msg: string)

     Set a checkpoint identified by msg.  Upon test failure all
     checkpoints encountered so far are printed out.  Example:
     checkpoint("Checkpoint A")
     check((42, "the Answer to life and everything") == (1, "a"))
     checkpoint("Checkpoint B")

     outputs "Checkpoint A" once it fails.

73 Templates
************

   * suite
          template suite*(name: expr; body: stmt): stmt {.immediate, dirty.}

     Declare a test suite identified by name with optional 'setup'
     and/or 'teardown' section.

     A test suite is a series of one or more related tests sharing a
     common fixture ('setup', 'teardown').  The fixture is executed for
     EACH test.
     suite "test suite for addition":
       setup:
         let result = 4

       test "2 + 2 = 4":
         check(2+2 == result)

       test "(2 + -2) != 4":
         check(2 + -2 != result)

       # No teardown needed

     The suite will run the individual test cases in the order in which
     they were listed.  With default global settings the above code
     prints:
     [OK] 2 + 2 = 4
     [OK] (2 + -2) != 4

   * test
          template test*(name: expr; body: stmt): stmt {.immediate, dirty.}

     Define a single test case identified by name.
     test "roses are red":
       let roses = "red"
       check(roses == "red")

     The above code outputs:
     [OK] roses are red

   * fail
          template fail*()

     Print out the checkpoints encountered so far and quit if
     'abortOnError' is true.  Otherwise, erase the checkpoints and
     indicate the test has failed (change exit code and test status).
     This template is useful for debugging, but is otherwise mostly used
     internally.  Example:
     checkpoint("Checkpoint A")
     complicatedProcInThread()
     fail()

     outputs "Checkpoint A" before quitting.

   * require
          template require*(conditions: stmt): stmt {.immediate.}

     Same as check except any failed test causes the program to quit
     immediately.  Any teardown statements are not executed and the
     failed test output is not generated.

74 Macros
*********

   * check
          macro check*(conditions: stmt): stmt {.immediate.}

     Verify if a statement or a list of statements is true.  A helpful
     error message and set checkpoints are printed out on failure (if
     'outputLevel' is not 'PRINT_NONE').  Example:
     import strutils

     check("AKB48".toLower() == "akb48")

     let teams = {'A', 'K', 'B', '4', '8'}

     check:
       "AKB48".toLower() == "akb48"
       'C' in teams

   * expect
          macro expect*(exceptions: varargs[expr]; body: stmt): stmt {.immediate.}

     Test if body raises an exception found in the passed exceptions.
     The test passes if the raised exception is part of the acceptable
     exceptions.  Otherwise, it fails.  Example:
     import math
     proc defectiveRobot() =
       randomize()
       case random(1..4)
       of 1: raise newException(OSError, "CANNOT COMPUTE!")
       of 2: discard parseInt("Hello World!")
       of 3: raise newException(IOError, "I can't do that Dave.")
       else: assert 2 + 2 == 5

     expect IOError, OSError, ValueError, AssertionError:
       defectiveRobot()


File: nim-ref-0.13.0.info,  Node: /pure/nimprof,  Next: /pure/oswalkdir,  Prev: /pure/unittest,  Up: Top

75 Procedures
*************

   * setSamplingFrequency
          proc setSamplingFrequency*(intervalInUs: int)

     set this to change the sampling frequency.  Default value is 5ms.
     Set it to 0 to disable time based profiling; it uses an imprecise
     instruction count measure instead then.

   * disableProfiling
          proc disableProfiling*()

   * enableProfiling
          proc enableProfiling*()


File: nim-ref-0.13.0.info,  Node: /pure/oswalkdir,  Next: /pure/asyncnet,  Prev: /pure/nimprof,  Up: Top

76 Types
********

   * PathComponent pcFile, ## path refers to a file pcLinkToFile, ##
     path refers to a symbolic link to a file pcDir, ## path refers to a
     directory pcLinkToDir ## path refers to a symbolic link to a
     directory
          PathComponent* = enum
            pcFile,                     ## path refers to a file
            pcLinkToFile,               ## path refers to a symbolic link to a file
            pcDir,                      ## path refers to a directory
            pcLinkToDir                 ## path refers to a symbolic link to a directory

     Enumeration specifying a path component.

77 Iterators
************

   * walkDir path: string]
          iterator walkDir*(dir: string; relative = false): tuple[kind: PathComponent,
              path: string]

   * walkDirRec
          iterator walkDirRec*(dir: string; filter = {pcFile, pcDir}): string


File: nim-ref-0.13.0.info,  Node: /pure/asyncnet,  Next: /pure/xmldom,  Prev: /pure/oswalkdir,  Up: Top

78 Types
********

   * AsyncSocket
          AsyncSocket* = ref AsyncSocketDesc

79 Procedures
*************

   * newAsyncSocket sockType: SockType = SOCK_STREAM; protocol: Protocol
     = IPPROTO_TCP; buffered = true): AsyncSocket
          proc newAsyncSocket*(fd: AsyncFD; domain: Domain = AF_INET;
                              sockType: SockType = SOCK_STREAM;
                              protocol: Protocol = IPPROTO_TCP; buffered = true): AsyncSocket

     Creates a new 'AsyncSocket' based on the supplied params.

   * newAsyncSocket protocol: Protocol = IPPROTO_TCP; buffered = true):
     AsyncSocket
          proc newAsyncSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
                              protocol: Protocol = IPPROTO_TCP; buffered = true): AsyncSocket

     Creates a new asynchronous socket.

     This procedure will also create a brand new file descriptor for
     this socket.

   * newAsyncSocket
          proc newAsyncSocket*(domain, sockType, protocol: cint; buffered = true): AsyncSocket

     Creates a new asynchronous socket.

     This procedure will also create a brand new file descriptor for
     this socket.

   * connect
          proc connect*(socket: AsyncSocket; address: string; port: Port) {.async.}

     Connects 'socket' to server at 'address:port'.

     Returns a 'Future' which will complete when the connection succeeds
     or an error occurs.

   * recv string] {.async.}
          proc recv*(socket: AsyncSocket; size: int; flags = {SocketFlag.SafeDisconn}): Future[
              string] {.async.}

     Reads *up to* 'size' bytes from 'socket'.

     For buffered sockets this function will attempt to read all the
     requested data.  It will read this data in 'BufferSize' chunks.

     For unbuffered sockets this function makes no effort to read all
     the data requested.  It will return as much data as the operating
     system gives it.

     If socket is disconnected during the recv operation then the future
     may complete with only a part of the requested data.

     If socket is disconnected and no data is available to be read then
     the future will complete with a value of '""'.

   * send
          proc send*(socket: AsyncSocket; data: string; flags = {SocketFlag.SafeDisconn}) {.async.}

     Sends 'data' to 'socket'.  The returned future will complete once
     all data has been sent.

   * acceptAddr tuple[address: string, client: AsyncSocket]]
          proc acceptAddr*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[
              tuple[address: string, client: AsyncSocket]]

     Accepts a new connection.  Returns a future containing the client
     socket corresponding to that connection and the remote address of
     the client.  The future will complete when the connection is
     successfully accepted.

   * accept AsyncSocket]
          proc accept*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[
              AsyncSocket]

     Accepts a new connection.  Returns a future containing the client
     socket corresponding to that connection.  The future will complete
     when the connection is successfully accepted.

   * recvLineInto flags = {SocketFlag.SafeDisconn}) {.async.}
          proc recvLineInto*(socket: AsyncSocket; resString: FutureVar[string];
                            flags = {SocketFlag.SafeDisconn}) {.async.}

     Reads a line of data from 'socket' into 'resString'.

     If a full line is read '\r\L' is not added to 'line', however if
     solely '\r\L' is read then 'line' will be set to it.

     If the socket is disconnected, 'line' will be set to '""'.

     If the socket is disconnected in the middle of a line (before
     '\r\L' is read) then line will be set to '""'.  The partial line
     *will be lost*.

     *Warning*: The 'Peek' flag is not yet implemented.

     *Warning*: 'recvLineInto' on unbuffered sockets assumes that the
     protocol uses '\r\L' to delimit a new line.

     *Warning*: 'recvLineInto' currently uses a raw pointer to a string
     for performance reasons.  This will likely change soon to use
     FutureVars.

   * recvLine async.}
          proc recvLine*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[string] {.
              async.}

     Reads a line of data from 'socket'.  Returned future will complete
     once a full line is read or an error occurs.

     If a full line is read '\r\L' is not added to 'line', however if
     solely '\r\L' is read then 'line' will be set to it.

     If the socket is disconnected, 'line' will be set to '""'.

     If the socket is disconnected in the middle of a line (before
     '\r\L' is read) then line will be set to '""'.  The partial line
     *will be lost*.

     *Warning*: The 'Peek' flag is not yet implemented.

     *Warning*: 'recvLine' on unbuffered sockets assumes that the
     protocol uses '\r\L' to delimit a new line.

   * listen
          proc listen*(socket: AsyncSocket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}

     Marks 'socket' as accepting connections.  'Backlog' specifies the
     maximum length of the queue of pending connections.

     Raises an EOS error upon failure.

   * bindAddr
          proc bindAddr*(socket: AsyncSocket; port = Port(0); address = "") {.tags: [ReadIOEffect].}

     Binds 'address':'port' to the socket.

     If 'address' is "" then ADDR_ANY will be bound.

   * close
          proc close*(socket: AsyncSocket)

     Closes the socket.

   * wrapSocket
          proc wrapSocket*(ctx: SslContext; socket: AsyncSocket)

     Wraps a socket in an SSL context.  This function effectively turns
     'socket' into an SSL socket.

     *Disclaimer*: This code is not well tested, may be very unsafe and
     prone to security vulnerabilities.

   * wrapConnectedSocket handshake: SslHandshakeType)
          proc wrapConnectedSocket*(ctx: SslContext; socket: AsyncSocket;
                                   handshake: SslHandshakeType)

     Wraps a connected socket in an SSL context.  This function
     effectively turns 'socket' into an SSL socket.

     This should be called on a connected socket, and will perform an
     SSL handshake immediately.

     *Disclaimer*: This code is not well tested, may be very unsafe and
     prone to security vulnerabilities.

   * getSockOpt tags: [ReadIOEffect].}
          proc getSockOpt*(socket: AsyncSocket; opt: SOBool; level = SOL_SOCKET): bool {.
              tags: [ReadIOEffect].}

     Retrieves option 'opt' as a boolean value.

   * setSockOpt tags: [WriteIOEffect].}
          proc setSockOpt*(socket: AsyncSocket; opt: SOBool; value: bool; level = SOL_SOCKET) {.
              tags: [WriteIOEffect].}

     Sets option 'opt' to a boolean value specified by 'value'.

   * isSsl
          proc isSsl*(socket: AsyncSocket): bool

     Determines whether 'socket' is a SSL socket.

   * getFd
          proc getFd*(socket: AsyncSocket): SocketHandle

     Returns the socket's file descriptor.

   * isClosed
          proc isClosed*(socket: AsyncSocket): bool

     Determines whether the socket has been closed.


File: nim-ref-0.13.0.info,  Node: /pure/xmldom,  Next: /pure/unicode,  Prev: /pure/asyncnet,  Up: Top

80 Types
********

   * EWrongDocumentErr
          EWrongDocumentErr* = object of EDOMException

     If a node is used in a different document than the one that created
     it (that doesn't support it)

81 Procedures
*************

   * getDOM
          proc getDOM*(): PDOMImplementation

     Returns a DOMImplementation

   * createDocument qualifiedName: string): PDocument
          proc createDocument*(dom: PDOMImplementation; namespaceURI: string;
                              qualifiedName: string): PDocument

     Creates an XML Document object of the specified type with its
     document element.

   * createDocument
          proc createDocument*(dom: PDOMImplementation; n: PElement): PDocument

     Creates an XML Document object of the specified type with its
     document element.

   * hasFeature
          proc hasFeature*(dom: PDOMImplementation; feature: string; version: string = ""): bool

     Returns 'true' if this 'version' of the DomImplementation
     implements 'feature', otherwise 'false'

   * implementation
          proc implementation*(doc: PDocument): PDOMImplementation

   * documentElement
          proc documentElement*(doc: PDocument): PElement

   * createAttribute
          proc createAttribute*(doc: PDocument; name: string): PAttr

     Creates an Attr of the given name.  Note that the Attr instance can
     then be set on an Element using the setAttributeNode method.  To
     create an attribute with a qualified name and namespace URI, use
     the createAttributeNS method.

   * createAttributeNS
          proc createAttributeNS*(doc: PDocument; namespaceURI: string; qualifiedName: string): PAttr

     Creates an attribute of the given qualified name and namespace URI

   * createCDATASection
          proc createCDATASection*(doc: PDocument; data: string): PCDataSection

     Creates a CDATASection node whose value is the specified string.

   * createComment
          proc createComment*(doc: PDocument; data: string): PComment

     Creates a Comment node given the specified string.

   * createDocumentFragment
          proc createDocumentFragment*(doc: PDocument): PDocumentFragment

     Creates an empty DocumentFragment object.

   * createElement
          proc createElement*(doc: PDocument; tagName: string): PElement

     Creates an element of the type specified.

   * createElementNS
          proc createElementNS*(doc: PDocument; namespaceURI: string; qualifiedName: string): PElement

     Creates an element of the given qualified name and namespace URI.

   * createProcessingInstruction
          proc createProcessingInstruction*(doc: PDocument; target: string; data: string): PProcessingInstruction

     Creates a ProcessingInstruction node given the specified name and
     data strings.

   * createTextNode
          proc createTextNode*(doc: PDocument; data: string): PText

     Creates a Text node given the specified string.

   * getElementsByTagName
          proc getElementsByTagName*(doc: PDocument; tagName: string): seq[PNode]

     Returns a NodeList of all the Elements with a given tag name in the
     order in which they are encountered in a preorder traversal of the
     Document tree.

   * getElementsByTagNameNS PNode]
          proc getElementsByTagNameNS*(doc: PDocument; namespaceURI: string; localName: string): seq[
              PNode]

     Returns a NodeList of all the Elements with a given localName and
     namespaceURI in the order in which they are encountered in a
     preorder traversal of the Document tree.

   * importNode
          proc importNode*(doc: PDocument; importedNode: PNode; deep: bool): PNode

     Imports a node from another document to this document

   * firstChild
          proc firstChild*(n: PNode): PNode

     Returns this node's first child

   * lastChild
          proc lastChild*(n: PNode): PNode

     Returns this node's last child

   * localName
          proc localName*(n: PNode): string

     Returns this nodes local name

   * namespaceURI
          proc namespaceURI*(n: PNode): string

     Returns this nodes namespace URI

   * 'namespaceURI='
          proc `namespaceURI =`*(n: PNode; value: string)

   * nextSibling
          proc nextSibling*(n: PNode): PNode

     Returns the next sibling of this node

   * nodeName
          proc nodeName*(n: PNode): string

     Returns the name of this node

   * nodeType
          proc nodeType*(n: PNode): int

     Returns the type of this node

   * ownerDocument
          proc ownerDocument*(n: PNode): PDocument

     Returns the owner document of this node

   * parentNode
          proc parentNode*(n: PNode): PNode

     Returns the parent node of this node

   * previousSibling
          proc previousSibling*(n: PNode): PNode

     Returns the previous sibling of this node

   * 'prefix='
          proc `prefix =`*(n: PNode; value: string)

     Modifies the prefix of this node

   * appendChild
          proc appendChild*(n: PNode; newChild: PNode)

     Adds the node newChild to the end of the list of children of this
     node.  If the newChild is already in the tree, it is first removed.

   * cloneNode
          proc cloneNode*(n: PNode; deep: bool): PNode

     Returns a duplicate of this node, if 'deep' is true, Element node's
     children are copied

   * hasAttributes
          proc hasAttributes*(n: PNode): bool

     Returns whether this node (if it is an element) has any attributes.

   * hasChildNodes
          proc hasChildNodes*(n: PNode): bool

     Returns whether this node has any children.

   * insertBefore
          proc insertBefore*(n: PNode; newChild: PNode; refChild: PNode): PNode

     Inserts the node 'newChild' before the existing child node
     'refChild'.  If 'refChild' is nil, insert 'newChild' at the end of
     the list of children.

   * isSupported
          proc isSupported*(n: PNode; feature: string; version: string): bool

     Tests whether the DOM implementation implements a specific feature
     and that feature is supported by this node.

   * normalize
          proc normalize*(n: PNode)

     Merges all separated TextNodes together, and removes any empty
     TextNodes

   * removeChild
          proc removeChild*(n: PNode; oldChild: PNode): PNode

     Removes the child node indicated by 'oldChild' from the list of
     children, and returns it.

   * replaceChild
          proc replaceChild*(n: PNode; newChild: PNode; oldChild: PNode): PNode

     Replaces the child node 'oldChild' with 'newChild' in the list of
     children, and returns the 'oldChild' node.

   * getNamedItem
          proc getNamedItem*(nList: seq[PNode]; name: string): PNode

     Retrieves a node specified by 'name'.  If this node cannot be found
     returns 'nil'

   * getNamedItem
          proc getNamedItem*(nList: seq[PAttr]; name: string): PAttr

     Retrieves a node specified by 'name'.  If this node cannot be found
     returns 'nil'

   * getNamedItemNS
          proc getNamedItemNS*(nList: seq[PNode]; namespaceURI: string; localName: string): PNode

     Retrieves a node specified by 'localName' and 'namespaceURI'.  If
     this node cannot be found returns 'nil'

   * getNamedItemNS
          proc getNamedItemNS*(nList: seq[PAttr]; namespaceURI: string; localName: string): PAttr

     Retrieves a node specified by 'localName' and 'namespaceURI'.  If
     this node cannot be found returns 'nil'

   * item
          proc item*(nList: seq[PNode]; index: int): PNode

     Returns the 'index' th item in the map.  If 'index' is greater than
     or equal to the number of nodes in this map, this returns 'nil'.

   * removeNamedItem
          proc removeNamedItem*(nList: var seq[PNode]; name: string): PNode

     Removes a node specified by 'name' Raises the 'ENotFoundErr'
     exception, if the node was not found

   * removeNamedItemNS
          proc removeNamedItemNS*(nList: var seq[PNode]; namespaceURI: string; localName: string): PNode

     Removes a node specified by local name and namespace URI

   * setNamedItem
          proc setNamedItem*(nList: var seq[PNode]; arg: PNode): PNode

     Adds 'arg' as a 'Node' to the 'NList' If a node with the same name
     is already present in this map, it is replaced by the new one.

   * setNamedItem
          proc setNamedItem*(nList: var seq[PAttr]; arg: PAttr): PAttr

     Adds 'arg' as a 'Node' to the 'NList' If a node with the same name
     is already present in this map, it is replaced by the new one.

   * setNamedItemNS
          proc setNamedItemNS*(nList: var seq[PNode]; arg: PNode): PNode

     Adds a node using its 'namespaceURI' and 'localName'

   * setNamedItemNS
          proc setNamedItemNS*(nList: var seq[PAttr]; arg: PAttr): PAttr

     Adds a node using its 'namespaceURI' and 'localName'

   * name
          proc name*(a: PAttr): string

     Returns the name of the Attribute

   * specified
          proc specified*(a: PAttr): bool

     Specifies whether this attribute was specified in the original
     document

   * ownerElement
          proc ownerElement*(a: PAttr): PElement

     Returns this Attributes owner element

   * tagName
          proc tagName*(el: PElement): string

     Returns the Element Tag Name

   * getAttribute
          proc getAttribute*(el: PElement; name: string): string

     Retrieves an attribute value by 'name'

   * getAttributeNS
          proc getAttributeNS*(el: PElement; namespaceURI: string; localName: string): string

     Retrieves an attribute value by 'localName' and 'namespaceURI'

   * getAttributeNode
          proc getAttributeNode*(el: PElement; name: string): PAttr

     Retrieves an attribute node by 'name' To retrieve an attribute node
     by qualified name and namespace URI, use the getAttributeNodeNS
     method

   * getAttributeNodeNS
          proc getAttributeNodeNS*(el: PElement; namespaceURI: string; localName: string): PAttr

     Retrieves an Attr node by 'localName' and 'namespaceURI'

   * getElementsByTagName
          proc getElementsByTagName*(el: PElement; name: string): seq[PNode]

     Returns a NodeList of all descendant Elements of 'el' with a given
     tag 'name', in the order in which they are encountered in a
     preorder traversal of this Element tree If 'name' is *, returns all
     descendant of 'el'

   * getElementsByTagNameNS PNode]
          proc getElementsByTagNameNS*(el: PElement; namespaceURI: string; localName: string): seq[
              PNode]

     Returns a NodeList of all the descendant Elements with a given
     'localName' and 'namespaceURI' in the order in which they are
     encountered in a preorder traversal of this Element tree

   * hasAttribute
          proc hasAttribute*(el: PElement; name: string): bool

     Returns 'true' when an attribute with a given 'name' is specified
     on this element , 'false' otherwise.

   * hasAttributeNS
          proc hasAttributeNS*(el: PElement; namespaceURI: string; localName: string): bool

     Returns 'true' when an attribute with a given 'localName' and
     'namespaceURI' is specified on this element , 'false' otherwise

   * removeAttribute
          proc removeAttribute*(el: PElement; name: string)

     Removes an attribute by 'name'

   * removeAttributeNS
          proc removeAttributeNS*(el: PElement; namespaceURI: string; localName: string)

     Removes an attribute by 'localName' and 'namespaceURI'

   * removeAttributeNode
          proc removeAttributeNode*(el: PElement; oldAttr: PAttr): PAttr

     Removes the specified attribute node If the attribute node cannot
     be found raises 'ENotFoundErr'

   * setAttributeNode
          proc setAttributeNode*(el: PElement; newAttr: PAttr): PAttr

     Adds a new attribute node, if an attribute with the same nodeName
     is present, it is replaced by the new one and the replaced
     attribute is returned, otherwise 'nil' is returned.

   * setAttributeNodeNS
          proc setAttributeNodeNS*(el: PElement; newAttr: PAttr): PAttr

     Adds a new attribute node, if an attribute with the localName and
     namespaceURI of 'newAttr' is present, it is replaced by the new one
     and the replaced attribute is returned, otherwise 'nil' is
     returned.

   * setAttribute
          proc setAttribute*(el: PElement; name: string; value: string)

     Adds a new attribute, as specified by 'name' and 'value' If an
     attribute with that name is already present in the element, its
     value is changed to be that of the value parameter Raises the
     EInvalidCharacterErr if the specified 'name' contains illegal
     characters

   * setAttributeNS
          proc setAttributeNS*(el: PElement; namespaceURI, localName, value: string)

     Adds a new attribute, as specified by 'namespaceURI', 'localName'
     and 'value'.

   * splitData
          proc splitData*(textNode: PText; offset: int): PText

     Breaks this node into two nodes at the specified offset, keeping
     both in the tree as siblings.

   * target
          proc target*(pi: PProcessingInstruction): string

     Returns the Processing Instructions target

   * '$'
          proc `$`*(doc: PDocument): string

     Converts a PDocument object into a string representation of it's
     XML


File: nim-ref-0.13.0.info,  Node: /pure/unicode,  Next: /pure/colors,  Prev: /pure/xmldom,  Up: Top

82 Types
********

   * Rune16
          Rune16* = distinct int16

     16 bit Unicode character

83 Procedures
*************

   * '&lt;=%'
          proc `<=%`*(a, b: Rune): bool

   * '&lt;%'
          proc `<%`*(a, b: Rune): bool

   * '=='
          proc `==`*(a, b: Rune): bool

   * runeLen
          proc runeLen*(s: string): int {.rtl, extern: "nuc$1".}

     Returns the number of Unicode characters of the string 's'

   * runeLenAt
          proc runeLenAt*(s: string; i: Natural): int

     Returns the number of bytes the rune starting at 's[i]' takes

   * validateUtf8
          proc validateUtf8*(s: string): int

     Returns the position of the invalid byte in 's' if the string 's'
     does not hold valid UTF-8 data.  Otherwise '-1' is returned.

   * runeAt
          proc runeAt*(s: string; i: Natural): Rune

     Returns the unicode character in 's' at byte index 'i'

   * toUTF8
          proc toUTF8*(c: Rune): string {.rtl, extern: "nuc$1".}

     Converts a rune into its UTF-8 representation

   * '$'
          proc `$`*(rune: Rune): string

     Converts a Rune to a string

   * '$'
          proc `$`*(runes: seq[Rune]): string

     Converts a sequence of Runes to a string

   * toLower
          proc toLower*(c: Rune): Rune {.rtl, extern: "nuc$1", procvar.}

     Converts 'c' into lower case.  This works for any Unicode
     character.  If possible, prefer 'toLower' over 'toUpper'.

   * toUpper
          proc toUpper*(c: Rune): Rune {.rtl, extern: "nuc$1", procvar.}

     Converts 'c' into upper case.  This works for any Unicode
     character.  If possible, prefer 'toLower' over 'toUpper'.

   * toTitle
          proc toTitle*(c: Rune): Rune {.rtl, extern: "nuc$1", procvar.}

     Converts 'c' to title case

   * isLower
          proc isLower*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}

     Returns true iff 'c' is a lower case Unicode character.  If
     possible, prefer 'isLower' over 'isUpper'.

   * isUpper
          proc isUpper*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}

     Returns true iff 'c' is a upper case Unicode character.  If
     possible, prefer 'isLower' over 'isUpper'.

   * isAlpha
          proc isAlpha*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}

     Returns true iff 'c' is an _alpha_ Unicode character (i.e., a
     letter)

   * isTitle
          proc isTitle*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}

     Returns true iff 'c' is a Unicode titlecase character

   * isWhiteSpace
          proc isWhiteSpace*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}

     Returns true iff 'c' is a Unicode whitespace character

   * isCombining
          proc isCombining*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}

     Returns true iff 'c' is a Unicode combining character

   * toRunes
          proc toRunes*(s: string): seq[Rune]

     Obtains a sequence containing the Runes in 's'

   * cmpRunesIgnoreCase
          proc cmpRunesIgnoreCase*(a, b: string): int {.rtl, extern: "nuc$1", procvar.}

     Compares two UTF-8 strings and ignores the case.  Returns:

     0 iff a == b
     < 0 iff a < b
     > 0 iff a > b

   * reversed
          proc reversed*(s: string): string

     Returns the reverse of 's', interpreting it as Unicode characters.
     Unicode combining characters are correctly interpreted as well:
     assert reversed("Reverse this!") == "!siht esreveR"
     assert reversed("先秦兩漢") == "漢兩秦先"
     assert reversed("as⃝df̅") == "f̅ds⃝a"
     assert reversed("a⃞b⃞c⃞") == "c⃞b⃞a⃞"

   * graphemeLen
          proc graphemeLen*(s: string; i: Natural): Natural

     The number of bytes belonging to 's[i]' including following
     combining characters.

   * lastRune
          proc lastRune*(s: string; last: int): (Rune, int)

     length of the last rune in 's[0..last]'.  Returns the rune and its
     length in bytes.

84 Templates
************

   * fastRuneAt
          template fastRuneAt*(s: string; i: int; result: expr; doInc = true)

     Returns the Unicode character 's[i]' in 'result'.  If 'doInc ==
     true' 'i' is incremented by the number of bytes that have been
     processed.

85 Iterators
************

   * runes
          iterator runes*(s: string): Rune

     Iterates over any unicode character of the string 's'


File: nim-ref-0.13.0.info,  Node: /pure/colors,  Next: /pure/md5,  Prev: /pure/unicode,  Up: Top

86 Types
********

   * Color
          Color* = distinct int

     a color stored as RGB

87 Procedures
*************

   * '=='
          proc `==`*(a, b: Color): bool {.borrow.}

     compares two colors.

   * '+'
          proc `+`*(a, b: Color): Color

     adds two colors: This uses saturated artithmetic, so that each
     color component cannot overflow (255 is used as a maximum).

   * '-'
          proc `-`*(a, b: Color): Color

     subtracts two colors: This uses saturated artithmetic, so that each
     color component cannot overflow (255 is used as a maximum).

   * extractRGB
          proc extractRGB*(a: Color): tuple[r, g, b: range[0 .. 255]]

     extracts the red/green/blue components of the color a.

   * intensity
          proc intensity*(a: Color; f: float): Color

     returns a with intensity f.  f should be a float from 0.0
     (completely dark) to 1.0 (full color intensity).

   * '$'
          proc `$`*(c: Color): string

     converts a color into its textual representation.  Example:
     '#00FF00'.

   * parseColor
          proc parseColor*(name: string): Color

     parses name to a color value.  If no valid color could be parsed
     'EInvalidValue' is raised.

   * isColor
          proc isColor*(name: string): bool

     returns true if name is a known color name or a hexadecimal color
     prefixed with '#'.

   * rgb
          proc rgb*(r, g, b: range[0 .. 255]): Color

     constructs a color from RGB values.

88 Templates
************

   * mix
          template mix*(a, b: Color; fn: expr): expr

     uses fn to mix the colors a and b.  fn is invoked for each
     component R, G, and B. This is a template because fn should be
     inlined and the compiler cannot inline proc pointers yet.  If fn's
     result is not in the range[0..255], it will be saturated to be so.


File: nim-ref-0.13.0.info,  Node: /pure/md5,  Next: /pure/basic3d,  Prev: /pure/colors,  Up: Top

89 Types
********

   * MD5Context state: MD5State count: array[0 ..  1, uint32] buffer:
     MD5Buffer

          MD5Context* {.final.} = object
            state: MD5State
            count: array[0 .. 1, uint32]
            buffer: MD5Buffer


90 Procedures
*************

   * md5Init
          proc md5Init*(c: var MD5Context)

     initializes a MD5Context

   * md5Update
          proc md5Update*(c: var MD5Context; input: cstring; len: int)

     updates the MD5Context with the input data of length len

   * md5Final
          proc md5Final*(c: var MD5Context; digest: var MD5Digest)

     finishes the MD5Context and stores the result in digest

   * toMD5
          proc toMD5*(s: string): MD5Digest

     computes the MD5Digest value for a string s

   * '$'
          proc `$`*(d: MD5Digest): string

     converts a MD5Digest value into its string representation

   * getMD5
          proc getMD5*(s: string): string

     computes an MD5 value of s and returns its string representation

   * '=='
          proc `==`*(D1, D2: MD5Digest): bool

     checks if two MD5Digest values are identical


File: nim-ref-0.13.0.info,  Node: /pure/basic3d,  Next: /pure/oids,  Prev: /pure/md5,  Up: Top

91 Let variable
***************

   * ZAXIS
          ZAXIS*: Vector3d = vector3d(0.0'f64, 0.0'f64, 1.0'f64)

     Quick access to an 3d z-axis unit vector

92 Types
********

   * Vector3d x*, y*, z*: float

          Vector3d* = object
            x*, y*, z*: float


     Implements a 3d *direction vector* stored as an x , y and z
     coordinate.  Direction vector means, that when transforming a
     vector with a matrix, the translational part of the matrix is
     ignored.

93 Procedures
*************

   * matrix3d noInit.}
          proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float): Matrix3d {.
              noInit.}

     Creates a new 4x4 3d transformation matrix.  ax , ay , az is the
     local x axis.  bx , by , bz is the local y axis.  cx , cy , cz is
     the local z axis.  tx , ty , tz is the translation.

   * vector3d
          proc vector3d*(x, y, z: float): Vector3d {.noInit, inline.}

     Returns a new 3d vector (x,'y','z')

   * point3d
          proc point3d*(x, y, z: float): Point3d {.noInit, inline.}

     Returns a new 4d point (x,'y','z')

   * tryNormalize
          proc tryNormalize*(v: var Vector3d): bool

     Modifies v to have a length of 1.0, keeping its angle.  If v has
     zero length (and thus no angle), it is left unmodified and false is
     returned, otherwise true is returned.

   * setElements inline.}
          proc setElements*(t: var Matrix3d; ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float) {.
              inline.}

     Sets arbitrary elements in an exisitng matrix.

   * matrix3d
          proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float): Matrix3d

   * '&amp;'
          proc `&`*(a, b: Matrix3d): Matrix3d {.noinit.}

     Concatenates matrices returning a new matrix.

   * scale
          proc scale*(s: float): Matrix3d {.noInit.}

     Returns a new scaling matrix.

   * scale
          proc scale*(s: float; org: Point3d): Matrix3d {.noInit.}

     Returns a new scaling matrix using, org as scale origin.

   * stretch
          proc stretch*(sx, sy, sz: float): Matrix3d {.noInit.}

     Returns new a stretch matrix, which is a scale matrix with non
     uniform scale in x,y and z.

   * stretch
          proc stretch*(sx, sy, sz: float; org: Point3d): Matrix3d {.noInit.}

     Returns a new stretch matrix, which is a scale matrix with non
     uniform scale in x,y and z.  org is used as stretch origin.

   * move
          proc move*(dx, dy, dz: float): Matrix3d {.noInit.}

     Returns a new translation matrix.

   * move
          proc move*(v: Vector3d): Matrix3d {.noInit.}

     Returns a new translation matrix from a vector.

   * rotate
          proc rotate*(angle: float; axis: Vector3d): Matrix3d {.noInit.}

     Creates a rotation matrix that rotates angle radians over axis,
     which passes through origo.

   * rotate
          proc rotate*(angle: float; org: Point3d; axis: Vector3d): Matrix3d {.noInit.}

     Creates a rotation matrix that rotates angle radians over axis,
     which passes through org.

   * rotateX
          proc rotateX*(angle: float): Matrix3d {.noInit.}

     Creates a matrix that rotates around the x-axis with angle radians,
     which is also called a 'roll' matrix.

   * rotateY
          proc rotateY*(angle: float): Matrix3d {.noInit.}

     Creates a matrix that rotates around the y-axis with angle radians,
     which is also called a 'pitch' matrix.

   * rotateZ
          proc rotateZ*(angle: float): Matrix3d {.noInit.}

     Creates a matrix that rotates around the z-axis with angle radians,
     which is also called a 'yaw' matrix.

   * isUniform
          proc isUniform*(m: Matrix3d; tol = 1e-06'f64): bool

     Checks if the transform is uniform, that is perpendicular axes of
     equal length, which means (for example) it cannot transform a
     sphere into an ellipsoid.  tol is used as tolerance for both equal
     length comparison and perpendicular comparison.

   * mirror
          proc mirror*(planeperp: Vector3d): Matrix3d {.noInit.}

     Creates a matrix that mirrors over the plane that has planeperp as
     normal, and passes through origo.  planeperp does not need to be
     normalized.

   * mirror
          proc mirror*(org: Point3d; planeperp: Vector3d): Matrix3d {.noInit.}

     Creates a matrix that mirrors over the plane that has planeperp as
     normal, and passes through org.  planeperp does not need to be
     normalized.

   * determinant
          proc determinant*(m: Matrix3d): float

     Computes the determinant of matrix m.

   * inverse
          proc inverse*(m: Matrix3d): Matrix3d {.noInit.}

     Computes the inverse of matrix m.  If the matrix determinant is
     zero, thus not invertible, a EDivByZero will be raised.

   * equals
          proc equals*(m1: Matrix3d; m2: Matrix3d; tol = 1e-06'f64): bool

     Checks if all elements of m1'and 'm2 is equal within a given
     tolerance tol.

   * '=~'
          proc `=~`*(m1, m2: Matrix3d): bool

     Checks if m1 and m2 is approximately equal, using a tolerance of
     1e-6.

   * transpose
          proc transpose*(m: Matrix3d): Matrix3d {.noInit.}

     Returns the transpose of m

   * getXAxis
          proc getXAxis*(m: Matrix3d): Vector3d {.noInit.}

     Gets the local x axis of m

   * getYAxis
          proc getYAxis*(m: Matrix3d): Vector3d {.noInit.}

     Gets the local y axis of m

   * getZAxis
          proc getZAxis*(m: Matrix3d): Vector3d {.noInit.}

     Gets the local y axis of m

   * '$'
          proc `$`*(m: Matrix3d): string

     String representation of m

   * apply
          proc apply*(m: Matrix3d; x, y, z: var float; translate = false)

     Applies transformation m onto x , y , z , optionally using the
     translation part of the matrix.

   * vector3d
          proc vector3d*(x, y, z: float): Vector3d

   * len
          proc len*(v: Vector3d): float

     Returns the length of the vector v.

   * 'len='
          proc `len =`*(v: var Vector3d; newlen: float) {.noInit.}

     Sets the length of the vector, keeping its direction.  If the
     vector has zero length before changing it's length, an arbitrary
     vector of the requested length is returned.

   * sqrLen
          proc sqrLen*(v: Vector3d): float {.inline.}

     Computes the squared length of the vector, which is faster than
     computing the absolute length.

   * '$'
          proc `$`*(v: Vector3d): string

     String representation of v

   * '&amp;'
          proc `&`*(v: Vector3d; m: Matrix3d): Vector3d {.noInit.}

     Concatenate vector v with a transformation matrix.  Transforming a
     vector ignores the translational part of the matrix.

   * '&amp;='
          proc `&=`*(v: var Vector3d; m: Matrix3d) {.noInit.}

     Applies transformation m onto v in place.  Transforming a vector
     ignores the translational part of the matrix.

   * transformNorm
          proc transformNorm*(v: var Vector3d; m: Matrix3d)

     Applies a normal direction transformation m onto v in place.  The
     resulting vector is _not_ normalized.  Transforming a vector
     ignores the translational part of the matrix.  If the matrix is not
     invertible (determinant=0), an EDivByZero will be raised.

   * transformInv
          proc transformInv*(v: var Vector3d; m: Matrix3d)

     Applies the inverse of m on vector v.  Transforming a vector
     ignores the translational part of the matrix.  Transforming a
     vector ignores the translational part of the matrix.  If the matrix
     is not invertible (determinant=0), an EDivByZero will be raised.

   * transformNormInv
          proc transformNormInv*(vec: var Vector3d; m: Matrix3d)

     Applies an inverse normal direction transformation m onto v in
     place.  This is faster than creating an inverse matrix and
     transformNorm(...)  it.  Transforming a vector ignores the
     translational part of the matrix.

   * tryNormalize
          proc tryNormalize*(v: var Vector3d): bool

     Modifies v to have a length of 1.0, keeping its angle.  If v has
     zero length (and thus no angle), it is left unmodified and false is
     returned, otherwise true is returned.

   * normalize
          proc normalize*(v: var Vector3d) {.inline.}

     Modifies v to have a length of 1.0, keeping its angle.  If v has
     zero length, an EDivByZero will be raised.

   * rotate
          proc rotate*(vec: var Vector3d; angle: float; axis: Vector3d)

     Rotates vec in place, with angle radians over axis, which passes
     through origo.

   * scale
          proc scale*(v: var Vector3d; s: float)

     Scales the vector in place with factor s

   * stretch
          proc stretch*(v: var Vector3d; sx, sy, sz: float)

     Scales the vector non uniformly with factors sx , sy , sz

   * mirror
          proc mirror*(v: var Vector3d; planeperp: Vector3d)

     Computes the mirrored vector of v over the plane that has planeperp
     as normal direction.  planeperp does not need to be normalized.

   * '-'
          proc `-`*(v: Vector3d): Vector3d

     Negates a vector

   * dot
          proc dot*(v1, v2: Vector3d): float {.inline.}

     Computes the dot product of two vectors.  Returns 0.0 if the
     vectors are perpendicular.

   * cross
          proc cross*(v1, v2: Vector3d): Vector3d {.inline.}

     Computes the cross product of two vectors.  The result is a vector
     which is perpendicular to the plane of v1 and v2, which means
     cross(xaxis,yaxis)=zaxis.  The magnitude of the result is zero if
     the vectors are colinear.

   * equals
          proc equals*(v1, v2: Vector3d; tol = 1e-06'f64): bool

     Checks if two vectors approximately equals with a tolerance.

   * '=~'
          proc `=~`*(v1, v2: Vector3d): bool

     Checks if two vectors approximately equals with a hardcoded
     tolerance 1e-6

   * angleTo
          proc angleTo*(v1, v2: Vector3d): float

     Returns the smallest angle between v1 and v2, which is in range
     0-PI

   * arbitraryAxis
          proc arbitraryAxis*(norm: Vector3d): Matrix3d {.noInit.}

     Computes the rotation matrix that would transform world z vector
     into norm.  The inverse of this matrix is useful to transform a
     planar 3d object to 2d space.  This is the same algorithm used to
     interpret DXF and DWG files.

   * bisect
          proc bisect*(v1, v2: Vector3d): Vector3d {.noInit.}

     Computes the bisector between v1 and v2 as a normalized vector.  If
     one of the input vectors has zero length, a normalized version of
     the other is returned.  If both input vectors has zero length, an
     arbitrary normalized vector v1 is returned.

   * point3d
          proc point3d*(x, y, z: float): Point3d

   * sqrDist
          proc sqrDist*(a, b: Point3d): float

     Computes the squared distance between a'and 'b

   * dist
          proc dist*(a, b: Point3d): float {.inline.}

     Computes the absolute distance between a'and 'b

   * '$'
          proc `$`*(p: Point3d): string

     String representation of p

   * '&amp;'
          proc `&`*(p: Point3d; m: Matrix3d): Point3d

     Concatenates a point p with a transform m, resulting in a new,
     transformed point.

   * '&amp;='
          proc `&=`*(p: var Point3d; m: Matrix3d)

     Applies transformation m onto p in place.

   * transformInv
          proc transformInv*(p: var Point3d; m: Matrix3d)

     Applies the inverse of transformation m onto p in place.  If the
     matrix is not invertable (determinant=0) , EDivByZero will be
     raised.

   * '+'
          proc `+`*(p: Point3d; v: Vector3d): Point3d {.noInit, inline.}

     Adds a vector v to a point p, resulting in a new point.

   * '+='
          proc `+=`*(p: var Point3d; v: Vector3d) {.noInit, inline.}

     Adds a vector v to a point p in place.

   * '-'
          proc `-`*(p: Point3d; v: Vector3d): Point3d {.noInit, inline.}

     Subtracts a vector v from a point p, resulting in a new point.

   * '-'
          proc `-`*(p1, p2: Point3d): Vector3d {.noInit, inline.}

     Subtracts p2'from 'p1 resulting in a difference vector.

   * '-='
          proc `-=`*(p: var Point3d; v: Vector3d) {.noInit, inline.}

     Subtracts a vector v from a point p in place.

   * '=~'
          proc `=~`*(p1, p2: Point3d): bool {.inline.}

     Checks if two vectors approximately equals with a hardcoded
     tolerance 1e-6

   * rotate
          proc rotate*(p: var Point3d; rad: float; axis: Vector3d)

     Rotates point p in place rad radians about an axis passing through
     origo.

   * rotate
          proc rotate*(p: var Point3d; angle: float; org: Point3d; axis: Vector3d)

     Rotates point p in place rad radians about an axis passing through
     org

   * scale
          proc scale*(p: var Point3d; fac: float) {.inline.}

     Scales a point in place fac times with world origo as origin.

   * scale
          proc scale*(p: var Point3d; fac: float; org: Point3d) {.inline.}

     Scales the point in place fac times with org as origin.

   * stretch
          proc stretch*(p: var Point3d; facx, facy, facz: float) {.inline.}

     Scales a point in place non uniformly facx , facy , facz times with
     world origo as origin.

   * stretch
          proc stretch*(p: var Point3d; facx, facy, facz: float; org: Point3d) {.inline.}

     Scales the point in place non uniformly facx , facy , facz times
     with org as origin.

   * move
          proc move*(p: var Point3d; dx, dy, dz: float) {.inline.}

     Translates a point dx , dy , dz in place.

   * move
          proc move*(p: var Point3d; v: Vector3d) {.inline.}

     Translates a point with vector v in place.

   * area
          proc area*(a, b, c: Point3d): float {.inline.}

     Computes the area of the triangle thru points a , b and c


File: nim-ref-0.13.0.info,  Node: /pure/oids,  Next: /pure/math,  Prev: /pure/basic3d,  Up: Top

94 Types
********

   * Oid time: int32 ## fuzz: int32 ## count: int32 ##

          Oid* = object
            time: int32                  ##
            fuzz: int32                  ##
            count: int32                 ##


     an OID

95 Procedures
*************

   * '=='
          proc `==`*(oid1: Oid; oid2: Oid): bool

     Compare two Mongo Object IDs for equality

   * hexbyte
          proc hexbyte*(hex: char): int

   * parseOid
          proc parseOid*(str: cstring): Oid

     parses an OID.

   * oidToString
          proc oidToString*(oid: Oid; str: cstring)

   * '$'
          proc `$`*(oid: Oid): string

   * genOid
          proc genOid*(): Oid

     generates a new OID.

   * generatedTime
          proc generatedTime*(oid: Oid): Time

     returns the generated timestamp of the OID.


File: nim-ref-0.13.0.info,  Node: /pure/math,  Next: /pure/securehash,  Prev: /pure/oids,  Up: Top

96 Types
********

   * FloatClass fcNormal, ## value is an ordinary nonzero floating point
     value fcSubnormal, ## value is a subnormal (a very small) floating
     point value fcZero, ## value is zero fcNegZero, ## value is the
     negative zero fcNan, ## value is Not-A-Number (NAN) fcInf, ## value
     is positive infinity fcNegInf ## value is negative infinity
          FloatClass* = enum
            fcNormal,                   ## value is an ordinary nonzero floating point value
            fcSubnormal,                ## value is a subnormal (a very small) floating point value
            fcZero,                     ## value is zero
            fcNegZero,                  ## value is the negative zero
            fcNan,                      ## value is Not-A-Number (NAN)
            fcInf,                      ## value is positive infinity
            fcNegInf                    ## value is negative infinity

     describes the class a floating point value belongs to.  This is the
     type that is returned by classify.

97 Procedures
*************

   * binom
          proc binom*(n, k: int): int {.noSideEffect.}

     Computes the binomial coefficient

   * fac
          proc fac*(n: int): int {.noSideEffect.}

     Computes the faculty/factorial function.

   * classify
          proc classify*(x: float): FloatClass

     Classifies a floating point value.  Returns x's class as specified
     by FloatClass.

   * isPowerOfTwo
          proc isPowerOfTwo*(x: int): bool {.noSideEffect.}

     Returns true, if x is a power of two, false otherwise.  Zero and
     negative numbers are not a power of two.

   * nextPowerOfTwo
          proc nextPowerOfTwo*(x: int): int {.noSideEffect.}

     Returns x rounded up to the nearest power of two.  Zero and
     negative numbers get rounded up to 1.

   * countBits32
          proc countBits32*(n: int32): int {.noSideEffect.}

     Counts the set bits in n.

   * sum
          proc sum*[T](x: openArray[T]): T {.noSideEffect.}

     Computes the sum of the elements in x.  If x is empty, 0 is
     returned.

   * random
          proc random*(max: int): int {.benign.}

     Returns a random number in the range 0..max-1.  The sequence of
     random number is always the same, unless randomize is called which
     initializes the random number generator with a "random" number,
     i.e.  a tickcount.

   * random
          proc random*(max: float): float {.benign.}

     Returns a random number in the range 0..<max.  The sequence of
     random number is always the same, unless randomize is called which
     initializes the random number generator with a "random" number,
     i.e.  a tickcount.  This has a 16-bit resolution on windows and a
     48-bit resolution on other platforms.

   * randomize
          proc randomize*() {.benign.}

     Initializes the random number generator with a "random" number,
     i.e.  a tickcount.  Note: Does nothing for the JavaScript target,
     as JavaScript does not support this.  Nor does it work for
     NimScript.

   * randomize
          proc randomize*(seed: int) {.benign.}

     Initializes the random number generator with a specific seed.
     Note: Does nothing for the JavaScript target, as JavaScript does
     not support this.

   * sqrt
          proc sqrt*(x: float): float {.importc: "sqrt", header: "<math.h>".}

     Computes the square root of x.

   * cbrt
          proc cbrt*(x: float): float {.importc: "cbrt", header: "<math.h>".}

     Computes the cubic root of x

   * ln
          proc ln*(x: float): float {.importc: "log", header: "<math.h>".}

     Computes the natural log of x

   * log10
          proc log10*(x: float): float {.importc: "log10", header: "<math.h>".}

     Computes the common logarithm (base 10) of x

   * log2
          proc log2*(x: float): float

     Computes the binary logarithm (base 2) of x

   * exp
          proc exp*(x: float): float {.importc: "exp", header: "<math.h>".}

     Computes the exponential function of x (pow(E, x))

   * frexp
          proc frexp*(x: float; exponent: var int): float {.importc: "frexp", header: "<math.h>".}

     Split a number into mantissa and exponent.  frexp calculates the
     mantissa m (a float greater than or equal to 0.5 and less than 1)
     and the integer value n such that x (the original float value)
     equals m * 2**n.  frexp stores n in exponent and returns m.

   * round
          proc round*(x: float): int {.importc: "lrint", header: "<math.h>".}

     Converts a float to an int by rounding.

   * arccos
          proc arccos*(x: float): float {.importc: "acos", header: "<math.h>".}

     Computes the arc cosine of x

   * arcsin
          proc arcsin*(x: float): float {.importc: "asin", header: "<math.h>".}

     Computes the arc sine of x

   * arctan
          proc arctan*(x: float): float {.importc: "atan", header: "<math.h>".}

     Calculate the arc tangent of y / x

   * arctan2
          proc arctan2*(y, x: float): float {.importc: "atan2", header: "<math.h>".}

     Calculate the arc tangent of y / x.  atan2 returns the arc tangent
     of y / x; it produces correct results even when the resulting angle
     is near pi/2 or -pi/2 (x near 0).

   * cos
          proc cos*(x: float): float {.importc: "cos", header: "<math.h>".}

     Computes the cosine of x

   * cosh
          proc cosh*(x: float): float {.importc: "cosh", header: "<math.h>".}

     Computes the hyperbolic cosine of x

   * hypot
          proc hypot*(x, y: float): float {.importc: "hypot", header: "<math.h>".}

     Computes the hypotenuse of a right-angle triangle with x and y as
     its base and height.  Equivalent to 'sqrt(x*x + y*y)'.

   * sinh
          proc sinh*(x: float): float {.importc: "sinh", header: "<math.h>".}

     Computes the hyperbolic sine of x

   * sin
          proc sin*(x: float): float {.importc: "sin", header: "<math.h>".}

     Computes the sine of x

   * tan
          proc tan*(x: float): float {.importc: "tan", header: "<math.h>".}

     Computes the tangent of x

   * tanh
          proc tanh*(x: float): float {.importc: "tanh", header: "<math.h>".}

     Computes the hyperbolic tangent of x

   * pow
          proc pow*(x, y: float): float {.importc: "pow", header: "<math.h>".}

     Computes x to power of y.

   * erf
          proc erf*(x: float): float {.importc: "erf", header: "<math.h>".}

     The error function

   * erfc
          proc erfc*(x: float): float {.importc: "erfc", header: "<math.h>".}

     The complementary error function

   * lgamma
          proc lgamma*(x: float): float {.importc: "lgamma", header: "<math.h>".}

     Natural log of the gamma function

   * tgamma
          proc tgamma*(x: float): float {.importc: "tgamma", header: "<math.h>".}

     The gamma function

   * trunc
          proc trunc*(x: float): float {.importc: "trunc", header: "<math.h>".}

     Truncates x to the decimal point
     echo trunc(PI) # 3.0

   * floor
          proc floor*(x: float): float {.importc: "floor", header: "<math.h>".}

     Computes the floor function (i.e., the largest integer not greater
     than x)
     echo floor(-3.5) ## -4.0

   * ceil
          proc ceil*(x: float): float {.importc: "ceil", header: "<math.h>".}

     Computes the ceiling function (i.e., the smallest integer not less
     than x)
     echo ceil(-2.1) ## -2.0

   * fmod
          proc fmod*(x, y: float): float {.importc: "fmod", header: "<math.h>".}

     Computes the remainder of x divided by y
     echo fmod(-2.5, 0.3) ## -0.1

   * degToRad
          proc degToRad*[T: float32 | float64](d: T): T {.inline.}

     Convert from degrees to radians

   * radToDeg
          proc radToDeg*[T: float32 | float64](d: T): T {.inline.}

     Convert from radians to degrees

   * 'mod'
          proc `mod`*(x, y: float): float

     Computes the modulo operation for float operators.  Equivalent to
     'x - y * floor(x/y)'.  Note that the remainder will always have the
     same sign as the divisor.
     echo (4.0 mod -3.1) # -2.2

   * random
          proc random*[T](x: Slice[T]): T

     For a slice a ..  b returns a value in the range a ..  b-1.

   * random
          proc random*[T](a: openArray[T]): T

     returns a random element from the openarray a.

   * '^'
          proc `^`*[T](x, y: T): T

     Computes 'x' to the power 'y`. ``x' must be non-negative, use pow
     <#pow,float,float> for negative exponents.

   * gcd
          proc gcd*[T](x, y: T): T

     Computes the greatest common divisor of 'x' and 'y'.  Note that for
     floats, the result cannot always be interpreted as "greatest
     decimal z such that 'z*N == x and z*M == y' where N and M are
     positive integers."

   * lcm
          proc lcm*[T](x, y: T): T

     Computes the least common multiple of 'x' and 'y'.


File: nim-ref-0.13.0.info,  Node: /pure/securehash,  Next: /pure/terminal,  Prev: /pure/math,  Up: Top

98 Types
********

   * SecureHash
          SecureHash* = distinct Sha1Digest

99 Procedures
*************

   * secureHash
          proc secureHash*(str: string): SecureHash

   * secureHashFile
          proc secureHashFile*(filename: string): SecureHash

   * '$'
          proc `$`*(self: SecureHash): string

   * parseSecureHash
          proc parseSecureHash*(hash: string): SecureHash

   * '=='
          proc `==`*(a, b: SecureHash): bool


File: nim-ref-0.13.0.info,  Node: /pure/terminal,  Next: /pure/parseopt2,  Prev: /pure/securehash,  Up: Top

100 Types
*********

   * Style styleBright = 1, ## bright text styleDim, ## dim text
     styleUnknown, ## unknown styleUnderscore = 4, ## underscored text
     styleBlink, ## blinking/bold text styleReverse = 7, ## unknown
     styleHidden ## hidden text
          Style* = enum
            styleBright = 1,              ## bright text
            styleDim,                   ## dim text
            styleUnknown,               ## unknown
            styleUnderscore = 4,          ## underscored text
            styleBlink,                 ## blinking/bold text
            styleReverse = 7,             ## unknown
            styleHidden                 ## hidden text

     different styles for text output

   * BackgroundColor bgBlack = 40, ## black bgRed, ## red bgGreen, ##
     green bgYellow, ## yellow bgBlue, ## blue bgMagenta, ## magenta
     bgCyan, ## cyan bgWhite ## white
          BackgroundColor* = enum
            bgBlack = 40,                 ## black
            bgRed,                      ## red
            bgGreen,                    ## green
            bgYellow,                   ## yellow
            bgBlue,                     ## blue
            bgMagenta,                  ## magenta
            bgCyan,                     ## cyan
            bgWhite                     ## white

     terminal's background colors

   * TerminalCmd resetStyle ## reset attributes
          TerminalCmd* = enum
            resetStyle                  ## reset attributes

     commands that can be expressed as arguments

101 Procedures
**************

   * setCursorPos
          proc setCursorPos*(f: File; x, y: int)

     Sets the terminal's cursor to the (x,y) position.  (0,0) is the
     upper left of the screen.

   * setCursorXPos
          proc setCursorXPos*(f: File; x: int)

     Sets the terminal's cursor to the x position.  The y position is
     not changed.

   * setCursorYPos
          proc setCursorYPos*(f: File; y: int)

     Sets the terminal's cursor to the y position.  The x position is
     not changed.  *Warning*: This is not supported on UNIX!

   * cursorUp
          proc cursorUp*(f: File; count = 1)

     Moves the cursor up by count rows.

   * cursorDown
          proc cursorDown*(f: File; count = 1)

     Moves the cursor down by count rows.

   * cursorForward
          proc cursorForward*(f: File; count = 1)

     Moves the cursor forward by count columns.

   * cursorBackward
          proc cursorBackward*(f: File; count = 1)

     Moves the cursor backward by count columns.

   * eraseLine
          proc eraseLine*(f: File)

     Erases the entire current line.

   * eraseScreen
          proc eraseScreen*(f: File)

     Erases the screen with the background colour and moves the cursor
     to home.

   * resetAttributes
          proc resetAttributes*(f: File)

     Resets all attributes.

   * setStyle
          proc setStyle*(f: File; style: set[Style])

     Sets the terminal style.

   * writeStyled
          proc writeStyled*(txt: string; style: set[Style] = {styleBright})

     Writes the text txt in a given style to stdout.

   * setForegroundColor
          proc setForegroundColor*(f: File; fg: ForegroundColor; bright = false)

     Sets the terminal's foreground color.

   * setBackgroundColor
          proc setBackgroundColor*(f: File; bg: BackgroundColor; bright = false)

     Sets the terminal's background color.

   * isatty
          proc isatty*(f: File): bool

     Returns true if f is associated with a terminal device.

   * getch
          proc getch*(): char

     Read a single character from the terminal, blocking until it is
     entered.  The character is not printed to the terminal.  This is
     not available for Windows.

   * resetAttributes
          proc resetAttributes*() {.noconv.}

     Resets all attributes on stdout.  It is advisable to register this
     as a quit proc with 'system.addQuitProc(resetAttributes)'.

102 Templates
*************

   * styledEcho
          template styledEcho*(args: varargs[expr]): expr

     Echoes styles arguments to stdout using 'styledWriteLine'.

   * setCursorPos
          template setCursorPos*(x, y: int)

   * setCursorXPos
          template setCursorXPos*(x: int)

   * cursorUp
          template cursorUp*(count = 1)

   * cursorDown
          template cursorDown*(count = 1)

   * cursorForward
          template cursorForward*(count = 1)

   * cursorBackward
          template cursorBackward*(count = 1)

   * eraseLine
          template eraseLine*()

   * eraseScreen
          template eraseScreen*()

   * setStyle
          template setStyle*(style: set[Style])

   * setForegroundColor
          template setForegroundColor*(fg: ForegroundColor; bright = false)

   * setBackgroundColor
          template setBackgroundColor*(bg: BackgroundColor; bright = false)

103 Macros
**********

   * styledWriteLine
          macro styledWriteLine*(f: File; m: varargs[expr]): stmt

     Similar to 'writeLine', but treating terminal style arguments
     specially.  When some argument is 'Style', 'set[Style]',
     'ForegroundColor', 'BackgroundColor' or 'TerminalCmd' then it is
     not sent directly to 'f', but instead corresponding terminal style
     proc is called.

     Example:
     proc error(msg: string) =
       styleWriteLine(stderr, fgRed, "Error: ", resetStyle, msg)


File: nim-ref-0.13.0.info,  Node: /pure/parseopt2,  Next: /pure/xmlparser,  Prev: /pure/terminal,  Up: Top

104 Types
*********

   * OptParser cmd: seq[string] pos: int remainingShortOptions: string
     kind*: CmdLineKind ## the dected command line token key*, val*:
     TaintedString ## key and value pair; "key" is the option ## or the
     argument, "value" is not "" if ## the option was given a value

          OptParser* = object of RootObj
            cmd: seq[string]
            pos: int
            remainingShortOptions: string
            kind*: CmdLineKind           ## the dected command line token
            key*, val*: TaintedString     ## key and value pair; ``key`` is the option
                                   ## or the argument, ``value`` is not "" if
                                   ## the option was given a value


     this object implements the command line parser

   * GetoptResult
          GetoptResult* = tuple[kind: CmdLineKind, key, val: TaintedString]

105 Procedures
**************

   * initOptParser
          proc initOptParser*(cmdline: seq[string]): OptParser {.rtl.}

     Initalizes option parses with cmdline.  cmdline should not contain
     argument 0 - program name.  If cmdline == nil default to current
     command line arguments.

   * initOptParser
          proc initOptParser*(cmdline: string): OptParser {.rtl, deprecated.}

     Initalizes option parses with cmdline.  Splits cmdline in on spaces
     and calls initOptParser(openarray[string]) Do not use.

   * initOptParser
          proc initOptParser*(): OptParser

     Initializes option parser from current command line arguments.

   * next
          proc next*(p: var OptParser) {.rtl, extern: "npo2$1".}

   * cmdLineRest
          proc cmdLineRest*(p: OptParser): TaintedString {.rtl, extern: "npo2$1", deprecated.}

     Returns part of command line string that has not been parsed yet.
     Do not use - does not correctly handle whitespace.

106 Iterators
*************

   * getopt
          iterator getopt*(): GetoptResult

     This is an convenience iterator for iterating over the command
     line.  This uses the OptParser object.  Example:
     var
       filename = ""
     for kind, key, val in getopt():
       case kind
       of cmdArgument:
         filename = key
       of cmdLongOption, cmdShortOption:
         case key
         of "help", "h": writeHelp()
         of "version", "v": writeVersion()
       of cmdEnd: assert(false) # cannot happen
     if filename == "":
       # no filename has been given, so we show the help:
       writeHelp()


File: nim-ref-0.13.0.info,  Node: /pure/xmlparser,  Next: /pure/fenv,  Prev: /pure/parseopt2,  Up: Top

107 Types
*********

   * XmlError errors*: seq[string] ## all detected parsing errors

          XmlError* = object of ValueError
            errors*: seq[string]         ## all detected parsing errors


     exception that is raised for invalid XML

108 Procedures
**************

   * parseXml
          proc parseXml*(s: Stream; filename: string; errors: var seq[string]): XmlNode

     parses the XML from stream s and returns a 'PXmlNode'.  Every
     occurred parsing error is added to the errors sequence.

   * parseXml
          proc parseXml*(s: Stream): XmlNode

     parses the XTML from stream s and returns a 'PXmlNode'.  All
     parsing errors are turned into an 'EInvalidXML' exception.

   * loadXml
          proc loadXml*(path: string; errors: var seq[string]): XmlNode

     Loads and parses XML from file specified by 'path', and returns a
     'PXmlNode'.  Every occurred parsing error is added to the errors
     sequence.

   * loadXml
          proc loadXml*(path: string): XmlNode

     Loads and parses XML from file specified by 'path', and returns a
     'PXmlNode'.  All parsing errors are turned into an 'EInvalidXML'
     exception.


File: nim-ref-0.13.0.info,  Node: /pure/fenv,  Next: /pure/strutils,  Prev: /pure/xmlparser,  Up: Top

109 Variables
*************

   * FE_DFL_ENV
          FE_DFL_ENV* {.importc, header: "<fenv.h>".}: cint

     macro of type pointer to fenv_t to be used as the argument to
     functions taking an argument of type fenv_t; in this case the
     default environment will be used

110 Types
*********

   * Tfexcept
          Tfexcept* {.importc: "fexcept_t", header: "<fenv.h>", final, pure.} = object

     Represents the floating-point status flags collectively, including
     any status the implementation associates with the flags.  A
     floating-point status flag is a system variable whose value is set
     (but never cleared) when a floating-point exception is raised,
     which occurs as a side effect of exceptional floating-point
     arithmetic to provide auxiliary information.  A floating-point
     control mode is a system variable whose value may be set by the
     user to affect the subsequent behavior of floating-point
     arithmetic.

111 Procedures
**************

   * feclearexcept
          proc feclearexcept*(excepts: cint): cint {.importc, header: "<fenv.h>".}

     Clear the supported exceptions represented by excepts.

   * fegetexceptflag header: "<fenv.h>".}
          proc fegetexceptflag*(flagp: ptr Tfexcept; excepts: cint): cint {.importc,
              header: "<fenv.h>".}

     Store implementation-defined representation of the exception flags
     indicated by excepts in the object pointed to by flagp.

   * feraiseexcept
          proc feraiseexcept*(excepts: cint): cint {.importc, header: "<fenv.h>".}

     Raise the supported exceptions represented by excepts.

   * fesetexceptflag header: "<fenv.h>".}
          proc fesetexceptflag*(flagp: ptr Tfexcept; excepts: cint): cint {.importc,
              header: "<fenv.h>".}

     Set complete status for exceptions indicated by excepts according
     to the representation in the object pointed to by flagp.

   * fetestexcept
          proc fetestexcept*(excepts: cint): cint {.importc, header: "<fenv.h>".}

     Determine which of subset of the exceptions specified by excepts
     are currently set.

   * fegetround
          proc fegetround*(): cint {.importc, header: "<fenv.h>".}

     Get current rounding direction.

   * fesetround
          proc fesetround*(roundingDirection: cint): cint {.importc, header: "<fenv.h>".}

     Establish the rounding direction represented by roundingDirection.

   * fegetenv
          proc fegetenv*(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>".}

     Store the current floating-point environment in the object pointed
     to by envp.

   * feholdexcept
          proc feholdexcept*(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>".}

     Save the current environment in the object pointed to by envp,
     clear exception flags and install a non-stop mode (if available)
     for all exceptions.

   * fesetenv
          proc fesetenv*(a1: ptr Tfenv): cint {.importc, header: "<fenv.h>".}

     Establish the floating-point environment represented by the object
     pointed to by envp.

   * feupdateenv
          proc feupdateenv*(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>".}

     Save current exceptions in temporary storage, install environment
     represented by object pointed to by envp and raise exceptions
     according to saved exceptions.

112 Templates
*************

   * fpRadix
          template fpRadix*(): int

     The (integer) value of the radix used to represent any floating
     point type on the architecture used to build the program.

   * mantissaDigits
          template mantissaDigits*(T: typedesc[float32]): int

     Number of digits (in base 'floatingPointRadix') in the mantissa of
     32-bit floating-point numbers.

   * digits
          template digits*(T: typedesc[float32]): int

     Number of decimal digits that can be represented in a 32-bit
     floating-point type without losing precision.

   * minExponent
          template minExponent*(T: typedesc[float32]): int

     Minimum (negative) exponent for 32-bit floating-point numbers.

   * maxExponent
          template maxExponent*(T: typedesc[float32]): int

     Maximum (positive) exponent for 32-bit floating-point numbers.

   * min10Exponent
          template min10Exponent*(T: typedesc[float32]): int

     Minimum (negative) exponent in base 10 for 32-bit floating-point
     numbers.

   * max10Exponent
          template max10Exponent*(T: typedesc[float32]): int

     Maximum (positive) exponent in base 10 for 32-bit floating-point
     numbers.

   * minimumPositiveValue
          template minimumPositiveValue*(T: typedesc[float32]): float32

     The smallest positive (nonzero) number that can be represented in a
     32-bit floating-point type.

   * maximumPositiveValue
          template maximumPositiveValue*(T: typedesc[float32]): float32

     The largest positive number that can be represented in a 32-bit
     floating-point type.

   * epsilon
          template epsilon*(T: typedesc[float32]): float32

     The difference between 1.0 and the smallest number greater than 1.0
     that can be represented in a 32-bit floating-point type.

   * mantissaDigits
          template mantissaDigits*(T: typedesc[float64]): int

     Number of digits (in base 'floatingPointRadix') in the mantissa of
     64-bit floating-point numbers.

   * digits
          template digits*(T: typedesc[float64]): int

     Number of decimal digits that can be represented in a 64-bit
     floating-point type without losing precision.

   * minExponent
          template minExponent*(T: typedesc[float64]): int

     Minimum (negative) exponent for 64-bit floating-point numbers.

   * maxExponent
          template maxExponent*(T: typedesc[float64]): int

     Maximum (positive) exponent for 64-bit floating-point numbers.

   * min10Exponent
          template min10Exponent*(T: typedesc[float64]): int

     Minimum (negative) exponent in base 10 for 64-bit floating-point
     numbers.

   * max10Exponent
          template max10Exponent*(T: typedesc[float64]): int

     Maximum (positive) exponent in base 10 for 64-bit floating-point
     numbers.

   * minimumPositiveValue
          template minimumPositiveValue*(T: typedesc[float64]): float64

     The smallest positive (nonzero) number that can be represented in a
     64-bit floating-point type.

   * maximumPositiveValue
          template maximumPositiveValue*(T: typedesc[float64]): float64

     The largest positive number that can be represented in a 64-bit
     floating-point type.

   * epsilon
          template epsilon*(T: typedesc[float64]): float64

     The difference between 1.0 and the smallest number greater than 1.0
     that can be represented in a 64-bit floating-point type.


File: nim-ref-0.13.0.info,  Node: /pure/strutils,  Next: /pure/asyncdispatch,  Prev: /pure/fenv,  Up: Top

113 Constant variables
**********************

   * AllChars
          AllChars* = {'\0' .. '\xFF'}

     A set with all the possible characters.

     Not very useful by its own, you can use it to create _inverted_
     sets to make the find() proc (#find,string,set[char],int) find
     *invalid* characters in strings.  Example:
     let invalid = AllChars - Digits
     doAssert "01234".find(invalid) == -1
     doAssert "01A34".find(invalid) == 2

114 Types
*********

   * CharSet
          CharSet* {.deprecated.} = set[char]

   * FloatFormatMode ffDefault, ## use the shorter floating point
     notation ffDecimal, ## use decimal floating point notation
     ffScientific ## use scientific notation (using "e" character)
          FloatFormatMode* = enum
            ffDefault,                  ## use the shorter floating point notation
            ffDecimal,                  ## use decimal floating point notation
            ffScientific                ## use scientific notation (using ``e`` character)

     the different modes of floating point formating

115 Procedures
**************

   * isAlpha
          proc isAlpha*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsAlphaChar".}

     Checks whether or not c is alphabetical.

     This checks a-z, A-Z ASCII characters only.

   * isAlphaNumeric extern: "nsuIsAlphaNumericChar".}
          proc isAlphaNumeric*(c: char): bool {.noSideEffect, procvar, rtl,
                                            extern: "nsuIsAlphaNumericChar".}

     Checks whether or not c is alphanumeric.

     This checks a-z, A-Z, 0-9 ASCII characters only.

   * isDigit
          proc isDigit*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsDigitChar".}

     Checks whether or not c is a number.

     This checks 0-9 ASCII characters only.

   * isSpace
          proc isSpace*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsSpaceChar".}

     Checks whether or not c is a whitespace character.

   * isLower
          proc isLower*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsLowerChar".}

     Checks whether or not c is a lower case character.

     This checks ASCII characters only.

   * isUpper
          proc isUpper*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsUpperChar".}

     Checks whether or not c is an upper case character.

     This checks ASCII characters only.

   * isAlpha
          proc isAlpha*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsAlphaStr".}

     Checks whether or not s is alphabetical.

     This checks a-z, A-Z ASCII characters only.  Returns true if all
     characters in s are alphabetic and there is at least one character
     in s.

   * isAlphaNumeric extern: "nsuIsAlphaNumericStr".}
          proc isAlphaNumeric*(s: string): bool {.noSideEffect, procvar, rtl,
                                              extern: "nsuIsAlphaNumericStr".}

     Checks whether or not s is alphanumeric.

     This checks a-z, A-Z, 0-9 ASCII characters only.  Returns true if
     all characters in s are alpanumeric and there is at least one
     character in s.

   * isDigit
          proc isDigit*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsDigitStr".}

     Checks whether or not s is a numeric value.

     This checks 0-9 ASCII characters only.  Returns true if all
     characters in s are numeric and there is at least one character in
     s.

   * isSpace
          proc isSpace*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsSpaceStr".}

     Checks whether or not s is completely whitespace.

     Returns true if all characters in s are whitespace characters and
     there is at least one character in s.

   * isLower
          proc isLower*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsLowerStr".}

     Checks whether or not s contains all lower case characters.

     This checks ASCII characters only.  Returns true if all characters
     in s are lower case and there is at least one character in s.

   * isUpper
          proc isUpper*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsUpperStr".}

     Checks whether or not s contains all upper case characters.

     This checks ASCII characters only.  Returns true if all characters
     in s are upper case and there is at least one character in s.

   * toLower
          proc toLower*(c: char): char {.noSideEffect, procvar, rtl, extern: "nsuToLowerChar".}

     Converts c into lower case.

     This works only for the letters 'A-Z'.  See unicode.toLower
     (unicode.html#toLower) for a version that works for any Unicode
     character.

   * toLower
          proc toLower*(s: string): string {.noSideEffect, procvar, rtl, extern: "nsuToLowerStr".}

     Converts s into lower case.

     This works only for the letters 'A-Z'.  See unicode.toLower
     (unicode.html#toLower) for a version that works for any Unicode
     character.

   * toUpper
          proc toUpper*(c: char): char {.noSideEffect, procvar, rtl, extern: "nsuToUpperChar".}

     Converts c into upper case.

     This works only for the letters 'A-Z'.  See unicode.toUpper
     (unicode.html#toUpper) for a version that works for any Unicode
     character.

   * toUpper
          proc toUpper*(s: string): string {.noSideEffect, procvar, rtl, extern: "nsuToUpperStr".}

     Converts s into upper case.

     This works only for the letters 'A-Z'.  See unicode.toUpper
     (unicode.html#toUpper) for a version that works for any Unicode
     character.

   * capitalize extern: "nsuCapitalize".}
          proc capitalize*(s: string): string {.noSideEffect, procvar, rtl,
                                            extern: "nsuCapitalize".}

     Converts the first character of s into upper case.

     This works only for the letters 'A-Z'.

   * normalize
          proc normalize*(s: string): string {.noSideEffect, procvar, rtl, extern: "nsuNormalize".}

     Normalizes the string s.

     That means to convert it to lower case and remove any '_'.  This is
     needed for Nim identifiers for example.

   * cmpIgnoreCase procvar.}
          proc cmpIgnoreCase*(a, b: string): int {.noSideEffect, rtl, extern: "nsuCmpIgnoreCase",
                                              procvar.}

     Compares two strings in a case insensitive manner.  Returns:

     0 iff a == b
     < 0 iff a < b
     > 0 iff a > b

   * cmpIgnoreStyle extern: "nsuCmpIgnoreStyle", procvar.}
          proc cmpIgnoreStyle*(a, b: string): int {.noSideEffect, rtl,
                                               extern: "nsuCmpIgnoreStyle", procvar.}

     Compares two strings normalized (i.e.  case and underscores do not
     matter).  Returns:

     0 iff a == b
     < 0 iff a < b
     > 0 iff a > b

   * strip noSideEffect, rtl, extern: "nsuStrip".}
          proc strip*(s: string; leading = true; trailing = true; chars: set[char] = Whitespace): string {.
              noSideEffect, rtl, extern: "nsuStrip".}

     Strips chars from s and returns the resulting string.

     If leading is true, leading chars are stripped.  If trailing is
     true, trailing chars are stripped.

   * toOctal
          proc toOctal*(c: char): string {.noSideEffect, rtl, extern: "nsuToOctal".}

     Converts a character c to its octal representation.

     The resulting string may not have a leading zero.  Its length is
     always exactly 3.

   * splitLines
          proc splitLines*(s: string): seq[string] {.noSideEffect, rtl, extern: "nsuSplitLines".}

     The same as the splitLines (#splitLines.i,string) iterator, but is
     a proc that returns a sequence of substrings.

   * countLines
          proc countLines*(s: string): int {.noSideEffect, rtl, extern: "nsuCountLines".}

     Returns the number of new line separators in the string s.

     This is the same as 'len(splitLines(s))', but much more efficient
     because it doesn't modify the string creating temporal objects.
     Every character literal (manual.html#character-literals) newline
     combination (CR, LF, CR-LF) is supported.

     Despite its name this proc might not actually return the _number of
     lines_ in s because the concept of what a line is can vary.  For
     example, a string like 'Hello world' is a line of text, but the
     proc will return a value of zero because there are no newline
     separators.  Also, text editors usually don't count trailing
     newline characters in a text file as a new empty line, but this
     proc will.

   * split extern: "nsuSplitCharSet".}
          proc split*(s: string; seps: set[char] = Whitespace): seq[string] {.noSideEffect, rtl,
              extern: "nsuSplitCharSet".}

     The same as the split iterator (#split.i,string,set[char]), but is
     a proc that returns a sequence of substrings.

   * split extern: "nsuSplitChar".}
          proc split*(s: string; sep: char): seq[string] {.noSideEffect, rtl,
              extern: "nsuSplitChar".}

     The same as the split iterator (#split.i,string,char), but is a
     proc that returns a sequence of substrings.

   * split extern: "nsuSplitString".}
          proc split*(s: string; sep: string): seq[string] {.noSideEffect, rtl,
              extern: "nsuSplitString".}

     Splits the string s into substrings using a string separator.

     Substrings are separated by the string sep.  This is a wrapper
     around the split iterator (#split.i,string,string).

   * toHex extern: "nsuToHex".}
          proc toHex*(x: BiggestInt; len: Positive): string {.noSideEffect, rtl,
              extern: "nsuToHex".}

     Converts x to its hexadecimal representation.

     The resulting string will be exactly len characters long.  No
     prefix like '0x' is generated.  x is treated as an unsigned value.

   * intToStr extern: "nsuIntToStr".}
          proc intToStr*(x: int; minchars: Positive = 1): string {.noSideEffect, rtl,
              extern: "nsuIntToStr".}

     Converts x to its decimal representation.

     The resulting string will be minimally minchars characters long.
     This is achieved by adding leading zeros.

   * parseInt
          proc parseInt*(s: string): int {.noSideEffect, procvar, rtl, extern: "nsuParseInt".}

     Parses a decimal integer value contained in s.

     If s is not a valid integer, ValueError is raised.

   * parseBiggestInt extern: "nsuParseBiggestInt".}
          proc parseBiggestInt*(s: string): BiggestInt {.noSideEffect, procvar, rtl,
              extern: "nsuParseBiggestInt".}

     Parses a decimal integer value contained in s.

     If s is not a valid integer, ValueError is raised.

   * parseFloat extern: "nsuParseFloat".}
          proc parseFloat*(s: string): float {.noSideEffect, procvar, rtl,
                                           extern: "nsuParseFloat".}

     Parses a decimal floating point value contained in s.  If s is not
     a valid floating point number, ValueError is raised.  'NAN', 'INF',
     '-INF' are also supported (case insensitive comparison).

   * parseHexInt extern: "nsuParseHexInt".}
          proc parseHexInt*(s: string): int {.noSideEffect, procvar, rtl,
                                          extern: "nsuParseHexInt".}

     Parses a hexadecimal integer value contained in s.

     If s is not a valid integer, ValueError is raised.  s can have one
     of the following optional prefixes: '0x', '0X', '#'.  Underscores
     within s are ignored.

   * parseBool
          proc parseBool*(s: string): bool

     Parses a value into a bool.

     If 's' is one of the following values: 'y, yes, true, 1, on', then
     returns true.  If 's' is one of the following values: 'n, no,
     false, 0, off', then returns false.  If 's' is something else a
     'ValueError' exception is raised.

   * parseEnum
          proc parseEnum*[T: enum](s: string): T

     Parses an enum 'T'.

     Raises 'ValueError' for an invalid value in s.  The comparison is
     done in a style insensitive way.

   * parseEnum
          proc parseEnum*[T: enum](s: string; default: T): T

     Parses an enum 'T'.

     Uses default for an invalid value in s.  The comparison is done in
     a style insensitive way.

   * repeat extern: "nsuRepeatChar".}
          proc repeat*(c: char; count: Natural): string {.noSideEffect, rtl,
              extern: "nsuRepeatChar".}

     Returns a string of length count consisting only of the character
     c.  You can use this proc to left align strings.  Example:
     proc tabexpand(indent: int, text: string, tabsize: int = 4) =
       echo '\t'.repeat(indent div tabsize), ' '.repeat(indent mod tabsize),
           text

     tabexpand(4, "At four")
     tabexpand(5, "At five")
     tabexpand(6, "At six")

   * repeat
          proc repeat*(s: string; n: Natural): string {.noSideEffect, rtl, extern: "nsuRepeatStr".}

     Returns String s concatenated n times.  Example:
     echo "+++ STOP ".repeat(4), "+++"

   * repeatChar
          proc repeatChar*(count: Natural; c: char = ' '): string {.deprecated.}

     deprecated: use repeat() or spaces()

   * repeatStr
          proc repeatStr*(count: Natural; s: string): string {.deprecated.}

     deprecated: use repeat(string, count) or string.repeat(count)

   * align extern: "nsuAlignString".}
          proc align*(s: string; count: Natural; padding = ' '): string {.noSideEffect, rtl,
              extern: "nsuAlignString".}

     Aligns a string s with padding, so that it is of length count.

     padding characters (by default spaces) are added before s resulting
     in right alignment.  If 's.len >= count', no spaces are added and s
     is returned unchanged.  If you need to left align a string use the
     repeatChar proc (#repeatChar).  Example:
     assert align("abc", 4) == " abc"
     assert align("a", 0) == "a"
     assert align("1232", 6) == "  1232"
     assert align("1232", 6, '#') == "##1232"

   * wordWrap seps: set[char] = Whitespace; newLine = "\x0A"): string
     {.noSideEffect, rtl, extern: "nsuWordWrap".}
          proc wordWrap*(s: string; maxLineWidth = 80; splitLongWords = true;
                        seps: set[char] = Whitespace; newLine = "\x0A"): string {.noSideEffect,
              rtl, extern: "nsuWordWrap".}

     Word wraps s.

   * indent extern: "nsuIndent".}
          proc indent*(s: string; count: Natural; padding: string = " "): string {.noSideEffect, rtl,
              extern: "nsuIndent".}

     Indents each line in 's' by 'count' amount of 'padding'.

     *Note:* This currently does not preserve the specific new line
     characters used.

   * unindent extern: "nsuUnindent".}
          proc unindent*(s: string; eatAllIndent = false): string {.noSideEffect, rtl,
              extern: "nsuUnindent".}

     Unindents s.

   * startsWith
          proc startsWith*(s, prefix: string): bool {.noSideEffect, rtl, extern: "nsuStartsWith".}

     Returns true iff 's' starts with 'prefix'.

     If 'prefix == ""' true is returned.

   * endsWith
          proc endsWith*(s, suffix: string): bool {.noSideEffect, rtl, extern: "nsuEndsWith".}

     Returns true iff 's' ends with 'suffix'.

     If 'suffix == ""' true is returned.

   * continuesWith extern: "nsuContinuesWith".}
          proc continuesWith*(s, substr: string; start: Natural): bool {.noSideEffect, rtl,
              extern: "nsuContinuesWith".}

     Returns true iff 's' continues with 'substr' at position 'start'.

     If 'substr == ""' true is returned.

   * addSep
          proc addSep*(dest: var string; sep = ", "; startLen: Natural = 0) {.noSideEffect, inline.}

     Adds a separator to dest only if its length is bigger than
     startLen.

     A shorthand for:
     if dest.len > startLen: add(dest, sep)

     This is often useful for generating some code where the items need
     to be _separated_ by sep.  sep is only added if dest is longer than
     startLen.  The following example creates a string describing an
     array of integers:
     var arr = "["
     for x in items([2, 3, 5, 7, 11]):
       addSep(arr, startLen=len("["))
       add(arr, $x)
     add(arr, "]")

   * allCharsInSet
          proc allCharsInSet*(s: string; theSet: set[char]): bool

     Returns true iff each character of s is in the set theSet.

   * abbrev
          proc abbrev*(s: string; possibilities: openArray[string]): int

     Returns the index of the first item in possibilities if not
     ambiguous.

     Returns -1 if no item has been found and -2 if multiple items
     match.

   * join extern: "nsuJoinSep".}
          proc join*(a: openArray[string]; sep: string): string {.noSideEffect, rtl,
              extern: "nsuJoinSep".}

     Concatenates all strings in a separating them with sep.

   * join
          proc join*(a: openArray[string]): string {.noSideEffect, rtl, extern: "nsuJoin".}

     Concatenates all strings in a.

   * find extern: "nsuFindStr".}
          proc find*(s, sub: string; start: Natural = 0): int {.noSideEffect, rtl,
              extern: "nsuFindStr".}

     Searches for sub in s starting at position start.

     Searching is case-sensitive.  If sub is not in s, -1 is returned.

   * find extern: "nsuFindChar".}
          proc find*(s: string; sub: char; start: Natural = 0): int {.noSideEffect, rtl,
              extern: "nsuFindChar".}

     Searches for sub in s starting at position start.

     Searching is case-sensitive.  If sub is not in s, -1 is returned.

   * find extern: "nsuFindCharSet".}
          proc find*(s: string; chars: set[char]; start: Natural = 0): int {.noSideEffect, rtl,
              extern: "nsuFindCharSet".}

     Searches for chars in s starting at position start.

     If s contains none of the characters in chars, -1 is returned.

   * rfind
          proc rfind*(s, sub: string; start: int = - 1): int {.noSideEffect.}

     Searches for sub in s in reverse, starting at start and going
     backwards to 0.

     Searching is case-sensitive.  If sub is not in s, -1 is returned.

   * rfind
          proc rfind*(s: string; sub: char; start: int = - 1): int {.noSideEffect, rtl.}

     Searches for sub in s in reverse starting at position start.

     Searching is case-sensitive.  If sub is not in s, -1 is returned.

   * count extern: "nsuCountString".}
          proc count*(s: string; sub: string; overlapping: bool = false): int {.noSideEffect, rtl,
              extern: "nsuCountString".}

     Count the occurrences of a substring sub in the string s.
     Overlapping occurrences of sub only count when overlapping is set
     to true.

   * count
          proc count*(s: string; sub: char): int {.noSideEffect, rtl, extern: "nsuCountChar".}

     Count the occurrences of the character sub in the string s.

   * count extern: "nsuCountCharSet".}
          proc count*(s: string; subs: set[char]): int {.noSideEffect, rtl,
              extern: "nsuCountCharSet".}

     Count the occurrences of the group of character subs in the string
     s.

   * quoteIfContainsWhite
          proc quoteIfContainsWhite*(s: string): string {.deprecated.}

     Returns ''"' & s & '"'' if s contains a space and does not start
     with a quote, else returns s.

     *DEPRECATED* as it was confused for shell quoting function.  For
     this application use osproc.quoteShell (osproc.html#quoteShell).

   * contains
          proc contains*(s: string; c: char): bool {.noSideEffect.}

     Same as 'find(s, c) >= 0'.

   * contains
          proc contains*(s, sub: string): bool {.noSideEffect.}

     Same as 'find(s, sub) >= 0'.

   * contains
          proc contains*(s: string; chars: set[char]): bool {.noSideEffect.}

     Same as 'find(s, chars) >= 0'.

   * replace extern: "nsuReplaceStr".}
          proc replace*(s, sub: string; by = ""): string {.noSideEffect, rtl,
              extern: "nsuReplaceStr".}

     Replaces sub in s by the string by.

   * replace extern: "nsuReplaceChar".}
          proc replace*(s: string; sub, by: char): string {.noSideEffect, rtl,
              extern: "nsuReplaceChar".}

     Replaces sub in s by the character by.

     Optimized version of replace (#replace,string,string) for
     characters.

   * replaceWord extern: "nsuReplaceWord".}
          proc replaceWord*(s, sub: string; by = ""): string {.noSideEffect, rtl,
              extern: "nsuReplaceWord".}

     Replaces sub in s by the string by.

     Each occurrence of sub has to be surrounded by word boundaries
     (comparable to '\\w' in regular expressions), otherwise it is not
     replaced.

   * delete
          proc delete*(s: var string; first, last: int) {.noSideEffect, rtl, extern: "nsuDelete".}

     Deletes in s the characters at position first ..  last.

     This modifies s itself, it does not return a copy.

   * parseOctInt
          proc parseOctInt*(s: string): int {.noSideEffect, rtl, extern: "nsuParseOctInt".}

     Parses an octal integer value contained in s.

     If s is not a valid integer, ValueError is raised.  s can have one
     of the following optional prefixes: '0o', '0O'.  Underscores within
     s are ignored.

   * toOct extern: "nsuToOct".}
          proc toOct*(x: BiggestInt; len: Positive): string {.noSideEffect, rtl,
              extern: "nsuToOct".}

     Converts x into its octal representation.

     The resulting string is always len characters long.  No leading
     '0o' prefix is generated.

   * toBin extern: "nsuToBin".}
          proc toBin*(x: BiggestInt; len: Positive): string {.noSideEffect, rtl,
              extern: "nsuToBin".}

     Converts x into its binary representation.

     The resulting string is always len characters long.  No leading
     '0b' prefix is generated.

   * insertSep extern: "nsuInsertSep".}
          proc insertSep*(s: string; sep = '_'; digits = 3): string {.noSideEffect, rtl,
              extern: "nsuInsertSep".}

     Inserts the separator sep after digits digits from right to left.

     Even though the algorithm works with any string s, it is only
     useful if s contains a number.  Example: 'insertSep("1000000") ==
     "1_000_000"'

   * escape extern: "nsuEscape".}
          proc escape*(s: string; prefix = "\""; suffix = "\""): string {.noSideEffect, rtl,
              extern: "nsuEscape".}

     Escapes a string s.

     This does these operations (at the same time):

        * replaces any '\' by '\\'
        * replaces any ''' by '\''
        * replaces any '"' by '\"'
        * replaces any other character in the set '{'\0'..'\31',
          '\128'..'\255'}' by '\xHH' where 'HH' is its hexadecimal
          value.

     The procedure has been designed so that its output is usable for
     many different common syntaxes.  The resulting string is prefixed
     with prefix and suffixed with suffix.  Both may be empty strings.

   * unescape extern: "nsuUnescape".}
          proc unescape*(s: string; prefix = "\""; suffix = "\""): string {.noSideEffect, rtl,
              extern: "nsuUnescape".}

     Unescapes a string s.

     This complements escape (#escape) as it performs the opposite
     operations.

     If s does not begin with 'prefix' and end with 'suffix' a
     ValueError exception will be raised.

   * validIdentifier extern: "nsuValidIdentifier".}
          proc validIdentifier*(s: string): bool {.noSideEffect, rtl,
                                               extern: "nsuValidIdentifier".}

     Returns true if s is a valid identifier.

     A valid identifier starts with a character of the set
     IdentStartChars and is followed by any number of characters of the
     set IdentChars.

   * editDistance
          proc editDistance*(a, b: string): int {.noSideEffect, rtl, extern: "nsuEditDistance".}

     Returns the edit distance between a and b.

     This uses the Levenshtein distance algorithm with only a linear
     memory overhead.  This implementation is highly optimized!

   * formatBiggestFloat precision: range[0 ..  32] = 16; decimalSep =
     '.'): string {.  noSideEffect, rtl, extern: "nsu$1".}
          proc formatBiggestFloat*(f: BiggestFloat; format: FloatFormatMode = ffDefault;
                                  precision: range[0 .. 32] = 16; decimalSep = '.'): string {.
              noSideEffect, rtl, extern: "nsu$1".}

     Converts a floating point value f to a string.

     If 'format == ffDecimal' then precision is the number of digits to
     be printed after the decimal point.  If 'format == ffScientific'
     then precision is the maximum number of significant digits to be
     printed.  precision's default value is the maximum number of
     meaningful digits after the decimal point for Nim's 'biggestFloat'
     type.

     If 'precision == 0', it tries to format it nicely.

   * formatFloat precision: range[0 ..  32] = 16; decimalSep = '.'):
     string {.noSideEffect, rtl, extern: "nsu$1".}
          proc formatFloat*(f: float; format: FloatFormatMode = ffDefault;
                           precision: range[0 .. 32] = 16; decimalSep = '.'): string {.noSideEffect,
              rtl, extern: "nsu$1".}

     Converts a floating point value f to a string.

     If 'format == ffDecimal' then precision is the number of digits to
     be printed after the decimal point.  If 'format == ffScientific'
     then precision is the maximum number of significant digits to be
     printed.  precision's default value is the maximum number of
     meaningful digits after the decimal point for Nim's 'float' type.

   * formatSize
          proc formatSize*(bytes: BiggestInt; decimalSep = '.'): string

     Rounds and formats bytes.  Examples:
     formatSize(1'i64 shl 31 + 300'i64) == "2.204GB"
     formatSize(4096) == "4KB"

   * addf extern: "nsuAddf".}
          proc addf*(s: var string; formatstr: string; a: varargs[string, `$`]) {.noSideEffect, rtl,
              extern: "nsuAddf".}

     The same as 'add(s, formatstr % a)', but more efficient.

   * '%' extern: "nsuFormatOpenArray".}
          proc `%`*(formatstr: string; a: openArray[string]): string {.noSideEffect, rtl,
              extern: "nsuFormatOpenArray".}

     Interpolates a format string with the values from a.

     The substitution operator performs string substitutions in
     formatstr and returns a modified formatstr.  This is often called
     string interpolation.

     This is best explained by an example:
     "$1 eats $2." % ["The cat", "fish"]

     Results in:
     "The cat eats fish."

     The substitution variables (the thing after the '$') are enumerated
     from 1 to 'a.len'.  To produce a verbatim '$', use '$$'.  The
     notation '$#' can be used to refer to the next substitution
     variable:
     "$# eats $#." % ["The cat", "fish"]

     Substitution variables can also be words (that is
     '[A-Za-z_]+[A-Za-z0-9_]*') in which case the arguments in a with
     even indices are keys and with odd indices are the corresponding
     values.  An example:
     "$animal eats $food." % ["animal", "The cat", "food", "fish"]

     Results in:
     "The cat eats fish."

     The variables are compared with cmpIgnoreStyle.  ValueError is
     raised if an ill-formed format string has been passed to the %
     operator.

   * '%' extern: "nsuFormatSingleElem".}
          proc `%`*(formatstr, a: string): string {.noSideEffect, rtl,
                                               extern: "nsuFormatSingleElem".}

     This is the same as 'formatstr % [a]'.

   * format extern: "nsuFormatVarargs".}
          proc format*(formatstr: string; a: varargs[string, `$`]): string {.noSideEffect, rtl,
              extern: "nsuFormatVarargs".}

     This is the same as 'formatstr % a' except that it supports auto
     stringification.

   * removeSuffix extern: "nsuRemoveSuffixCharSet".}
          proc removeSuffix*(s: var string; chars: set[char] = Newlines) {.rtl,
              extern: "nsuRemoveSuffixCharSet".}

     Removes the first matching character from the string (in-place)
     given a set of characters.  If the set of characters is only equal
     to Newlines then it will remove both the newline and return feed.
     ..  code-block:: nim

          var

               userInput = "Hello World!rn" otherInput = "Hello!?!"

          userInput.removeSuffix userInput == "Hello World!"
          userInput.removeSuffix({'!', '?'}) userInput == "Hello World"
          otherInput.removeSuffix({'!', '?'}) otherInput == "Hello!?"

   * removeSuffix
          proc removeSuffix*(s: var string; c: char) {.rtl, extern: "nsuRemoveSuffixChar".}

     Removes a single character (in-place) from a string.  ..
     code-block:: nim

          var

               table = "users"

          table.removeSuffix('s') table == "user"

   * removeSuffix extern: "nsuRemoveSuffixString".}
          proc removeSuffix*(s: var string; suffix: string) {.rtl,
              extern: "nsuRemoveSuffixString".}

     Remove the first matching suffix (in-place) from a string.  ..
     code-block:: nim

          var

               answers = "yeses"

          answers.removeSuffix("es") answers == "yes"

116 Templates
*************

   * spaces
          template spaces*(n: Natural): string

     Returns a String with n space characters.  You can use this proc to
     left align strings.  Example:
     let
       width = 15
       text1 = "Hello user!"
       text2 = "This is a very long string"
     echo text1 & spaces(max(0, width - text1.len)) & "|"
     echo text2 & spaces(max(0, width - text2.len)) & "|"

117 Iterators
*************

   * split
          iterator split*(s: string; seps: set[char] = Whitespace): string

     Splits the string s into substrings using a group of separators.

     Substrings are separated by a substring containing only seps.  Note
     that whole sequences of characters found in 'seps' will be counted
     as a single split point and leading/trailing separators will be
     ignored.  The following example:
     for word in split("  this is an  example  "):
       writeLine(stdout, word)

     ...generates this output:
     "this"
     "is"
     "an"
     "example"

     And the following code:
     for word in split(";;this;is;an;;example;;;", {';'}):
       writeLine(stdout, word)

     ...produces the same output as the first example.  The code:
     let date = "2012-11-20T22:08:08.398990"
     let separators = {' ', '-', ':', 'T'}
     for number in split(date, separators):
       writeLine(stdout, number)

     ...results in:
     "2012"
     "11"
     "20"
     "22"
     "08"
     "08.398990"

   * split
          iterator split*(s: string; sep: char): string

     Splits the string s into substrings using a single separator.

     Substrings are separated by the character sep.  Unlike the version
     of the iterator which accepts a set of separator characters, this
     proc will not coalesce groups of the separator, returning a string
     for each found character.  The code:
     for word in split(";;this;is;an;;example;;;", ';'):
       writeLine(stdout, word)

     Results in:
     ""
     ""
     "this"
     "is"
     "an"
     ""
     "example"
     ""
     ""
     ""

   * split
          iterator split*(s: string; sep: string): string

     Splits the string s into substrings using a string separator.

     Substrings are separated by the string sep.

   * splitLines
          iterator splitLines*(s: string): string

     Splits the string s into its containing lines.

     Every character literal (manual.html#character-literals) newline
     combination (CR, LF, CR-LF) is supported.  The result strings
     contain no trailing '\n'.

     Example:
     for line in splitLines("\nthis\nis\nan\n\nexample\n"):
       writeLine(stdout, line)

     Results in:
     ""
     "this"
     "is"
     "an"
     ""
     "example"
     ""

   * tokenize isSep: bool]
          iterator tokenize*(s: string; seps: set[char] = Whitespace): tuple[token: string,
              isSep: bool]

     Tokenizes the string s into substrings.

     Substrings are separated by a substring containing only seps.
     Examples:
     for word in tokenize("  this is an  example  "):
       writeLine(stdout, word)

     Results in:
     ("  ", true)
     ("this", false)
     (" ", true)
     ("is", false)
     (" ", true)
     ("an", false)
     ("  ", true)
     ("example", false)
     ("  ", true)


File: nim-ref-0.13.0.info,  Node: /pure/asyncdispatch,  Next: /pure/net,  Prev: /pure/strutils,  Up: Top

118 Types
*********

   * FutureError cause*: FutureBase

          FutureError* = object of Exception
            cause*: FutureBase


   * AsyncFD
          AsyncFD* = distinct int

119 Procedures
**************

   * newFuture
          proc newFuture*[T](fromProc: string = "unspecified"): Future[T]

     Creates a new future.

     Specifying 'fromProc', which is a string specifying the name of the
     proc that this future belongs to, is a good habit as it helps with
     debugging.

   * newFutureVar
          proc newFutureVar*[T](fromProc = "unspecified"): FutureVar[T]

     Create a new 'FutureVar'.  This Future type is ideally suited for
     situations where you want to avoid unnecessary allocations of
     Futures.

     Specifying 'fromProc', which is a string specifying the name of the
     proc that this future belongs to, is a good habit as it helps with
     debugging.

   * clean
          proc clean*[T](future: FutureVar[T])

     Resets the 'finished' status of 'future'.

   * complete
          proc complete*[T](future: Future[T]; val: T)

     Completes 'future' with value 'val'.

   * complete
          proc complete*(future: Future[void])

     Completes a void 'future'.

   * complete
          proc complete*[T](future: FutureVar[T])

     Completes a 'FutureVar'.

   * fail
          proc fail*[T](future: Future[T]; error: ref Exception)

     Completes 'future' with 'error'.

   * 'callback='
          proc `callback =`*(future: FutureBase; cb: proc () {.closure, gcsafe.})

     Sets the callback proc to be called when the future completes.

     If future has already completed then 'cb' will be called
     immediately.

     *Note*: You most likely want the other 'callback' setter which
     passes 'future' as a param to the callback.

   * 'callback=' cb: proc (future: Future[T]) {.closure, gcsafe.})
          proc `callback =`*[T](future: Future[T];
                              cb: proc (future: Future[T]) {.closure, gcsafe.})

     Sets the callback proc to be called when the future completes.

     If future has already completed then 'cb' will be called
     immediately.

   * read
          proc read*[T](future: Future[T]): T

     Retrieves the value of 'future'.  Future must be finished otherwise
     this function will fail with a 'ValueError' exception.

     If the result of the future is an error then that error will be
     raised.

   * readError
          proc readError*[T](future: Future[T]): ref Exception

     Retrieves the exception stored in 'future'.

     An 'ValueError' exception will be thrown if no exception exists in
     the specified Future.

   * mget
          proc mget*[T](future: FutureVar[T]): var T

     Returns a mutable value stored in 'future'.

     Unlike 'read', this function will not raise an exception if the
     Future has not been finished.

   * finished
          proc finished*[T](future: Future[T]): bool

     Determines whether 'future' has completed.

     'True' may indicate an error or a value.  Use 'failed' to
     distinguish.

   * failed
          proc failed*(future: FutureBase): bool

     Determines whether 'future' completed with an error.

   * asyncCheck
          proc asyncCheck*[T](future: Future[T])

     Sets a callback on 'future' which raises an exception if the future
     finished with an error.

     This should be used instead of 'discard' to discard void futures.

   * 'and'
          proc `and`*[T, Y](fut1: Future[T]; fut2: Future[Y]): Future[void]

     Returns a future which will complete once both 'fut1' and 'fut2'
     complete.

   * 'or'
          proc `or`*[T, Y](fut1: Future[T]; fut2: Future[Y]): Future[void]

     Returns a future which will complete once either 'fut1' or 'fut2'
     complete.

   * '=='
          proc `==`*(x: AsyncFD; y: AsyncFD): bool {.borrow.}

   * newDispatcher
          proc newDispatcher*(): PDispatcher

     Creates a new Dispatcher instance.

   * getGlobalDispatcher
          proc getGlobalDispatcher*(): PDispatcher

     Retrieves the global thread-local dispatcher.

   * register
          proc register*(fd: AsyncFD)

     Registers 'fd' with the dispatcher.

   * poll
          proc poll*(timeout = 500)

     Waits for completion events and processes them.

   * connect domain = nativesockets.AF_INET): Future[void]
          proc connect*(socket: AsyncFD; address: string; port: Port;
                       domain = nativesockets.AF_INET): Future[void]

     Connects 'socket' to server at 'address:port'.

     Returns a 'Future' which will complete when the connection succeeds
     or an error occurs.

   * recv
          proc recv*(socket: AsyncFD; size: int; flags = {SocketFlag.SafeDisconn}): Future[string]

     Reads *up to* 'size' bytes from 'socket'.  Returned future will
     complete once all the data requested is read, a part of the data
     has been read, or the socket has disconnected in which case the
     future will complete with a value of '""'.

     *Warning*: The 'Peek' socket flag is not supported on Windows.

   * recvInto flags = {SocketFlag.SafeDisconn}): Future[int]
          proc recvInto*(socket: AsyncFD; buf: cstring; size: int;
                        flags = {SocketFlag.SafeDisconn}): Future[int]

     Reads *up to* 'size' bytes from 'socket' into 'buf', which must at
     least be of that size.  Returned future will complete once all the
     data requested is read, a part of the data has been read, or the
     socket has disconnected in which case the future will complete with
     a value of '0'.

     *Warning*: The 'Peek' socket flag is not supported on Windows.

   * send
          proc send*(socket: AsyncFD; data: string; flags = {SocketFlag.SafeDisconn}): Future[void]

     Sends 'data' to 'socket'.  The returned future will complete once
     all data has been sent.

   * acceptAddr tuple[address: string, client: AsyncFD]]
          proc acceptAddr*(socket: AsyncFD; flags = {SocketFlag.SafeDisconn}): Future[
              tuple[address: string, client: AsyncFD]]

     Accepts a new connection.  Returns a future containing the client
     socket corresponding to that connection and the remote address of
     the client.  The future will complete when the connection is
     successfully accepted.

     The resulting client socket is automatically registered to the
     dispatcher.

     The 'accept' call may result in an error if the connecting socket
     disconnects during the duration of the 'accept'.  If the
     'SafeDisconn' flag is specified then this error will not be raised
     and instead accept will be called again.

   * newAsyncNativeSocket
          proc newAsyncNativeSocket*(domain, sockType, protocol: cint): AsyncFD

     Creates a new socket and registers it with the dispatcher
     implicitly.

   * newAsyncNativeSocket sockType: SockType = SOCK_STREAM; protocol:
     Protocol = IPPROTO_TCP): AsyncFD
          proc newAsyncNativeSocket*(domain: Domain = nativesockets.AF_INET;
                                    sockType: SockType = SOCK_STREAM;
                                    protocol: Protocol = IPPROTO_TCP): AsyncFD

     Creates a new socket and registers it with the dispatcher
     implicitly.

   * closeSocket
          proc closeSocket*(socket: AsyncFD)

     Closes a socket and ensures that it is unregistered.

   * unregister
          proc unregister*(fd: AsyncFD)

     Unregisters 'fd'.

   * sleepAsync
          proc sleepAsync*(ms: int): Future[void]

     Suspends the execution of the current async procedure for the next
     'ms' milliseconds.

   * accept
          proc accept*(socket: AsyncFD; flags = {SocketFlag.SafeDisconn}): Future[AsyncFD]

     Accepts a new connection.  Returns a future containing the client
     socket corresponding to that connection.  The future will complete
     when the connection is successfully accepted.

   * recvLine
          proc recvLine*(socket: AsyncFD): Future[string] {.async.}

     Reads a line of data from 'socket'.  Returned future will complete
     once a full line is read or an error occurs.

     If a full line is read '\r\L' is not added to 'line', however if
     solely '\r\L' is read then 'line' will be set to it.

     If the socket is disconnected, 'line' will be set to '""'.

     If the socket is disconnected in the middle of a line (before
     '\r\L' is read) then line will be set to '""'.  The partial line
     *will be lost*.

     *Warning*: This assumes that lines are delimited by '\r\L'.

     *Note*: This procedure is mostly used for testing.  You likely want
     to use 'asyncnet.recvLine' instead.

   * runForever
          proc runForever*()

     Begins a never ending global dispatcher poll loop.

   * waitFor
          proc waitFor*[T](fut: Future[T]): T

     *Blocks* the current thread until the specified future completes.

120 Macros
**********

   * async
          macro async*(prc: stmt): stmt {.immediate.}

     Macro which processes async procedures into the appropriate
     iterators and yield statements.


File: nim-ref-0.13.0.info,  Node: /pure/net,  Next: /pure/dynlib,  Prev: /pure/asyncdispatch,  Up: Top

121 Constant variables
**********************

   * BufferSize
          BufferSize*: int = 4000

     size of a buffered socket's buffer

122 Types
*********

   * SslHandshakeType handshakeAsClient, handshakeAsServer
          SslHandshakeType* = enum
            handshakeAsClient, handshakeAsServer

   * SocketFlag Peek, SafeDisconn ## Ensures disconnection exceptions
     (ECONNRESET, EPIPE etc) are not thrown.
          SocketFlag* {.pure.} = enum
            Peek, SafeDisconn            ## Ensures disconnection exceptions (ECONNRESET, EPIPE etc) are not thrown.

   * IpAddress case family*: IpAddressFamily ## the type of the IP
     address (IPv4 or IPv6) of IpAddressFamily.IPv6: address_v6*:
     array[0 ..  15, uint8] ## Contains the IP address in bytes in ##
     case of IPv6

     of IpAddressFamily.IPv4: address_v4*: array[0 ..  3, uint8] ##
     Contains the IP address in bytes in ## case of IPv4

          IpAddress* = object
            case family*: IpAddressFamily ## the type of the IP address (IPv4 or IPv6)
            of IpAddressFamily.IPv6:
                address_v6*: array[0 .. 15, uint8] ## Contains the IP address in bytes in
                                              ## case of IPv6

            of IpAddressFamily.IPv4:
                address_v4*: array[0 .. 3, uint8] ## Contains the IP address in bytes in
                                             ## case of IPv4



     stores an arbitrary IP address

123 Procedures
**************

   * isIpAddress
          proc isIpAddress*(address_str: string): bool {.tags: [].}

   * parseIpAddress
          proc parseIpAddress*(address_str: string): IpAddress

   * socketError lastError = (- 1).OSErrorCode): void
          proc socketError*(socket: Socket; err: int = - 1; async = false;
                           lastError = (- 1).OSErrorCode): void

   * isDisconnectionError
          proc isDisconnectionError*(flags: set[SocketFlag]; lastError: OSErrorCode): bool

     Determines whether 'lastError' is a disconnection error.  Only does
     this if flags contains 'SafeDisconn'.

   * toOSFlags
          proc toOSFlags*(socketFlags: set[SocketFlag]): cint

     Converts the flags into the underlying OS representation.

   * newSocket sockType: SockType = SOCK_STREAM; protocol: Protocol =
     IPPROTO_TCP; buffered = true): Socket
          proc newSocket*(fd: SocketHandle; domain: Domain = AF_INET;
                         sockType: SockType = SOCK_STREAM; protocol: Protocol = IPPROTO_TCP;
                         buffered = true): Socket

     Creates a new socket as specified by the params.

   * newSocket
          proc newSocket*(domain, sockType, protocol: cint; buffered = true): Socket

     Creates a new socket.

     If an error occurs EOS will be raised.

   * newSocket protocol: Protocol = IPPROTO_TCP; buffered = true):
     Socket
          proc newSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
                         protocol: Protocol = IPPROTO_TCP; buffered = true): Socket

     Creates a new socket.

     If an error occurs EOS will be raised.

   * raiseSSLError
          proc raiseSSLError*(s = "")

     Raises a new SSL error.

   * newContext keyFile = ""): SSLContext
          proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";
                          keyFile = ""): SSLContext

     Creates an SSL context.

     Protocol version specifies the protocol to use.  SSLv2, SSLv3,
     TLSv1 are available with the addition of 'protSSLv23' which allows
     for compatibility with all of them.

     There are currently only two options for verify mode; one is
     'CVerifyNone' and with it certificates will not be verified the
     other is 'CVerifyPeer' and certificates will be verified for it,
     'CVerifyPeer' is the safest choice.

     The last two parameters specify the certificate file path and the
     key file path, a server socket will most likely not work without
     these.  Certificates can be generated using the following command:
     'openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout
     mycert.pem -out mycert.pem'.

   * wrapSocket
          proc wrapSocket*(ctx: SSLContext; socket: Socket)

     Wraps a socket in an SSL context.  This function effectively turns
     'socket' into an SSL socket.

     This must be called on an unconnected socket; an SSL session will
     be started when the socket is connected.

     *Disclaimer*: This code is not well tested, may be very unsafe and
     prone to security vulnerabilities.

   * wrapConnectedSocket handshake: SslHandshakeType)
          proc wrapConnectedSocket*(ctx: SSLContext; socket: Socket;
                                   handshake: SslHandshakeType)

     Wraps a connected socket in an SSL context.  This function
     effectively turns 'socket' into an SSL socket.

     This should be called on a connected socket, and will perform an
     SSL handshake immediately.

     *Disclaimer*: This code is not well tested, may be very unsafe and
     prone to security vulnerabilities.

   * getSocketError
          proc getSocketError*(socket: Socket): OSErrorCode

     Checks 'osLastError' for a valid error.  If it has been reset it
     uses the last error stored in the socket object.

   * socketError lastError = (- 1).OSErrorCode)
          proc socketError*(socket: Socket; err: int = - 1; async = false;
                           lastError = (- 1).OSErrorCode)

     Raises an OSError based on the error code returned by 'SSLGetError'
     (for SSL sockets) and 'osLastError' otherwise.

     If 'async' is 'true' no error will be thrown in the case when the
     error was caused by no data being available to be read.

     If 'err' is not lower than 0 no exception will be raised.

   * listen
          proc listen*(socket: Socket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}

     Marks 'socket' as accepting connections.  'Backlog' specifies the
     maximum length of the queue of pending connections.

     Raises an EOS error upon failure.

   * bindAddr
          proc bindAddr*(socket: Socket; port = Port(0); address = "") {.tags: [ReadIOEffect].}

     Binds 'address':'port' to the socket.

     If 'address' is "" then ADDR_ANY will be bound.

   * acceptAddr flags = {SocketFlag.SafeDisconn}) {.tags:
     [ReadIOEffect], gcsafe, locks: 0.}
          proc acceptAddr*(server: Socket; client: var Socket; address: var string;
                          flags = {SocketFlag.SafeDisconn}) {.tags: [ReadIOEffect], gcsafe,
              locks: 0.}

     Blocks until a connection is being made from a client.  When a
     connection is made sets 'client' to the client socket and 'address'
     to the address of the connecting client.  This function will raise
     EOS if an error occurs.

     The resulting client will inherit any properties of the server
     socket.  For example: whether the socket is buffered or not.

     *Note*: 'client' must be initialised (with 'new'), this function
     makes no effort to initialise the 'client' variable.

     The 'accept' call may result in an error if the connecting socket
     disconnects during the duration of the 'accept'.  If the
     'SafeDisconn' flag is specified then this error will not be raised
     and instead accept will be called again.

   * accept tags: [ReadIOEffect].}
          proc accept*(server: Socket; client: var Socket; flags = {SocketFlag.SafeDisconn}) {.
              tags: [ReadIOEffect].}

     Equivalent to 'acceptAddr' but doesn't return the address, only the
     socket.

     *Note*: 'client' must be initialised (with 'new'), this function
     makes no effort to initialise the 'client' variable.

     The 'accept' call may result in an error if the connecting socket
     disconnects during the duration of the 'accept'.  If the
     'SafeDisconn' flag is specified then this error will not be raised
     and instead accept will be called again.

   * close
          proc close*(socket: Socket)

     Closes a socket.

   * toCInt
          proc toCInt*(opt: SOBool): cint

     Converts a 'SOBool' into its Socket Option cint representation.

   * getSockOpt tags: [ReadIOEffect].}
          proc getSockOpt*(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {.
              tags: [ReadIOEffect].}

     Retrieves option 'opt' as a boolean value.

   * getLocalAddr
          proc getLocalAddr*(socket: Socket): (string, Port)

     Get the socket's local address and port number.

     This is high-level interface for getsockname.

   * getPeerAddr
          proc getPeerAddr*(socket: Socket): (string, Port)

     Get the socket's peer address and port number.

     This is high-level interface for getpeername.

   * setSockOpt tags: [WriteIOEffect].}
          proc setSockOpt*(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {.
              tags: [WriteIOEffect].}

     Sets option 'opt' to a boolean value specified by 'value'.

   * connect
          proc connect*(socket: Socket; address: string; port = Port(0)) {.tags: [ReadIOEffect].}

     Connects socket to 'address':'port'.  'Address' can be an IP
     address or a host name.  If 'address' is a host name, this function
     will try each IP of that host name.  'htons' is already performed
     on 'port' so you must not do it.

     If 'socket' is an SSL socket a handshake will be automatically
     performed.

   * handshake
          proc handshake*(socket: Socket): bool {.tags: [ReadIOEffect, WriteIOEffect].}

     This proc needs to be called on a socket after it connects.  This
     is only applicable when using 'connectAsync'.  This proc performs
     the SSL handshake.

     Returns 'False' whenever the socket is not yet ready for a
     handshake, 'True' whenever handshake completed successfully.

     A ESSL error is raised on any other errors.

   * gotHandshake
          proc gotHandshake*(socket: Socket): bool

     Determines whether a handshake has occurred between a client
     ('socket') and the server that 'socket' is connected to.

     Throws ESSL if 'socket' is not an SSL socket.

   * hasDataBuffered
          proc hasDataBuffered*(s: Socket): bool

     Determines whether a socket has data buffered.

   * recv
          proc recv*(socket: Socket; data: pointer; size: int): int {.tags: [ReadIOEffect].}

     Receives data from a socket.

     *Note*: This is a low-level function, you may be interested in the
     higher level versions of this function which are also named 'recv'.

   * recv tags: [ReadIOEffect, TimeEffect].}
          proc recv*(socket: Socket; data: pointer; size: int; timeout: int): int {.
              tags: [ReadIOEffect, TimeEffect].}

     overload with a 'timeout' parameter in milliseconds.

   * recv flags = {SocketFlag.SafeDisconn}): int
          proc recv*(socket: Socket; data: var string; size: int; timeout = - 1;
                    flags = {SocketFlag.SafeDisconn}): int

     Higher-level version of 'recv'.

     When 0 is returned the socket's connection has been closed.

     This function will throw an EOS exception when an error occurs.  A
     value lower than 0 is never returned.

     A timeout may be specified in milliseconds, if enough data is not
     received within the time specified an ETimeout exception will be
     raised.

     *Note*: 'data' must be initialised.

     *Warning*: Only the 'SafeDisconn' flag is currently supported.

   * readLine flags = {SocketFlag.SafeDisconn}) {.tags: [ReadIOEffect,
     TimeEffect].}
          proc readLine*(socket: Socket; line: var TaintedString; timeout = - 1;
                        flags = {SocketFlag.SafeDisconn}) {.tags: [ReadIOEffect, TimeEffect].}

     Reads a line of data from 'socket'.

     If a full line is read '\r\L' is not added to 'line', however if
     solely '\r\L' is read then 'line' will be set to it.

     If the socket is disconnected, 'line' will be set to '""'.

     An EOS exception will be raised in the case of a socket error.

     A timeout can be specified in milliseconds, if data is not received
     within the specified time an ETimeout exception will be raised.

     *Warning*: Only the 'SafeDisconn' flag is currently supported.

   * recvFrom port: var Port; flags = 0'i32): int {.tags:
     [ReadIOEffect].}
          proc recvFrom*(socket: Socket; data: var string; length: int; address: var string;
                        port: var Port; flags = 0'i32): int {.tags: [ReadIOEffect].}

     Receives data from 'socket'.  This function should normally be used
     with connection-less sockets (UDP sockets).

     If an error occurs an EOS exception will be raised.  Otherwise the
     return value will be the length of data received.

     *Warning:* This function does not yet have a buffered
     implementation, so when 'socket' is buffered the non-buffered
     implementation will be used.  Therefore if 'socket' contains
     something in its buffer this function will make no effort to return
     it.

   * skip
          proc skip*(socket: Socket; size: int; timeout = - 1)

     Skips 'size' amount of bytes.

     An optional timeout can be specified in milliseconds, if skipping
     the bytes takes longer than specified an ETimeout exception will be
     raised.

     Returns the number of skipped bytes.

   * send
          proc send*(socket: Socket; data: pointer; size: int): int {.tags: [WriteIOEffect].}

     Sends data to a socket.

     *Note*: This is a low-level version of 'send'.  You likely should
     use the version below.

   * send tags: [WriteIOEffect].}
          proc send*(socket: Socket; data: string; flags = {SocketFlag.SafeDisconn}) {.
              tags: [WriteIOEffect].}

     sends data to a socket.

   * trySend
          proc trySend*(socket: Socket; data: string): bool {.tags: [WriteIOEffect].}

     Safe alternative to 'send'.  Does not raise an EOS when an error
     occurs, and instead returns 'false' on failure.

   * sendTo af: Domain = AF_INET; flags = 0'i32): int {.tags:
     [WriteIOEffect].}
          proc sendTo*(socket: Socket; address: string; port: Port; data: pointer; size: int;
                      af: Domain = AF_INET; flags = 0'i32): int {.tags: [WriteIOEffect].}

     This proc sends 'data' to the specified 'address', which may be an
     IP address or a hostname, if a hostname is specified this function
     will try each IP of that hostname.

     *Note:* You may wish to use the high-level version of this function
     which is defined below.

     *Note:* This proc is not available for SSL sockets.

   * sendTo tags: [WriteIOEffect].}
          proc sendTo*(socket: Socket; address: string; port: Port; data: string): int {.
              tags: [WriteIOEffect].}

     This proc sends 'data' to the specified 'address', which may be an
     IP address or a hostname, if a hostname is specified this function
     will try each IP of that hostname.

     This is the high-level version of the above 'sendTo' function.

   * connect tags: [ReadIOEffect, WriteIOEffect].}
          proc connect*(socket: Socket; address: string; port = Port(0); timeout: int) {.
              tags: [ReadIOEffect, WriteIOEffect].}

     Connects to server as specified by 'address' on port specified by
     'port'.

     The 'timeout' paremeter specifies the time in milliseconds to allow
     for the connection to the server to be made.

   * isSsl
          proc isSsl*(socket: Socket): bool

     Determines whether 'socket' is a SSL socket.

   * getFd
          proc getFd*(socket: Socket): SocketHandle

     Returns the socket's file descriptor

   * IPv4_any
          proc IPv4_any*(): IpAddress

     Returns the IPv4 any address, which can be used to listen on all
     available network adapters

   * IPv4_loopback
          proc IPv4_loopback*(): IpAddress

     Returns the IPv4 loopback address (127.0.0.1)

   * IPv4_broadcast
          proc IPv4_broadcast*(): IpAddress

     Returns the IPv4 broadcast address (255.255.255.255)

   * IPv6_any
          proc IPv6_any*(): IpAddress

     Returns the IPv6 any address (::0), which can be used to listen on
     all available network adapters

   * IPv6_loopback
          proc IPv6_loopback*(): IpAddress

     Returns the IPv6 loopback address (::1)

   * '=='
          proc `==`*(lhs, rhs: IpAddress): bool

     Compares two IpAddresses for Equality.  Returns two if the
     addresses are equal

   * '$'
          proc `$`*(address: IpAddress): string

     Converts an IpAddress into the textual representation


File: nim-ref-0.13.0.info,  Node: /pure/dynlib,  Next: /pure/romans,  Prev: /pure/net,  Up: Top

124 Types
*********

   * LibHandle
          LibHandle* = pointer

     a handle to a dynamically loaded library

125 Procedures
**************

   * loadLib
          proc loadLib*(path: string; global_symbols = false): LibHandle

     loads a library from path.  Returns nil if the library could not be
     loaded.

   * loadLib
          proc loadLib*(): LibHandle

     gets the handle from the current executable.  Returns nil if the
     library could not be loaded.

   * unloadLib
          proc unloadLib*(lib: LibHandle)

     unloads the library lib

   * raiseInvalidLibrary
          proc raiseInvalidLibrary*(name: cstring) {.noinline, noreturn.}

     raises an EInvalidLibrary exception.

   * symAddr
          proc symAddr*(lib: LibHandle; name: cstring): pointer

     retrieves the address of a procedure/variable from lib.  Returns
     nil if the symbol could not be found.

   * checkedSymAddr
          proc checkedSymAddr*(lib: LibHandle; name: cstring): pointer

     retrieves the address of a procedure/variable from lib.  Raises
     EInvalidLibrary if the symbol could not be found.


File: nim-ref-0.13.0.info,  Node: /pure/romans,  Next: /pure/options,  Prev: /pure/dynlib,  Up: Top

126 Constant variables
**********************

   * RomanNumeralDigits
          RomanNumeralDigits* = {'I', 'i', 'V', 'v', 'X', 'x', 'L', 'l', 'C', 'c', 'D', 'd', 'M', 'm'}

     set of all characters a Roman numeral may consist of

127 Procedures
**************

   * romanToDecimal
          proc romanToDecimal*(romanVal: string): int

     Converts a Roman numeral to its int representation.

   * decimalToRoman
          proc decimalToRoman*(number: range[1 .. 3999]): string

     Converts a number to a Roman numeral.


File: nim-ref-0.13.0.info,  Node: /pure/options,  Next: /pure/encodings,  Prev: /pure/romans,  Up: Top

128 Types
*********

   * UnpackError
          UnpackError* = ref object of ValueError

129 Procedures
**************

   * some
          proc some*[T](val: T): Option[T]

     Returns a 'Option' that has this value.

   * none
          proc none*(T: typedesc): Option[T]

     Returns a 'Option' for this type that has no value.

   * isSome
          proc isSome*[T](self: Option[T]): bool

   * isNone
          proc isNone*[T](self: Option[T]): bool

   * unsafeGet
          proc unsafeGet*[T](self: Option[T]): T

     Returns the value of a 'some'.  Behavior is undefined for 'none'.

   * get
          proc get*[T](self: Option[T]): T

     Returns contents of the Option.  If it is none, then an exception
     is thrown.

   * get
          proc get*[T](self: Option[T]; otherwise: T): T

     Returns the contents of this option or otherwise if the option is
     none.

   * map
          proc map*[T](self: Option[T]; callback: proc (input: T))

     Applies a callback to the value in this Option

   * map
          proc map*[T, R](self: Option[T]; callback: proc (input: T): R): Option[R]

     Applies a callback to the value in this Option and returns an
     option containing the new value.  If this option is None, None will
     be returned

   * filter
          proc filter*[T](self: Option[T]; callback: proc (input: T): bool): Option[T]

     Applies a callback to the value in this Option.  If the callback
     returns true, the option is returned as a Some.  If it returns
     false, it is returned as a None.

   * '=='
          proc `==`*(a, b: Option): bool

     Returns 'true' if both 'Option``s are ``none', or if they have
     equal values

   * '$'
          proc `$`*[T](self: Option[T]): string

     Returns the contents of this option or otherwise if the option is
     none.


File: nim-ref-0.13.0.info,  Node: /pure/encodings,  Next: /pure/etcpriv,  Prev: /pure/options,  Up: Top

130 Types
*********

   * EncodingConverter
          EncodingConverter* = ptr ConverterObj

     can convert between two character sets

   * EncodingError
          EncodingError* = object of ValueError

     exception that is raised for encoding errors

131 Procedures
**************

   * getCurrentEncoding
          proc getCurrentEncoding*(): string

     retrieves the current encoding.  On Unix, always "UTF-8" is
     returned.

   * open
          proc open*(destEncoding = "UTF-8"; srcEncoding = "CP1252"): EncodingConverter

     opens a converter that can convert from srcEncoding to
     destEncoding.  Raises EIO if it cannot fulfill the request.

   * close
          proc close*(c: EncodingConverter)

     frees the resources the converter c holds.

   * convert
          proc convert*(c: EncodingConverter; s: string): string

     converts s to destEncoding that was given to the converter c.  It
     assumed that s is in srcEncoding.

   * convert
          proc convert*(s: string; destEncoding = "UTF-8"; srcEncoding = "CP1252"): string

     converts s to destEncoding.  It assumed that s is in srcEncoding.
     This opens a converter, uses it and closes it again and is thus
     more convienent but also likely less efficient than re-using a
     converter.


File: nim-ref-0.13.0.info,  Node: /pure/etcpriv,  Next: /pure/parsecsv,  Prev: /pure/encodings,  Up: Top

132 Constant variables
**********************

   * magicIdentSeparatorRuneByteWidth
          magicIdentSeparatorRuneByteWidth* = 3

133 Procedures
**************

   * isMagicIdentSeparatorRune
          proc isMagicIdentSeparatorRune*(cs: cstring; i: int): bool {.inline.}


File: nim-ref-0.13.0.info,  Node: /pure/parsecsv,  Next: /pure/coro,  Prev: /pure/etcpriv,  Up: Top

134 Types
*********

   * CsvError
          CsvError* = object of IOError

     exception that is raised if a parsing error occurs

135 Procedures
**************

   * open quote = '\"'; escape = '\0'; skipInitialSpace = false)
          proc open*(my: var CsvParser; input: Stream; filename: string; separator = ',';
                    quote = '\"'; escape = '\0'; skipInitialSpace = false)

     initializes the parser with an input stream.  Filename is only used
     for nice error messages.  The parser's behaviour can be controlled
     by the diverse optional parameters:

        * separator: character used to separate fields
        * quote: Used to quote fields containing special characters like
          separator, quote or new-line characters.  '0' disables the
          parsing of quotes.
        * escape: removes any special meaning from the following
          character; '0' disables escaping; if escaping is disabled and
          quote is not '0', two quote characters are parsed one literal
          quote character.
        * skipInitialSpace: If true, whitespace immediately following
          the separator is ignored.

   * processedRows
          proc processedRows*(my: var CsvParser): int

     returns number of the processed rows

   * readRow
          proc readRow*(my: var CsvParser; columns = 0): bool

     reads the next row; if columns > 0, it expects the row to have
     exactly this many columns.  Returns false if the end of the file
     has been encountered else true.

   * close
          proc close*(my: var CsvParser) {.inline.}

     closes the parser my and its associated input stream.


File: nim-ref-0.13.0.info,  Node: /pure/coro,  Next: /pure/numeric,  Prev: /pure/parsecsv,  Up: Top

136 Procedures
**************

   * start
          proc start*(c: proc (); stacksize: int = defaultStackSize)

     Adds coroutine to event loop.  It does not run immediately.

   * suspend
          proc suspend*(sleepTime: float = 0)

     Stops coroutine execution and resumes no sooner than after
     'sleeptime' seconds.  Until then other coroutines are executed.

     This is similar to a yield, or a yieldFrom:idx in Python.

   * run
          proc run*()

     Starts main event loop which exits when all coroutines exit.
     Calling this proc starts execution of first coroutine.

   * alive
          proc alive*(c: proc ()): bool

     Returns 'true' if coroutine has not returned, 'false' otherwise.

   * wait
          proc wait*(c: proc (); interval = 0.01'f64)

     Returns only after coroutine 'c' has returned.  'interval' is time
     in seconds how often.


File: nim-ref-0.13.0.info,  Node: /pure/numeric,  Next: /pure/parsecfg,  Prev: /pure/coro,  Up: Top

137 Types
*********

   * OneVarFunction
          OneVarFunction* = proc (x: float): float

138 Procedures
**************

   * brent rootx, rooty: float, success: bool]
          proc brent*(xmin, xmax: float; function: OneVarFunction; tol: float; maxiter = 1000): tuple[
              rootx, rooty: float, success: bool]

     Searches function for a root between xmin and xmax using brents
     method.  If the function value at xmin'and 'xmax has the same sign,
     rootx/rooty is set too the extrema value closest to x-axis and
     succes is set to false.  Otherwise there exists at least one root
     and success is set to true.  This root is searched for at most
     maxiter iterations.  If tol tolerance is reached within maxiter
     iterations the root refinement stops and success=true.


File: nim-ref-0.13.0.info,  Node: /pure/parsecfg,  Next: /pure/times,  Prev: /pure/numeric,  Up: Top

139 Types
*********

   * CfgParser tok: Token filename: string

          CfgParser* = object of BaseLexer
            tok: Token
            filename: string


     the parser object.

140 Procedures
**************

   * open extern: "npc$1".}
          proc open*(c: var CfgParser; input: Stream; filename: string; lineOffset = 0) {.rtl,
              extern: "npc$1".}

     initializes the parser with an input stream.  Filename is only used
     for nice error messages.  lineOffset can be used to influence the
     line number information in the generated error messages.

   * close
          proc close*(c: var CfgParser) {.rtl, extern: "npc$1".}

     closes the parser c and its associated input stream.

   * getColumn
          proc getColumn*(c: CfgParser): int {.rtl, extern: "npc$1".}

     get the current column the parser has arrived at.

   * getLine
          proc getLine*(c: CfgParser): int {.rtl, extern: "npc$1".}

     get the current line the parser has arrived at.

   * getFilename
          proc getFilename*(c: CfgParser): string {.rtl, extern: "npc$1".}

     get the filename of the file that the parser processes.

   * errorStr
          proc errorStr*(c: CfgParser; msg: string): string {.rtl, extern: "npc$1".}

     returns a properly formated error message containing current line
     and column information.

   * warningStr
          proc warningStr*(c: CfgParser; msg: string): string {.rtl, extern: "npc$1".}

     returns a properly formated warning message containing current line
     and column information.

   * ignoreMsg
          proc ignoreMsg*(c: CfgParser; e: CfgEvent): string {.rtl, extern: "npc$1".}

     returns a properly formated warning message containing that an
     entry is ignored.

   * next
          proc next*(c: var CfgParser): CfgEvent {.rtl, extern: "npc$1".}

     retrieves the first/next event.  This controls the parser.


File: nim-ref-0.13.0.info,  Node: /pure/times,  Next: /pure/events,  Prev: /pure/parsecfg,  Up: Top

141 Types
*********

   * WeekDay dMon, dTue, dWed, dThu, dFri, dSat, dSun
          WeekDay* = enum
            dMon, dTue, dWed, dThu, dFri, dSat, dSun

     represents a weekday

   * TimeInterval milliseconds*: int ## The number of milliseconds
     seconds*: int ## The number of seconds minutes*: int ## The number
     of minutes hours*: int ## The number of hours days*: int ## The
     number of days months*: int ## The number of months years*: int ##
     The number of years

          TimeInterval* = object
            milliseconds*: int           ## The number of milliseconds
            seconds*: int                ## The number of seconds
            minutes*: int                ## The number of minutes
            hours*: int                  ## The number of hours
            days*: int                   ## The number of days
            months*: int                 ## The number of months
            years*: int                  ## The number of years


     a time interval

142 Procedures
**************

   * getTime
          proc getTime*(): Time {.tags: [TimeEffect], benign.}

     gets the current calendar time as a UNIX epoch value (number of
     seconds elapsed since 1970) with integer precission.  Use epochTime
     for higher resolution.

   * getLocalTime
          proc getLocalTime*(t: Time): TimeInfo {.tags: [TimeEffect], raises: [], benign.}

     converts the calendar time t to broken-time representation,
     expressed relative to the user's specified time zone.

   * getGMTime
          proc getGMTime*(t: Time): TimeInfo {.tags: [TimeEffect], raises: [], benign.}

     converts the calendar time t to broken-down time representation,
     expressed in Coordinated Universal Time (UTC).

   * timeInfoToTime
          proc timeInfoToTime*(timeInfo: TimeInfo): Time {.tags: [], benign.}

     converts a broken-down time structure to calendar time
     representation.  The function ignores the specified contents of the
     structure members weekday and yearday and recomputes them from the
     other information in the broken-down time structure.

   * fromSeconds
          proc fromSeconds*(since1970: float): Time {.tags: [], raises: [], benign.}

     Takes a float which contains the number of seconds since the unix
     epoch and returns a time object.

   * fromSeconds
          proc fromSeconds*(since1970: int64): Time {.tags: [], raises: [], benign.}

     Takes an int which contains the number of seconds since the unix
     epoch and returns a time object.

   * toSeconds
          proc toSeconds*(time: Time): float {.tags: [], raises: [], benign.}

     Returns the time in seconds since the unix epoch.

   * '$'
          proc `$`*(timeInfo: TimeInfo): string {.tags: [], raises: [], benign.}

     converts a TimeInfo object to a string representation.

   * '$'
          proc `$`*(time: Time): string {.tags: [], raises: [], benign.}

     converts a calendar time to a string representation.

   * '-'
          proc `-`*(a, b: Time): int64 {.rtl, extern: "ntDiffTime", tags: [], raises: [], benign.}

     computes the difference of two calendar times.  Result is in
     seconds.

   * '&lt;'
          proc `<`*(a, b: Time): bool {.rtl, extern: "ntLtTime", tags: [], raises: [].}

     returns true iff 'a < b', that is iff a happened before b.

   * '&lt;='
          proc `<=`*(a, b: Time): bool {.rtl, extern: "ntLeTime", tags: [], raises: [].}

     returns true iff 'a <= b'.

   * '=='
          proc `==`*(a, b: Time): bool {.rtl, extern: "ntEqTime", tags: [], raises: [].}

     returns true if 'a == b', that is if both times represent the same
     value

   * getTzname
          proc getTzname*(): tuple[nonDST, DST: string] {.tags: [TimeEffect], raises: [], benign.}

     returns the local timezone; 'nonDST' is the name of the local
     non-DST timezone, 'DST' is the name of the local DST timezone.

   * getTimezone
          proc getTimezone*(): int {.tags: [TimeEffect], raises: [], benign.}

     returns the offset of the local (non-DST) timezone in seconds west
     of UTC.

   * getStartMilsecs
          proc getStartMilsecs*(): int {.deprecated, tags: [TimeEffect], benign.}

     get the milliseconds from the start of the program.  *Deprecated
     since version 0.8.10.*  Use 'epochTime' or 'cpuTime' instead.

   * initInterval
          proc initInterval*(milliseconds, seconds, minutes, hours, days, months, years: int = 0): TimeInterval

     creates a new 'TimeInterval'.

     You can also use the convenience procedures called 'milliseconds',
     'seconds', 'minutes', 'hours', 'days', 'months', and 'years'.

     Example:
     let day = initInterval(hours=24)
     let tomorrow = getTime() + day
     echo(tomorrow)

   * '+'
          proc `+`*(ti1, ti2: TimeInterval): TimeInterval

     Adds two 'TimeInterval' objects together.

   * '-'
          proc `-`*(ti1, ti2: TimeInterval): TimeInterval

     Subtracts TimeInterval 'ti1' from 'ti2'.

   * isLeapYear
          proc isLeapYear*(year: int): bool

     returns true if 'year' is a leap year

   * getDaysInMonth
          proc getDaysInMonth*(month: Month; year: int): int

     Get the number of days in a 'month' of a 'year'

   * getDaysInYear
          proc getDaysInYear*(year: int): int

     Get the number of days in a 'year'

   * '+'
          proc `+`*(a: TimeInfo; interval: TimeInterval): TimeInfo

     adds 'interval' time from TimeInfo 'a'.

     *Note:* This has been only briefly tested and it may not be very
     accurate.

   * '-'
          proc `-`*(a: TimeInfo; interval: TimeInterval): TimeInfo

     subtracts 'interval' time from TimeInfo 'a'.

     *Note:* This has been only briefly tested, it is inaccurate
     especially when you subtract so much that you reach the Julian
     calendar.

   * miliseconds
          proc miliseconds*(t: TimeInterval): int {.deprecated.}

   * 'miliseconds='
          proc `miliseconds =`*(t: var TimeInterval; milliseconds: int) {.deprecated.}

     An alias for a misspelled field in 'TimeInterval'.

     *Warning:* This should not be used!  It will be removed in the next
     version.

   * epochTime
          proc epochTime*(): float {.rtl, extern: "nt$1", tags: [TimeEffect].}

     gets time after the UNIX epoch (1970) in seconds.  It is a float
     because sub-second resolution is likely to be supported (depending
     on the hardware/OS).

   * cpuTime
          proc cpuTime*(): float {.rtl, extern: "nt$1", tags: [TimeEffect].}

     gets time spent that the CPU spent to run the current process in
     seconds.  This may be more useful for benchmarking than
     'epochTime'.  However, it may measure the real time instead
     (depending on the OS). The value of the result has no meaning.  To
     generate useful timing values, take the difference between the
     results of two 'cpuTime' calls:
     var t0 = cpuTime()
     doWork()
     echo "CPU time [s] ", cpuTime() - t0

   * unixTimeToWinTime
          proc unixTimeToWinTime*(t: Time): int64

     converts a UNIX Time ('time_t') to a Windows file time

   * winTimeToUnixTime
          proc winTimeToUnixTime*(t: int64): Time

     converts a Windows time to a UNIX Time ('time_t')

   * getDateStr
          proc getDateStr*(): string {.rtl, extern: "nt$1", tags: [TimeEffect].}

     gets the current date as a string of the format 'YYYY-MM-DD'.

   * getClockStr
          proc getClockStr*(): string {.rtl, extern: "nt$1", tags: [TimeEffect].}

     gets the current clock time as a string of the format 'HH:MM:SS'.

   * '$'
          proc `$`*(day: WeekDay): string

     stingify operator for 'WeekDay'.

   * '$'
          proc `$`*(m: Month): string

     stingify operator for 'Month'.

   * milliseconds
          proc milliseconds*(ms: int): TimeInterval {.inline.}

     TimeInterval of ms milliseconds

     Note: not all time functions have millisecond resolution

   * seconds
          proc seconds*(s: int): TimeInterval {.inline.}

     TimeInterval of s seconds

     'echo getTime() + 5.second'

   * minutes
          proc minutes*(m: int): TimeInterval {.inline.}

     TimeInterval of m minutes

     'echo getTime() + 5.minutes'

   * hours
          proc hours*(h: int): TimeInterval {.inline.}

     TimeInterval of h hours

     'echo getTime() + 2.hours'

   * days
          proc days*(d: int): TimeInterval {.inline.}

     TimeInterval of d days

     'echo getTime() + 2.days'

   * months
          proc months*(m: int): TimeInterval {.inline.}

     TimeInterval of m months

     'echo getTime() + 2.months'

   * years
          proc years*(y: int): TimeInterval {.inline.}

     TimeInterval of y years

     'echo getTime() + 2.years'

   * '+='
          proc `+=`*(t: var Time; ti: TimeInterval)

     modifies t by adding the interval ti

   * '+'
          proc `+`*(t: Time; ti: TimeInterval): Time

     adds the interval ti to Time t by converting to localTime, adding
     the interval, and converting back

     'echo getTime() + 1.day'

   * '-='
          proc `-=`*(t: var Time; ti: TimeInterval)

     modifies t by subtracting the interval ti

   * '-'
          proc `-`*(t: Time; ti: TimeInterval): Time

     adds the interval ti to Time t

     'echo getTime() - 1.day'

   * format
          proc format*(info: TimeInfo; f: string): string

     This function formats info as specified by f.  The following format
     specifiers are available:

     Specifier   Description                                                             Example
     ---------------------------------------------------------------------------------------------------------------------------------
     d           Numeric value of the day of the month, it will be one or two digits     '1/04/2012 -> 1', '21/04/2012 -> 21'
                 long.
     dd          Same as above, but always two digits.                                   '1/04/2012 -> 01', '21/04/2012 -> 21'
     ddd         Three letter string which indicates the day of the week.                'Saturday -> Sat', 'Monday -> Mon'
     dddd        Full string for the day of the week.                                    'Saturday -> Saturday', 'Monday -> Monday'
     h           The hours in one digit if possible.  Ranging from 0-12.                 '5pm -> 5', '2am -> 2'
     hh          The hours in two digits always.  If the hour is one digit 0 is          '5pm -> 05', '11am -> 11'
                 prepended.
     H           The hours in one digit if possible, randing from 0-24.                  '5pm -> 17', '2am -> 2'
     HH          The hours in two digits always.  0 is prepended if the hour is one      '5pm -> 17', '2am -> 02'
                 digit.
     m           The minutes in 1 digit if possible.                                     '5:30 -> 30', '2:01 -> 1'
     mm          Same as above but always 2 digits, 0 is prepended if the minute is      '5:30 -> 30', '2:01 -> 01'
                 one digit.
     M           The month in one digit if possible.                                     'September -> 9', 'December -> 12'
     MM          The month in two digits always.  0 is prepended.                        'September -> 09', 'December -> 12'
     MMM         Abbreviated three-letter form of the month.                             'September -> Sep', 'December -> Dec'
     MMMM        Full month string, properly capitalized.                                'September -> September'
     s           Seconds as one digit if possible.                                       '00:00:06 -> 6'
     ss          Same as above but always two digits.  0 is prepended.                   '00:00:06 -> 06'
     t           'A' when time is in the AM. 'P' when time is in the PM.
     tt          Same as above, but 'AM' and 'PM' instead of 'A' and 'P' respectively.
     y(yyyy)     This displays the year to different digits.  You most likely only
                 want 2 or 4 'y's
     yy          Displays the year to two digits.                                        '2012 -> 12'
     yyyy        Displays the year to four digits.                                       '2012 -> 2012'
     z           Displays the timezone offset from UTC.                                  'GMT+7 -> +7', 'GMT-5 -> -5'
     zz          Same as above but with leading 0.                                       'GMT+7 -> +07', 'GMT-5 -> -05'
     zzz         Same as above but with ':00'.                                           'GMT+7 -> +07:00', 'GMT-5 -> -05:00'
     ZZZ         Displays the name of the timezone.                                      'GMT -> GMT', 'EST -> EST'

     Other strings can be inserted by putting them in ''''.  For example
     'hh'->'mm' will give '01->56'.  The following characters can be
     inserted without quoting them: ':' '-' '(' ')' '/' '[' ']' ','.
     However you don't need to necessarily separate format specifiers, a
     unambiguous format string like 'yyyyMMddhhmmss' is valid too.

   * parse
          proc parse*(value, layout: string): TimeInfo

     This function parses a date/time string using the standard format
     identifiers (below) The function defaults information not provided
     in the format string from the running program (timezone, month,
     year, etc)

     Specifier   Description                                                             Example
     ---------------------------------------------------------------------------------------------------------------------------------
     d           Numeric value of the day of the month, it will be one or two digits     '1/04/2012 -> 1', '21/04/2012 -> 21'
                 long.
     dd          Same as above, but always two digits.                                   '1/04/2012 -> 01', '21/04/2012 -> 21'
     ddd         Three letter string which indicates the day of the week.                'Saturday -> Sat', 'Monday -> Mon'
     dddd        Full string for the day of the week.                                    'Saturday -> Saturday', 'Monday -> Monday'
     h           The hours in one digit if possible.  Ranging from 0-12.                 '5pm -> 5', '2am -> 2'
     hh          The hours in two digits always.  If the hour is one digit 0 is          '5pm -> 05', '11am -> 11'
                 prepended.
     H           The hours in one digit if possible, randing from 0-24.                  '5pm -> 17', '2am -> 2'
     HH          The hours in two digits always.  0 is prepended if the hour is one      '5pm -> 17', '2am -> 02'
                 digit.
     m           The minutes in 1 digit if possible.                                     '5:30 -> 30', '2:01 -> 1'
     mm          Same as above but always 2 digits, 0 is prepended if the minute is      '5:30 -> 30', '2:01 -> 01'
                 one digit.
     M           The month in one digit if possible.                                     'September -> 9', 'December -> 12'
     MM          The month in two digits always.  0 is prepended.                        'September -> 09', 'December -> 12'
     MMM         Abbreviated three-letter form of the month.                             'September -> Sep', 'December -> Dec'
     MMMM        Full month string, properly capitalized.                                'September -> September'
     s           Seconds as one digit if possible.                                       '00:00:06 -> 6'
     ss          Same as above but always two digits.  0 is prepended.                   '00:00:06 -> 06'
     t           'A' when time is in the AM. 'P' when time is in the PM.
     tt          Same as above, but 'AM' and 'PM' instead of 'A' and 'P' respectively.
     yy          Displays the year to two digits.                                        '2012 -> 12'
     yyyy        Displays the year to four digits.                                       '2012 -> 2012'
     z           Displays the timezone offset from UTC.                                  'GMT+7 -> +7', 'GMT-5 -> -5'
     zz          Same as above but with leading 0.                                       'GMT+7 -> +07', 'GMT-5 -> -05'
     zzz         Same as above but with ':00'.                                           'GMT+7 -> +07:00', 'GMT-5 -> -05:00'
     ZZZ         Displays the name of the timezone.                                      'GMT -> GMT', 'EST -> EST'

     Other strings can be inserted by putting them in ''''.  For example
     'hh'->'mm' will give '01->56'.  The following characters can be
     inserted without quoting them: ':' '-' '(' ')' '/' '[' ']' ','.
     However you don't need to necessarily separate format specifiers, a
     unambiguous format string like 'yyyyMMddhhmmss' is valid too.

   * countLeapYears
          proc countLeapYears*(yearSpan: int): int

     Returns the number of leap years spanned by a given number of
     years.

     Note: for leap years, start date is assumed to be 1 AD. counts the
     number of leap years up to January 1st of a given year.  Keep in
     mind that if specified year is a leap year, the leap day has not
     happened before January 1st of that year.

   * countDays
          proc countDays*(yearSpan: int): int

     Returns the number of days spanned by a given number of years.

   * countYears
          proc countYears*(daySpan: int): int

     Returns the number of years spanned by a given number of days.

   * countYearsAndDays
          proc countYearsAndDays*(daySpan: int): tuple[years: int, days: int]

     Returns the number of years spanned by a given number of days and
     the remainder as days.

   * getDayOfWeek
          proc getDayOfWeek*(day, month, year: int): WeekDay

     Returns the day of the week enum from day, month and year.

   * getDayOfWeekJulian
          proc getDayOfWeekJulian*(day, month, year: int): WeekDay

     Returns the day of the week enum from day, month and year,
     according to the Julian calender.

   * timeToTimeInfo
          proc timeToTimeInfo*(t: Time): TimeInfo

     Converts a Time to TimeInfo.

   * timeToTimeInterval
          proc timeToTimeInterval*(t: Time): TimeInterval

     Converts a Time to a TimeInterval.


File: nim-ref-0.13.0.info,  Node: /pure/events,  Next: /pure/basic2d,  Prev: /pure/times,  Up: Top

143 Types
*********

   * EventHandler
          EventHandler* = tuple[name: string, handlers: seq[proc (e: EventArgs) {.closure.}]]

     An eventhandler for an event.

   * EventError
          EventError* = object of ValueError

144 Procedures
**************

   * initEventHandler
          proc initEventHandler*(name: string): EventHandler

     Initializes an EventHandler with the specified name and returns it.

   * addHandler
          proc addHandler*(handler: var EventHandler; fn: proc (e: EventArgs) {.closure.})

     Adds the callback to the specified event handler.

   * removeHandler
          proc removeHandler*(handler: var EventHandler; fn: proc (e: EventArgs) {.closure.})

     Removes the callback from the specified event handler.

   * containsHandler
          proc containsHandler*(handler: var EventHandler; fn: proc (e: EventArgs) {.closure.}): bool

     Checks if a callback is registered to this event handler.

   * clearHandlers
          proc clearHandlers*(handler: var EventHandler)

     Clears all of the callbacks from the event handler.

   * on
          proc on*(emitter: var EventEmitter; event: string; fn: proc (e: EventArgs) {.closure.})

     Assigns a event handler with the specified callback.  If the event
     doesn't exist, it will be created.

   * emit
          proc emit*(emitter: var EventEmitter; eventhandler: var EventHandler; args: EventArgs)

     Fires an event handler with specified event arguments.

   * emit
          proc emit*(emitter: var EventEmitter; event: string; args: EventArgs)

     Fires an event handler with specified event arguments.

   * initEventEmitter
          proc initEventEmitter*(): EventEmitter

     Creates and returns a new EventEmitter.


File: nim-ref-0.13.0.info,  Node: /pure/basic2d,  Next: /pure/strtabs,  Prev: /pure/events,  Up: Top

145 Let variable
****************

   * YAXIS
          YAXIS*: Vector2d = vector2d(0.0'f64, 1.0'f64)

     Quick access to an 2d y-axis unit vector

146 Types
*********

   * Vector2d x*, y*: float

          Vector2d* = object
            x*, y*: float


     Implements a 2d *direction vector* stored as an x coordinate and an
     y coordinate.  Direction vector means, that when transforming a
     vector with a matrix, the translational part of the matrix is
     ignored.

147 Procedures
**************

   * matrix2d
          proc matrix2d*(ax, ay, bx, by, tx, ty: float): Matrix2d {.noInit.}

     Creates a new matrix.  ax,'ay' is the local x axis bx,'by' is the
     local y axis tx,'ty' is the translation

   * vector2d
          proc vector2d*(x, y: float): Vector2d {.noInit, inline.}

     Returns a new vector (x,'y')

   * point2d
          proc point2d*(x, y: float): Point2d {.noInit, inline.}

     Returns a new point (x,'y')

   * setElements
          proc setElements*(t: var Matrix2d; ax, ay, bx, by, tx, ty: float) {.inline.}

     Sets arbitrary elements in an existing matrix.

   * matrix2d
          proc matrix2d*(ax, ay, bx, by, tx, ty: float): Matrix2d

   * '&amp;'
          proc `&`*(a, b: Matrix2d): Matrix2d {.noInit.}

     Concatenates matrices returning a new matrix.

   * scale
          proc scale*(s: float): Matrix2d {.noInit.}

     Returns a new scale matrix.

   * scale
          proc scale*(s: float; org: Point2d): Matrix2d {.noInit.}

     Returns a new scale matrix using, org as scale origin.

   * stretch
          proc stretch*(sx, sy: float): Matrix2d {.noInit.}

     Returns new a stretch matrix, which is a scale matrix with non
     uniform scale in x and y.

   * stretch
          proc stretch*(sx, sy: float; org: Point2d): Matrix2d {.noInit.}

     Returns a new stretch matrix, which is a scale matrix with non
     uniform scale in x and y.  org is used as stretch origin.

   * move
          proc move*(dx, dy: float): Matrix2d {.noInit.}

     Returns a new translation matrix.

   * move
          proc move*(v: Vector2d): Matrix2d {.noInit.}

     Returns a new translation matrix from a vector.

   * rotate
          proc rotate*(rad: float): Matrix2d {.noInit.}

     Returns a new rotation matrix, which represents a rotation by rad
     radians

   * rotate
          proc rotate*(rad: float; org: Point2d): Matrix2d {.noInit.}

     Returns a new rotation matrix, which represents a rotation by rad
     radians around the origin org

   * mirror
          proc mirror*(v: Vector2d): Matrix2d {.noInit.}

     Returns a new mirror matrix, mirroring around the line that passes
     through origo and has the direction of v

   * mirror
          proc mirror*(org: Point2d; v: Vector2d): Matrix2d {.noInit.}

     Returns a new mirror matrix, mirroring around the line that passes
     through org and has the direction of v

   * skew
          proc skew*(xskew, yskew: float): Matrix2d {.noInit.}

     Returns a new skew matrix, which has its x axis rotated xskew
     radians from the local x axis, and y axis rotated yskew radians
     from the local y axis

   * '$'
          proc `$`*(t: Matrix2d): string {.noInit.}

     Returns a string representation of the matrix

   * isUniform
          proc isUniform*(t: Matrix2d; tol = 1e-06'f64): bool

     Checks if the transform is uniform, that is perpendicular axes of
     equal length, which means (for example) it cannot transform a
     circle into an ellipse.  tol is used as tolerance for both equal
     length comparison and perp.  comparison.

   * determinant
          proc determinant*(t: Matrix2d): float

     Computes the determinant of the matrix.

   * isMirroring
          proc isMirroring*(m: Matrix2d): bool

     Checks if the m is a mirroring matrix, which means it will reverse
     direction of a curve transformed with it

   * inverse
          proc inverse*(m: Matrix2d): Matrix2d {.noInit.}

     Returns a new matrix, which is the inverse of the matrix If the
     matrix is not invertible (determinant=0), an EDivByZero will be
     raised.

   * equals
          proc equals*(m1: Matrix2d; m2: Matrix2d; tol = 1e-06'f64): bool

     Checks if all elements of m1'and 'm2 is equal within a given
     tolerance tol.

   * '=~'
          proc `=~`*(m1, m2: Matrix2d): bool

     Checks if m1'and 'm2 is approximately equal, using a tolerance of
     1e-6.

   * isIdentity
          proc isIdentity*(m: Matrix2d; tol = 1e-06'f64): bool

     Checks is a matrix is approximately an identity matrix, using tol
     as tolerance for each element.

   * apply
          proc apply*(m: Matrix2d; x, y: var float; translate = false)

     Applies transformation m onto x,'y', optionally using the
     translation part of the matrix.

   * vector2d
          proc vector2d*(x, y: float): Vector2d

   * polarVector2d
          proc polarVector2d*(ang: float; len: float): Vector2d {.noInit.}

     Returns a new vector with angle ang and magnitude len

   * slopeVector2d
          proc slopeVector2d*(slope: float; len: float): Vector2d {.noInit.}

     Returns a new vector having slope (dy/dx) given by slope, and a
     magnitude of len

   * len
          proc len*(v: Vector2d): float {.inline.}

     Returns the length of the vector.

   * 'len='
          proc `len =`*(v: var Vector2d; newlen: float) {.noInit.}

     Sets the length of the vector, keeping its angle.

   * sqrLen
          proc sqrLen*(v: Vector2d): float {.inline.}

     Computes the squared length of the vector, which is faster than
     computing the absolute length.

   * angle
          proc angle*(v: Vector2d): float

     Returns the angle of the vector.  (The counter clockwise plane
     angle between posetive x axis and v)

   * '$'
          proc `$`*(v: Vector2d): string

     String representation of v

   * '&amp;'
          proc `&`*(v: Vector2d; m: Matrix2d): Vector2d {.noInit.}

     Concatenate vector v with a transformation matrix.  Transforming a
     vector ignores the translational part of the matrix.

   * '&amp;='
          proc `&=`*(v: var Vector2d; m: Matrix2d) {.inline.}

     Applies transformation m onto v in place.  Transforming a vector
     ignores the translational part of the matrix.

   * tryNormalize
          proc tryNormalize*(v: var Vector2d): bool

     Modifies v to have a length of 1.0, keeping its angle.  If v has
     zero length (and thus no angle), it is left unmodified and false is
     returned, otherwise true is returned.

   * normalize
          proc normalize*(v: var Vector2d) {.inline.}

     Modifies v to have a length of 1.0, keeping its angle.  If v has
     zero length, an EDivByZero will be raised.

   * transformNorm
          proc transformNorm*(v: var Vector2d; t: Matrix2d)

     Applies a normal direction transformation t onto v in place.  The
     resulting vector is _not_ normalized.  Transforming a vector
     ignores the translational part of the matrix.  If the matrix is not
     invertible (determinant=0), an EDivByZero will be raised.

   * transformInv
          proc transformInv*(v: var Vector2d; t: Matrix2d)

     Applies inverse of a transformation t to v in place.  This is
     faster than creating an inverse matrix and apply() it.
     Transforming a vector ignores the translational part of the matrix.
     If the matrix is not invertible (determinant=0), an EDivByZero will
     be raised.

   * transformNormInv
          proc transformNormInv*(v: var Vector2d; t: Matrix2d)

     Applies an inverse normal direction transformation t onto v in
     place.  This is faster than creating an inverse matrix and
     transformNorm(...)  it.  Transforming a vector ignores the
     translational part of the matrix.

   * rotate90
          proc rotate90*(v: var Vector2d) {.inline.}

     Quickly rotates vector v 90 degrees counter clockwise, without
     using any trigonometrics.

   * rotate180
          proc rotate180*(v: var Vector2d) {.inline.}

     Quickly rotates vector v 180 degrees counter clockwise, without
     using any trigonometrics.

   * rotate270
          proc rotate270*(v: var Vector2d) {.inline.}

     Quickly rotates vector v 270 degrees counter clockwise, without
     using any trigonometrics.

   * rotate
          proc rotate*(v: var Vector2d; rad: float)

     Rotates vector v rad radians in place.

   * scale
          proc scale*(v: var Vector2d; fac: float) {.inline.}

     Scales vector v rad radians in place.

   * stretch
          proc stretch*(v: var Vector2d; facx, facy: float) {.inline.}

     Stretches vector v facx times horizontally, and facy times
     vertically.

   * mirror
          proc mirror*(v: var Vector2d; mirrvec: Vector2d)

     Mirrors vector v using mirrvec as mirror direction.

   * '-'
          proc `-`*(v: Vector2d): Vector2d

     Negates a vector

   * dot
          proc dot*(v1, v2: Vector2d): float

     Computes the dot product of two vectors.  Returns 0.0 if the
     vectors are perpendicular.

   * cross
          proc cross*(v1, v2: Vector2d): float

     Computes the cross product of two vectors, also called the
     'perpendicular dot product' in 2d.  Returns 0.0 if the vectors are
     parallel.

   * equals
          proc equals*(v1, v2: Vector2d; tol = 1e-06'f64): bool

     Checks if two vectors approximately equals with a tolerance.

   * '=~'
          proc `=~`*(v1, v2: Vector2d): bool

     Checks if two vectors approximately equals with a hardcoded
     tolerance 1e-6

   * angleTo
          proc angleTo*(v1, v2: Vector2d): float

     Returns the smallest of the two possible angles between v1 and v2
     in radians.

   * angleCCW
          proc angleCCW*(v1, v2: Vector2d): float

     Returns the counter clockwise plane angle from v1 to v2, in range 0
     - 2*PI

   * angleCW
          proc angleCW*(v1, v2: Vector2d): float

     Returns the clockwise plane angle from v1 to v2, in range 0 - 2*PI

   * turnAngle
          proc turnAngle*(v1, v2: Vector2d): float

     Returns the amount v1 should be rotated (in radians) to equal v2,
     in range -PI to PI

   * bisect
          proc bisect*(v1, v2: Vector2d): Vector2d {.noInit.}

     Computes the bisector between v1 and v2 as a normalized vector.  If
     one of the input vectors has zero length, a normalized version of
     the other is returned.  If both input vectors has zero length, an
     arbitrary normalized vector is returned.

   * point2d
          proc point2d*(x, y: float): Point2d

   * sqrDist
          proc sqrDist*(a, b: Point2d): float

     Computes the squared distance between a and b

   * dist
          proc dist*(a, b: Point2d): float {.inline.}

     Computes the absolute distance between a and b

   * angle
          proc angle*(a, b: Point2d): float

     Computes the angle of the vector b-a

   * '$'
          proc `$`*(p: Point2d): string

     String representation of p

   * '&amp;'
          proc `&`*(p: Point2d; t: Matrix2d): Point2d {.noInit, inline.}

     Concatenates a point p with a transform t, resulting in a new,
     transformed point.

   * '&amp;='
          proc `&=`*(p: var Point2d; t: Matrix2d) {.inline.}

     Applies transformation t onto p in place.

   * transformInv
          proc transformInv*(p: var Point2d; t: Matrix2d) {.inline.}

     Applies the inverse of transformation t onto p in place.  If the
     matrix is not invertable (determinant=0) , EDivByZero will be
     raised.

   * '+'
          proc `+`*(p: Point2d; v: Vector2d): Point2d {.noInit, inline.}

     Adds a vector v to a point p, resulting in a new point.

   * '+='
          proc `+=`*(p: var Point2d; v: Vector2d) {.noInit, inline.}

     Adds a vector v to a point p in place.

   * '-'
          proc `-`*(p: Point2d; v: Vector2d): Point2d {.noInit, inline.}

     Subtracts a vector v from a point p, resulting in a new point.

   * '-'
          proc `-`*(p1, p2: Point2d): Vector2d {.noInit, inline.}

     Subtracts p2'from 'p1 resulting in a difference vector.

   * '-='
          proc `-=`*(p: var Point2d; v: Vector2d) {.noInit, inline.}

     Subtracts a vector v from a point p in place.

   * '=~'
          proc `=~`*(p1, p2: Point2d): bool {.inline.}

     Checks if two vectors approximately equals with a hardcoded
     tolerance 1e-6

   * polar
          proc polar*(p: Point2d; ang, dist: float): Point2d {.noInit.}

     Returns a point with a given angle and distance away from p

   * rotate
          proc rotate*(p: var Point2d; rad: float)

     Rotates a point in place rad radians around origo.

   * rotate
          proc rotate*(p: var Point2d; rad: float; org: Point2d)

     Rotates a point in place rad radians using org as center of
     rotation.

   * scale
          proc scale*(p: var Point2d; fac: float) {.inline.}

     Scales a point in place fac times with world origo as origin.

   * scale
          proc scale*(p: var Point2d; fac: float; org: Point2d) {.inline.}

     Scales the point in place fac times with org as origin.

   * stretch
          proc stretch*(p: var Point2d; facx, facy: float) {.inline.}

     Scales a point in place non uniformly facx and facy times with
     world origo as origin.

   * stretch
          proc stretch*(p: var Point2d; facx, facy: float; org: Point2d) {.inline.}

     Scales the point in place non uniformly facx and facy times with
     org as origin.

   * move
          proc move*(p: var Point2d; dx, dy: float) {.inline.}

     Translates a point dx, dy in place.

   * move
          proc move*(p: var Point2d; v: Vector2d) {.inline.}

     Translates a point with vector v in place.

   * sgnArea
          proc sgnArea*(a, b, c: Point2d): float

     Computes the signed area of the triangle thru points a,'b' and c
     result>0.0 for counter clockwise triangle result<0.0 for clockwise
     triangle This is commonly used to determinate side of a point with
     respect to a line.

   * area
          proc area*(a, b, c: Point2d): float

     Computes the area of the triangle thru points a,'b' and c

   * closestPoint
          proc closestPoint*(p: Point2d; pts: varargs[Point2d]): Point2d

     Returns a point selected from pts, that has the closest euclidean
     distance to p

   * normAngle
          proc normAngle*(ang: float): float

     Returns an angle in radians, that is equal to ang, but in the range
     0 to <2*PI

   * degToRad
          proc degToRad*(deg: float): float {.inline.}

     converts deg degrees to radians

   * radToDeg
          proc radToDeg*(rad: float): float {.inline.}

     converts rad radians to degrees


File: nim-ref-0.13.0.info,  Node: /pure/strtabs,  Next: /pure/db_common,  Prev: /pure/basic2d,  Up: Top

148 Types
*********

   * StringTableRef
          StringTableRef* = ref StringTableObj

     use this type to declare string tables

   * FormatFlag useEnvironment, ## use environment variable if the
     "$key" ## is not found in the table useEmpty, ## use the empty
     string as a default, thus it ## won't throw an exception if "$key"
     is not ## in the table useKey ## do not replace "$key" if it is not
     found ## in the table (or in the environment)
          FormatFlag* = enum
            useEnvironment,             ## use environment variable if the ``$key``
                           ## is not found in the table
            useEmpty,                   ## use the empty string as a default, thus it
                     ## won't throw an exception if ``$key`` is not
                     ## in the table
            useKey                      ## do not replace ``$key`` if it is not found
                  ## in the table (or in the environment)

     flags for the % operator

149 Procedures
**************

   * len
          proc len*(t: StringTableRef): int {.rtl, extern: "nst$1".}

     returns the number of keys in t.

   * '[]' deprecatedGet.}
          proc `[]`*(t: StringTableRef; key: string): var string {.rtl, extern: "nstTake",
              deprecatedGet.}

     retrieves the location at 't[key]'.  If key is not in t, the
     'KeyError' exception is raised.  One can check with 'hasKey'
     whether the key exists.

   * mget
          proc mget*(t: StringTableRef; key: string): var string {.deprecated.}

     retrieves the location at 't[key]'.  If key is not in t, the
     'KeyError' exception is raised.  Use "'[]"' instead.

   * getOrDefault
          proc getOrDefault*(t: StringTableRef; key: string): string

   * hasKey
          proc hasKey*(t: StringTableRef; key: string): bool {.rtl, extern: "nst$1".}

     returns true iff key is in the table t.

   * '[]='
          proc `[]=`*(t: StringTableRef; key, val: string) {.rtl, extern: "nstPut".}

     puts a (key, value)-pair into t.

   * newStringTable
          proc newStringTable*(mode: StringTableMode): StringTableRef {.rtl, extern: "nst$1".}

     creates a new string table that is empty.

   * clear
          proc clear*(s: StringTableRef; mode: StringTableMode)

     resets a string table to be empty again.

   * newStringTable rtl, extern: "nst$1WithPairs".}
          proc newStringTable*(keyValuePairs: varargs[string]; mode: StringTableMode): StringTableRef {.
              rtl, extern: "nst$1WithPairs".}

     creates a new string table with given key value pairs.  Example:
     var mytab = newStringTable("key1", "val1", "key2", "val2",
                                modeCaseInsensitive)

   * newStringTable mode: StringTableMode = modeCaseSensitive):
     StringTableRef {.rtl, extern: "nst$1WithTableConstr".}
          proc newStringTable*(keyValuePairs: varargs[tuple[key, val: string]];
                              mode: StringTableMode = modeCaseSensitive): StringTableRef {.rtl,
              extern: "nst$1WithTableConstr".}

     creates a new string table with given key value pairs.  Example:
     var mytab = newStringTable({"key1": "val1", "key2": "val2"},
                                modeCaseInsensitive)

   * '%' extern: "nstFormat".}
          proc `%`*(f: string; t: StringTableRef; flags: set[FormatFlag] = {}): string {.rtl,
              extern: "nstFormat".}

     The % operator for string tables.

   * '$'
          proc `$`*(t: StringTableRef): string {.rtl, extern: "nstDollar".}

     The $ operator for string tables.

150 Iterators
*************

   * pairs
          iterator pairs*(t: StringTableRef): tuple[key, value: string]

     iterates over every (key, value) pair in the table t.

   * keys
          iterator keys*(t: StringTableRef): string

     iterates over every key in the table t.

   * values
          iterator values*(t: StringTableRef): string

     iterates over every value in the table t.


File: nim-ref-0.13.0.info,  Node: /pure/db_common,  Next: /pure/lexbase,  Prev: /pure/strtabs,  Up: Top

151 Types
*********

   * DbColumns
          DbColumns* = seq[DbColumn]

152 Procedures
**************

   * dbError
          proc dbError*(msg: string) {.noreturn, noinline.}

     raises an DbError exception with message msg.

153 Templates
*************

   * sql
          template sql*(query: string): SqlQuery

     constructs a SqlQuery from the string query.  This is supposed to
     be used as a raw-string-literal modifier: 'sql"update user set
     counter = counter + 1"'

     If assertions are turned off, it does nothing.  If assertions are
     turned on, later versions will check the string for valid syntax.


File: nim-ref-0.13.0.info,  Node: /pure/lexbase,  Next: /pure/ropes,  Prev: /pure/db_common,  Up: Top

154 Constant variables
**********************

   * NewLines
          NewLines* = {'\x0D', '\x0A'}

155 Types
*********

   * BaseLexer bufpos*: int ## the current position within the buffer
     when defined(js): buf*: string

     else: buf*: cstring

     bufLen*: int ## length of buffer in characters input: Stream ## the
     input stream lineNumber*: int ## the current line number sentinel:
     int lineStart: int refillChars: set[char]

          BaseLexer* = object of RootObj
            bufpos*: int                 ## the current position within the buffer
            when defined(js):
                buf*: string

            else:
                buf*: cstring

            bufLen*: int                 ## length of buffer in characters
            input: Stream                ## the input stream
            lineNumber*: int             ## the current line number
            sentinel: int
            lineStart: int
            refillChars: set[char]


     the base lexer.  Inherit your lexer from this object.

156 Procedures
**************

   * close
          proc close*(L: var BaseLexer)

     closes the base lexer.  This closes L's associated stream too.

   * handleCR
          proc handleCR*(L: var BaseLexer; pos: int): int

     Call this if you scanned over 'c' in the buffer; it returns the the
     position to continue the scanning from.  pos must be the position
     of the 'c'.

   * handleLF
          proc handleLF*(L: var BaseLexer; pos: int): int

     Call this if you scanned over 'L' in the buffer; it returns the the
     position to continue the scanning from.  pos must be the position
     of the 'L'.

   * handleRefillChar
          proc handleRefillChar*(L: var BaseLexer; pos: int): int

     To be documented.

   * open refillChars: set[char] = NewLines)
          proc open*(L: var BaseLexer; input: Stream; bufLen: int = 8192;
                    refillChars: set[char] = NewLines)

     inits the BaseLexer with a stream to read from.

   * getColNumber
          proc getColNumber*(L: BaseLexer; pos: int): int

     retrieves the current column.

   * getCurrentLine
          proc getCurrentLine*(L: BaseLexer; marker: bool = true): string

     retrieves the current line.


File: nim-ref-0.13.0.info,  Node: /pure/ropes,  Next: /pure/asyncftpclient,  Prev: /pure/lexbase,  Up: Top

157 Procedures
**************

   * len
          proc len*(a: Rope): int {.rtl, extern: "nro$1".}

     the rope's length

   * rope
          proc rope*(s: string): Rope {.rtl, extern: "nro$1Str".}

     Converts a string to a rope.

   * rope
          proc rope*(i: BiggestInt): Rope {.rtl, extern: "nro$1BiggestInt".}

     Converts an int to a rope.

   * rope
          proc rope*(f: BiggestFloat): Rope {.rtl, extern: "nro$1BiggestFloat".}

     Converts a float to a rope.

   * enableCache
          proc enableCache*() {.rtl, extern: "nro$1".}

     Enables the caching of leaves.  This reduces the memory footprint
     at the cost of runtime efficiency.

   * disableCache
          proc disableCache*() {.rtl, extern: "nro$1".}

     the cache is discarded and disabled.  The GC will reuse its used
     memory.

   * '&amp;'
          proc `&`*(a, b: Rope): Rope {.rtl, extern: "nroConcRopeRope".}

     the concatenation operator for ropes.

   * '&amp;'
          proc `&`*(a: Rope; b: string): Rope {.rtl, extern: "nroConcRopeStr".}

     the concatenation operator for ropes.

   * '&amp;'
          proc `&`*(a: string; b: Rope): Rope {.rtl, extern: "nroConcStrRope".}

     the concatenation operator for ropes.

   * '&amp;'
          proc `&`*(a: openArray[Rope]): Rope {.rtl, extern: "nroConcOpenArray".}

     the concatenation operator for an openarray of ropes.

   * add
          proc add*(a: var Rope; b: Rope) {.rtl, extern: "nro$1Rope".}

     adds b to the rope a.

   * add
          proc add*(a: var Rope; b: string) {.rtl, extern: "nro$1Str".}

     adds b to the rope a.

   * '[]'
          proc `[]`*(r: Rope; i: int): char {.rtl, extern: "nroCharAt".}

     returns the character at position i in the rope r.  This is quite
     expensive!  Worst-case: O(n).  If 'i >= r.len', '\0' is returned.

   * write
          proc write*(f: File; r: Rope) {.rtl, extern: "nro$1".}

     writes a rope to a file.

   * '$'
          proc `$`*(r: Rope): string {.rtl, extern: "nroToString".}

     converts a rope back to a string.

   * '%'
          proc `%`*(frmt: string; args: openArray[Rope]): Rope {.rtl, extern: "nroFormat".}

     % substitution operator for ropes.  Does not support the
     '$identifier' nor '${identifier}' notations.

   * addf
          proc addf*(c: var Rope; frmt: string; args: openArray[Rope]) {.rtl, extern: "nro$1".}

     shortcut for 'add(c, frmt % args)'.

   * equalsFile
          proc equalsFile*(r: Rope; f: File): bool {.rtl, extern: "nro$1File".}

     returns true if the contents of the file f equal r.

   * equalsFile
          proc equalsFile*(r: Rope; filename: string): bool {.rtl, extern: "nro$1Str".}

     returns true if the contents of the file f equal r.  If f does not
     exist, false is returned.

158 Iterators
*************

   * leaves
          iterator leaves*(r: Rope): string

     iterates over any leaf string in the rope r.

   * items
          iterator items*(r: Rope): char

     iterates over any character in the rope r.


File: nim-ref-0.13.0.info,  Node: /pure/asyncftpclient,  Next: /pure/base64,  Prev: /pure/ropes,  Up: Top

159 Types
*********

   * ProgressChangedProc closure, gcsafe.}
          ProgressChangedProc* = proc (total, progress: BiggestInt; speed: float): Future[void] {.
              closure, gcsafe.}

160 Procedures
**************

   * send
          proc send*(ftp: AsyncFtpClient; m: string): Future[TaintedString] {.async.}

     Send a message to the server, and wait for a primary reply.  '\c\L'
     is added for you.

     *Note:* The server may return multiple lines of coded replies.

   * connect
          proc connect*(ftp: AsyncFtpClient) {.async.}

     Connect to the FTP server specified by 'ftp'.

   * pwd
          proc pwd*(ftp: AsyncFtpClient): Future[TaintedString] {.async.}

     Returns the current working directory.

   * cd
          proc cd*(ftp: AsyncFtpClient; dir: string) {.async.}

     Changes the current directory on the remote FTP server to 'dir'.

   * cdup
          proc cdup*(ftp: AsyncFtpClient) {.async.}

     Changes the current directory to the parent of the current
     directory.

   * listDirs
          proc listDirs*(ftp: AsyncFtpClient; dir = ""): Future[seq[string]] {.async.}

     Returns a list of filenames in the given directory.  If 'dir' is
     "", the current directory is used.  If 'async' is true, this
     function will return immediately and it will be your job to use
     asyncio's 'poll' to progress this operation.

   * existsFile
          proc existsFile*(ftp: AsyncFtpClient; file: string): Future[bool] {.async.}

     Determines whether 'file' exists.

   * createDir
          proc createDir*(ftp: AsyncFtpClient; dir: string; recursive = false) {.async.}

     Creates a directory 'dir'.  If 'recursive' is true, the topmost
     subdirectory of 'dir' will be created first, following the
     secondmost...  etc.  this allows you to give a full path as the
     'dir' without worrying about subdirectories not existing.

   * chmod async.}
          proc chmod*(ftp: AsyncFtpClient; path: string; permissions: set[FilePermission]) {.
              async.}

     Changes permission of 'path' to 'permissions'.

   * list
          proc list*(ftp: AsyncFtpClient; dir = ""): Future[string] {.async.}

     Lists all files in 'dir'.  If 'dir' is '""', uses the current
     working directory.

   * retrText
          proc retrText*(ftp: AsyncFtpClient; file: string): Future[string] {.async.}

     Retrieves 'file'.  File must be ASCII text.

   * defaultOnProgressChanged nimcall, gcsafe.}
          proc defaultOnProgressChanged*(total, progress: BiggestInt; speed: float): Future[void] {.
              nimcall, gcsafe.}

     Default FTP 'onProgressChanged' handler.  Does nothing.

   * retrFile onProgressChanged: ProgressChangedProc =
     defaultOnProgressChanged) {.  async.}
          proc retrFile*(ftp: AsyncFtpClient; file, dest: string;
                        onProgressChanged: ProgressChangedProc = defaultOnProgressChanged) {.
              async.}

     Downloads 'file' and saves it to 'dest'.  The 'EvRetr' event is
     passed to the specified 'handleEvent' function when the download is
     finished.  The event's 'filename' field will be equal to 'file'.

   * store onProgressChanged: ProgressChangedProc =
     defaultOnProgressChanged) {.  async.}
          proc store*(ftp: AsyncFtpClient; file, dest: string;
                     onProgressChanged: ProgressChangedProc = defaultOnProgressChanged) {.
              async.}

     Uploads 'file' to 'dest' on the remote FTP server.  Usage of this
     function asynchronously is recommended to view the progress of the
     download.  The 'EvStore' event is passed to the specified
     'handleEvent' function when the upload is finished, and the
     'filename' field will be equal to 'file'.

   * newAsyncFtpClient
          proc newAsyncFtpClient*(address: string; port = Port(21); user, pass = ""): AsyncFtpClient

     Creates a new 'AsyncFtpClient' object.


File: nim-ref-0.13.0.info,  Node: /pure/base64,  Next: /pure/smtp,  Prev: /pure/asyncftpclient,  Up: Top

161 Procedures
**************

   * encode
          proc encode*[T: SomeInteger | char](s: openarray[T]; lineLen = 75; newLine = "\x0D\x0A"): string

     encodes s into base64 representation.  After lineLen characters, a
     newline is added.

     This procedure encodes an openarray (array or sequence) of either
     integers or characters.

   * encode
          proc encode*(s: string; lineLen = 75; newLine = "\x0D\x0A"): string

     encodes s into base64 representation.  After lineLen characters, a
     newline is added.

     This procedure encodes a string.

   * decode
          proc decode*(s: string): string

     decodes a string in base64 representation back into its original
     form.  Whitespace is skipped.


File: nim-ref-0.13.0.info,  Node: /pure/smtp,  Next: /pure/xmltree,  Prev: /pure/base64,  Up: Top

162 Types
*********

   * AsyncSmtp sock: AsyncSocket address: string port: Port useSsl: bool
     debug: bool

          AsyncSmtp* = ref object
            sock: AsyncSocket
            address: string
            port: Port
            useSsl: bool
            debug: bool


163 Procedures
**************

   * connect sslContext = defaultSSLContext): Smtp
          proc connect*(address: string; port = Port(25); ssl = false; debug = false;
                       sslContext = defaultSSLContext): Smtp

     Establishes a connection with a SMTP server.  May fail with
     ReplyError or with a socket error.

   * auth
          proc auth*(smtp: var Smtp; username, password: string)

     Sends an AUTH command to the server to login as the username using
     password.  May fail with ReplyError.

   * sendmail
          proc sendmail*(smtp: var Smtp; fromaddr: string; toaddrs: seq[string]; msg: string)

     Sends msg from fromaddr to toaddr.  Messages may be formed using
     'createMessage' by converting the Message into a string.

   * close
          proc close*(smtp: Smtp)

     Disconnects from the SMTP server and closes the socket.

   * createMessage otherHeaders: openarray[tuple[name, value: string]]):
     Message
          proc createMessage*(mSubject, mBody: string; mTo, mCc: seq[string];
                             otherHeaders: openarray[tuple[name, value: string]]): Message

     Creates a new MIME compliant message.

   * createMessage
          proc createMessage*(mSubject, mBody: string; mTo, mCc: seq[string] = @ []): Message

     Alternate version of the above.

   * '$'
          proc `$`*(msg: Message): string

     stringify for 'Message'.

   * newAsyncSmtp sslContext = defaultSslContext): AsyncSmtp
          proc newAsyncSmtp*(address: string; port: Port; useSsl = false;
                            sslContext = defaultSslContext): AsyncSmtp

     Creates a new 'AsyncSmtp' instance.

   * connect
          proc connect*(smtp: AsyncSmtp) {.async.}

     Establishes a connection with a SMTP server.  May fail with
     ReplyError or with a socket error.

   * auth
          proc auth*(smtp: AsyncSmtp; username, password: string) {.async.}

     Sends an AUTH command to the server to login as the username using
     password.  May fail with ReplyError.

   * sendMail async.}
          proc sendMail*(smtp: AsyncSmtp; fromAddr: string; toAddrs: seq[string]; msg: string) {.
              async.}

     Sends 'msg' from 'fromAddr' to the addresses specified in
     'toAddrs'.  Messages may be formed using 'createMessage' by
     converting the Message into a string.

   * close
          proc close*(smtp: AsyncSmtp) {.async.}

     Disconnects from the SMTP server and closes the socket.


File: nim-ref-0.13.0.info,  Node: /pure/xmltree,  Next: /pure/mimetypes,  Prev: /pure/smtp,  Up: Top

164 Constant variables
**********************

   * xmlHeader
          xmlHeader* = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\x0A"

     header to use for complete XML output

165 Procedures
**************

   * newElement
          proc newElement*(tag: string): XmlNode

     creates a new 'PXmlNode' of kind 'xnText' with the given tag.

   * newText
          proc newText*(text: string): XmlNode

     creates a new 'PXmlNode' of kind 'xnText' with the text text.

   * newComment
          proc newComment*(comment: string): XmlNode

     creates a new 'PXmlNode' of kind 'xnComment' with the text comment.

   * newCData
          proc newCData*(cdata: string): XmlNode

     creates a new 'PXmlNode' of kind 'xnComment' with the text cdata.

   * newEntity
          proc newEntity*(entity: string): XmlNode

     creates a new 'PXmlNode' of kind 'xnEntity' with the text entity.

   * text
          proc text*(n: XmlNode): string {.inline.}

     gets the associated text with the node n.  n can be a CDATA, Text,
     comment, or entity node.

   * 'text='
          proc `text =`*(n: XmlNode; text: string) {.inline.}

     sets the associated text with the node n.  n can be a CDATA, Text,
     comment, or entity node.

   * rawText
          proc rawText*(n: XmlNode): string {.inline.}

     returns the underlying 'text' string by reference.  This is only
     used for speed hacks.

   * rawTag
          proc rawTag*(n: XmlNode): string {.inline.}

     returns the underlying 'tag' string by reference.  This is only
     used for speed hacks.

   * innerText
          proc innerText*(n: XmlNode): string

     gets the inner text of n.  n has to be an 'xnElement' node.  Only
     'xnText' and 'xnEntity' nodes are considered part of n's inner
     text, other child nodes are silently ignored.

   * tag
          proc tag*(n: XmlNode): string {.inline.}

     gets the tag name of n.  n has to be an 'xnElement' node.

   * 'tag='
          proc `tag =`*(n: XmlNode; tag: string) {.inline.}

     sets the tag name of n.  n has to be an 'xnElement' node.

   * add
          proc add*(father, son: XmlNode) {.inline.}

     adds the child son to father.

   * insert
          proc insert*(father, son: XmlNode; index: int) {.inline.}

     insert the child son to a given position in father.

   * len
          proc len*(n: XmlNode): int {.inline.}

     returns the number n's children.

   * kind
          proc kind*(n: XmlNode): XmlNodeKind {.inline.}

     returns n's kind.

   * '[]'
          proc `[]`*(n: XmlNode; i: int): XmlNode {.inline.}

     returns the i'th child of n.

   * delete
          proc delete*(n: XmlNode; i: Natural) {.noSideEffect.}

     delete the i'th child of n.

   * '[]'
          proc `[]`*(n: var XmlNode; i: int): var XmlNode {.inline.}

     returns the i'th child of n so that it can be modified

   * mget
          proc mget*(n: var XmlNode; i: int): var XmlNode {.inline, deprecated.}

     returns the i'th child of n so that it can be modified.  Use "'[]"'
     instead.

   * attrs
          proc attrs*(n: XmlNode): XmlAttributes {.inline.}

     gets the attributes belonging to n.  Returns nil if attributes have
     not been initialised for this node.

   * 'attrs='
          proc `attrs =`*(n: XmlNode; attr: XmlAttributes) {.inline.}

     sets the attributes belonging to n.

   * attrsLen
          proc attrsLen*(n: XmlNode): int {.inline.}

     returns the number of n's attributes.

   * clientData
          proc clientData*(n: XmlNode): int {.inline.}

     gets the client data of n.  The client data field is used by the
     HTML parser and generator.

   * 'clientData='
          proc `clientData =`*(n: XmlNode; data: int) {.inline.}

     sets the client data of n.  The client data field is used by the
     HTML parser and generator.

   * addEscaped
          proc addEscaped*(result: var string; s: string)

     same as 'result.add(escape(s))', but more efficient.

   * escape
          proc escape*(s: string): string

     escapes s for inclusion into an XML document.  Escapes these
     characters:
     char  is converted to
     ------------------------
     '<'   '&lt;'
     '>'   '&gt;'
     '&'   '&amp;'
     '"'   '&quot;'
     '''   '&#x27;'
     '/'   '&#x2F;'

   * add
          proc add*(result: var string; n: XmlNode; indent = 0; indWidth = 2)

     adds the textual representation of n to result.

   * '$'
          proc `$`*(n: XmlNode): string

     converts n into its string representation.  No '<$xml ...$>'
     declaration is produced, so that the produced XML fragments are
     composable.

   * newXmlTree attributes: XmlAttributes = nil): XmlNode
          proc newXmlTree*(tag: string; children: openArray[XmlNode];
                          attributes: XmlAttributes = nil): XmlNode

     creates a new XML tree with tag, children and attributes

   * child
          proc child*(n: XmlNode; name: string): XmlNode

     Finds the first child element of n with a name of name.  Returns
     nil on failure.

   * attr
          proc attr*(n: XmlNode; name: string): string

     Finds the first attribute of n with a name of name.  Returns "" on
     failure.

   * findAll
          proc findAll*(n: XmlNode; tag: string; result: var seq[XmlNode])

     Iterates over all the children of n returning those matching tag.

     Found nodes satisfying the condition will be appended to the result
     sequence, which can't be nil or the proc will crash.  Usage
     example:
     var
       html: XmlNode
       tags: seq[XmlNode] = @[]

     html = buildHtml()
     findAll(html, "img", tags)
     for imgTag in tags:
       process(imgTag)

   * findAll
          proc findAll*(n: XmlNode; tag: string): seq[XmlNode]

     Shortcut version to assign in let blocks.  Example:
     var html: XmlNode

     html = buildHtml(html)
     for imgTag in html.findAll("img"):
       process(imgTag)

166 Macros
**********

   * '&lt;&gt;'
          macro `<>`*(x: expr): expr {.immediate.}

     Constructor macro for XML. Example usage:
     <>a(href="http://nim-lang.org", newText("Nim rules."))

     Produces an XML tree for:
     <a href="http://nim-lang.org">Nim rules.</a>

167 Iterators
*************

   * items
          iterator items*(n: XmlNode): XmlNode {.inline.}

     iterates over any child of n.

   * mitems
          iterator mitems*(n: var XmlNode): var XmlNode {.inline.}

     iterates over any child of n.


File: nim-ref-0.13.0.info,  Node: /pure/mimetypes,  Next: /pure/rationals,  Prev: /pure/xmltree,  Up: Top

168 Constant variables
**********************

   * mimes "atom": "application/atom+xml", "atomcat":
     "application/atomcat+xml", "atomsrv": "application/atomserv+xml",
     "lin": "application/bbolin", "cap": "application/cap", "pcap":
     "application/cap", "cu": "application/cu-seeme", "davmount":
     "application/davmount+xml", "tsp": "application/dsptype", "es":
     "application/ecmascript", "spl": "application/futuresplash", "hta":
     "application/hta", "jar": "application/java-archive", "ser":
     "application/java-serialized-object", "class":
     "application/java-vm", "js": "application/javascript", "m3g":
     "application/m3g", "hqx": "application/mac-binhex40", "cpt":
     "application/mac-compactpro", "nb": "application/mathematica",
     "nbp": "application/mathematica", "mdb": "application/msaccess",
     "doc": "application/msword", "dot": "application/msword", "mxf":
     "application/mxf", "bin": "application/octet-stream", "oda":
     "application/oda", "ogx": "application/ogg", "pdf":
     "application/pdf", "key": "application/pgp-keys", "pgp":
     "application/pgp-signature", "prf": "application/pics-rules", "ps":
     "application/postscript", "ai": "application/postscript", "eps":
     "application/postscript", "epsi": "application/postscript", "epsf":
     "application/postscript", "eps2": "application/postscript", "eps3":
     "application/postscript", "rar": "application/rar", "rdf":
     "application/rdf+xml", "rss": "application/rss+xml", "rtf":
     "application/rtf", "smi": "application/smil", "smil":
     "application/smil", "xhtml": "application/xhtml+xml", "xht":
     "application/xhtml+xml", "xml": "application/xml", "xsl":
     "application/xml", "xsd": "application/xml", "xspf":
     "application/xspf+xml", "zip": "application/zip", "apk":
     "application/vnd.android.package-archive", "cdy":
     "application/vnd.cinderella", "kml":
     "application/vnd.google-earth.kml+xml", "kmz":
     "application/vnd.google-earth.kmz", "xul":
     "application/vnd.mozilla.xul+xml", "xls":
     "application/vnd.ms-excel", "xlb": "application/vnd.ms-excel",
     "xlt": "application/vnd.ms-excel", "cat":
     "application/vnd.ms-pki.seccat", "stl":
     "application/vnd.ms-pki.stl", "ppt":
     "application/vnd.ms-powerpoint", "pps":
     "application/vnd.ms-powerpoint", "xlsx":
     "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
     "xltx":
     "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
     "pptx":
     "application/vnd.openxmlformats-officedocument.presentationml.presentation",
     "ppsx":
     "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
     "potx":
     "application/vnd.openxmlformats-officedocument.presentationml.template",
     "docx":
     "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
     "dotx":
     "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
     "cod": "application/vnd.rim.cod", "mmf": "application/vnd.smaf",
     "sis": "application/vnd.symbian.install", "vsd":
     "application/vnd.visio", "wbxml": "application/vnd.wap.wbxml",
     "wmlc": "application/vnd.wap.wmlc", "wmlsc":
     "application/vnd.wap.wmlscriptc", "wpd":
     "application/vnd.wordperfect", "wp5":
     "application/vnd.wordperfect5.1", "wk": "application/x-123", "7z":
     "application/x-7z-compressed", "abw": "application/x-abiword",
     "dmg": "application/x-apple-diskimage", "bcpio":
     "application/x-bcpio", "torrent": "application/x-bittorrent",
     "cab": "application/x-cab", "cbr": "application/x-cbr", "cbz":
     "application/x-cbz", "cdf": "application/x-cdf", "cda":
     "application/x-cdf", "vcd": "application/x-cdlink", "pgn":
     "application/x-chess-pgn", "cpio": "application/x-cpio", "csh":
     "application/x-csh", "deb": "application/x-debian-package", "udeb":
     "application/x-debian-package", "dcr": "application/x-director",
     "dir": "application/x-director", "dxr": "application/x-director",
     "dms": "application/x-dms", "wad": "application/x-doom", "dvi":
     "application/x-dvi", "rhtml": "application/x-httpd-eruby", "pfa":
     "application/x-font", "pfb": "application/x-font", "gsf":
     "application/x-font", "pcf": "application/x-font", "pcf.Z":
     "application/x-font", "mm": "application/x-freemind", "spl":
     "application/x-futuresplash", "gnumeric": "application/x-gnumeric",
     "sgf": "application/x-go-sgf", "gcf":
     "application/x-graphing-calculator", "gtar": "application/x-gtar",
     "tgz": "application/x-gtar", "taz": "application/x-gtar", "hdf":
     "application/x-hdf", "phtml": "application/x-httpd-php", "pht":
     "application/x-httpd-php", "php": "application/x-httpd-php",
     "phps": "application/x-httpd-php-source", "php3":
     "application/x-httpd-php3", "php3p":
     "application/x-httpd-php3-preprocessed", "php4":
     "application/x-httpd-php4", "php5": "application/x-httpd-php5",
     "ica": "application/x-ica", "info": "application/x-info", "ins":
     "application/x-internet-signup", "isp":
     "application/x-internet-signup", "iii": "application/x-iphone",
     "iso": "application/x-iso9660-image", "jam": "application/x-jam",
     "jnlp": "application/x-java-jnlp-file", "jmz":
     "application/x-jmol", "chrt": "application/x-kchart", "kil":
     "application/x-killustrator", "skp": "application/x-koan", "skd":
     "application/x-koan", "skt": "application/x-koan", "skm":
     "application/x-koan", "kpr": "application/x-kpresenter", "kpt":
     "application/x-kpresenter", "ksp": "application/x-kspread", "kwd":
     "application/x-kword", "kwt": "application/x-kword", "latex":
     "application/x-latex", "lha": "application/x-lha", "lyx":
     "application/x-lyx", "lzh": "application/x-lzh", "lzx":
     "application/x-lzx", "frm": "application/x-maker", "maker":
     "application/x-maker", "frame": "application/x-maker", "fm":
     "application/x-maker", "fb": "application/x-maker", "book":
     "application/x-maker", "fbdoc": "application/x-maker", "mif":
     "application/x-mif", "wmd": "application/x-ms-wmd", "wmz":
     "application/x-ms-wmz", "com": "application/x-msdos-program",
     "exe": "application/x-msdos-program", "bat":
     "application/x-msdos-program", "dll":
     "application/x-msdos-program", "msi": "application/x-msi", "nc":
     "application/x-netcdf", "pac": "application/x-ns-proxy-autoconfig",
     "dat": "application/x-ns-proxy-autoconfig", "nwc":
     "application/x-nwc", "o": "application/x-object", "oza":
     "application/x-oz-application", "p7r":
     "application/x-pkcs7-certreqresp", "crl":
     "application/x-pkcs7-crl", "pyc": "application/x-python-code",
     "pyo": "application/x-python-code", "qgs": "application/x-qgis",
     "shp": "application/x-qgis", "shx": "application/x-qgis", "qtl":
     "application/x-quicktimeplayer", "rpm":
     "application/x-redhat-package-manager", "rb": "application/x-ruby",
     "sh": "application/x-sh", "shar": "application/x-shar", "swf":
     "application/x-shockwave-flash", "swfl":
     "application/x-shockwave-flash", "scr":
     "application/x-silverlight", "sit": "application/x-stuffit",
     "sitx": "application/x-stuffit", "sv4cpio":
     "application/x-sv4cpio", "sv4crc": "application/x-sv4crc", "tar":
     "application/x-tar", "tcl": "application/x-tcl", "gf":
     "application/x-tex-gf", "pk": "application/x-tex-pk", "texinfo":
     "application/x-texinfo", "texi": "application/x-texinfo", "~":
     "application/x-trash", "%": "application/x-trash", "bak":
     "application/x-trash", "old": "application/x-trash", "sik":
     "application/x-trash", "t": "application/x-troff", "tr":
     "application/x-troff", "roff": "application/x-troff", "man":
     "application/x-troff-man", "me": "application/x-troff-me", "ms":
     "application/x-troff-ms", "ustar": "application/x-ustar", "src":
     "application/x-wais-source", "wz": "application/x-wingz", "crt":
     "application/x-x509-ca-cert", "xcf": "application/x-xcf", "fig":
     "application/x-xfig", "xpi": "application/x-xpinstall", "amr":
     "audio/amr", "awb": "audio/amr-wb", "amr": "audio/amr", "awb":
     "audio/amr-wb", "axa": "audio/annodex", "au": "audio/basic", "snd":
     "audio/basic", "flac": "audio/flac", "mid": "audio/midi", "midi":
     "audio/midi", "kar": "audio/midi", "mpga": "audio/mpeg", "mpega":
     "audio/mpeg", "mp2": "audio/mpeg", "mp3": "audio/mpeg", "m4a":
     "audio/mpeg", "m3u": "audio/mpegurl", "oga": "audio/ogg", "ogg":
     "audio/ogg", "spx": "audio/ogg", "sid": "audio/prs.sid", "aif":
     "audio/x-aiff", "aiff": "audio/x-aiff", "aifc": "audio/x-aiff",
     "gsm": "audio/x-gsm", "m3u": "audio/x-mpegurl", "wma":
     "audio/x-ms-wma", "wax": "audio/x-ms-wax", "ra":
     "audio/x-pn-realaudio", "rm": "audio/x-pn-realaudio", "ram":
     "audio/x-pn-realaudio", "ra": "audio/x-realaudio", "pls":
     "audio/x-scpls", "sd2": "audio/x-sd2", "wav": "audio/x-wav", "alc":
     "chemical/x-alchemy", "cac": "chemical/x-cache", "cache":
     "chemical/x-cache", "csf": "chemical/x-cache-csf", "cbin":
     "chemical/x-cactvs-binary", "cascii": "chemical/x-cactvs-binary",
     "ctab": "chemical/x-cactvs-binary", "cdx": "chemical/x-cdx", "cer":
     "chemical/x-cerius", "c3d": "chemical/x-chem3d", "chm":
     "chemical/x-chemdraw", "cif": "chemical/x-cif", "cmdf":
     "chemical/x-cmdf", "cml": "chemical/x-cml", "cpa":
     "chemical/x-compass", "bsd": "chemical/x-crossfire", "csml":
     "chemical/x-csml", "csm": "chemical/x-csml", "ctx":
     "chemical/x-ctx", "cxf": "chemical/x-cxf", "cef": "chemical/x-cxf",
     "smi": "#chemical/x-daylight-smiles", "emb":
     "chemical/x-embl-dl-nucleotide", "embl":
     "chemical/x-embl-dl-nucleotide", "spc": "chemical/x-galactic-spc",
     "inp": "chemical/x-gamess-input", "gam": "chemical/x-gamess-input",
     "gamin": "chemical/x-gamess-input", "fch":
     "chemical/x-gaussian-checkpoint", "fchk":
     "chemical/x-gaussian-checkpoint", "cub":
     "chemical/x-gaussian-cube", "gau": "chemical/x-gaussian-input",
     "gjc": "chemical/x-gaussian-input", "gjf":
     "chemical/x-gaussian-input", "gal": "chemical/x-gaussian-log",
     "gcg": "chemical/x-gcg8-sequence", "gen": "chemical/x-genbank",
     "hin": "chemical/x-hin", "istr": "chemical/x-isostar", "ist":
     "chemical/x-isostar", "jdx": "chemical/x-jcamp-dx", "dx":
     "chemical/x-jcamp-dx", "kin": "chemical/x-kinemage", "mcm":
     "chemical/x-macmolecule", "mmd": "chemical/x-macromodel-input",
     "mmod": "chemical/x-macromodel-input", "mol":
     "chemical/x-mdl-molfile", "rd": "chemical/x-mdl-rdfile", "rxn":
     "chemical/x-mdl-rxnfile", "sd": "chemical/x-mdl-sdfile", "sdf":
     "chemical/x-mdl-sdfile", "tgf": "chemical/x-mdl-tgf", "mif":
     "#chemical/x-mif", "mcif": "chemical/x-mmcif", "mol2":
     "chemical/x-mol2", "b": "chemical/x-molconn-Z", "gpt":
     "chemical/x-mopac-graph", "mop": "chemical/x-mopac-input",
     "mopcrt": "chemical/x-mopac-input", "mpc":
     "chemical/x-mopac-input", "zmt": "chemical/x-mopac-input", "moo":
     "chemical/x-mopac-out", "mvb": "chemical/x-mopac-vib", "asn":
     "chemical/x-ncbi-asn1", "prt": "chemical/x-ncbi-asn1-ascii", "ent":
     "chemical/x-ncbi-asn1-ascii", "val": "chemical/x-ncbi-asn1-binary",
     "aso": "chemical/x-ncbi-asn1-binary", "asn":
     "chemical/x-ncbi-asn1-spec", "pdb": "chemical/x-pdb", "ent":
     "chemical/x-pdb", "ros": "chemical/x-rosdal", "sw":
     "chemical/x-swissprot", "vms": "chemical/x-vamas-iso14976", "vmd":
     "chemical/x-vmd", "xtel": "chemical/x-xtel", "xyz":
     "chemical/x-xyz", "gif": "image/gif", "ief": "image/ief", "jpeg":
     "image/jpeg", "jpg": "image/jpeg", "jpe": "image/jpeg", "pcx":
     "image/pcx", "png": "image/png", "svg": "image/svg+xml", "svgz":
     "image/svg+xml", "tiff": "image/tiff", "tif": "image/tiff", "djvu":
     "image/vnd.djvu", "djv": "image/vnd.djvu", "wbmp":
     "image/vnd.wap.wbmp", "cr2": "image/x-canon-cr2", "crw":
     "image/x-canon-crw", "ras": "image/x-cmu-raster", "cdr":
     "image/x-coreldraw", "pat": "image/x-coreldrawpattern", "cdt":
     "image/x-coreldrawtemplate", "cpt": "image/x-corelphotopaint",
     "erf": "image/x-epson-erf", "ico": "image/x-icon", "art":
     "image/x-jg", "jng": "image/x-jng", "bmp": "image/x-ms-bmp", "nef":
     "image/x-nikon-nef", "orf": "image/x-olympus-orf", "psd":
     "image/x-photoshop", "pnm": "image/x-portable-anymap", "pbm":
     "image/x-portable-bitmap", "pgm": "image/x-portable-graymap",
     "ppm": "image/x-portable-pixmap", "rgb": "image/x-rgb", "xbm":
     "image/x-xbitmap", "xpm": "image/x-xpixmap", "xwd":
     "image/x-xwindowdump", "eml": "message/rfc822", "igs":
     "model/iges", "iges": "model/iges", "msh": "model/mesh", "mesh":
     "model/mesh", "silo": "model/mesh", "wrl": "model/vrml", "vrml":
     "model/vrml", "x3dv": "model/x3d+vrml", "x3d": "model/x3d+xml",
     "x3db": "model/x3d+binary", "manifest": "text/cache-manifest",
     "ics": "text/calendar", "icz": "text/calendar", "css": "text/css",
     "csv": "text/csv", "323": "text/h323", "html": "text/html", "htm":
     "text/html", "shtml": "text/html", "uls": "text/iuls", "mml":
     "text/mathml", "asc": "text/plain", "txt": "text/plain", "text":
     "text/plain", "pot": "text/plain", "brf": "text/plain", "rtx":
     "text/richtext", "sct": "text/scriptlet", "wsc": "text/scriptlet",
     "tm": "text/texmacs", "ts": "text/texmacs", "tsv":
     "text/tab-separated-values", "jad":
     "text/vnd.sun.j2me.app-descriptor", "wml": "text/vnd.wap.wml",
     "wmls": "text/vnd.wap.wmlscript", "bib": "text/x-bibtex", "boo":
     "text/x-boo", "h++": "text/x-c++hdr", "hpp": "text/x-c++hdr",
     "hxx": "text/x-c++hdr", "hh": "text/x-c++hdr", "c++":
     "text/x-c++src", "cpp": "text/x-c++src", "cxx": "text/x-c++src",
     "cc": "text/x-c++src", "h": "text/x-chdr", "htc":
     "text/x-component", "csh": "text/x-csh", "c": "text/x-csrc", "d":
     "text/x-dsrc", "diff": "text/x-diff", "patch": "text/x-diff", "hs":
     "text/x-haskell", "java": "text/x-java", "lhs":
     "text/x-literate-haskell", "moc": "text/x-moc", "p":
     "text/x-pascal", "pas": "text/x-pascal", "gcd": "text/x-pcs-gcd",
     "pl": "text/x-perl", "pm": "text/x-perl", "py": "text/x-python",
     "scala": "text/x-scala", "etx": "text/x-setext", "sh": "text/x-sh",
     "tcl": "text/x-tcl", "tk": "text/x-tcl", "tex": "text/x-tex",
     "ltx": "text/x-tex", "sty": "text/x-tex", "cls": "text/x-tex",
     "vcs": "text/x-vcalendar", "vcf": "text/x-vcard", "3gp":
     "video/3gpp", "axv": "video/annodex", "dl": "video/dl", "dif":
     "video/dv", "dv": "video/dv", "fli": "video/fli", "gl": "video/gl",
     "mpeg": "video/mpeg", "mpg": "video/mpeg", "mpe": "video/mpeg",
     "mp4": "video/mp4", "qt": "video/quicktime", "mov":
     "video/quicktime", "ogv": "video/ogg", "mxu": "video/vnd.mpegurl",
     "flv": "video/x-flv", "lsf": "video/x-la-asf", "lsx":
     "video/x-la-asf", "mng": "video/x-mng", "asf": "video/x-ms-asf",
     "asx": "video/x-ms-asf", "wm": "video/x-ms-wm", "wmv":
     "video/x-ms-wmv", "wmx": "video/x-ms-wmx", "wvx": "video/x-ms-wvx",
     "avi": "video/x-msvideo", "movie": "video/x-sgi-movie", "mpv":
     "video/x-matroska", "mkv": "video/x-matroska", "ice":
     "x-conference/x-cooltalk", "sisx": "x-epoc/x-sisx-app", "vrm":
     "x-world/x-vrml", "vrml": "x-world/x-vrml", "wrl":
     "x-world/x-vrml"}
          mimes* = {"ez": "application/andrew-inset", "anx": "application/annodex",
                  "atom": "application/atom+xml", "atomcat": "application/atomcat+xml",
                  "atomsrv": "application/atomserv+xml", "lin": "application/bbolin",
                  "cap": "application/cap", "pcap": "application/cap",
                  "cu": "application/cu-seeme", "davmount": "application/davmount+xml",
                  "tsp": "application/dsptype", "es": "application/ecmascript",
                  "spl": "application/futuresplash", "hta": "application/hta",
                  "jar": "application/java-archive",
                  "ser": "application/java-serialized-object",
                  "class": "application/java-vm", "js": "application/javascript",
                  "m3g": "application/m3g", "hqx": "application/mac-binhex40",
                  "cpt": "application/mac-compactpro", "nb": "application/mathematica",
                  "nbp": "application/mathematica", "mdb": "application/msaccess",
                  "doc": "application/msword", "dot": "application/msword",
                  "mxf": "application/mxf", "bin": "application/octet-stream",
                  "oda": "application/oda", "ogx": "application/ogg",
                  "pdf": "application/pdf", "key": "application/pgp-keys",
                  "pgp": "application/pgp-signature", "prf": "application/pics-rules",
                  "ps": "application/postscript", "ai": "application/postscript",
                  "eps": "application/postscript", "epsi": "application/postscript",
                  "epsf": "application/postscript", "eps2": "application/postscript",
                  "eps3": "application/postscript", "rar": "application/rar",
                  "rdf": "application/rdf+xml", "rss": "application/rss+xml",
                  "rtf": "application/rtf", "smi": "application/smil",
                  "smil": "application/smil", "xhtml": "application/xhtml+xml",
                  "xht": "application/xhtml+xml", "xml": "application/xml",
                  "xsl": "application/xml", "xsd": "application/xml",
                  "xspf": "application/xspf+xml", "zip": "application/zip",
                  "apk": "application/vnd.android.package-archive",
                  "cdy": "application/vnd.cinderella",
                  "kml": "application/vnd.google-earth.kml+xml",
                  "kmz": "application/vnd.google-earth.kmz",
                  "xul": "application/vnd.mozilla.xul+xml",
                  "xls": "application/vnd.ms-excel", "xlb": "application/vnd.ms-excel",
                  "xlt": "application/vnd.ms-excel", "cat": "application/vnd.ms-pki.seccat",
                  "stl": "application/vnd.ms-pki.stl",
                  "ppt": "application/vnd.ms-powerpoint",
                  "pps": "application/vnd.ms-powerpoint", "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation", "ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "potx": "application/vnd.openxmlformats-officedocument.presentationml.template", "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
                  "cod": "application/vnd.rim.cod", "mmf": "application/vnd.smaf",
                  "sis": "application/vnd.symbian.install", "vsd": "application/vnd.visio",
                  "wbxml": "application/vnd.wap.wbxml", "wmlc": "application/vnd.wap.wmlc",
                  "wmlsc": "application/vnd.wap.wmlscriptc",
                  "wpd": "application/vnd.wordperfect",
                  "wp5": "application/vnd.wordperfect5.1", "wk": "application/x-123",
                  "7z": "application/x-7z-compressed", "abw": "application/x-abiword",
                  "dmg": "application/x-apple-diskimage", "bcpio": "application/x-bcpio",
                  "torrent": "application/x-bittorrent", "cab": "application/x-cab",
                  "cbr": "application/x-cbr", "cbz": "application/x-cbz",
                  "cdf": "application/x-cdf", "cda": "application/x-cdf",
                  "vcd": "application/x-cdlink", "pgn": "application/x-chess-pgn",
                  "cpio": "application/x-cpio", "csh": "application/x-csh",
                  "deb": "application/x-debian-package",
                  "udeb": "application/x-debian-package", "dcr": "application/x-director",
                  "dir": "application/x-director", "dxr": "application/x-director",
                  "dms": "application/x-dms", "wad": "application/x-doom",
                  "dvi": "application/x-dvi", "rhtml": "application/x-httpd-eruby",
                  "pfa": "application/x-font", "pfb": "application/x-font",
                  "gsf": "application/x-font", "pcf": "application/x-font",
                  "pcf.Z": "application/x-font", "mm": "application/x-freemind",
                  "spl": "application/x-futuresplash", "gnumeric": "application/x-gnumeric",
                  "sgf": "application/x-go-sgf", "gcf": "application/x-graphing-calculator",
                  "gtar": "application/x-gtar", "tgz": "application/x-gtar",
                  "taz": "application/x-gtar", "hdf": "application/x-hdf",
                  "phtml": "application/x-httpd-php", "pht": "application/x-httpd-php",
                  "php": "application/x-httpd-php",
                  "phps": "application/x-httpd-php-source",
                  "php3": "application/x-httpd-php3",
                  "php3p": "application/x-httpd-php3-preprocessed",
                  "php4": "application/x-httpd-php4", "php5": "application/x-httpd-php5",
                  "ica": "application/x-ica", "info": "application/x-info",
                  "ins": "application/x-internet-signup",
                  "isp": "application/x-internet-signup", "iii": "application/x-iphone",
                  "iso": "application/x-iso9660-image", "jam": "application/x-jam",
                  "jnlp": "application/x-java-jnlp-file", "jmz": "application/x-jmol",
                  "chrt": "application/x-kchart", "kil": "application/x-killustrator",
                  "skp": "application/x-koan", "skd": "application/x-koan",
                  "skt": "application/x-koan", "skm": "application/x-koan",
                  "kpr": "application/x-kpresenter", "kpt": "application/x-kpresenter",
                  "ksp": "application/x-kspread", "kwd": "application/x-kword",
                  "kwt": "application/x-kword", "latex": "application/x-latex",
                  "lha": "application/x-lha", "lyx": "application/x-lyx",
                  "lzh": "application/x-lzh", "lzx": "application/x-lzx",
                  "frm": "application/x-maker", "maker": "application/x-maker",
                  "frame": "application/x-maker", "fm": "application/x-maker",
                  "fb": "application/x-maker", "book": "application/x-maker",
                  "fbdoc": "application/x-maker", "mif": "application/x-mif",
                  "wmd": "application/x-ms-wmd", "wmz": "application/x-ms-wmz",
                  "com": "application/x-msdos-program",
                  "exe": "application/x-msdos-program",
                  "bat": "application/x-msdos-program",
                  "dll": "application/x-msdos-program", "msi": "application/x-msi",
                  "nc": "application/x-netcdf", "pac": "application/x-ns-proxy-autoconfig",
                  "dat": "application/x-ns-proxy-autoconfig", "nwc": "application/x-nwc",
                  "o": "application/x-object", "oza": "application/x-oz-application",
                  "p7r": "application/x-pkcs7-certreqresp",
                  "crl": "application/x-pkcs7-crl", "pyc": "application/x-python-code",
                  "pyo": "application/x-python-code", "qgs": "application/x-qgis",
                  "shp": "application/x-qgis", "shx": "application/x-qgis",
                  "qtl": "application/x-quicktimeplayer",
                  "rpm": "application/x-redhat-package-manager", "rb": "application/x-ruby",
                  "sh": "application/x-sh", "shar": "application/x-shar",
                  "swf": "application/x-shockwave-flash",
                  "swfl": "application/x-shockwave-flash",
                  "scr": "application/x-silverlight", "sit": "application/x-stuffit",
                  "sitx": "application/x-stuffit", "sv4cpio": "application/x-sv4cpio",
                  "sv4crc": "application/x-sv4crc", "tar": "application/x-tar",
                  "tcl": "application/x-tcl", "gf": "application/x-tex-gf",
                  "pk": "application/x-tex-pk", "texinfo": "application/x-texinfo",
                  "texi": "application/x-texinfo", "~": "application/x-trash",
                  "%": "application/x-trash", "bak": "application/x-trash",
                  "old": "application/x-trash", "sik": "application/x-trash",
                  "t": "application/x-troff", "tr": "application/x-troff",
                  "roff": "application/x-troff", "man": "application/x-troff-man",
                  "me": "application/x-troff-me", "ms": "application/x-troff-ms",
                  "ustar": "application/x-ustar", "src": "application/x-wais-source",
                  "wz": "application/x-wingz", "crt": "application/x-x509-ca-cert",
                  "xcf": "application/x-xcf", "fig": "application/x-xfig",
                  "xpi": "application/x-xpinstall", "amr": "audio/amr", "awb": "audio/amr-wb",
                  "amr": "audio/amr", "awb": "audio/amr-wb", "axa": "audio/annodex",
                  "au": "audio/basic", "snd": "audio/basic", "flac": "audio/flac",
                  "mid": "audio/midi", "midi": "audio/midi", "kar": "audio/midi",
                  "mpga": "audio/mpeg", "mpega": "audio/mpeg", "mp2": "audio/mpeg",
                  "mp3": "audio/mpeg", "m4a": "audio/mpeg", "m3u": "audio/mpegurl",
                  "oga": "audio/ogg", "ogg": "audio/ogg", "spx": "audio/ogg",
                  "sid": "audio/prs.sid", "aif": "audio/x-aiff", "aiff": "audio/x-aiff",
                  "aifc": "audio/x-aiff", "gsm": "audio/x-gsm", "m3u": "audio/x-mpegurl",
                  "wma": "audio/x-ms-wma", "wax": "audio/x-ms-wax",
                  "ra": "audio/x-pn-realaudio", "rm": "audio/x-pn-realaudio",
                  "ram": "audio/x-pn-realaudio", "ra": "audio/x-realaudio",
                  "pls": "audio/x-scpls", "sd2": "audio/x-sd2", "wav": "audio/x-wav",
                  "alc": "chemical/x-alchemy", "cac": "chemical/x-cache",
                  "cache": "chemical/x-cache", "csf": "chemical/x-cache-csf",
                  "cbin": "chemical/x-cactvs-binary", "cascii": "chemical/x-cactvs-binary",
                  "ctab": "chemical/x-cactvs-binary", "cdx": "chemical/x-cdx",
                  "cer": "chemical/x-cerius", "c3d": "chemical/x-chem3d",
                  "chm": "chemical/x-chemdraw", "cif": "chemical/x-cif",
                  "cmdf": "chemical/x-cmdf", "cml": "chemical/x-cml",
                  "cpa": "chemical/x-compass", "bsd": "chemical/x-crossfire",
                  "csml": "chemical/x-csml", "csm": "chemical/x-csml",
                  "ctx": "chemical/x-ctx", "cxf": "chemical/x-cxf", "cef": "chemical/x-cxf",
                  "smi": "#chemical/x-daylight-smiles",
                  "emb": "chemical/x-embl-dl-nucleotide",
                  "embl": "chemical/x-embl-dl-nucleotide", "spc": "chemical/x-galactic-spc",
                  "inp": "chemical/x-gamess-input", "gam": "chemical/x-gamess-input",
                  "gamin": "chemical/x-gamess-input",
                  "fch": "chemical/x-gaussian-checkpoint",
                  "fchk": "chemical/x-gaussian-checkpoint",
                  "cub": "chemical/x-gaussian-cube", "gau": "chemical/x-gaussian-input",
                  "gjc": "chemical/x-gaussian-input", "gjf": "chemical/x-gaussian-input",
                  "gal": "chemical/x-gaussian-log", "gcg": "chemical/x-gcg8-sequence",
                  "gen": "chemical/x-genbank", "hin": "chemical/x-hin",
                  "istr": "chemical/x-isostar", "ist": "chemical/x-isostar",
                  "jdx": "chemical/x-jcamp-dx", "dx": "chemical/x-jcamp-dx",
                  "kin": "chemical/x-kinemage", "mcm": "chemical/x-macmolecule",
                  "mmd": "chemical/x-macromodel-input",
                  "mmod": "chemical/x-macromodel-input", "mol": "chemical/x-mdl-molfile",
                  "rd": "chemical/x-mdl-rdfile", "rxn": "chemical/x-mdl-rxnfile",
                  "sd": "chemical/x-mdl-sdfile", "sdf": "chemical/x-mdl-sdfile",
                  "tgf": "chemical/x-mdl-tgf", "mif": "#chemical/x-mif",
                  "mcif": "chemical/x-mmcif", "mol2": "chemical/x-mol2",
                  "b": "chemical/x-molconn-Z", "gpt": "chemical/x-mopac-graph",
                  "mop": "chemical/x-mopac-input", "mopcrt": "chemical/x-mopac-input",
                  "mpc": "chemical/x-mopac-input", "zmt": "chemical/x-mopac-input",
                  "moo": "chemical/x-mopac-out", "mvb": "chemical/x-mopac-vib",
                  "asn": "chemical/x-ncbi-asn1", "prt": "chemical/x-ncbi-asn1-ascii",
                  "ent": "chemical/x-ncbi-asn1-ascii", "val": "chemical/x-ncbi-asn1-binary",
                  "aso": "chemical/x-ncbi-asn1-binary", "asn": "chemical/x-ncbi-asn1-spec",
                  "pdb": "chemical/x-pdb", "ent": "chemical/x-pdb",
                  "ros": "chemical/x-rosdal", "sw": "chemical/x-swissprot",
                  "vms": "chemical/x-vamas-iso14976", "vmd": "chemical/x-vmd",
                  "xtel": "chemical/x-xtel", "xyz": "chemical/x-xyz", "gif": "image/gif",
                  "ief": "image/ief", "jpeg": "image/jpeg", "jpg": "image/jpeg",
                  "jpe": "image/jpeg", "pcx": "image/pcx", "png": "image/png",
                  "svg": "image/svg+xml", "svgz": "image/svg+xml", "tiff": "image/tiff",
                  "tif": "image/tiff", "djvu": "image/vnd.djvu", "djv": "image/vnd.djvu",
                  "wbmp": "image/vnd.wap.wbmp", "cr2": "image/x-canon-cr2",
                  "crw": "image/x-canon-crw", "ras": "image/x-cmu-raster",
                  "cdr": "image/x-coreldraw", "pat": "image/x-coreldrawpattern",
                  "cdt": "image/x-coreldrawtemplate", "cpt": "image/x-corelphotopaint",
                  "erf": "image/x-epson-erf", "ico": "image/x-icon", "art": "image/x-jg",
                  "jng": "image/x-jng", "bmp": "image/x-ms-bmp", "nef": "image/x-nikon-nef",
                  "orf": "image/x-olympus-orf", "psd": "image/x-photoshop",
                  "pnm": "image/x-portable-anymap", "pbm": "image/x-portable-bitmap",
                  "pgm": "image/x-portable-graymap", "ppm": "image/x-portable-pixmap",
                  "rgb": "image/x-rgb", "xbm": "image/x-xbitmap", "xpm": "image/x-xpixmap",
                  "xwd": "image/x-xwindowdump", "eml": "message/rfc822", "igs": "model/iges",
                  "iges": "model/iges", "msh": "model/mesh", "mesh": "model/mesh",
                  "silo": "model/mesh", "wrl": "model/vrml", "vrml": "model/vrml",
                  "x3dv": "model/x3d+vrml", "x3d": "model/x3d+xml",
                  "x3db": "model/x3d+binary", "manifest": "text/cache-manifest",
                  "ics": "text/calendar", "icz": "text/calendar", "css": "text/css",
                  "csv": "text/csv", "323": "text/h323", "html": "text/html",
                  "htm": "text/html", "shtml": "text/html", "uls": "text/iuls",
                  "mml": "text/mathml", "asc": "text/plain", "txt": "text/plain",
                  "text": "text/plain", "pot": "text/plain", "brf": "text/plain",
                  "rtx": "text/richtext", "sct": "text/scriptlet", "wsc": "text/scriptlet",
                  "tm": "text/texmacs", "ts": "text/texmacs",
                  "tsv": "text/tab-separated-values",
                  "jad": "text/vnd.sun.j2me.app-descriptor", "wml": "text/vnd.wap.wml",
                  "wmls": "text/vnd.wap.wmlscript", "bib": "text/x-bibtex",
                  "boo": "text/x-boo", "h++": "text/x-c++hdr", "hpp": "text/x-c++hdr",
                  "hxx": "text/x-c++hdr", "hh": "text/x-c++hdr", "c++": "text/x-c++src",
                  "cpp": "text/x-c++src", "cxx": "text/x-c++src", "cc": "text/x-c++src",
                  "h": "text/x-chdr", "htc": "text/x-component", "csh": "text/x-csh",
                  "c": "text/x-csrc", "d": "text/x-dsrc", "diff": "text/x-diff",
                  "patch": "text/x-diff", "hs": "text/x-haskell", "java": "text/x-java",
                  "lhs": "text/x-literate-haskell", "moc": "text/x-moc", "p": "text/x-pascal",
                  "pas": "text/x-pascal", "gcd": "text/x-pcs-gcd", "pl": "text/x-perl",
                  "pm": "text/x-perl", "py": "text/x-python", "scala": "text/x-scala",
                  "etx": "text/x-setext", "sh": "text/x-sh", "tcl": "text/x-tcl",
                  "tk": "text/x-tcl", "tex": "text/x-tex", "ltx": "text/x-tex",
                  "sty": "text/x-tex", "cls": "text/x-tex", "vcs": "text/x-vcalendar",
                  "vcf": "text/x-vcard", "3gp": "video/3gpp", "axv": "video/annodex",
                  "dl": "video/dl", "dif": "video/dv", "dv": "video/dv", "fli": "video/fli",
                  "gl": "video/gl", "mpeg": "video/mpeg", "mpg": "video/mpeg",
                  "mpe": "video/mpeg", "mp4": "video/mp4", "qt": "video/quicktime",
                  "mov": "video/quicktime", "ogv": "video/ogg", "mxu": "video/vnd.mpegurl",
                  "flv": "video/x-flv", "lsf": "video/x-la-asf", "lsx": "video/x-la-asf",
                  "mng": "video/x-mng", "asf": "video/x-ms-asf", "asx": "video/x-ms-asf",
                  "wm": "video/x-ms-wm", "wmv": "video/x-ms-wmv", "wmx": "video/x-ms-wmx",
                  "wvx": "video/x-ms-wvx", "avi": "video/x-msvideo",
                  "movie": "video/x-sgi-movie", "mpv": "video/x-matroska",
                  "mkv": "video/x-matroska", "ice": "x-conference/x-cooltalk",
                  "sisx": "x-epoc/x-sisx-app", "vrm": "x-world/x-vrml",
                  "vrml": "x-world/x-vrml", "wrl": "x-world/x-vrml"}

169 Types
*********

   * MimeDB mimes: StringTableRef

          MimeDB* = object
            mimes: StringTableRef


170 Procedures
**************

   * newMimetypes
          proc newMimetypes*(): MimeDB

     Creates a new Mimetypes database.  The database will contain the
     most common mimetypes.

   * getMimetype
          proc getMimetype*(mimedb: MimeDB; ext: string; default = "text/plain"): string

     Gets mimetype which corresponds to 'ext'.  Returns 'default' if
     'ext' could not be found.

   * getExt
          proc getExt*(mimedb: MimeDB; mimetype: string; default = "txt"): string

     Gets extension which corresponds to 'mimetype'.  Returns 'default'
     if 'mimetype' could not be found.  Extensions are returned without
     the leading dot.

   * register
          proc register*(mimedb: var MimeDB; ext: string; mimetype: string)

     Adds 'mimetype' to the 'mimedb'.


File: nim-ref-0.13.0.info,  Node: /pure/rationals,  Next: /pure/selectors,  Prev: /pure/mimetypes,  Up: Top

171 Types
*********

   * Rational num*, den*: T

          Rational*[T] = object
            num*, den*: T


     a rational number, consisting of a numerator and denominator

172 Procedures
**************

   * initRational
          proc initRational*[T: SomeInteger](num, den: T): Rational[T]

     Create a new rational number.

   * '//'
          proc `//`*[T](num, den: T): Rational[T]

     A friendlier version of initRational.  Example usage:
     var x = 1//3 + 1//5

   * '$'
          proc `$`*[T](x: Rational[T]): string

     Turn a rational number into a string.

   * toRational
          proc toRational*[T: SomeInteger](x: T): Rational[T]

     Convert some integer x to a rational number.

   * toRational
          proc toRational*(x: float; n: int = high(int)): Rational[int]

     Calculate the best rational numerator and denominator that
     approximates to x, where the denominator is smaller than n (default
     is the largest possible int to give maximum resolution)

     The algorithm is based on the Farey sequence named after John Farey
     import math, rationals
     for i in 1..10:
       let t = (10 ^ (i+3)).int
       let x = toRational(PI, t)
       let newPI = x.num / x.den
       echo x, " ", newPI, " error: ", PI - newPI, "  ", t

   * toFloat
          proc toFloat*[T](x: Rational[T]): float

     Convert a rational number x to a float.

   * toInt
          proc toInt*[T](x: Rational[T]): int

     Convert a rational number x to an int.  Conversion rounds towards 0
     if x does not contain an integer value.

   * reduce
          proc reduce*[T: SomeInteger](x: var Rational[T])

     Reduce rational x.

   * '+'
          proc `+`*[T](x, y: Rational[T]): Rational[T]

     Add two rational numbers.

   * '+'
          proc `+`*[T](x: Rational[T]; y: T): Rational[T]

     Add rational x to int y.

   * '+'
          proc `+`*[T](x: T; y: Rational[T]): Rational[T]

     Add int x to rational y.

   * '+='
          proc `+=`*[T](x: var Rational[T]; y: Rational[T])

     Add rational y to rational x.

   * '+='
          proc `+=`*[T](x: var Rational[T]; y: T)

     Add int y to rational x.

   * '-'
          proc `-`*[T](x: Rational[T]): Rational[T]

     Unary minus for rational numbers.

   * '-'
          proc `-`*[T](x, y: Rational[T]): Rational[T]

     Subtract two rational numbers.

   * '-'
          proc `-`*[T](x: Rational[T]; y: T): Rational[T]

     Subtract int y from rational x.

   * '-'
          proc `-`*[T](x: T; y: Rational[T]): Rational[T]

     Subtract rational y from int x.

   * '-='
          proc `-=`*[T](x: var Rational[T]; y: Rational[T])

     Subtract rational y from rational x.

   * '-='
          proc `-=`*[T](x: var Rational[T]; y: T)

     Subtract int y from rational x.

   * '*'
          proc `*`*[T](x, y: Rational[T]): Rational[T]

     Multiply two rational numbers.

   * '*'
          proc `*`*[T](x: Rational[T]; y: T): Rational[T]

     Multiply rational x with int y.

   * '*'
          proc `*`*[T](x: T; y: Rational[T]): Rational[T]

     Multiply int x with rational y.

   * '*='
          proc `*=`*[T](x: var Rational[T]; y: Rational[T])

     Multiply rationals y to x.

   * '*='
          proc `*=`*[T](x: var Rational[T]; y: T)

     Multiply int y to rational x.

   * reciprocal
          proc reciprocal*[T](x: Rational[T]): Rational[T]

     Calculate the reciprocal of x.  (1/x)

   * '/'
          proc `/`*[T](x, y: Rational[T]): Rational[T]

     Divide rationals x by y.

   * '/'
          proc `/`*[T](x: Rational[T]; y: T): Rational[T]

     Divide rational x by int y.

   * '/'
          proc `/`*[T](x: T; y: Rational[T]): Rational[T]

     Divide int x by Rational y.

   * '/='
          proc `/=`*[T](x: var Rational[T]; y: Rational[T])

     Divide rationals x by y in place.

   * '/='
          proc `/=`*[T](x: var Rational[T]; y: T)

     Divide rational x by int y in place.

   * cmp
          proc cmp*(x, y: Rational): int {.procvar.}

     Compares two rationals.

   * '&lt;'
          proc `<`*(x, y: Rational): bool

   * '&lt;='
          proc `<=`*(x, y: Rational): bool

   * '=='
          proc `==`*(x, y: Rational): bool

   * abs
          proc abs*[T](x: Rational[T]): Rational[T]

   * hash
          proc hash*[T](x: Rational[T]): Hash

     Computes hash for rational x


File: nim-ref-0.13.0.info,  Node: /pure/selectors,  Next: /pure/mersenne,  Prev: /pure/rationals,  Up: Top

173 Types
*********

   * ReadyInfo
          ReadyInfo* = tuple[key: SelectorKey, events: set[Event]]

   * Selector

          Selector* = ref object


     An object which holds file descriptors to be checked for read/write
     status.

174 Procedures
**************

   * hash
          proc hash*(x: SocketHandle): Hash {.borrow.}

   * '$'
          proc `$`*(x: SocketHandle): string {.borrow.}

   * register discardable.}
          proc register*(s: Selector; fd: SocketHandle; events: set[Event]; data: SelectorData): SelectorKey {.
              discardable.}

     Registers file descriptor 'fd' to selector 's' with a set of Event
     'events'.

   * update discardable.}
          proc update*(s: Selector; fd: SocketHandle; events: set[Event]): SelectorKey {.
              discardable.}

     Updates the events which 'fd' wants notifications for.

   * unregister
          proc unregister*(s: Selector; fd: SocketHandle): SelectorKey {.discardable.}

     Unregisters file descriptor 'fd' from selector 's'.

   * close
          proc close*(s: Selector)

     Closes the selector

   * select
          proc select*(s: Selector; timeout: int): seq[ReadyInfo]

     The 'events' field of the returned 'key' contains the original
     events for which the 'fd' was bound.  This is contrary to the
     'events' field of the 'ReadyInfo' tuple which determines which
     events are ready on the 'fd'.

   * newSelector
          proc newSelector*(): Selector

     Creates a new selector

   * contains
          proc contains*(s: Selector; fd: SocketHandle): bool

     Determines whether selector contains a file descriptor.

   * '[]'
          proc `[]`*(s: Selector; fd: SocketHandle): SelectorKey

     Retrieves the selector key for 'fd'.

   * contains
          proc contains*(s: Selector; key: SelectorKey): bool

     Determines whether selector contains this selector key.  More
     accurate than checking if the file descriptor is in the selector
     because it ensures that the keys are equal.  File descriptors may
     not always be unique especially when an fd is closed and then a new
     one is opened, the new one may have the same value.


File: nim-ref-0.13.0.info,  Node: /pure/mersenne,  Next: /pure/browsers,  Prev: /pure/selectors,  Up: Top

175 Types
*********

   * MersenneTwister mt: array[0 ..  623, uint32] index: int

          MersenneTwister* = object
            mt: array[0 .. 623, uint32]
            index: int


176 Procedures
**************

   * newMersenneTwister
          proc newMersenneTwister*(seed: int): MersenneTwister

   * getNum
          proc getNum*(m: var MersenneTwister): int


File: nim-ref-0.13.0.info,  Node: /pure/browsers,  Next: /pure/parseopt,  Prev: /pure/mersenne,  Up: Top

177 Procedures
**************

   * openDefaultBrowser
          proc openDefaultBrowser*(url: string)

     opens url with the user's default browser.  This does not block.

     Under Windows, 'ShellExecute' is used.  Under Mac OS X the 'open'
     command is used.  Under Unix, it is checked if 'gnome-open' exists
     and used if it does.  Next attempt is 'kde-open', then 'xdg-open'.
     Otherwise the environment variable 'BROWSER' is used to determine
     the default browser to use.


File: nim-ref-0.13.0.info,  Node: /pure/parseopt,  Next: /pure/memfiles,  Prev: /pure/browsers,  Up: Top

178 Types
*********

   * OptParser cmd: string pos: int inShortState: bool kind*:
     CmdLineKind ## the dected command line token key*, val*:
     TaintedString ## key and value pair; "key" is the option ## or the
     argument, "value" is not "" if ## the option was given a value

          OptParser* = object of RootObj
            cmd: string
            pos: int
            inShortState: bool
            kind*: CmdLineKind           ## the dected command line token
            key*, val*: TaintedString     ## key and value pair; ``key`` is the option
                                   ## or the argument, ``value`` is not "" if
                                   ## the option was given a value


     this object implements the command line parser

179 Procedures
**************

   * initOptParser
          proc initOptParser*(cmdline = ""): OptParser

     inits the option parser.  If 'cmdline == ""', the real command line
     (as provided by the 'OS' module) is taken.

   * next
          proc next*(p: var OptParser) {.rtl, extern: "npo$1".}

     parses the first or next option; 'p.kind' describes what token has
     been parsed.  'p.key' and 'p.val' are set accordingly.

   * cmdLineRest
          proc cmdLineRest*(p: OptParser): TaintedString {.rtl, extern: "npo$1".}

     retrieves the rest of the command line that has not been parsed
     yet.

180 Iterators
*************

   * getopt
          iterator getopt*(): tuple[kind: CmdLineKind, key, val: TaintedString]

     This is an convenience iterator for iterating over the command
     line.  This uses the OptParser object.  Example:
     var
       filename = ""
     for kind, key, val in getopt():
       case kind
       of cmdArgument:
         filename = key
       of cmdLongOption, cmdShortOption:
         case key
         of "help", "h": writeHelp()
         of "version", "v": writeVersion()
       of cmdEnd: assert(false) # cannot happen
     if filename == "":
       # no filename has been given, so we show the help:
       writeHelp()


File: nim-ref-0.13.0.info,  Node: /pure/memfiles,  Next: /pure/asyncfile,  Prev: /pure/parseopt,  Up: Top

181 Types
*********

   * MemFile mem*: pointer ## a pointer to the memory mapped file.  The
     pointer ## can be used directly to change the contents of the ##
     file, if it was opened with write access.  size*: int ## size of
     the memory mapped file when defined(windows): fHandle: Handle
     mapHandle: Handle wasOpened: bool ## only close if wasOpened

     else: handle: cint

          MemFile* = object
            mem*: pointer                ## a pointer to the memory mapped file. The pointer
                        ## can be used directly to change the contents of the
                        ## file, if it was opened with write access.
            size*: int                   ## size of the memory mapped file
            when defined(windows):
                fHandle: Handle
                mapHandle: Handle
                wasOpened: bool          ## only close if wasOpened

            else:
                handle: cint



     represents a memory mapped file

   * MemSlice data*: pointer size*: int

          MemSlice* = object
            data*: pointer
            size*: int


     represent slice of a MemFile for iteration over delimited
     lines/records

182 Procedures
**************

   * mapMem
          proc mapMem*(m: var MemFile; mode: FileMode = fmRead; mappedSize = - 1; offset = 0): pointer

   * unmapMem
          proc unmapMem*(f: var MemFile; p: pointer; size: int)

     unmaps the memory region '(p, <p+size)' of the mapped file f.  All
     changes are written back to the file system, if f was opened with
     write access.  'size' must be of exactly the size that was
     requested via 'mapMem'.

   * open newFileSize = - 1): MemFile
          proc open*(filename: string; mode: FileMode = fmRead; mappedSize = - 1; offset = 0;
                    newFileSize = - 1): MemFile

     opens a memory mapped file.  If this fails, 'EOS' is raised.
     newFileSize can only be set if the file does not exist and is
     opened with write access (e.g., with fmReadWrite).  mappedSize and
     offset can be used to map only a slice of the file.  Example:
     var
       mm, mm_full, mm_half: MemFile

     mm = memfiles.open("/tmp/test.mmap", mode = fmWrite, newFileSize = 1024)    # Create a new file
     mm.close()

     # Read the whole file, would fail if newFileSize was set
     mm_full = memfiles.open("/tmp/test.mmap", mode = fmReadWrite, mappedSize = -1)

     # Read the first 512 bytes
     mm_half = memfiles.open("/tmp/test.mmap", mode = fmReadWrite, mappedSize = 512)

   * close
          proc close*(f: var MemFile)

     closes the memory mapped file f.  All changes are written back to
     the file system, if f was opened with write access.

   * '$'
          proc `$`*(ms: MemSlice): string {.inline.}

     Return a Nim string built from a MemSlice.

183 Iterators
*************

   * memSlices
          iterator memSlices*(mfile: MemFile; delim = '\x0A'; eat = '\x0D'): MemSlice {.inline.}

     Iterates over [optional eat] delim-delimited slices in MemFile
     mfile.

     Default parameters parse lines ending in either Unix(\l) or
     Windows(\r\l) style on on a line-by-line basis.  I.e., not every
     line needs the same ending.  Unlike readLine(File) & lines(File),
     archaic MacOS9 \r-delimited lines are not supported as a third
     option for each line.  Such archaic MacOS9 files can be handled by
     passing delim='\r', eat='\0', though.

     Delimiters are not part of the returned slice.  A final,
     unterminated line or record is returned just like any other.

     Non-default delimiters can be passed to allow iteration over other
     sorts of "line-like" variable length records.  Pass eat='\0' to be
     strictly delim-delimited.  (Eating an optional prefix equal to '\0'
     is not supported.)

     This zero copy, memchr-limited interface is probably the fastest
     way to iterate over line-like records in a file.  However, returned
     (data,size) objects are not Nim strings, bounds checked Nim arrays,
     or even terminated C strings.  So, care is required to access the
     data (e.g., think C mem* functions, not str* functions).  Example:
     var count = 0
     for slice in memSlices(memfiles.open("foo")):
       if slice.size > 0 and cast[cstring](slice.data)[0] != '#':
         inc(count)
     echo count

   * lines inline.}
          iterator lines*(mfile: MemFile; buf: var TaintedString; delim = '\x0A'; eat = '\x0D'): TaintedString {.
              inline.}

     Replace contents of passed buffer with each new line, like
     readLine(File) (system.html#readLine,File,TaintedString).  delim,
     eat, and delimiting logic is exactly as for memSlices (#memSlices),
     but Nim strings are returned.  Example:
     var buffer: TaintedString = ""
     for line in lines(memfiles.open("foo"), buffer):
       echo line

   * lines
          iterator lines*(mfile: MemFile; delim = '\x0A'; eat = '\x0D'): TaintedString {.inline.}

     Return each line in a file as a Nim string, like lines(File)
     (system.html#lines.i,File).  delim, eat, and delimiting logic is
     exactly as for memSlices (#memSlices), but Nim strings are
     returned.  Example:
     for line in lines(memfiles.open("foo")):
       echo line


File: nim-ref-0.13.0.info,  Node: /pure/asyncfile,  Next: /pure/osproc,  Prev: /pure/memfiles,  Up: Top

184 Types
*********

   * AsyncFile fd: AsyncFd offset: int64

          AsyncFile* = ref object
            fd: AsyncFd
            offset: int64


185 Procedures
**************

   * openAsync
          proc openAsync*(filename: string; mode = fmRead): AsyncFile

     Opens a file specified by the path in 'filename' using the
     specified 'mode' asynchronously.

   * read
          proc read*(f: AsyncFile; size: int): Future[string]

     Read 'size' bytes from the specified file asynchronously starting
     at the current position of the file pointer.

     If the file pointer is past the end of the file then an empty
     string is returned.

   * readLine
          proc readLine*(f: AsyncFile): Future[string] {.async.}

     Reads a single line from the specified file asynchronously.

   * getFilePos
          proc getFilePos*(f: AsyncFile): int64

     Retrieves the current position of the file pointer that is used to
     read from the specified file.  The file's first byte has the index
     zero.

   * setFilePos
          proc setFilePos*(f: AsyncFile; pos: int64)

     Sets the position of the file pointer that is used for read/write
     operations.  The file's first byte has the index zero.

   * readAll
          proc readAll*(f: AsyncFile): Future[string] {.async.}

     Reads all data from the specified file.

   * write
          proc write*(f: AsyncFile; data: string): Future[void]

     Writes 'data' to the file specified asynchronously.

     The returned Future will complete once all data has been written to
     the specified file.

   * close
          proc close*(f: AsyncFile)

     Closes the file specified.


File: nim-ref-0.13.0.info,  Node: /pure/osproc,  Next: /pure/endians,  Prev: /pure/asyncfile,  Up: Top

186 Constant variables
**********************

   * poUseShell
          poUseShell* {.deprecated.} = poUsePath

     Deprecated alias for poUsePath.

187 Types
*********

   * Process
          Process* = ref ProcessObj

     represents an operating system process

188 Procedures
**************

   * quoteShellWindows
          proc quoteShellWindows*(s: string): string {.noSideEffect, rtl, extern: "nosp$1".}

     Quote s, so it can be safely passed to Windows API. Based on
     Python's subprocess.list2cmdline See
     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
     (http://msdn.microsoft.com/en-us/library/17w5ykft.aspx)

   * quoteShellPosix
          proc quoteShellPosix*(s: string): string {.noSideEffect, rtl, extern: "nosp$1".}

     Quote s, so it can be safely passed to POSIX shell.  Based on
     Python's pipes.quote

   * quoteShell
          proc quoteShell*(s: string): string {.noSideEffect, rtl, extern: "nosp$1".}

     Quote s, so it can be safely passed to shell.

   * execProcess env: StringTableRef = nil; options: set[ProcessOption]
     = { poStdErrToStdOut, poUsePath, poEvalCommand}): TaintedString
     {.rtl, extern: "nosp$1", tags: [ExecIOEffect, ReadIOEffect].}
          proc execProcess*(command: string; args: openArray[string] = [];
                           env: StringTableRef = nil; options: set[ProcessOption] = {
              poStdErrToStdOut, poUsePath, poEvalCommand}): TaintedString {.rtl,
              extern: "nosp$1", tags: [ExecIOEffect, ReadIOEffect].}

     A convenience procedure that executes 'command' with 'startProcess'
     and returns its output as a string.  WARNING: this function uses
     poEvalCommand by default for backward compatibility.  Make sure to
     pass options explicitly.
     let outp = execProcess("nim c -r mytestfile.nim")
     # Note: outp may have an interleave of text from the nim compile
     # and any output from mytestfile when it runs

   * execCmd
          proc execCmd*(command: string): int {.rtl, extern: "nosp$1", tags: [ExecIOEffect].}

     Executes 'command' and returns its error code.  Standard input,
     output, error streams are inherited from the calling process.  This
     operation is also often called system.
     let errC = execCmd("nim c -r mytestfile.nim")

   * startProcess args: openArray[string] = []; env: StringTableRef =
     nil; options: set[ProcessOption] = {poStdErrToStdOut}): Process
     {.rtl, extern: "nosp$1", tags: [ExecIOEffect, ReadEnvEffect].}
          proc startProcess*(command: string; workingDir: string = "";
                            args: openArray[string] = []; env: StringTableRef = nil;
                            options: set[ProcessOption] = {poStdErrToStdOut}): Process {.rtl,
              extern: "nosp$1", tags: [ExecIOEffect, ReadEnvEffect].}

     Starts a process.  Command is the executable file, workingDir is
     the process's working directory.  If 'workingDir == ""' the current
     directory is used.  args are the command line arguments that are
     passed to the process.  On many operating systems, the first
     command line argument is the name of the executable.  args should
     not contain this argument!  env is the environment that will be
     passed to the process.  If 'env == nil' the environment is
     inherited of the parent process.  options are additional flags that
     may be passed to startProcess.  See the documentation of
     'ProcessOption' for the meaning of these flags.  You need to close
     the process when done.

     Note that you can't pass any args if you use the option
     'poEvalCommand', which invokes the system shell to run the
     specified command.  In this situation you have to concatenate
     manually the contents of args to command carefully escaping/quoting
     any special characters, since it will be passed _as is_ to the
     system shell.  Each system/shell may feature different escaping
     rules, so try to avoid this kind of shell invocation if possible as
     it leads to non portable software.

     Return value: The newly created process object.  Nil is never
     returned, but 'EOS' is raised in case of an error.

   * startCmd options: set[ProcessOption] = {poStdErrToStdOut,
     poUsePath}): Process {.  tags: [ExecIOEffect, ReadEnvEffect],
     deprecated.}
          proc startCmd*(command: string;
                        options: set[ProcessOption] = {poStdErrToStdOut, poUsePath}): Process {.
              tags: [ExecIOEffect, ReadEnvEffect], deprecated.}

     Deprecated - use startProcess directly.

   * close
          proc close*(p: Process) {.rtl, extern: "nosp$1", tags: [].}

     When the process has finished executing, cleanup related handles

   * suspend
          proc suspend*(p: Process) {.rtl, extern: "nosp$1", tags: [].}

     Suspends the process p.

   * resume
          proc resume*(p: Process) {.rtl, extern: "nosp$1", tags: [].}

     Resumes the process p.

   * terminate
          proc terminate*(p: Process) {.rtl, extern: "nosp$1", tags: [].}

     Stop the process p.  On Posix OSes the procedure sends 'SIGTERM' to
     the process.  On Windows the Win32 API function
     'TerminateProcess()' is called to stop the process.

   * kill
          proc kill*(p: Process) {.rtl, extern: "nosp$1", tags: [].}

     Kill the process p.  On Posix OSes the procedure sends 'SIGKILL' to
     the process.  On Windows 'kill()' is simply an alias for
     'terminate()'.

   * running
          proc running*(p: Process): bool {.rtl, extern: "nosp$1", tags: [].}

     Returns true iff the process p is still running.  Returns
     immediately.

   * processID
          proc processID*(p: Process): int {.rtl, extern: "nosp$1".}

     returns p's process ID.

   * waitForExit
          proc waitForExit*(p: Process; timeout: int = - 1): int {.rtl, extern: "nosp$1", tags: [].}

     waits for the process to finish and returns p's error code.

     *Warning*: Be careful when using waitForExit for processes created
     without poParentStreams because they may fill output buffers,
     causing deadlock.

   * peekExitCode
          proc peekExitCode*(p: Process): int {.tags: [].}

     return -1 if the process is still running.  Otherwise the process'
     exit code

   * inputStream
          proc inputStream*(p: Process): Stream {.rtl, extern: "nosp$1", tags: [].}

     returns 'p''s input stream for writing to.

     *Warning*: The returned Stream should not be closed manually as it
     is closed when closing the Process 'p'.

   * outputStream
          proc outputStream*(p: Process): Stream {.rtl, extern: "nosp$1", tags: [].}

     returns 'p''s output stream for reading from.

     *Warning*: The returned Stream should not be closed manually as it
     is closed when closing the Process 'p'.

   * errorStream
          proc errorStream*(p: Process): Stream {.rtl, extern: "nosp$1", tags: [].}

     returns 'p''s error stream for reading from.

     *Warning*: The returned Stream should not be closed manually as it
     is closed when closing the Process 'p'.

   * inputHandle
          proc inputHandle*(p: Process): FileHandle {.rtl, extern: "nosp$1", tags: [].}

     returns 'p''s input file handle for writing to.

     *Warning*: The returned FileHandle should not be closed manually as
     it is closed when closing the Process 'p'.

   * outputHandle
          proc outputHandle*(p: Process): FileHandle {.rtl, extern: "nosp$1", tags: [].}

     returns 'p''s output file handle for reading from.

     *Warning*: The returned FileHandle should not be closed manually as
     it is closed when closing the Process 'p'.

   * errorHandle
          proc errorHandle*(p: Process): FileHandle {.rtl, extern: "nosp$1", tags: [].}

     returns 'p''s error file handle for reading from.

     *Warning*: The returned FileHandle should not be closed manually as
     it is closed when closing the Process 'p'.

   * countProcessors
          proc countProcessors*(): int {.rtl, extern: "nosp$1".}

     returns the numer of the processors/cores the machine has.  Returns
     0 if it cannot be detected.

   * execProcesses options = {poStdErrToStdOut, poParentStreams}; n =
     countProcessors(); beforeRunEvent: proc (idx: int) = nil;
     afterRunEvent: proc (idx: int; p: Process) = nil): int {.rtl,
     extern: "nosp$1", tags: [ExecIOEffect, TimeEffect, ReadEnvEffect,
     RootEffect].}
          proc execProcesses*(cmds: openArray[string];
                             options = {poStdErrToStdOut, poParentStreams};
                             n = countProcessors(); beforeRunEvent: proc (idx: int) = nil;
                             afterRunEvent: proc (idx: int; p: Process) = nil): int {.rtl,
              extern: "nosp$1", tags: [ExecIOEffect, TimeEffect, ReadEnvEffect, RootEffect].}

     executes the commands cmds in parallel.  Creates n processes that
     execute in parallel.  The highest return value of all processes is
     returned.  Runs beforeRunEvent before running each command.

   * select
          proc select*(readfds: var seq[Process]; timeout = 500): int {.benign.}

     select with a sensible Nim interface.  timeout is in milliseconds.
     Specify -1 for no timeout.  Returns the number of processes that
     are ready to read from.  The processes that are ready to be read
     from are removed from readfds.

     *Warning*: This function may give unexpected or completely wrong
     results on Windows.

   * hasData
          proc hasData*(p: Process): bool

   * execCmdEx options: set[ProcessOption] = {poStdErrToStdOut,
     poUsePath}): tuple[ output: TaintedString, exitCode: int] {.tags:
     [ExecIOEffect, ReadIOEffect], gcsafe.}
          proc execCmdEx*(command: string;
                         options: set[ProcessOption] = {poStdErrToStdOut, poUsePath}): tuple[
              output: TaintedString, exitCode: int] {.tags: [ExecIOEffect, ReadIOEffect], gcsafe.}

     a convenience proc that runs the command, grabs all its output and
     exit code and returns both.
     let (outp, errC) = execCmdEx("nim c -r mytestfile.nim")


File: nim-ref-0.13.0.info,  Node: /pure/endians,  Next: /pure/nativesockets,  Prev: /pure/osproc,  Up: Top

189 Procedures
**************

   * swapEndian64
          proc swapEndian64*(outp, inp: pointer)

     copies inp to outp swapping bytes.  Both buffers are supposed to
     contain at least 8 bytes.

   * swapEndian32
          proc swapEndian32*(outp, inp: pointer)

     copies inp to outp swapping bytes.  Both buffers are supposed to
     contain at least 4 bytes.

   * swapEndian16
          proc swapEndian16*(outp, inp: pointer)

     copies inp to outp swapping bytes.  Both buffers are supposed to
     contain at least 2 bytes.

   * littleEndian64
          proc littleEndian64*(outp, inp: pointer) {.inline.}

   * littleEndian32
          proc littleEndian32*(outp, inp: pointer) {.inline.}

   * littleEndian16
          proc littleEndian16*(outp, inp: pointer) {.inline.}

   * bigEndian64
          proc bigEndian64*(outp, inp: pointer) {.inline.}

   * bigEndian32
          proc bigEndian32*(outp, inp: pointer) {.inline.}

   * bigEndian16
          proc bigEndian16*(outp, inp: pointer) {.inline.}


File: nim-ref-0.13.0.info,  Node: /pure/nativesockets,  Next: /pure/subexes,  Prev: /pure/endians,  Up: Top

190 Let variable
****************

   * osInvalidSocket
          osInvalidSocket* = winlean.INVALID_SOCKET

191 Types
*********

   * Hostent name*: string aliases*: seq[string] addrtype*: Domain
     length*: int addrList*: seq[string]

          Hostent* = object
            name*: string
            aliases*: seq[string]
            addrtype*: Domain
            length*: int
            addrList*: seq[string]


     information about a given host

192 Procedures
**************

   * ioctlsocket importc: "ioctlsocket", dynlib: "ws2_32.dll".}
          proc ioctlsocket*(s: SocketHandle; cmd: clong; argptr: ptr clong): cint {.stdcall,
              importc: "ioctlsocket", dynlib: "ws2_32.dll".}

   * '=='
          proc `==`*(a, b: Port): bool {.borrow.}

     '==' for ports.

   * '$'
          proc `$`*(p: Port): string {.borrow.}

     returns the port number as a string

   * toInt
          proc toInt*(domain: Domain): cint

     Converts the Domain enum to a platform-dependent 'cint'.

   * toInt
          proc toInt*(typ: SockType): cint

     Converts the SockType enum to a platform-dependent 'cint'.

   * toInt
          proc toInt*(p: Protocol): cint

     Converts the Protocol enum to a platform-dependent 'cint'.

   * newNativeSocket protocol: Protocol = IPPROTO_TCP): SocketHandle
          proc newNativeSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
                               protocol: Protocol = IPPROTO_TCP): SocketHandle

     Creates a new socket; returns InvalidSocket if an error occurs.

   * newNativeSocket
          proc newNativeSocket*(domain: cint; sockType: cint; protocol: cint): SocketHandle

     Creates a new socket; returns InvalidSocket if an error occurs.

     Use this overload if one of the enums specified above does not
     contain what you need.

   * close
          proc close*(socket: SocketHandle)

     closes a socket.

   * bindAddr
          proc bindAddr*(socket: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint

   * listen
          proc listen*(socket: SocketHandle; backlog = SOMAXCONN): cint {.tags: [ReadIOEffect].}

     Marks 'socket' as accepting connections.  'Backlog' specifies the
     maximum length of the queue of pending connections.

   * getAddrInfo sockType: SockType = SOCK_STREAM; protocol: Protocol =
     IPPROTO_TCP): ptr AddrInfo
          proc getAddrInfo*(address: string; port: Port; domain: Domain = AF_INET;
                           sockType: SockType = SOCK_STREAM; protocol: Protocol = IPPROTO_TCP): ptr AddrInfo

          *Warning*: The resulting 'ptr TAddrInfo' must be freed using
          'dealloc'!

   * dealloc
          proc dealloc*(ai: ptr AddrInfo)

   * ntohl
          proc ntohl*(x: int32): int32

     Converts 32-bit integers from network to host byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 4-byte swap
     operation.

   * ntohs
          proc ntohs*(x: int16): int16

     Converts 16-bit integers from network to host byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 2-byte swap
     operation.

   * getServByName
          proc getServByName*(name, proto: string): Servent {.tags: [ReadIOEffect].}

     Searches the database from the beginning and finds the first entry
     for which the service name specified by 'name' matches the s_name
     member and the protocol name specified by 'proto' matches the
     s_proto member.

     On posix this will search through the '/etc/services' file.

   * getServByPort
          proc getServByPort*(port: Port; proto: string): Servent {.tags: [ReadIOEffect].}

     Searches the database from the beginning and finds the first entry
     for which the port specified by 'port' matches the s_port member
     and the protocol name specified by 'proto' matches the s_proto
     member.

     On posix this will search through the '/etc/services' file.

   * getHostByAddr
          proc getHostByAddr*(ip: string): Hostent {.tags: [ReadIOEffect].}

     This function will lookup the hostname of an IP Address.

   * getHostByName
          proc getHostByName*(name: string): Hostent {.tags: [ReadIOEffect].}

     This function will lookup the IP address of a hostname.

   * getSockDomain
          proc getSockDomain*(socket: SocketHandle): Domain

     returns the socket's domain (AF_INET or AF_INET6).

   * getAddrString
          proc getAddrString*(sockAddr: ptr SockAddr): string

     return the string representation of address within sockAddr

   * getSockName
          proc getSockName*(socket: SocketHandle): Port

     returns the socket's associated port number.

   * getLocalAddr
          proc getLocalAddr*(socket: SocketHandle; domain: Domain): (string, Port)

     returns the socket's local address and port number.

     Similar to POSIX's getsockname.

   * getPeerAddr
          proc getPeerAddr*(socket: SocketHandle; domain: Domain): (string, Port)

     returns the socket's peer address and port number.

     Similar to POSIX's getpeername

   * getSockOptInt tags: [ReadIOEffect].}
          proc getSockOptInt*(socket: SocketHandle; level, optname: int): int {.
              tags: [ReadIOEffect].}

     getsockopt for integer options.

   * setSockOptInt tags: [WriteIOEffect].}
          proc setSockOptInt*(socket: SocketHandle; level, optname, optval: int) {.
              tags: [WriteIOEffect].}

     setsockopt for integer options.

   * setBlocking
          proc setBlocking*(s: SocketHandle; blocking: bool)

     Sets blocking mode on socket.

     Raises EOS on error.

   * select
          proc select*(readfds: var seq[SocketHandle]; timeout = 500): int

     Traditional select function.  This function will return the number
     of sockets that are ready to be read from, written to, or which
     have errors.  If there are none; 0 is returned.  'Timeout' is in
     milliseconds and -1 can be specified for no timeout.

     A socket is removed from the specific 'seq' when it has data
     waiting to be read/written to or has errors ('exceptfds').

   * selectWrite tags: [ReadIOEffect].}
          proc selectWrite*(writefds: var seq[SocketHandle]; timeout = 500): int {.
              tags: [ReadIOEffect].}

     When a socket in 'writefds' is ready to be written to then a
     non-zero value will be returned specifying the count of the sockets
     which can be written to.  The sockets which can be written to will
     also be removed from 'writefds'.

     'timeout' is specified in milliseconds and '-1' can be specified
     for an unlimited time.

193 Templates
*************

   * htonl
          template htonl*(x: int32): expr

     Converts 32-bit integers from host to network byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 4-byte swap
     operation.

   * htons
          template htons*(x: int16): expr

     Converts 16-bit positive integers from host to network byte order.
     On machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 2-byte swap
     operation.


File: nim-ref-0.13.0.info,  Node: /pure/subexes,  Next: /pure/json,  Prev: /pure/nativesockets,  Up: Top

194 Types
*********

   * SubexError
          SubexError* = object of ValueError

     exception that is raised for an invalid subex

   * Subex
          Subex* = distinct string

     string that contains a substitution expression

195 Procedures
**************

   * subex
          proc subex*(s: string): Subex

     constructs a _substitution expression_ from s.  Currently this
     performs no syntax checking but this may change in later versions.

   * addf extern: "nfrmtAddf".}
          proc addf*(s: var string; formatstr: Subex; a: varargs[string, `$`]) {.noSideEffect, rtl,
              extern: "nfrmtAddf".}

     The same as 'add(s, formatstr % a)', but more efficient.

   * '%' extern: "nfrmtFormatOpenArray".}
          proc `%`*(formatstr: Subex; a: openarray[string]): string {.noSideEffect, rtl,
              extern: "nfrmtFormatOpenArray".}

     The substitution operator performs string substitutions in
     formatstr and returns a modified formatstr.  This is often called
     string interpolation.

   * '%' extern: "nfrmtFormatSingleElem".}
          proc `%`*(formatstr: Subex; a: string): string {.noSideEffect, rtl,
              extern: "nfrmtFormatSingleElem".}

     This is the same as 'formatstr % [a]'.

   * format extern: "nfrmtFormatVarargs".}
          proc format*(formatstr: Subex; a: varargs[string, `$`]): string {.noSideEffect, rtl,
              extern: "nfrmtFormatVarargs".}

     The substitution operator performs string substitutions in
     formatstr and returns a modified formatstr.  This is often called
     string interpolation.


File: nim-ref-0.13.0.info,  Node: /pure/json,  Next: /pure/httpserver,  Prev: /pure/subexes,  Up: Top

196 Types
*********

   * JsonParser a: string tok: TokKind kind: JsonEventKind err:
     JsonError state: seq[ParserState] filename: string

          JsonParser* = object of BaseLexer
            a: string
            tok: TokKind
            kind: JsonEventKind
            err: JsonError
            state: seq[ParserState]
            filename: string


     the parser object.

   * JsonParsingError
          JsonParsingError* = object of ValueError

     is raised for a JSON error

197 Procedures
**************

   * open
          proc open*(my: var JsonParser; input: Stream; filename: string)

     initializes the parser with an input stream.  Filename is only used
     for nice error messages.

   * close
          proc close*(my: var JsonParser) {.inline.}

     closes the parser my and its associated input stream.

   * str
          proc str*(my: JsonParser): string {.inline.}

     returns the character data for the events: 'jsonInt', 'jsonFloat',
     'jsonString'

   * getInt
          proc getInt*(my: JsonParser): BiggestInt {.inline.}

     returns the number for the event: 'jsonInt'

   * getFloat
          proc getFloat*(my: JsonParser): float {.inline.}

     returns the number for the event: 'jsonFloat'

   * kind
          proc kind*(my: JsonParser): JsonEventKind {.inline.}

     returns the current event type for the JSON parser

   * getColumn
          proc getColumn*(my: JsonParser): int {.inline.}

     get the current column the parser has arrived at.

   * getLine
          proc getLine*(my: JsonParser): int {.inline.}

     get the current line the parser has arrived at.

   * getFilename
          proc getFilename*(my: JsonParser): string {.inline.}

     get the filename of the file that the parser processes.

   * errorMsg
          proc errorMsg*(my: JsonParser): string

     returns a helpful error message for the event 'jsonError'

   * errorMsgExpected
          proc errorMsgExpected*(my: JsonParser; e: string): string

     returns an error message "e expected" in the same format as the
     other error messages

   * next
          proc next*(my: var JsonParser)

     retrieves the first/next event.  This controls the parser.

   * raiseParseErr
          proc raiseParseErr*(p: JsonParser; msg: string) {.noinline, noreturn.}

     raises an EJsonParsingError exception.

   * newJString
          proc newJString*(s: string): JsonNode

     Creates a new JString JsonNode.

   * newJInt
          proc newJInt*(n: BiggestInt): JsonNode

     Creates a new JInt JsonNode.

   * newJFloat
          proc newJFloat*(n: float): JsonNode

     Creates a new JFloat JsonNode.

   * newJBool
          proc newJBool*(b: bool): JsonNode

     Creates a new JBool JsonNode.

   * newJNull
          proc newJNull*(): JsonNode

     Creates a new JNull JsonNode.

   * newJObject
          proc newJObject*(): JsonNode

     Creates a new JObject JsonNode

   * newJArray
          proc newJArray*(): JsonNode

     Creates a new JArray JsonNode

   * getStr
          proc getStr*(n: JsonNode; default: string = ""): string

     Retrieves the string value of a JString JsonNode.

     Returns 'default' if 'n' is not a 'JString', or if 'n' is nil.

   * getNum
          proc getNum*(n: JsonNode; default: BiggestInt = 0): BiggestInt

     Retrieves the int value of a JInt JsonNode.

     Returns 'default' if 'n' is not a 'JInt', or if 'n' is nil.

   * getFNum
          proc getFNum*(n: JsonNode; default: float = 0.0'f64): float

     Retrieves the float value of a JFloat JsonNode.

     Returns 'default' if 'n' is not a 'JFloat' or 'JInt', or if 'n' is
     nil.

   * getBVal
          proc getBVal*(n: JsonNode; default: bool = false): bool

     Retrieves the bool value of a JBool JsonNode.

     Returns 'default' if 'n' is not a 'JBool', or if 'n' is nil.

   * getFields tuple[key: string, val: JsonNode]]
          proc getFields*(n: JsonNode; default: seq[tuple[key: string, val: JsonNode]] = @ []): seq[
              tuple[key: string, val: JsonNode]]

     Retrieves the key, value pairs of a JObject JsonNode.

     Returns 'default' if 'n' is not a 'JObject', or if 'n' is nil.

   * getElems
          proc getElems*(n: JsonNode; default: seq[JsonNode] = @ []): seq[JsonNode]

     Retrieves the int value of a JArray JsonNode.

     Returns 'default' if 'n' is not a 'JArray', or if 'n' is nil.

   * '%'
          proc `%`*(s: string): JsonNode

     Generic constructor for JSON data.  Creates a new JString JsonNode.

   * '%'
          proc `%`*(n: BiggestInt): JsonNode

     Generic constructor for JSON data.  Creates a new JInt JsonNode.

   * '%'
          proc `%`*(n: float): JsonNode

     Generic constructor for JSON data.  Creates a new JFloat JsonNode.

   * '%'
          proc `%`*(b: bool): JsonNode

     Generic constructor for JSON data.  Creates a new JBool JsonNode.

   * '%'
          proc `%`*(keyVals: openArray[tuple[key: string, val: JsonNode]]): JsonNode

     Generic constructor for JSON data.  Creates a new JObject JsonNode

   * '%'
          proc `%`*(elements: openArray[JsonNode]): JsonNode

     Generic constructor for JSON data.  Creates a new JArray JsonNode

   * '=='
          proc `==`*(a, b: JsonNode): bool

     Check two nodes for equality

   * hash
          proc hash*(n: JsonNode): Hash

     Compute the hash for a JSON node

   * len
          proc len*(n: JsonNode): int

     If n is a JArray, it returns the number of elements.  If n is a
     JObject, it returns the number of pairs.  Else it returns 0.

   * '[]'
          proc `[]`*(node: JsonNode; name: string): JsonNode {.inline.}

     Gets a field from a JObject, which must not be nil.  If the value
     at name does not exist, returns nil

   * '[]'
          proc `[]`*(node: JsonNode; index: int): JsonNode {.inline.}

     Gets the node at index in an Array.  Result is undefined if index
     is out of bounds

   * hasKey
          proc hasKey*(node: JsonNode; key: string): bool

     Checks if key exists in node.

   * existsKey
          proc existsKey*(node: JsonNode; key: string): bool {.deprecated.}

     Deprecated for hasKey

   * add
          proc add*(father, child: JsonNode)

     Adds child to a JArray node father.

   * add
          proc add*(obj: JsonNode; key: string; val: JsonNode)

     Adds '(key, val)' pair to the JObject node obj.  For speed reasons
     no check for duplicate keys is performed!  But '[]=' performs the
     check.

   * '[]='
          proc `[]=`*(obj: JsonNode; key: string; val: JsonNode) {.inline.}

     Sets a field from a JObject.  Performs a check for duplicate keys.

   * '{}'
          proc `{}`*(node: JsonNode; keys: varargs[string]): JsonNode

     Traverses the node and gets the given value.  If any of the keys do
     not exist, returns nil.  Also returns nil if one of the
     intermediate data structures is not an object

   * '{}='
          proc `{}=`*(node: JsonNode; keys: varargs[string]; value: JsonNode)

     Traverses the node and tries to set the value at the given location
     to value If any of the keys are missing, they are added

   * delete
          proc delete*(obj: JsonNode; key: string)

     Deletes 'obj[key]' preserving the order of the other (key,
     value)-pairs.

   * copy
          proc copy*(p: JsonNode): JsonNode

     Performs a deep copy of a.

   * escapeJson
          proc escapeJson*(s: string): string

     Converts a string s to its JSON representation.

   * pretty
          proc pretty*(node: JsonNode; indent = 2): string

     Converts node to its JSON Representation, with indentation and on
     multiple lines.

   * toUgly
          proc toUgly*(result: var string; node: JsonNode)

     Converts node to its JSON Representation, without regard for human
     readability.  Meant to improve '$' string conversion performance.

     This provides higher efficiency than the 'toPretty' procedure as it
     does *not* attempt to format the resulting JSON to make it human
     readable.

   * '$'
          proc `$`*(node: JsonNode): string

     Converts node to its JSON Representation on one line.

   * parseJson
          proc parseJson*(s: Stream; filename: string): JsonNode

     Parses from a stream s into a JsonNode.  filename is only needed
     for nice error messages.

   * parseJson
          proc parseJson*(buffer: string): JsonNode

     Parses JSON from buffer.

   * parseFile
          proc parseFile*(filename: string): JsonNode

     Parses file into a JsonNode.

198 Macros
**********

   * '%*'
          macro `%*`*(x: expr): expr

     Convert an expression to a JsonNode directly, without having to
     specify % for every element.

199 Iterators
*************

   * items
          iterator items*(node: JsonNode): JsonNode

     Iterator for the items of node.  node has to be a JArray.

   * mitems
          iterator mitems*(node: var JsonNode): var JsonNode

     Iterator for the items of node.  node has to be a JArray.  Items
     can be modified.

   * pairs
          iterator pairs*(node: JsonNode): tuple[key: string, val: JsonNode]

     Iterator for the child elements of node.  node has to be a JObject.

   * mpairs
          iterator mpairs*(node: var JsonNode): var tuple[key: string, val: JsonNode]

     Iterator for the child elements of node.  node has to be a JObject.
     Items can be modified


File: nim-ref-0.13.0.info,  Node: /pure/httpserver,  Next: /pure/cgi,  Prev: /pure/json,  Up: Top

200 Procedures
**************

   * serveFile
          proc serveFile*(client: Socket; filename: string)

     serves a file to the client.

   * open
          proc open*(s: var Server; port = Port(80); reuseAddr = false)

     creates a new server at port port.  If 'port == 0' a free port is
     acquired that can be accessed later by the 'port' proc.

   * port
          proc port*(s: var Server): Port

     get the port number the server has acquired.

   * next
          proc next*(s: var Server)

     proceed to the first/next request.

   * close
          proc close*(s: Server)

     closes the server (and the socket the server uses).

   * run port = Port(80))
          proc run*(handleRequest: proc (client: Socket; path, query: string): bool {.closure.};
                   port = Port(80))

     encapsulates the server object and main loop

   * asyncHTTPServer path, query: string): bool {.closure, gcsafe.};
     port = Port(80); address = ""; reuseAddr = false): PAsyncHTTPServer
          proc asyncHTTPServer*(handleRequest: proc (server: PAsyncHTTPServer; client: Socket;
                                                  path, query: string): bool {.closure, gcsafe.};
                               port = Port(80); address = ""; reuseAddr = false): PAsyncHTTPServer

     Creates an Asynchronous HTTP server at 'port'.

   * register
          proc register*(d: Dispatcher; s: PAsyncHTTPServer)

     Registers a 'PAsyncHTTPServer' with a 'Dispatcher'.

   * close
          proc close*(h: PAsyncHTTPServer)

     Closes the 'PAsyncHTTPServer'.


File: nim-ref-0.13.0.info,  Node: /pure/cgi,  Next: /pure/htmlgen,  Prev: /pure/httpserver,  Up: Top

201 Types
*********

   * RequestMethod methodNone, ## no REQUEST_METHOD environment variable
     methodPost, ## query uses the POST method methodGet ## query uses
     the GET method
          RequestMethod* = enum
            methodNone,                 ## no REQUEST_METHOD environment variable
            methodPost,                 ## query uses the POST method
            methodGet                   ## query uses the GET method

     the used request method

202 Procedures
**************

   * encodeUrl
          proc encodeUrl*(s: string): string

     Encodes a value to be HTTP safe: This means that characters in the
     set '{'A'..'Z', 'a'..'z', '0'..'9', '_'}' are carried over to the
     result, a space is converted to ''+'' and every other character is
     encoded as ''%xx'' where 'xx' denotes its hexadecimal value.

   * decodeUrl
          proc decodeUrl*(s: string): string

     Decodes a value from its HTTP representation: This means that a
     ''+'' is converted to a space, ''%xx'' (where 'xx' denotes a
     hexadecimal value) is converted to the character with ordinal
     number 'xx', and and every other character is carried over.

   * xmlEncode
          proc xmlEncode*(s: string): string

     Encodes a value to be XML safe:

        * '"' is replaced by '&quot;'
        * '<' is replaced by '&lt;'
        * '>' is replaced by '&gt;'
        * '&' is replaced by '&amp;'
        * every other character is carried over.

   * cgiError
          proc cgiError*(msg: string) {.noreturn.}

     raises an ECgi exception with message msg.

   * readData
          proc readData*(allowedMethods: set[RequestMethod] = {methodNone, methodPost, methodGet}): StringTableRef

     Read CGI data.  If the client does not use a method listed in the
     allowedMethods set, an ECgi exception is raised.

   * validateData
          proc validateData*(data: StringTableRef; validKeys: varargs[string])

     validates data; raises ECgi if this fails.  This checks that each
     variable name of the CGI data occurs in the validKeys array.

   * getContentLength
          proc getContentLength*(): string

     returns contents of the 'CONTENT_LENGTH' environment variable

   * getContentType
          proc getContentType*(): string

     returns contents of the 'CONTENT_TYPE' environment variable

   * getDocumentRoot
          proc getDocumentRoot*(): string

     returns contents of the 'DOCUMENT_ROOT' environment variable

   * getGatewayInterface
          proc getGatewayInterface*(): string

     returns contents of the 'GATEWAY_INTERFACE' environment variable

   * getHttpAccept
          proc getHttpAccept*(): string

     returns contents of the 'HTTP_ACCEPT' environment variable

   * getHttpAcceptCharset
          proc getHttpAcceptCharset*(): string

     returns contents of the 'HTTP_ACCEPT_CHARSET' environment variable

   * getHttpAcceptEncoding
          proc getHttpAcceptEncoding*(): string

     returns contents of the 'HTTP_ACCEPT_ENCODING' environment variable

   * getHttpAcceptLanguage
          proc getHttpAcceptLanguage*(): string

     returns contents of the 'HTTP_ACCEPT_LANGUAGE' environment variable

   * getHttpConnection
          proc getHttpConnection*(): string

     returns contents of the 'HTTP_CONNECTION' environment variable

   * getHttpCookie
          proc getHttpCookie*(): string

     returns contents of the 'HTTP_COOKIE' environment variable

   * getHttpHost
          proc getHttpHost*(): string

     returns contents of the 'HTTP_HOST' environment variable

   * getHttpReferer
          proc getHttpReferer*(): string

     returns contents of the 'HTTP_REFERER' environment variable

   * getHttpUserAgent
          proc getHttpUserAgent*(): string

     returns contents of the 'HTTP_USER_AGENT' environment variable

   * getPathInfo
          proc getPathInfo*(): string

     returns contents of the 'PATH_INFO' environment variable

   * getPathTranslated
          proc getPathTranslated*(): string

     returns contents of the 'PATH_TRANSLATED' environment variable

   * getQueryString
          proc getQueryString*(): string

     returns contents of the 'QUERY_STRING' environment variable

   * getRemoteAddr
          proc getRemoteAddr*(): string

     returns contents of the 'REMOTE_ADDR' environment variable

   * getRemoteHost
          proc getRemoteHost*(): string

     returns contents of the 'REMOTE_HOST' environment variable

   * getRemoteIdent
          proc getRemoteIdent*(): string

     returns contents of the 'REMOTE_IDENT' environment variable

   * getRemotePort
          proc getRemotePort*(): string

     returns contents of the 'REMOTE_PORT' environment variable

   * getRemoteUser
          proc getRemoteUser*(): string

     returns contents of the 'REMOTE_USER' environment variable

   * getRequestMethod
          proc getRequestMethod*(): string

     returns contents of the 'REQUEST_METHOD' environment variable

   * getRequestURI
          proc getRequestURI*(): string

     returns contents of the 'REQUEST_URI' environment variable

   * getScriptFilename
          proc getScriptFilename*(): string

     returns contents of the 'SCRIPT_FILENAME' environment variable

   * getScriptName
          proc getScriptName*(): string

     returns contents of the 'SCRIPT_NAME' environment variable

   * getServerAddr
          proc getServerAddr*(): string

     returns contents of the 'SERVER_ADDR' environment variable

   * getServerAdmin
          proc getServerAdmin*(): string

     returns contents of the 'SERVER_ADMIN' environment variable

   * getServerName
          proc getServerName*(): string

     returns contents of the 'SERVER_NAME' environment variable

   * getServerPort
          proc getServerPort*(): string

     returns contents of the 'SERVER_PORT' environment variable

   * getServerProtocol
          proc getServerProtocol*(): string

     returns contents of the 'SERVER_PROTOCOL' environment variable

   * getServerSignature
          proc getServerSignature*(): string

     returns contents of the 'SERVER_SIGNATURE' environment variable

   * getServerSoftware
          proc getServerSoftware*(): string

     returns contents of the 'SERVER_SOFTWARE' environment variable

   * setTestData
          proc setTestData*(keysvalues: varargs[string])

     fills the appropriate environment variables to test your CGI
     application.  This can only simulate the 'GET' request method.
     keysvalues should provide embedded (name, value)-pairs.  Example:
     setTestData("name", "Hanz", "password", "12345")

   * writeContentType
          proc writeContentType*()

     call this before starting to send your HTML data to stdout.  This
     implements this part of the CGI protocol:
     write(stdout, "Content-type: text/html\n\n")

   * writeErrorMessage
          proc writeErrorMessage*(data: string)

     Tries to reset browser state and writes data to stdout in
     <plaintext> tag.

   * setStackTraceStdout
          proc setStackTraceStdout*()

     Makes Nim output stacktraces to stdout, instead of server log.

   * setStackTraceNewLine
          proc setStackTraceNewLine*() {.deprecated.}

     Makes Nim output stacktraces to stdout, instead of server log.
     Depracated alias for setStackTraceStdout.

   * setCookie
          proc setCookie*(name, value: string)

     Sets a cookie.

   * getCookie
          proc getCookie*(name: string): TaintedString

     Gets a cookie.  If no cookie of name exists, "" is returned.

   * existsCookie
          proc existsCookie*(name: string): bool

     Checks if a cookie of name exists.

203 Iterators
*************

   * decodeData
          iterator decodeData*(data: string): tuple[key, value: TaintedString]

     Reads and decodes CGI data and yields the (name, value) pairs the
     data consists of.

   * decodeData methodGet}): tuple[key, value: TaintedString]
          iterator decodeData*(allowedMethods: set[RequestMethod] = {methodNone, methodPost,
              methodGet}): tuple[key, value: TaintedString]

     Reads and decodes CGI data and yields the (name, value) pairs the
     data consists of.  If the client does not use a method listed in
     the allowedMethods set, an ECgi exception is raised.


File: nim-ref-0.13.0.info,  Node: /pure/htmlgen,  Next: /pure/ospaths,  Prev: /pure/cgi,  Up: Top

204 Constant variables
**********************

   * commonAttr
          commonAttr* = coreAttr & eventAttr

205 Procedures
**************

   * xmlCheckedTag compileTime.}
          proc xmlCheckedTag*(e: NimNode; tag: string; optAttr = ""; reqAttr = ""; isLeaf = false): NimNode {.
              compileTime.}

     use this procedure to define a new XML tag

206 Macros
**********

   * a
          macro a*(e: expr): expr {.immediate.}

     generates the HTML 'a' element.

   * acronym
          macro acronym*(e: expr): expr {.immediate.}

     generates the HTML 'acronym' element.

   * address
          macro address*(e: expr): expr {.immediate.}

     generates the HTML 'address' element.

   * area
          macro area*(e: expr): expr {.immediate.}

     generates the HTML 'area' element.

   * b
          macro b*(e: expr): expr {.immediate.}

     generates the HTML 'b' element.

   * base
          macro base*(e: expr): expr {.immediate.}

     generates the HTML 'base' element.

   * big
          macro big*(e: expr): expr {.immediate.}

     generates the HTML 'big' element.

   * blockquote
          macro blockquote*(e: expr): expr {.immediate.}

     generates the HTML 'blockquote' element.

   * body
          macro body*(e: expr): expr {.immediate.}

     generates the HTML 'body' element.

   * br
          macro br*(e: expr): expr {.immediate.}

     generates the HTML 'br' element.

   * button
          macro button*(e: expr): expr {.immediate.}

     generates the HTML 'button' element.

   * caption
          macro caption*(e: expr): expr {.immediate.}

     generates the HTML 'caption' element.

   * cite
          macro cite*(e: expr): expr {.immediate.}

     generates the HTML 'cite' element.

   * code
          macro code*(e: expr): expr {.immediate.}

     generates the HTML 'code' element.

   * col
          macro col*(e: expr): expr {.immediate.}

     generates the HTML 'col' element.

   * colgroup
          macro colgroup*(e: expr): expr {.immediate.}

     generates the HTML 'colgroup' element.

   * dd
          macro dd*(e: expr): expr {.immediate.}

     generates the HTML 'dd' element.

   * del
          macro del*(e: expr): expr {.immediate.}

     generates the HTML 'del' element.

   * dfn
          macro dfn*(e: expr): expr {.immediate.}

     generates the HTML 'dfn' element.

   * 'div'
          macro `div`*(e: expr): expr {.immediate.}

     generates the HTML 'div' element.

   * dl
          macro dl*(e: expr): expr {.immediate.}

     generates the HTML 'dl' element.

   * dt
          macro dt*(e: expr): expr {.immediate.}

     generates the HTML 'dt' element.

   * em
          macro em*(e: expr): expr {.immediate.}

     generates the HTML 'em' element.

   * fieldset
          macro fieldset*(e: expr): expr {.immediate.}

     generates the HTML 'fieldset' element.

   * form
          macro form*(e: expr): expr {.immediate.}

     generates the HTML 'form' element.

   * h1
          macro h1*(e: expr): expr {.immediate.}

     generates the HTML 'h1' element.

   * h2
          macro h2*(e: expr): expr {.immediate.}

     generates the HTML 'h2' element.

   * h3
          macro h3*(e: expr): expr {.immediate.}

     generates the HTML 'h3' element.

   * h4
          macro h4*(e: expr): expr {.immediate.}

     generates the HTML 'h4' element.

   * h5
          macro h5*(e: expr): expr {.immediate.}

     generates the HTML 'h5' element.

   * h6
          macro h6*(e: expr): expr {.immediate.}

     generates the HTML 'h6' element.

   * head
          macro head*(e: expr): expr {.immediate.}

     generates the HTML 'head' element.

   * html
          macro html*(e: expr): expr {.immediate.}

     generates the HTML 'html' element.

   * hr
          macro hr*(): expr {.immediate.}

     generates the HTML 'hr' element.

   * i
          macro i*(e: expr): expr {.immediate.}

     generates the HTML 'i' element.

   * img
          macro img*(e: expr): expr {.immediate.}

     generates the HTML 'img' element.

   * input
          macro input*(e: expr): expr {.immediate.}

     generates the HTML 'input' element.

   * ins
          macro ins*(e: expr): expr {.immediate.}

     generates the HTML 'ins' element.

   * kbd
          macro kbd*(e: expr): expr {.immediate.}

     generates the HTML 'kbd' element.

   * label
          macro label*(e: expr): expr {.immediate.}

     generates the HTML 'label' element.

   * legend
          macro legend*(e: expr): expr {.immediate.}

     generates the HTML 'legend' element.

   * li
          macro li*(e: expr): expr {.immediate.}

     generates the HTML 'li' element.

   * link
          macro link*(e: expr): expr {.immediate.}

     generates the HTML 'link' element.

   * map
          macro map*(e: expr): expr {.immediate.}

     generates the HTML 'map' element.

   * meta
          macro meta*(e: expr): expr {.immediate.}

     generates the HTML 'meta' element.

   * noscript
          macro noscript*(e: expr): expr {.immediate.}

     generates the HTML 'noscript' element.

   * 'object'
          macro `object`*(e: expr): expr {.immediate.}

     generates the HTML 'object' element.

   * ol
          macro ol*(e: expr): expr {.immediate.}

     generates the HTML 'ol' element.

   * optgroup
          macro optgroup*(e: expr): expr {.immediate.}

     generates the HTML 'optgroup' element.

   * option
          macro option*(e: expr): expr {.immediate.}

     generates the HTML 'option' element.

   * p
          macro p*(e: expr): expr {.immediate.}

     generates the HTML 'p' element.

   * param
          macro param*(e: expr): expr {.immediate.}

     generates the HTML 'param' element.

   * pre
          macro pre*(e: expr): expr {.immediate.}

     generates the HTML 'pre' element.

   * q
          macro q*(e: expr): expr {.immediate.}

     generates the HTML 'q' element.

   * samp
          macro samp*(e: expr): expr {.immediate.}

     generates the HTML 'samp' element.

   * script
          macro script*(e: expr): expr {.immediate.}

     generates the HTML 'script' element.

   * select
          macro select*(e: expr): expr {.immediate.}

     generates the HTML 'select' element.

   * small
          macro small*(e: expr): expr {.immediate.}

     generates the HTML 'small' element.

   * span
          macro span*(e: expr): expr {.immediate.}

     generates the HTML 'span' element.

   * strong
          macro strong*(e: expr): expr {.immediate.}

     generates the HTML 'strong' element.

   * style
          macro style*(e: expr): expr {.immediate.}

     generates the HTML 'style' element.

   * sub
          macro sub*(e: expr): expr {.immediate.}

     generates the HTML 'sub' element.

   * sup
          macro sup*(e: expr): expr {.immediate.}

     generates the HTML 'sup' element.

   * table
          macro table*(e: expr): expr {.immediate.}

     generates the HTML 'table' element.

   * tbody
          macro tbody*(e: expr): expr {.immediate.}

     generates the HTML 'tbody' element.

   * td
          macro td*(e: expr): expr {.immediate.}

     generates the HTML 'td' element.

   * textarea
          macro textarea*(e: expr): expr {.immediate.}

     generates the HTML 'textarea' element.

   * tfoot
          macro tfoot*(e: expr): expr {.immediate.}

     generates the HTML 'tfoot' element.

   * th
          macro th*(e: expr): expr {.immediate.}

     generates the HTML 'th' element.

   * thead
          macro thead*(e: expr): expr {.immediate.}

     generates the HTML 'thead' element.

   * title
          macro title*(e: expr): expr {.immediate.}

     generates the HTML 'title' element.

   * tr
          macro tr*(e: expr): expr {.immediate.}

     generates the HTML 'tr' element.

   * tt
          macro tt*(e: expr): expr {.immediate.}

     generates the HTML 'tt' element.

   * ul
          macro ul*(e: expr): expr {.immediate.}

     generates the HTML 'ul' element.

   * 'var'
          macro `var`*(e: expr): expr {.immediate.}

     generates the HTML 'var' element.


File: nim-ref-0.13.0.info,  Node: /pure/ospaths,  Next: /pure/asynchttpserver,  Prev: /pure/htmlgen,  Up: Top

207 Constant variables
**********************

   * DynlibFormat
          DynlibFormat* = "lib$1.so"

     The format string to turn a filename into a DLL file (also called
     shared object on some operating systems).

   * ExtSep
          ExtSep* = '.'

     The character which separates the base filename from the extension;
     for example, the '.'  in 'os.nim'.

208 Types
*********

   * OSErrorCode
          OSErrorCode* = distinct int32

     Specifies an OS Error Code.

209 Procedures
**************

   * joinPath
          proc joinPath*(head, tail: string): string {.noSideEffect, rtl, extern: "nos$1".}

     Joins two directory names to one.

     For example on Unix:
     joinPath("usr", "lib")

     results in:
     "usr/lib"

     If head is the empty string, tail is returned.  If tail is the
     empty string, head is returned with a trailing path separator.  If
     tail starts with a path separator it will be removed when
     concatenated to head.  Other path separators not located on
     boundaries won't be modified.  More examples on Unix:
     assert joinPath("usr", "") == "usr/"
     assert joinPath("", "lib") == "lib"
     assert joinPath("", "/lib") == "/lib"
     assert joinPath("usr/", "/lib") == "usr/lib"

   * joinPath extern: "nos$1OpenArray".}
          proc joinPath*(parts: varargs[string]): string {.noSideEffect, rtl,
              extern: "nos$1OpenArray".}

     The same as joinPath(head, tail), but works with any number of
     directory parts.  You need to pass at least one element or the proc
     will assert in debug builds and crash on release builds.

   * '/'
          proc `/`*(head, tail: string): string {.noSideEffect.}

     The same as 'joinPath(head, tail)'

     Here are some examples for Unix:
     assert "usr" / "" == "usr/"
     assert "" / "lib" == "lib"
     assert "" / "/lib" == "/lib"
     assert "usr/" / "/lib" == "usr/lib"

   * splitPath extern: "nos$1".}
          proc splitPath*(path: string): tuple[head, tail: string] {.noSideEffect, rtl,
              extern: "nos$1".}

     Splits a directory into (head, tail), so that 'head / tail == path'
     (except for edge cases like "/usr").

     Examples:
     splitPath("usr/local/bin") -> ("usr/local", "bin")
     splitPath("usr/local/bin/") -> ("usr/local/bin", "")
     splitPath("bin") -> ("", "bin")
     splitPath("/bin") -> ("", "bin")
     splitPath("") -> ("", "")

   * parentDir
          proc parentDir*(path: string): string {.noSideEffect, rtl, extern: "nos$1".}

     Returns the parent directory of path.

     This is often the same as the 'head' result of 'splitPath'.  If
     there is no parent, "" is returned.

     Example: 'parentDir("/usr/local/bin") == "/usr/local"'.
     Example: 'parentDir("/usr/local/bin/") == "/usr/local"'.

   * tailDir
          proc tailDir*(path: string): string {.noSideEffect, rtl, extern: "nos$1".}

     Returns the tail part of path..

     Example: 'tailDir("/usr/local/bin") == "local/bin"'.
     Example: 'tailDir("usr/local/bin/") == "local/bin"'.
     Example: 'tailDir("bin") == ""'.

   * isRootDir
          proc isRootDir*(path: string): bool {.noSideEffect, rtl, extern: "nos$1".}

     Checks whether a given path is a root directory

   * '/../'
          proc `/../`*(head, tail: string): string {.noSideEffect.}

     The same as 'parentDir(head) / tail' unless there is no parent
     directory.  Then 'head / tail' is performed instead.

   * splitFile extern: "nos$1".}
          proc splitFile*(path: string): tuple[dir, name, ext: string] {.noSideEffect, rtl,
              extern: "nos$1".}

     Splits a filename into (dir, filename, extension).  dir does not
     end in DirSep.  extension includes the leading dot.

     Example:
     var (dir, name, ext) = splitFile("usr/local/nimc.html")
     assert dir == "usr/local"
     assert name == "nimc"
     assert ext == ".html"

     If path has no extension, ext is the empty string.  If path has no
     directory component, dir is the empty string.  If path has no
     filename component, name and ext are empty strings.

   * extractFilename
          proc extractFilename*(path: string): string {.noSideEffect, rtl, extern: "nos$1".}

     Extracts the filename of a given path.  This is the same as 'name &
     ext' from 'splitFile(path)'.

   * changeFileExt
          proc changeFileExt*(filename, ext: string): string {.noSideEffect, rtl, extern: "nos$1".}

     Changes the file extension to ext.

     If the filename has no extension, ext will be added.  If ext == ""
     then any extension is removed.  Ext should be given without the
     leading '.', because some filesystems may use a different
     character.  (Although I know of none such beast.)

   * addFileExt
          proc addFileExt*(filename, ext: string): string {.noSideEffect, rtl, extern: "nos$1".}

     Adds the file extension ext to filename, unless filename already
     has an extension.

     Ext should be given without the leading '.', because some
     filesystems may use a different character.  (Although I know of
     none such beast.)

   * cmpPaths
          proc cmpPaths*(pathA, pathB: string): int {.noSideEffect, rtl, extern: "nos$1".}

     Compares two paths.

     On a case-sensitive filesystem this is done case-sensitively
     otherwise case-insensitively.  Returns:

     0 iff pathA == pathB
     < 0 iff pathA < pathB
     > 0 iff pathA > pathB

   * isAbsolute
          proc isAbsolute*(path: string): bool {.rtl, noSideEffect, extern: "nos$1".}

     Checks whether a given path is absolute.

     On Windows, network paths are considered absolute too.

   * unixToNativePath extern: "nos$1".}
          proc unixToNativePath*(path: string; drive = ""): string {.noSideEffect, rtl,
              extern: "nos$1".}

     Converts an UNIX-like path to a native one.

     On an UNIX system this does nothing.  Else it converts '/', '.',
     '..'  to the appropriate things.

     On systems with a concept of "drives", drive is used to determine
     which drive label to use during absolute path conversion.  drive
     defaults to the drive of the current working directory, and is
     ignored on systems that do not have a concept of "drives".

   * getHomeDir
          proc getHomeDir*(): string {.rtl, extern: "nos$1", tags: [ReadEnvEffect, ReadIOEffect].}

     Returns the home directory of the current user.

     This proc is wrapped by the expandTilde proc for the convenience of
     processing paths coming from user configuration files.

   * getConfigDir tags: [ReadEnvEffect, ReadIOEffect].}
          proc getConfigDir*(): string {.rtl, extern: "nos$1",
                                      tags: [ReadEnvEffect, ReadIOEffect].}

     Returns the config directory of the current user for applications.

   * getTempDir
          proc getTempDir*(): string {.rtl, extern: "nos$1", tags: [ReadEnvEffect, ReadIOEffect].}

     Returns the temporary directory of the current user for
     applications to save temporary files in.

   * expandTilde
          proc expandTilde*(path: string): string {.tags: [ReadEnvEffect, ReadIOEffect].}

     Expands a path starting with '~/' to a full path.

     If path starts with the tilde character and is followed by / or \
     this proc will return the reminder of the path appended to the
     result of the getHomeDir() proc, otherwise the input path will be
     returned without modification.

     The behaviour of this proc is the same on the Windows platform
     despite not having this convention.  Example:
     let configFile = expandTilde("~" / "appname.cfg")
     echo configFile
     # --> C:\Users\amber\appname.cfg

   * findExe
          proc findExe*(exe: string): string {.tags: [ReadDirEffect, ReadEnvEffect, ReadIOEffect].}

     Searches for exe in the current working directory and then in
     directories listed in the 'PATH' environment variable.  Returns ""
     if the exe cannot be found.  On DOS-like platforms, exe is added
     the ExeExt (#ExeExt) file extension if it has none.

210 Iterators
*************

   * parentDirs
          iterator parentDirs*(path: string; fromRoot = false; inclusive = true): string

     Walks over all parent directories of a given path

     If fromRoot is set, the traversal will start from the file system
     root diretory.  If inclusive is set, the original argument will be
     included in the traversal.

     Relative paths won't be expanded by this proc.  Instead, it will
     traverse only the directories appearing in the relative path.


File: nim-ref-0.13.0.info,  Node: /pure/asynchttpserver,  Next: /pure/streams,  Prev: /pure/ospaths,  Up: Top

211 Types
*********

   * HttpVersion HttpVer11, HttpVer10
          HttpVersion* = enum
            HttpVer11, HttpVer10

212 Procedures
**************

   * '=='
          proc `==`*(protocol: tuple[orig: string, major, minor: int]; ver: HttpVersion): bool

   * newAsyncHttpServer
          proc newAsyncHttpServer*(reuseAddr = true): AsyncHttpServer

     Creates a new 'AsyncHttpServer' instance.

   * sendHeaders
          proc sendHeaders*(req: Request; headers: StringTableRef): Future[void]

     Sends the specified headers to the requesting client.

   * respond headers: StringTableRef = nil): Future[void]
          proc respond*(req: Request; code: HttpCode; content: string;
                       headers: StringTableRef = nil): Future[void]

     Responds to the request with the specified 'HttpCode', headers and
     content.

     This procedure will *not* close the client socket.

   * serve callback: proc (request: Request): Future[void] {.closure,
     gcsafe.}; address = "") {.async.}
          proc serve*(server: AsyncHttpServer; port: Port;
                     callback: proc (request: Request): Future[void] {.closure, gcsafe.};
                     address = "") {.async.}

     Starts the process of listening for incoming HTTP connections on
     the specified address and port.

     When a request is made by a client the specified callback will be
     called.

   * close
          proc close*(server: AsyncHttpServer)

     Terminates the async http server instance.


File: nim-ref-0.13.0.info,  Node: /pure/streams,  Next: /pure/htmlparser,  Prev: /pure/asynchttpserver,  Up: Top

213 Types
*********

   * StreamObj closeImpl*: proc (s: Stream) {.nimcall, tags: [],
     gcsafe.} atEndImpl*: proc (s: Stream): bool {.nimcall, tags: [],
     gcsafe.} setPositionImpl*: proc (s: Stream; pos: int) {.nimcall,
     tags: [], gcsafe.} getPositionImpl*: proc (s: Stream): int
     {.nimcall, tags: [], gcsafe.} readDataImpl*: proc (s: Stream;
     buffer: pointer; bufLen: int): int {.nimcall, tags: [ReadIOEffect],
     gcsafe.} peekDataImpl*: proc (s: Stream; buffer: pointer; bufLen:
     int): int {.nimcall, tags: [ReadIOEffect], gcsafe.} writeDataImpl*:
     proc (s: Stream; buffer: pointer; bufLen: int) {.nimcall, tags:
     [WriteIOEffect], gcsafe.} flushImpl*: proc (s: Stream) {.nimcall,
     tags: [WriteIOEffect], gcsafe.}

          StreamObj* = object of RootObj
            closeImpl*: proc (s: Stream) {.nimcall, tags: [], gcsafe.}
            atEndImpl*: proc (s: Stream): bool {.nimcall, tags: [], gcsafe.}
            setPositionImpl*: proc (s: Stream; pos: int) {.nimcall, tags: [], gcsafe.}
            getPositionImpl*: proc (s: Stream): int {.nimcall, tags: [], gcsafe.}
            readDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int {.nimcall,
                tags: [ReadIOEffect], gcsafe.}
            peekDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int {.nimcall,
                tags: [ReadIOEffect], gcsafe.}
            writeDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int) {.nimcall,
                tags: [WriteIOEffect], gcsafe.}
            flushImpl*: proc (s: Stream) {.nimcall, tags: [WriteIOEffect], gcsafe.}


     Stream interface that supports writing or reading.  Note that these
     fields here shouldn't be used directly.  They are accessible so
     that a stream implementation can override them.

   * StringStreamObj data*: string pos: int

          StringStreamObj* = object of StreamObj
            data*: string
            pos: int


   * FileStreamObj f: File

          FileStreamObj* = object of Stream
            f: File


214 Procedures
**************

   * flush
          proc flush*(s: Stream)

     flushes the buffers that the stream s might use.

   * close
          proc close*(s: Stream)

     closes the stream s.

   * close
          proc close*(s, unused: Stream) {.deprecated.}

     closes the stream s.

   * atEnd
          proc atEnd*(s: Stream): bool

     checks if more data can be read from f.  Returns true if all data
     has been read.

   * atEnd
          proc atEnd*(s, unused: Stream): bool {.deprecated.}

     checks if more data can be read from f.  Returns true if all data
     has been read.

   * setPosition
          proc setPosition*(s: Stream; pos: int)

     sets the position pos of the stream s.

   * setPosition
          proc setPosition*(s, unused: Stream; pos: int) {.deprecated.}

     sets the position pos of the stream s.

   * getPosition
          proc getPosition*(s: Stream): int

     retrieves the current position in the stream s.

   * getPosition
          proc getPosition*(s, unused: Stream): int {.deprecated.}

     retrieves the current position in the stream s.

   * readData
          proc readData*(s: Stream; buffer: pointer; bufLen: int): int

     low level proc that reads data into an untyped buffer of bufLen
     size.

   * readAll
          proc readAll*(s: Stream): string

     Reads all available data.

   * readData
          proc readData*(s, unused: Stream; buffer: pointer; bufLen: int): int {.deprecated.}

     low level proc that reads data into an untyped buffer of bufLen
     size.

   * peekData
          proc peekData*(s: Stream; buffer: pointer; bufLen: int): int

     low level proc that reads data into an untyped buffer of bufLen
     size without moving stream position

   * writeData
          proc writeData*(s: Stream; buffer: pointer; bufLen: int)

     low level proc that writes an untyped buffer of bufLen size to the
     stream s.

   * writeData
          proc writeData*(s, unused: Stream; buffer: pointer; bufLen: int) {.deprecated.}

     low level proc that writes an untyped buffer of bufLen size to the
     stream s.

   * write
          proc write*[T](s: Stream; x: T)

     generic write procedure.  Writes x to the stream s.
     Implementation:
     s.writeData(s, addr(x), sizeof(x))

   * write
          proc write*(s: Stream; x: string)

     writes the string x to the the stream s.  No length field or
     terminating zero is written.

   * writeLn
          proc writeLn*(s: Stream; args: varargs[string, `$`]) {.deprecated.}

     *Deprecated since version 0.11.4:* Use *writeLine* instead.

   * writeLine
          proc writeLine*(s: Stream; args: varargs[string, `$`])

     writes one or more strings to the the stream s followed by a new
     line.  No length field or terminating zero is written.

   * readChar
          proc readChar*(s: Stream): char

     reads a char from the stream s.  Raises EIO if an error occurred.
     Returns '0' as an EOF marker.

   * peekChar
          proc peekChar*(s: Stream): char

     peeks a char from the stream s.  Raises EIO if an error occurred.
     Returns '0' as an EOF marker.

   * readBool
          proc readBool*(s: Stream): bool

     reads a bool from the stream s.  Raises EIO if an error occurred.

   * peekBool
          proc peekBool*(s: Stream): bool

     peeks a bool from the stream s.  Raises EIO if an error occured.

   * readInt8
          proc readInt8*(s: Stream): int8

     reads an int8 from the stream s.  Raises EIO if an error occurred.

   * peekInt8
          proc peekInt8*(s: Stream): int8

     peeks an int8 from the stream s.  Raises EIO if an error occurred.

   * readInt16
          proc readInt16*(s: Stream): int16

     reads an int16 from the stream s.  Raises EIO if an error occurred.

   * peekInt16
          proc peekInt16*(s: Stream): int16

     peeks an int16 from the stream s.  Raises EIO if an error occurred.

   * readInt32
          proc readInt32*(s: Stream): int32

     reads an int32 from the stream s.  Raises EIO if an error occurred.

   * peekInt32
          proc peekInt32*(s: Stream): int32

     peeks an int32 from the stream s.  Raises EIO if an error occurred.

   * readInt64
          proc readInt64*(s: Stream): int64

     reads an int64 from the stream s.  Raises EIO if an error occurred.

   * peekInt64
          proc peekInt64*(s: Stream): int64

     peeks an int64 from the stream s.  Raises EIO if an error occurred.

   * readFloat32
          proc readFloat32*(s: Stream): float32

     reads a float32 from the stream s.  Raises EIO if an error
     occurred.

   * peekFloat32
          proc peekFloat32*(s: Stream): float32

     peeks a float32 from the stream s.  Raises EIO if an error
     occurred.

   * readFloat64
          proc readFloat64*(s: Stream): float64

     reads a float64 from the stream s.  Raises EIO if an error
     occurred.

   * peekFloat64
          proc peekFloat64*(s: Stream): float64

     peeks a float64 from the stream s.  Raises EIO if an error
     occurred.

   * readStr
          proc readStr*(s: Stream; length: int): TaintedString

     reads a string of length length from the stream s.  Raises EIO if
     an error occurred.

   * peekStr
          proc peekStr*(s: Stream; length: int): TaintedString

     peeks a string of length length from the stream s.  Raises EIO if
     an error occurred.

   * readLine
          proc readLine*(s: Stream; line: var TaintedString): bool

     reads a line of text from the stream s into line.  line must not be
     'nil'!  May throw an IO exception.  A line of text may be delimited
     by 'CR', 'LF' or 'CRLF'.  The newline character(s) are not part of
     the returned string.  Returns 'false' if the end of the file has
     been reached, 'true' otherwise.  If 'false' is returned line
     contains no new data.

   * peekLine
          proc peekLine*(s: Stream; line: var TaintedString): bool

     peeks a line of text from the stream s into line.  line must not be
     'nil'!  May throw an IO exception.  A line of text may be delimited
     by 'CR', 'LF' or 'CRLF'.  The newline character(s) are not part of
     the returned string.  Returns 'false' if the end of the file has
     been reached, 'true' otherwise.  If 'false' is returned line
     contains no new data.

   * readLine
          proc readLine*(s: Stream): TaintedString

     Reads a line from a stream s.  Note: This is not very efficient.
     Raises EIO if an error occurred.

   * peekLine
          proc peekLine*(s: Stream): TaintedString

     Peeks a line from a stream s.  Note: This is not very efficient.
     Raises EIO if an error occurred.

   * newStringStream
          proc newStringStream*(s: string = ""): StringStream

     creates a new stream from the string s.

   * newFileStream
          proc newFileStream*(f: File): FileStream

     creates a new stream from the file f.

   * newFileStream
          proc newFileStream*(filename: string; mode: FileMode = fmRead): FileStream

     creates a new stream from the file named filename with the mode
     mode.  If the file cannot be opened, nil is returned.  See the
     system (system.html) module for a list of available FileMode enums.


File: nim-ref-0.13.0.info,  Node: /pure/htmlparser,  Next: /pure/gentabs,  Prev: /pure/streams,  Up: Top

215 Types
*********

   * HtmlTag tagUnknown, ## unknown HTML element tagA, ## the HTML "a"
     element tagAbbr, ## the deprecated HTML "abbr" element tagAcronym,
     ## the HTML "acronym" element tagAddress, ## the HTML "address"
     element tagApplet, ## the deprecated HTML "applet" element tagArea,
     ## the HTML "area" element tagArticle, ## the HTML "article"
     element tagAside, ## the HTML "aside" element tagAudio, ## the HTML
     "audio" element tagB, ## the HTML "b" element tagBase, ## the HTML
     "base" element tagBdi, ## the HTML "bdi" element tagBdo, ## the
     deprecated HTML "dbo" element tagBasefont, ## the deprecated HTML
     "basefont" element tagBig, ## the HTML "big" element tagBlockquote,
     ## the HTML "blockquote" element tagBody, ## the HTML "body"
     element tagBr, ## the HTML "br" element tagButton, ## the HTML
     "button" element tagCanvas, ## the HTML "canvas" element
     tagCaption, ## the HTML "caption" element tagCenter, ## the
     deprecated HTML "center" element tagCite, ## the HTML "cite"
     element tagCode, ## the HTML "code" element tagCol, ## the HTML
     "col" element tagColgroup, ## the HTML "colgroup" element
     tagCommand, ## the HTML "command" element tagDatalist, ## the HTML
     "datalist" element tagDd, ## the HTML "dd" element tagDel, ## the
     HTML "del" element tagDetails, ## the HTML "details" element
     tagDfn, ## the HTML "dfn" element tagDialog, ## the HTML "dialog"
     element tagDiv, ## the HTML "div" element tagDir, ## the deprecated
     HTLM "dir" element tagDl, ## the HTML "dl" element tagDt, ## the
     HTML "dt" element tagEm, ## the HTML "em" element tagEmbed, ## the
     HTML "embed" element tagFieldset, ## the HTML "fieldset" element
     tagFigcaption, ## the HTML "figcaption" element tagFigure, ## the
     HTML "figure" element tagFont, ## the deprecated HTML "font"
     element tagFooter, ## the HTML "footer" element tagForm, ## the
     HTML "form" element tagFrame, ## the HTML "frame" element
     tagFrameset, ## the deprecated HTML "frameset" element tagH1, ##
     the HTML "h1" element tagH2, ## the HTML "h2" element tagH3, ## the
     HTML "h3" element tagH4, ## the HTML "h4" element tagH5, ## the
     HTML "h5" element tagH6, ## the HTML "h6" element tagHead, ## the
     HTML "head" element tagHeader, ## the HTML "header" element
     tagHgroup, ## the HTML "hgroup" element tagHtml, ## the HTML "html"
     element tagHr, ## the HTML "hr" element tagI, ## the HTML "i"
     element tagIframe, ## the deprecated HTML "iframe" element tagImg,
     ## the HTML "img" element tagInput, ## the HTML "input" element
     tagIns, ## the HTML "ins" element tagIsindex, ## the deprecated
     HTML "isindex" element tagKbd, ## the HTML "kbd" element tagKeygen,
     ## the HTML "keygen" element tagLabel, ## the HTML "label" element
     tagLegend, ## the HTML "legend" element tagLi, ## the HTML "li"
     element tagLink, ## the HTML "link" element tagMap, ## the HTML
     "map" element tagMark, ## the HTML "mark" element tagMenu, ## the
     deprecated HTML "menu" element tagMeta, ## the HTML "meta" element
     tagMeter, ## the HTML "meter" element tagNav, ## the HTML "nav"
     element tagNobr, ## the deprecated HTML "nobr" element tagNoframes,
     ## the deprecated HTML "noframes" element tagNoscript, ## the HTML
     "noscript" element tagObject, ## the HTML "object" element tagOl,
     ## the HTML "ol" element tagOptgroup, ## the HTML "optgroup"
     element tagOption, ## the HTML "option" element tagOutput, ## the
     HTML "output" element tagP, ## the HTML "p" element tagParam, ##
     the HTML "param" element tagPre, ## the HTML "pre" element
     tagProgress, ## the HTML "progress" element tagQ, ## the HTML "q"
     element tagRp, ## the HTML "rp" element tagRt, ## the HTML "rt"
     element tagRuby, ## the HTML "ruby" element tagS, ## the deprecated
     HTML "s" element tagSamp, ## the HTML "samp" element tagScript, ##
     the HTML "script" element tagSection, ## the HTML "section" element
     tagSelect, ## the HTML "select" element tagSmall, ## the HTML
     "small" element tagSource, ## the HTML "source" element tagSpan, ##
     the HTML "span" element tagStrike, ## the deprecated HTML "strike"
     element tagStrong, ## the HTML "strong" element tagStyle, ## the
     HTML "style" element tagSub, ## the HTML "sub" element tagSummary,
     ## the HTML "summary" element tagSup, ## the HTML "sup" element
     tagTable, ## the HTML "table" element tagTbody, ## the HTML "tbody"
     element tagTd, ## the HTML "td" element tagTextarea, ## the HTML
     "textarea" element tagTfoot, ## the HTML "tfoot" element tagTh, ##
     the HTML "th" element tagThead, ## the HTML "thead" element
     tagTime, ## the HTML "time" element tagTitle, ## the HTML "title"
     element tagTr, ## the HTML "tr" element tagTrack, ## the HTML
     "track" element tagTt, ## the HTML "tt" element tagU, ## the
     deprecated HTML "u" element tagUl, ## the HTML "ul" element tagVar,
     ## the HTML "var" element tagVideo, ## the HTML "video" element
     tagWbr ## the HTML "wbr" element
          HtmlTag* = enum
            tagUnknown,                 ## unknown HTML element
            tagA,                       ## the HTML ``a`` element
            tagAbbr,                    ## the deprecated HTML ``abbr`` element
            tagAcronym,                 ## the HTML ``acronym`` element
            tagAddress,                 ## the HTML ``address`` element
            tagApplet,                  ## the deprecated HTML ``applet`` element
            tagArea,                    ## the HTML ``area`` element
            tagArticle,                 ## the HTML ``article`` element
            tagAside,                   ## the HTML ``aside`` element
            tagAudio,                   ## the HTML ``audio`` element
            tagB,                       ## the HTML ``b`` element
            tagBase,                    ## the HTML ``base`` element
            tagBdi,                     ## the HTML ``bdi`` element
            tagBdo,                     ## the deprecated HTML ``dbo`` element
            tagBasefont,                ## the deprecated HTML ``basefont`` element
            tagBig,                     ## the HTML ``big`` element
            tagBlockquote,              ## the HTML ``blockquote`` element
            tagBody,                    ## the HTML ``body`` element
            tagBr,                      ## the HTML ``br`` element
            tagButton,                  ## the HTML ``button`` element
            tagCanvas,                  ## the HTML ``canvas`` element
            tagCaption,                 ## the HTML ``caption`` element
            tagCenter,                  ## the deprecated HTML ``center`` element
            tagCite,                    ## the HTML ``cite`` element
            tagCode,                    ## the HTML ``code`` element
            tagCol,                     ## the HTML ``col`` element
            tagColgroup,                ## the HTML ``colgroup`` element
            tagCommand,                 ## the HTML ``command`` element
            tagDatalist,                ## the HTML ``datalist`` element
            tagDd,                      ## the HTML ``dd`` element
            tagDel,                     ## the HTML ``del`` element
            tagDetails,                 ## the HTML ``details`` element
            tagDfn,                     ## the HTML ``dfn`` element
            tagDialog,                  ## the HTML ``dialog`` element
            tagDiv,                     ## the HTML ``div`` element
            tagDir,                     ## the deprecated HTLM ``dir`` element
            tagDl,                      ## the HTML ``dl`` element
            tagDt,                      ## the HTML ``dt`` element
            tagEm,                      ## the HTML ``em`` element
            tagEmbed,                   ## the HTML ``embed`` element
            tagFieldset,                ## the HTML ``fieldset`` element
            tagFigcaption,              ## the HTML ``figcaption`` element
            tagFigure,                  ## the HTML ``figure`` element
            tagFont,                    ## the deprecated HTML ``font`` element
            tagFooter,                  ## the HTML ``footer`` element
            tagForm,                    ## the HTML ``form`` element
            tagFrame,                   ## the HTML ``frame`` element
            tagFrameset,                ## the deprecated HTML ``frameset`` element
            tagH1,                      ## the HTML ``h1`` element
            tagH2,                      ## the HTML ``h2`` element
            tagH3,                      ## the HTML ``h3`` element
            tagH4,                      ## the HTML ``h4`` element
            tagH5,                      ## the HTML ``h5`` element
            tagH6,                      ## the HTML ``h6`` element
            tagHead,                    ## the HTML ``head`` element
            tagHeader,                  ## the HTML ``header`` element
            tagHgroup,                  ## the HTML ``hgroup`` element
            tagHtml,                    ## the HTML ``html`` element
            tagHr,                      ## the HTML ``hr`` element
            tagI,                       ## the HTML ``i`` element
            tagIframe,                  ## the deprecated HTML ``iframe`` element
            tagImg,                     ## the HTML ``img`` element
            tagInput,                   ## the HTML ``input`` element
            tagIns,                     ## the HTML ``ins`` element
            tagIsindex,                 ## the deprecated HTML ``isindex`` element
            tagKbd,                     ## the HTML ``kbd`` element
            tagKeygen,                  ## the HTML ``keygen`` element
            tagLabel,                   ## the HTML ``label`` element
            tagLegend,                  ## the HTML ``legend`` element
            tagLi,                      ## the HTML ``li`` element
            tagLink,                    ## the HTML ``link`` element
            tagMap,                     ## the HTML ``map`` element
            tagMark,                    ## the HTML ``mark`` element
            tagMenu,                    ## the deprecated HTML ``menu`` element
            tagMeta,                    ## the HTML ``meta`` element
            tagMeter,                   ## the HTML ``meter`` element
            tagNav,                     ## the HTML ``nav`` element
            tagNobr,                    ## the deprecated HTML ``nobr`` element
            tagNoframes,                ## the deprecated HTML ``noframes`` element
            tagNoscript,                ## the HTML ``noscript`` element
            tagObject,                  ## the HTML ``object`` element
            tagOl,                      ## the HTML ``ol`` element
            tagOptgroup,                ## the HTML ``optgroup`` element
            tagOption,                  ## the HTML ``option`` element
            tagOutput,                  ## the HTML ``output`` element
            tagP,                       ## the HTML ``p`` element
            tagParam,                   ## the HTML ``param`` element
            tagPre,                     ## the HTML ``pre`` element
            tagProgress,                ## the HTML ``progress`` element
            tagQ,                       ## the HTML ``q`` element
            tagRp,                      ## the HTML ``rp`` element
            tagRt,                      ## the HTML ``rt`` element
            tagRuby,                    ## the HTML ``ruby`` element
            tagS,                       ## the deprecated HTML ``s`` element
            tagSamp,                    ## the HTML ``samp`` element
            tagScript,                  ## the HTML ``script`` element
            tagSection,                 ## the HTML ``section`` element
            tagSelect,                  ## the HTML ``select`` element
            tagSmall,                   ## the HTML ``small`` element
            tagSource,                  ## the HTML ``source`` element
            tagSpan,                    ## the HTML ``span`` element
            tagStrike,                  ## the deprecated HTML ``strike`` element
            tagStrong,                  ## the HTML ``strong`` element
            tagStyle,                   ## the HTML ``style`` element
            tagSub,                     ## the HTML ``sub`` element
            tagSummary,                 ## the HTML ``summary`` element
            tagSup,                     ## the HTML ``sup`` element
            tagTable,                   ## the HTML ``table`` element
            tagTbody,                   ## the HTML ``tbody`` element
            tagTd,                      ## the HTML ``td`` element
            tagTextarea,                ## the HTML ``textarea`` element
            tagTfoot,                   ## the HTML ``tfoot`` element
            tagTh,                      ## the HTML ``th`` element
            tagThead,                   ## the HTML ``thead`` element
            tagTime,                    ## the HTML ``time`` element
            tagTitle,                   ## the HTML ``title`` element
            tagTr,                      ## the HTML ``tr`` element
            tagTrack,                   ## the HTML ``track`` element
            tagTt,                      ## the HTML ``tt`` element
            tagU,                       ## the deprecated HTML ``u`` element
            tagUl,                      ## the HTML ``ul`` element
            tagVar,                     ## the HTML ``var`` element
            tagVideo,                   ## the HTML ``video`` element
            tagWbr                      ## the HTML ``wbr`` element

     list of all supported HTML tags; order will always be
     alphabetically

216 Procedures
**************

   * htmlTag
          proc htmlTag*(n: XmlNode): HtmlTag

     gets n's tag as a 'HtmlTag'.

   * htmlTag
          proc htmlTag*(s: string): HtmlTag

     converts s to a 'HtmlTag'.  If s is no HTML tag, 'tagUnknown' is
     returned.

   * entityToUtf8
          proc entityToUtf8*(entity: string): string

     converts an HTML entity name like '&Uuml;' to its UTF-8 equivalent.
     ""  is returned if the entity name is unknown.  The HTML parser
     already converts entities to UTF-8.

   * parseHtml
          proc parseHtml*(s: Stream; filename: string; errors: var seq[string]): XmlNode

     parses the XML from stream s and returns a 'PXmlNode'.  Every
     occurred parsing error is added to the errors sequence.

   * parseHtml
          proc parseHtml*(s: Stream): XmlNode

     parses the XTML from stream s and returns a 'PXmlNode'.  All
     parsing errors are ignored.

   * loadHtml
          proc loadHtml*(path: string; errors: var seq[string]): XmlNode

     Loads and parses HTML from file specified by 'path', and returns a
     'PXmlNode'.  Every occurred parsing error is added to the errors
     sequence.

   * loadHtml
          proc loadHtml*(path: string): XmlNode

     Loads and parses HTML from file specified by 'path', and returns a
     'PXmlNode'.  All parsing errors are ignored.


File: nim-ref-0.13.0.info,  Node: /pure/gentabs,  Next: /pure/cookies,  Prev: /pure/htmlparser,  Up: Top

217 Types
*********

   * PGenTable
          PGenTable*[T] = ref GenTable[T]

     use this type to declare hash tables

218 Procedures
**************

   * len
          proc len*[T](tbl: PGenTable[T]): int {.inline.}

     returns the number of keys in tbl.

   * newGenTable
          proc newGenTable*[T](mode: GenTableMode): PGenTable[T]

     creates a new generic hash table that is empty.

   * hasKey
          proc hasKey*[T](tbl: PGenTable[T]; key: string): bool

     returns true iff key is in the table tbl.

   * '[]'
          proc `[]`*[T](tbl: PGenTable[T]; key: string): T

     retrieves the value at 'tbl[key]'.  If key is not in tbl,
     default(T) is returned and no exception is raised.  One can check
     with 'hasKey' whether the key exists.

   * '[]='
          proc `[]=`*[T](tbl: PGenTable[T]; key: string; val: T)

     puts a (key, value)-pair into tbl.

219 Iterators
*************

   * pairs
          iterator pairs*[T](tbl: PGenTable[T]): tuple[key: string, value: T]

     iterates over any (key, value) pair in the table tbl.


File: nim-ref-0.13.0.info,  Node: /pure/cookies,  Next: /pure/poly,  Prev: /pure/gentabs,  Up: Top

220 Procedures
**************

   * parseCookies
          proc parseCookies*(s: string): StringTableRef

     parses cookies into a string table.

   * setCookie secure = false; httpOnly = false): string
          proc setCookie*(key, value: string; domain = ""; path = ""; expires = ""; noName = false;
                         secure = false; httpOnly = false): string

     Creates a command in the format of 'Set-Cookie: key=value;
     Domain=...; ...'

   * setCookie noName = false; secure = false; httpOnly = false): string
          proc setCookie*(key, value: string; expires: TimeInfo; domain = ""; path = "";
                         noName = false; secure = false; httpOnly = false): string

     Creates a command in the format of 'Set-Cookie: key=value;
     Domain=...; ...'

     *Note:* UTC is assumed as the timezone for 'expires'.


File: nim-ref-0.13.0.info,  Node: /pure/poly,  Next: /pure/matchers,  Prev: /pure/cookies,  Up: Top

221 Types
*********

   * Poly cofs: seq[float]

          Poly* = object
            cofs: seq[float]


222 Procedures
**************

   * degree
          proc degree*(p: Poly): int

     Returns the degree of the polynomial, that is the number of
     coefficients-1

   * eval
          proc eval*(p: Poly; x: float): float

     Evaluates a polynomial function value for x quickly using Horners
     method

   * '[]'
          proc `[]`*(p: Poly; idx: int): float

     Gets a coefficient of the polynomial.  p[2] will returns the
     quadric term, p[3] the cubic etc.  Out of bounds index will return
     0.0.

   * '[]='
          proc `[]=`*(p: var Poly; idx: int; v: float)

     Sets an coefficient of the polynomial by index.  p[2] set the
     quadric term, p[3] the cubic etc.  If index is out of range for the
     coefficients, the polynomial grows to the smallest needed degree.

   * clean
          proc clean*(p: var Poly; zerotol = 0.0'f64)

     Removes leading zero coefficients of the polynomial.  An optional
     tolerance can be given for what's considered zero.

   * '$'
          proc `$`*(p: Poly): string

     Gets a somewhat reasonable string representation of the polynomial
     The format should be compatible with most online function plotters,
     for example directly in google search

   * derivative
          proc derivative*(p: Poly): Poly

     Returns a new polynomial, which is the derivative of p

   * diff
          proc diff*(p: Poly; x: float): float

     Evaluates the differentiation of a polynomial with respect to x
     quickly using a modifed Horners method

   * integral
          proc integral*(p: Poly): Poly

     Returns a new polynomial which is the indefinite integral of p.
     The constant term is set to 0.0

   * integrate
          proc integrate*(p: Poly; xmin, xmax: float): float

     Computes the definite integral of p between xmin and xmax quickly
     using a modified version of Horners method

   * initPoly
          proc initPoly*(cofs: varargs[float]): Poly

     Initializes a polynomial with given coefficients.  The most
     significant coefficient is first, so to create x^2-2x+3:
     intiPoly(1.0,-2.0,3.0)

   * divMod
          proc divMod*(p, d: Poly; q, r: var Poly)

     Divides p with d, and stores the quotinent in q and the remainder
     in d

   * '+'
          proc `+`*(p1: Poly; p2: Poly): Poly

     Adds two polynomials

   * '*'
          proc `*`*(p1: Poly; p2: Poly): Poly

     Multiplies the polynomial p1 with p2

   * '*'
          proc `*`*(p: Poly; f: float): Poly

     Multiplies the polynomial p with a real number

   * '*'
          proc `*`*(f: float; p: Poly): Poly

     Multiplies a real number with a polynomial

   * '-'
          proc `-`*(p: Poly): Poly

     Negates a polynomial

   * '-'
          proc `-`*(p1: Poly; p2: Poly): Poly

     Subtract p1 with p2

   * '/'
          proc `/`*(p: Poly; f: float): Poly

     Divides polynomial p with a real number f

   * '/'
          proc `/`*(p, q: Poly): Poly

     Divides polynomial p with polynomial q

   * 'mod'
          proc `mod`*(p, q: Poly): Poly

     Computes the polynomial modulo operation, that is the remainder of
     p/q

   * normalize
          proc normalize*(p: var Poly)

     Multiplies the polynomial inplace by a term so that the leading
     term is 1.0.  This might lead to an unstable polynomial if the
     leading term is zero.

   * solveQuadric
          proc solveQuadric*(a, b, c: float; zerotol = 0.0'f64): seq[float]

     Solves the quadric equation ax^2+bx+c, with a possible tolerance
     zerotol to find roots of curves just 'touching' the x axis.
     Returns sequence with 0,1 or 2 solutions.

   * roots maxiter = 1000): seq[float]
          proc roots*(p: Poly; tol = 1e-09'f64; zerotol = 1e-06'f64; mergetol = 1e-12'f64;
                     maxiter = 1000): seq[float]

     Computes the real roots of the polynomial p tol is the tolerance
     used to break searching for each root when reached.  zerotol is the
     tolerance, which is 'close enough' to zero to be considered a root
     and is used to find roots for curves that only 'touch' the x-axis.
     mergetol is the tolerance, of which two x-values are considered
     beeing the same root.  maxiter can be used to limit the number of
     iterations for each root.  Returns a (possibly empty) sorted
     sequence with the solutions.

223 Iterators
*************

   * items
          iterator items*(p: Poly): float

     Iterates through the coefficients of the polynomial.


File: nim-ref-0.13.0.info,  Node: /pure/matchers,  Next: /pure/parseutils,  Prev: /pure/poly,  Up: Top

224 Procedures
**************

   * validEmailAddress extern: "nsuValidEmailAddress".}
          proc validEmailAddress*(s: string): bool {.noSideEffect, rtl,
                                                 extern: "nsuValidEmailAddress".}

     returns true if s seems to be a valid e-mail address.  The checking
     also uses a domain list.

   * parseInt extern: "nmatchParseInt".}
          proc parseInt*(s: string; value: var int; validRange: Slice[int]) {.noSideEffect, rtl,
              extern: "nmatchParseInt".}

     parses s into an integer in the range validRange.  If successful,
     value is modified to contain the result.  Otherwise no exception is
     raised and value is not touched; this way a reasonable default
     value won't be overwritten.


File: nim-ref-0.13.0.info,  Node: /pure/parseutils,  Next: /pure/scgi,  Prev: /pure/matchers,  Up: Top

225 Types
*********

   * InterpolatedKind ikStr, ## "str" part of the interpolated string
     ikDollar, ## escaped "$" part of the interpolated string ikVar, ##
     "var" part of the interpolated string ikExpr ## "expr" part of the
     interpolated string
          InterpolatedKind* = enum
            ikStr,                      ## ``str`` part of the interpolated string
            ikDollar,                   ## escaped ``$`` part of the interpolated string
            ikVar,                      ## ``var`` part of the interpolated string
            ikExpr                      ## ``expr`` part of the interpolated string

     describes for interpolatedFragments which part of the interpolated
     string is yielded; for example in "str$$$var${expr}"

226 Procedures
**************

   * parseHex extern: "npuParseHex", noSideEffect.}
          proc parseHex*(s: string; number: var int; start = 0; maxLen = 0): int {.rtl,
              extern: "npuParseHex", noSideEffect.}

     Parses a hexadecimal number and stores its value in 'number'.

     Returns the number of the parsed characters or 0 in case of an
     error.  This proc is sensitive to the already existing value of
     'number' and will likely not do what you want unless you make sure
     'number' is zero.  You can use this feature to _chain_ calls,
     though the result int will quickly overflow.  Example:
     var value = 0
     discard parseHex("0x38", value)
     assert value == 56
     discard parseHex("0x34", value)
     assert value == 56 * 256 + 52
     value = -1
     discard parseHex("0x38", value)
     assert value == -200

     If 'maxLen==0' the length of the hexadecimal number has no upper
     bound.  Not more than "'maxLen" characters are parsed.

   * parseOct noSideEffect.}
          proc parseOct*(s: string; number: var int; start = 0): int {.rtl, extern: "npuParseOct",
              noSideEffect.}

     parses an octal number and stores its value in 'number'.  Returns
     the number of the parsed characters or 0 in case of an error.

   * parseIdent
          proc parseIdent*(s: string; ident: var string; start = 0): int

     parses an identifier and stores it in 'ident'.  Returns the number
     of the parsed characters or 0 in case of an error.

   * parseIdent
          proc parseIdent*(s: string; start = 0): string

     parses an identifier and stores it in 'ident'.  Returns the parsed
     identifier or an empty string in case of an error.

   * parseToken inline, deprecated.}
          proc parseToken*(s: string; token: var string; validChars: set[char]; start = 0): int {.
              inline, deprecated.}

     parses a token and stores it in 'token'.  Returns the number of the
     parsed characters or 0 in case of an error.  A token consists of
     the characters in validChars.

     *Deprecated since version 0.8.12*: Use 'parseWhile' instead.

   * skipWhitespace
          proc skipWhitespace*(s: string; start = 0): int {.inline.}

     skips the whitespace starting at 's[start]'.  Returns the number of
     skipped characters.

   * skip
          proc skip*(s, token: string; start = 0): int {.inline.}

     skips the token starting at 's[start]'.  Returns the length of
     token or 0 if there was no token at 's[start]'.

   * skipIgnoreCase
          proc skipIgnoreCase*(s, token: string; start = 0): int

     same as skip but case is ignored for token matching.

   * skipUntil
          proc skipUntil*(s: string; until: set[char]; start = 0): int {.inline.}

     Skips all characters until one char from the set until is found or
     the end is reached.  Returns number of characters skipped.

   * skipUntil
          proc skipUntil*(s: string; until: char; start = 0): int {.inline.}

     Skips all characters until the char until is found or the end is
     reached.  Returns number of characters skipped.

   * skipWhile
          proc skipWhile*(s: string; toSkip: set[char]; start = 0): int {.inline.}

     Skips all characters while one char from the set token is found.
     Returns number of characters skipped.

   * parseUntil
          proc parseUntil*(s: string; token: var string; until: set[char]; start = 0): int {.inline.}

     parses a token and stores it in 'token'.  Returns the number of the
     parsed characters or 0 in case of an error.  A token consists of
     the characters notin until.

   * parseUntil
          proc parseUntil*(s: string; token: var string; until: char; start = 0): int {.inline.}

     parses a token and stores it in 'token'.  Returns the number of the
     parsed characters or 0 in case of an error.  A token consists of
     any character that is not the until character.

   * parseWhile inline.}
          proc parseWhile*(s: string; token: var string; validChars: set[char]; start = 0): int {.
              inline.}

     parses a token and stores it in 'token'.  Returns the number of the
     parsed characters or 0 in case of an error.  A token consists of
     the characters in validChars.

   * captureBetween
          proc captureBetween*(s: string; first: char; second = '\0'; start = 0): string

     Finds the first occurrence of 'first', then returns everything from
     there up to 'second``(if ``second' is '0', then 'first' is used).

   * parseBiggestInt extern: "npuParseBiggestInt", noSideEffect.}
          proc parseBiggestInt*(s: string; number: var BiggestInt; start = 0): int {.rtl,
              extern: "npuParseBiggestInt", noSideEffect.}

     parses an integer starting at start and stores the value into
     number.  Result is the number of processed chars or 0 if there is
     no integer.  EOverflow is raised if an overflow occurs.

   * parseInt noSideEffect.}
          proc parseInt*(s: string; number: var int; start = 0): int {.rtl, extern: "npuParseInt",
              noSideEffect.}

     parses an integer starting at start and stores the value into
     number.  Result is the number of processed chars or 0 if there is
     no integer.  EOverflow is raised if an overflow occurs.

   * parseBiggestFloat magic: "ParseBiggestFloat", importc:
     "nimParseBiggestFloat", noSideEffect.}
          proc parseBiggestFloat*(s: string; number: var BiggestFloat; start = 0): int {.
              magic: "ParseBiggestFloat", importc: "nimParseBiggestFloat", noSideEffect.}

     parses a float starting at start and stores the value into number.
     Result is the number of processed chars or 0 if a parsing error
     occurred.

   * parseFloat extern: "npuParseFloat", noSideEffect.}
          proc parseFloat*(s: string; number: var float; start = 0): int {.rtl,
              extern: "npuParseFloat", noSideEffect.}

     parses a float starting at start and stores the value into number.
     Result is the number of processed chars or 0 if there occurred a
     parsing error.

227 Iterators
*************

   * interpolatedFragments value: string]
          iterator interpolatedFragments*(s: string): tuple[kind: InterpolatedKind,
              value: string]

     Tokenizes the string s into substrings for interpolation purposes.

     Example:
     for k, v in interpolatedFragments("  $this is ${an  example}  $$"):
       echo "(", k, ", \"", v, "\")"

     Results in:
     (ikString, "  ")
     (ikExpr, "this")
     (ikString, " is ")
     (ikExpr, "an  example")
     (ikString, "  ")
     (ikDollar, "$")


File: nim-ref-0.13.0.info,  Node: /pure/scgi,  Next: /pure/hashes,  Prev: /pure/parseutils,  Up: Top

228 Types
*********

   * ScgiError
          ScgiError* = object of IOError

     the exception that is raised, if a SCGI error occurs

   * AsyncScgiState
          AsyncScgiState* = ref AsyncScgiStateObj

229 Procedures
**************

   * raiseScgiError
          proc raiseScgiError*(msg: string) {.noreturn.}

     raises an ScgiError exception with message msg.

   * open
          proc open*(s: var ScgiState; port = Port(4000); address = "127.0.0.1"; reuseAddr = false)

     opens a connection.

   * close
          proc close*(s: var ScgiState)

     closes the connection.

   * next
          proc next*(s: var ScgiState; timeout: int = - 1): bool

     proceed to the first/next request.  Waits 'timeout' milliseconds
     for a request, if 'timeout' is -1 then this function will never
     time out.  Returns true if a new request has been processed.

   * writeStatusOkTextContent
          proc writeStatusOkTextContent*(c: Socket; contentType = "text/html")

     sends the following string to the socket c:
     Status: 200 OK\r\LContent-Type: text/html\r\L\r\L

     You should send this before sending your HTML page, for example.

   * run nimcall, gcsafe.}; port = Port(4000))
          proc run*(handleRequest: proc (client: Socket; input: string; headers: StringTableRef): bool {.
              nimcall, gcsafe.}; port = Port(4000))

     encapsulates the SCGI object and main loop.

   * open headers: StringTableRef) {.closure, gcsafe.}; port =
     Port(4000); address = "127.0.0.1"; reuseAddr = false):
     AsyncScgiState
          proc open*(handleRequest: proc (client: AsyncSocket; input: string;
                                       headers: StringTableRef) {.closure, gcsafe.};
                    port = Port(4000); address = "127.0.0.1"; reuseAddr = false): AsyncScgiState

     Creates an 'AsyncScgiState' object which serves as a SCGI server.

     After the execution of 'handleRequest' the client socket will be
     closed automatically unless it has already been closed.

   * register
          proc register*(d: Dispatcher; s: AsyncScgiState): Delegate {.discardable.}

     Registers 's' with dispatcher 'd'.

   * close
          proc close*(s: AsyncScgiState)

     Closes the 'AsyncScgiState'.


File: nim-ref-0.13.0.info,  Node: /pure/hashes,  Next: /pure/logging,  Prev: /pure/scgi,  Up: Top

230 Types
*********

   * Hash
          Hash* = int

     a hash value; hash tables using these values should always have a
     size of a power of two and can use the 'and' operator instead of
     'mod' for truncation of the hash value.

231 Procedures
**************

   * '!&amp;'
          proc `!&`*(h: Hash; val: int): Hash {.inline.}

     mixes a hash value h with val to produce a new hash value.  This is
     only needed if you need to implement a hash proc for a new
     datatype.

   * '!$'
          proc `!$`*(h: Hash): Hash {.inline.}

     finishes the computation of the hash value.  This is only needed if
     you need to implement a hash proc for a new datatype.

   * hashData
          proc hashData*(data: pointer; size: int): Hash

     hashes an array of bytes of size size

   * hash
          proc hash*(x: pointer): Hash {.inline.}

     efficient hashing of pointers

   * hash
          proc hash*[T: proc](x: T): Hash {.inline.}

     efficient hashing of proc vars; closures are supported too.

   * hash
          proc hash*(x: int): Hash {.inline.}

     efficient hashing of integers

   * hash
          proc hash*(x: int64): Hash {.inline.}

     efficient hashing of int64 integers

   * hash
          proc hash*(x: char): Hash {.inline.}

     efficient hashing of characters

   * hash
          proc hash*[T: Ordinal](x: T): Hash {.inline.}

     efficient hashing of other ordinal types (e.g., enums)

   * hash
          proc hash*(x: string): Hash

     efficient hashing of strings

   * hash
          proc hash*(sBuf: string; sPos, ePos: int): Hash

     efficient hashing of a string buffer, from starting position sPos
     to ending position ePos

     'hash(myStr, 0, myStr.high)' is equivalent to 'hash(myStr)'

   * hashIgnoreStyle
          proc hashIgnoreStyle*(x: string): Hash

     efficient hashing of strings; style is ignored

   * hashIgnoreStyle
          proc hashIgnoreStyle*(sBuf: string; sPos, ePos: int): Hash

     efficient hashing of a string buffer, from starting position sPos
     to ending position ePos; style is ignored

     'hashIgnoreStyle(myBuf, 0, myBuf.high)' is equivalent to
     'hashIgnoreStyle(myBuf)'

   * hashIgnoreCase
          proc hashIgnoreCase*(x: string): Hash

     efficient hashing of strings; case is ignored

   * hashIgnoreCase
          proc hashIgnoreCase*(sBuf: string; sPos, ePos: int): Hash

     efficient hashing of a string buffer, from starting position sPos
     to ending position ePos; case is ignored

     'hashIgnoreCase(myBuf, 0, myBuf.high)' is equivalent to
     'hashIgnoreCase(myBuf)'

   * hash
          proc hash*(x: float): Hash {.inline.}

     efficient hashing of floats.

   * hash
          proc hash*[A](x: openArray[A]): Hash

   * hash
          proc hash*[A](x: set[A]): Hash

   * hash
          proc hash*[T: tuple](x: T): Hash

     efficient hashing of tuples.

   * hash
          proc hash*[A](x: openArray[A]): Hash

     efficient hashing of arrays and sequences.

   * hash
          proc hash*[A](aBuf: openArray[A]; sPos, ePos: int): Hash

     efficient hashing of portions of arrays and sequences.

     'hash(myBuf, 0, myBuf.high)' is equivalent to 'hash(myBuf)'

   * hash
          proc hash*[A](x: set[A]): Hash

     efficient hashing of sets.


File: nim-ref-0.13.0.info,  Node: /pure/logging,  Next: /pure/xmldomparser,  Prev: /pure/hashes,  Up: Top

232 Constant variables
**********************

   * verboseFmtStr
          verboseFmtStr* = "$levelid, [$datetime] -- $appname: "

233 Types
*********

   * Level lvlAll, ## all levels active lvlDebug, ## debug level (and
     any above) active lvlInfo, ## info level (and any above) active
     lvlWarn, ## warn level (and any above) active lvlError, ## error
     level (and any above) active lvlFatal, ## fatal level (and any
     above) active lvlNone ## no levels active
          Level* = enum
            lvlAll,                     ## all levels active
            lvlDebug,                   ## debug level (and any above) active
            lvlInfo,                    ## info level (and any above) active
            lvlWarn,                    ## warn level (and any above) active
            lvlError,                   ## error level (and any above) active
            lvlFatal,                   ## fatal level (and any above) active
            lvlNone                     ## no levels active

     logging level

   * RollingFileLogger maxLines: int curLine: int baseName: string
     baseMode: FileMode logFiles: int bufSize: int

          RollingFileLogger* = ref object of FileLogger
            maxLines: int
            curLine: int
            baseName: string
            baseMode: FileMode
            logFiles: int
            bufSize: int


     logger that writes the messages to a file and performs log rotation

234 Procedures
**************

   * substituteLog
          proc substituteLog*(frmt: string; level: Level; args: varargs[string, `$`]): string

     Format a log message using the 'frmt' format string, 'level' and
     varargs.  See the module documentation for the format string
     syntax.

   * defaultFilename
          proc defaultFilename*(): string

     Returns the default filename for a logger.

   * newConsoleLogger
          proc newConsoleLogger*(levelThreshold = lvlAll; fmtStr = defaultFmtStr): ConsoleLogger

     Creates a new console logger.  This logger logs to the console.

   * newFileLogger levelThreshold = lvlAll; fmtStr = defaultFmtStr;
     bufSize: int = - 1): FileLogger
          proc newFileLogger*(filename = defaultFilename(); mode: FileMode = fmAppend;
                             levelThreshold = lvlAll; fmtStr = defaultFmtStr; bufSize: int = - 1): FileLogger

     Creates a new file logger.  This logger logs to a file.  Use
     'bufSize' as size of the output buffer when writing the file (-1:
     use system defaults, 0: unbuffered, >0: fixed buffer size).

   * newRollingFileLogger mode: FileMode = fmReadWrite; levelThreshold =
     lvlAll; fmtStr = defaultFmtStr; maxLines = 1000; bufSize: int = -
     1): RollingFileLogger
          proc newRollingFileLogger*(filename = defaultFilename();
                                    mode: FileMode = fmReadWrite; levelThreshold = lvlAll;
                                    fmtStr = defaultFmtStr; maxLines = 1000; bufSize: int = - 1): RollingFileLogger

     Creates a new rolling file logger.  Once a file reaches 'maxLines'
     lines a new log file will be started and the old will be renamed.
     Use 'bufSize' as size of the output buffer when writing the file
     (-1: use system defaults, 0: unbuffered, >0: fixed buffer size).

   * addHandler
          proc addHandler*(handler: Logger)

     Adds 'handler' to the list of handlers.

   * getHandlers
          proc getHandlers*(): seq[Logger]

     Returns a list of all the registered handlers.

   * setLogFilter
          proc setLogFilter*(lvl: Level)

     Sets the global log filter.

   * getLogFilter
          proc getLogFilter*(): Level

     Gets the global log filter.

235 Templates
*************

   * log
          template log*(level: Level; args: varargs[string, `$`])

     Logs a message to all registered handlers at the given level.

   * debug
          template debug*(args: varargs[string, `$`])

     Logs a debug message to all registered handlers.

   * info
          template info*(args: varargs[string, `$`])

     Logs an info message to all registered handlers.

   * warn
          template warn*(args: varargs[string, `$`])

     Logs a warning message to all registered handlers.

   * error
          template error*(args: varargs[string, `$`])

     Logs an error message to all registered handlers.

   * fatal
          template fatal*(args: varargs[string, `$`])

     Logs a fatal error message to all registered handlers.

236 Methods
***********

   * log raises: [Exception], tags: [TimeEffect, WriteIOEffect,
     ReadIOEffect], base.}
          method log*(logger: Logger; level: Level; args: varargs[string, `$`]) {.
              raises: [Exception], tags: [TimeEffect, WriteIOEffect, ReadIOEffect], base.}

     Override this method in custom loggers.  Default implementation
     does nothing.

   * log
          method log*(logger: ConsoleLogger; level: Level; args: varargs[string, `$`])

     Logs to the console using 'logger' only.

   * log
          method log*(logger: FileLogger; level: Level; args: varargs[string, `$`])

     Logs to a file using 'logger' only.

   * log
          method log*(logger: RollingFileLogger; level: Level; args: varargs[string, `$`])

     Logs to a file using rolling 'logger' only.


File: nim-ref-0.13.0.info,  Node: /pure/xmldomparser,  Next: /pure/algorithm,  Prev: /pure/logging,  Up: Top

237 Procedures
**************

   * loadXMLStream
          proc loadXMLStream*(stream: Stream): PDocument

     Loads and parses XML from a stream specified by 'stream', and
     returns a 'PDocument'

   * loadXML
          proc loadXML*(xml: string): PDocument

     Loads and parses XML from a string specified by 'xml', and returns
     a 'PDocument'

   * loadXMLFile
          proc loadXMLFile*(path: string): PDocument

     Loads and parses XML from a file specified by 'path', and returns a
     'PDocument'


File: nim-ref-0.13.0.info,  Node: /pure/algorithm,  Next: /pure/concurrency/cpuinfo,  Prev: /pure/xmldomparser,  Up: Top

238 Types
*********

   * SortOrder Descending, Ascending
          SortOrder* = enum
            Descending, Ascending

     sort order

239 Procedures
**************

   * '*'
          proc `*`*(x: int; order: SortOrder): int {.inline.}

     flips x if 'order == Descending'; if 'order == Ascending' then x is
     returned.  x is supposed to be the result of a comparator, ie '< 0'
     for _less than_, '== 0' for _equal_, '> 0' for _greater than_.

   * fill
          proc fill*[T](a: var openArray[T]; first, last: Natural; value: T)

     fills the array 'a[first..last]' with value.

   * fill
          proc fill*[T](a: var openArray[T]; value: T)

     fills the array a with value.

   * reverse
          proc reverse*[T](a: var openArray[T]; first, last: Natural)

     reverses the array 'a[first..last]'.

   * reverse
          proc reverse*[T](a: var openArray[T])

     reverses the array a.

   * reversed
          proc reversed*[T](a: openArray[T]; first: Natural; last: int): seq[T]

     returns the reverse of the array a[first..last].

   * reversed
          proc reversed*[T](a: openArray[T]): seq[T]

     returns the reverse of the array a.

   * binarySearch
          proc binarySearch*[T](a: openArray[T]; key: T): int

     binary search for key in a.  Returns -1 if not found.

   * smartBinarySearch
          proc smartBinarySearch*[T](a: openArray[T]; key: T): int

     'a.len' must be a power of 2 for this to work.

   * lowerBound
          proc lowerBound*[T](a: openArray[T]; key: T; cmp: proc (x, y: T): int {.closure.}): int

     same as binarySearch except that if key is not in a then this
     returns the location where key would be if it were.  In other words
     if you have a sorted sequence and you call insert(thing, elm,
     lowerBound(thing, elm)) the sequence will still be sorted.

     cmp is the comparator function to use, the expected return values
     are the same as that of system.cmp.

     example:
     var arr = @[1,2,3,5,6,7,8,9]
     arr.insert(4, arr.lowerBound(4))
     # after running the above arr is `[1,2,3,4,5,6,7,8,9]`

   * lowerBound
          proc lowerBound*[T](a: openArray[T]; key: T): int

   * sort order = SortOrder.Ascending)
          proc sort*[T](a: var openArray[T]; cmp: proc (x, y: T): int {.closure.};
                       order = SortOrder.Ascending)

     Default Nim sort (an implementation of merge sort).  The sorting is
     guaranteed to be stable and the worst case is guaranteed to be O(n
     log n).  The current implementation uses an iterative mergesort to
     achieve this.  It uses a temporary sequence of length 'a.len div
     2'.  Currently Nim does not support a sensible default argument for
     'cmp', so you have to provide one of your own.  However, the
     'system.cmp' procs can be used:
     sort(myIntArray, system.cmp[int])

     # do not use cmp[string] here as we want to use the specialized
     # overload:
     sort(myStrArray, system.cmp)

     You can inline adhoc comparison procs with the do notation
     (manual.html#do-notation).  Example:
     people.sort do (x, y: Person) -> int:
       result = cmp(x.surname, y.surname)
       if result == 0:
         result = cmp(x.name, y.name)

   * sorted order = SortOrder.Ascending): seq[T]
          proc sorted*[T](a: openArray[T]; cmp: proc (x, y: T): int {.closure.};
                         order = SortOrder.Ascending): seq[T]

     returns a sorted by cmp in the specified order.

   * isSorted order = SortOrder.Ascending): bool
          proc isSorted*[T](a: openarray[T]; cmp: proc (x, y: T): int {.closure.};
                           order = SortOrder.Ascending): bool

     Checks to see whether a is already sorted in order using cmp for
     the comparison.  Parameters identical to sort

   * product
          proc product*[T](x: openArray[seq[T]]): seq[seq[T]]

     produces the Cartesian product of the array.  Warning: complexity
     may explode.

   * nextPermutation
          proc nextPermutation*[T](x: var openarray[T]): bool {.discardable.}

     Calculates the next lexicographic permutation, directly modifying
     'x'.  The result is whether a permutation happened, otherwise we
     have reached the last-ordered permutation.
     var v = @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     v.nextPermutation()
     echo v # @[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]

   * prevPermutation
          proc prevPermutation*[T](x: var openarray[T]): bool {.discardable.}

     Calculates the previous lexicographic permutation, directly
     modifying 'x'.  The result is whether a permutation happened,
     otherwise we have reached the first-ordered permutation.
     var v = @[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
     v.prevPermutation()
     echo v # @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

240 Templates
*************

   * sortedByIt
          template sortedByIt*(seq1, op: expr): expr

     Convenience template around the 'sorted' proc to reduce typing.

     The template injects the 'it' variable which you can use directly
     in an expression.  Example:
     type Person = tuple[name: string, age: int]
     var
       p1: Person = (name: "p1", age: 60)
       p2: Person = (name: "p2", age: 20)
       p3: Person = (name: "p3", age: 30)
       p4: Person = (name: "p4", age: 30)
       people = @[p1,p2,p4,p3]

     echo people.sortedByIt(it.name)

     Because the underlying 'cmp()' is defined for tuples you can do a
     nested sort like in the following example:
     echo people.sortedByIt((it.age, it.name))


File: nim-ref-0.13.0.info,  Node: /pure/concurrency/cpuinfo,  Next: /pure/concurrency/threadpool,  Prev: /pure/algorithm,  Up: Top

241 Procedures
**************

   * countProcessors
          proc countProcessors*(): int {.rtl, extern: "ncpi$1".}

     returns the numer of the processors/cores the machine has.  Returns
     0 if it cannot be detected.


File: nim-ref-0.13.0.info,  Node: /pure/concurrency/threadpool,  Next: /pure/concurrency/cpuload,  Prev: /pure/concurrency/cpuinfo,  Up: Top

242 Constant variables
**********************

   * MaxDistinguishedThread
          MaxDistinguishedThread* = 32

     maximal number of "distinguished" threads.

243 Types
*********

   * ThreadId
          ThreadId* = range[0 .. MaxDistinguishedThread - 1]

244 Procedures
**************

   * await
          proc await*(fv: FlowVarBase)

     waits until the value for the flowVar arrives.  Usually it is not
     necessary to call this explicitly.

   * awaitAndThen
          proc awaitAndThen*[T](fv: FlowVar[T]; action: proc (x: T) {.closure.})

     blocks until the 'fv' is available and then passes its value to
     'action'.  Note that due to Nim's parameter passing semantics this
     means that 'T' doesn't need to be copied and so 'awaitAndThen' can
     sometimes be more efficient than '^'.

   * unsafeRead
          proc unsafeRead*[T](fv: FlowVar[ref T]): foreign ptr T

     blocks until the value is available and then returns this value.

   * '^'
          proc `^`*[T](fv: FlowVar[ref T]): ref T

     blocks until the value is available and then returns this value.

   * '^'
          proc `^`*[T](fv: FlowVar[T]): T

     blocks until the value is available and then returns this value.

   * awaitAny
          proc awaitAny*(flowVars: openArray[FlowVarBase]): int

     awaits any of the given flowVars.  Returns the index of one flowVar
     for which a value arrived.  A flowVar only supports one call to
     'awaitAny' at the same time.  That means if you await([a,b]) and
     await([b,c]) the second call will only await 'c'.  If there is no
     flowVar left to be able to wait on, -1 is returned.  *Note*: This
     results in non-deterministic behaviour and so should be avoided.

   * isReady
          proc isReady*(fv: FlowVarBase): bool

     Determines whether the specified 'FlowVarBase''s value is
     available.

     If 'true' awaiting 'fv' will not block.

   * setMinPoolSize
          proc setMinPoolSize*(size: range[1 .. MaxThreadPoolSize])

     sets the minimal thread pool size.  The default value of this is 4.

   * setMaxPoolSize
          proc setMaxPoolSize*(size: range[1 .. MaxThreadPoolSize])

     sets the maximal thread pool size.  The default value of this is
     'MaxThreadPoolSize'.

   * preferSpawn
          proc preferSpawn*(): bool

     Use this proc to determine quickly if a 'spawn' or a direct call is
     preferable.  If it returns 'true' a 'spawn' may make sense.  In
     general it is not necessary to call this directly; use 'spawnX'
     instead.

   * spawn
          proc spawn*(call: expr): expr {.magic: "Spawn".}

     always spawns a new task, so that the 'call' is never executed on
     the calling thread.  'call' has to be proc call 'p(...)'  where 'p'
     is gcsafe and has a return type that is either 'void' or compatible
     with 'FlowVar[T]'.

   * pinnedSpawn
          proc pinnedSpawn*(id: ThreadId; call: expr): expr {.magic: "Spawn".}

     always spawns a new task on the worker thread with 'id', so that
     the 'call' is *always* executed on the this thread.  'call' has to
     be proc call 'p(...)'  where 'p' is gcsafe and has a return type
     that is either 'void' or compatible with 'FlowVar[T]'.

   * parallel
          proc parallel*(body: stmt) {.magic: "Parallel".}

     a parallel section can be used to execute a block in parallel.
     'body' has to be in a DSL that is a particular subset of the
     language.  Please refer to the manual for further information.

   * sync
          proc sync*()

     a simple barrier to wait for all spawn'ed tasks.  If you need more
     elaborate waiting, you have to use an explicit barrier.

245 Templates
*************

   * spawnX
          template spawnX*(call: expr): expr

     spawns a new task if a CPU core is ready, otherwise executes the
     call in the calling thread.  Usually it is advised to use 'spawn'
     in order to not block the producer for an unknown amount of time.
     'call' has to be proc call 'p(...)'  where 'p' is gcsafe and has a
     return type that is either 'void' or compatible with 'FlowVar[T]'.


File: nim-ref-0.13.0.info,  Node: /pure/concurrency/cpuload,  Next: /pure/unidecode/unidecode,  Prev: /pure/concurrency/threadpool,  Up: Top

246 Types
*********

   * ThreadPoolState when defined(windows): prevSysKernel, prevSysUser,
     prevProcKernel, prevProcUser: FILETIME

     calls*: int

          ThreadPoolState* = object
            when defined(windows):
                prevSysKernel, prevSysUser, prevProcKernel, prevProcUser: FILETIME

            calls*: int


247 Procedures
**************

   * advice
          proc advice*(s: var ThreadPoolState): ThreadPoolAdvice


File: nim-ref-0.13.0.info,  Node: /pure/unidecode/unidecode,  Next: /pure/collections/sequtils,  Prev: /pure/concurrency/cpuload,  Up: Top

248 Procedures
**************

   * loadUnidecodeTable
          proc loadUnidecodeTable*(datafile = "unidecode.dat")

     loads the datafile that unidecode to work.  Unless this module is
     compiled with the 'embedUnidecodeTable' symbol defined, this needs
     to be called by the main thread before any thread can make a call
     to unidecode.

   * unidecode
          proc unidecode*(s: string): string

     Finds the sequence of ASCII characters that is the closest
     approximation to the UTF-8 string s.

     Example:

          unidecode("x53x17x4ExB0")
     Results in: "Bei Jing"


File: nim-ref-0.13.0.info,  Node: /pure/collections/sequtils,  Next: /pure/collections/sharedtables,  Prev: /pure/unidecode/unidecode,  Up: Top

249 Procedures
**************

   * concat
          proc concat*[T](seqs: varargs[seq[T]]): seq[T]

     Takes several sequences' items and returns them inside a new
     sequence.

     Example:
     let
       s1 = @[1, 2, 3]
       s2 = @[4, 5]
       s3 = @[6, 7]
       total = concat(s1, s2, s3)
     assert total == @[1, 2, 3, 4, 5, 6, 7]

   * cycle
          proc cycle*[T](s: seq[T]; n: Natural): seq[T]

     Returns a new sequence with the items of s repeated n times.

     Example:

          let

               s = @[1, 2, 3] total = s.cycle(3)

          assert total == @[1, 2, 3, 1, 2, 3, 1, 2, 3]

   * repeat
          proc repeat*[T](x: T; n: Natural): seq[T]

     Returns a new sequence with the item x repeated n times.

     Example:

          let

               total = repeat(5, 3)

          assert total == @[5, 5, 5]

   * deduplicate
          proc deduplicate*[T](seq1: seq[T]): seq[T]

     Returns a new sequence without duplicates.
     let
       dup1 = @[1, 1, 3, 4, 2, 2, 8, 1, 4]
       dup2 = @["a", "a", "c", "d", "d"]
       unique1 = deduplicate(dup1)
       unique2 = deduplicate(dup2)
     assert unique1 == @[1, 3, 4, 2, 8]
     assert unique2 == @["a", "c", "d"]

   * zip
          proc zip*[S, T](seq1: seq[S]; seq2: seq[T]): seq[tuple[a: S, b: T]]

     Returns a new sequence with a combination of the two input
     sequences.

     For convenience you can access the returned tuples through the
     named fields a and b.  If one sequence is shorter, the remaining
     items in the longer sequence are discarded.  Example:
     let
       short = @[1, 2, 3]
       long = @[6, 5, 4, 3, 2, 1]
       words = @["one", "two", "three"]
       zip1 = zip(short, long)
       zip2 = zip(short, words)
     assert zip1 == @[(1, 6), (2, 5), (3, 4)]
     assert zip2 == @[(1, "one"), (2, "two"), (3, "three")]
     assert zip1[2].b == 4
     assert zip2[2].b == "three"

   * distribute
          proc distribute*[T](s: seq[T]; num: Positive; spread = true): seq[seq[T]]

     Splits and distributes a sequence s into num sub sequences.

     Returns a sequence of num sequences.  For some input values this is
     the inverse of the concat (#concat) proc.  The proc will assert in
     debug builds if s is nil or num is less than one, and will likely
     crash on release builds.  The input sequence s can be empty, which
     will produce num empty sequences.

     If spread is false and the length of s is not a multiple of num,
     the proc will max out the first sub sequences with '1 + len(s) div
     num' entries, leaving the remainder of elements to the last
     sequence.

     On the other hand, if spread is true, the proc will distribute
     evenly the remainder of the division across all sequences, which
     makes the result more suited to multithreading where you are
     passing equal sized work units to a thread pool and want to
     maximize core usage.

     Example:
     let numbers = @[1, 2, 3, 4, 5, 6, 7]
     assert numbers.distribute(3) == @[@[1, 2, 3], @[4, 5], @[6, 7]]
     assert numbers.distribute(3, false)  == @[@[1, 2, 3], @[4, 5, 6], @[7]]
     assert numbers.distribute(6)[0] == @[1, 2]
     assert numbers.distribute(6)[5] == @[7]

   * map
          proc map*[T, S](data: openArray[T]; op: proc (x: T): S {.closure.}): seq[S] {.inline.}

     Returns a new sequence with the results of op applied to every item
     in data.

     Since the input is not modified you can use this version of 'map'
     to transform the type of the elements in the input sequence.
     Example:
     let
       a = @[1, 2, 3, 4]
       b = map(a, proc(x: int): string = $x)
     assert b == @["1", "2", "3", "4"]

   * map
          proc map*[T](data: var openArray[T]; op: proc (x: var T) {.closure.}) {.deprecated.}

     Applies op to every item in data modifying it directly.

     Note that this version of 'map' requires your input and output
     types to be the same, since they are modified in-place.  Example:
     var a = @["1", "2", "3", "4"]
     echo repr(a)
     # --> ["1", "2", "3", "4"]
     map(a, proc(x: var string) = x &= "42")
     echo repr(a)
     # --> ["142", "242", "342", "442"]

     *Deprecated since version 0.12.0:* Use the 'apply' proc instead.

   * apply
          proc apply*[T](data: var seq[T]; op: proc (x: var T) {.closure.}) {.inline.}

     Applies op to every item in data modifying it directly.

     Note that this requires your input and output types to be the same,
     since they are modified in-place.  The parameter function takes a
     'var T' type parameter.  Example:
     var a = @["1", "2", "3", "4"]
     echo repr(a)
     # --> ["1", "2", "3", "4"]
     map(a, proc(x: var string) = x &= "42")
     echo repr(a)
     # --> ["142", "242", "342", "442"]

   * apply
          proc apply*[T](data: var seq[T]; op: proc (x: T): T {.closure.}) {.inline.}

     Applies op to every item in data modifying it directly.

     Note that this requires your input and output types to be the same,
     since they are modified in-place.  The parameter function takes and
     returns a 'T' type variable.  Example:
     var a = @["1", "2", "3", "4"]
     echo repr(a)
     # --> ["1", "2", "3", "4"]
     map(a, proc(x: string): string = x & "42")
     echo repr(a)
     # --> ["142", "242", "342", "442"]

   * filter
          proc filter*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): seq[T] {.inline.}

     Returns a new sequence with all the items that fulfilled the
     predicate.

     Example:
     let
       colors = @["red", "yellow", "black"]
       f1 = filter(colors, proc(x: string): bool = x.len < 6)
       f2 = filter(colors) do (x: string) -> bool : x.len > 5
     assert f1 == @["red", "black"]
     assert f2 == @["yellow"]

   * keepIf
          proc keepIf*[T](seq1: var seq[T]; pred: proc (item: T): bool {.closure.}) {.inline.}

     Keeps the items in the passed sequence if they fulfilled the
     predicate.  Same as the 'filter' proc, but modifies the sequence
     directly.

     Example:
     var floats = @[13.0, 12.5, 5.8, 2.0, 6.1, 9.9, 10.1]
     keepIf(floats, proc(x: float): bool = x > 10)
     assert floats == @[13.0, 12.5, 10.1]

   * delete
          proc delete*[T](s: var seq[T]; first, last: Natural)

     Deletes in s the items at position first ..  last.  This modifies s
     itself, it does not return a copy.

     Example:
     let outcome = @[1,1,1,1,1,1,1,1]
     var dest = @[1,1,1,2,2,2,2,2,2,1,1,1,1,1]
     dest.delete(3, 8)
     assert outcome == dest

   * insert
          proc insert*[T](dest: var seq[T]; src: openArray[T]; pos = 0)

     Inserts items from src into dest at position pos.  This modifies
     dest itself, it does not return a copy.

     Example:
     var dest = @[1,1,1,1,1,1,1,1]
     let
       src = @[2,2,2,2,2,2]
       outcome = @[1,1,1,2,2,2,2,2,2,1,1,1,1,1]
     dest.insert(src, 3)
     assert dest == outcome

   * all
          proc all*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): bool

     Iterates through a sequence and checks if every item fulfills the
     predicate.

     Example:
     let numbers = @[1, 4, 5, 8, 9, 7, 4]
     assert all(numbers, proc (x: int): bool = return x < 10) == true
     assert all(numbers, proc (x: int): bool = return x < 9) == false

   * any
          proc any*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): bool

     Iterates through a sequence and checks if some item fulfills the
     predicate.

     Example:
     let numbers = @[1, 4, 5, 8, 9, 7, 4]
     assert any(numbers, proc (x: int): bool = return x > 8) == true
     assert any(numbers, proc (x: int): bool = return x > 9) == false

250 Templates
*************

   * filterIt
          template filterIt*(seq1, pred: expr): expr

     Returns a new sequence with all the items that fulfilled the
     predicate.

     Unlike the proc version, the predicate needs to be an expression
     using the 'it' variable for testing, like: 'filterIt("abcxyz", it
     == 'x')'.  Example:
     let
       temperatures = @[-272.15, -2.0, 24.5, 44.31, 99.9, -113.44]
       acceptable = filterIt(temperatures, it < 50 and it > -10)
       notAcceptable = filterIt(temperatures, it > 50 or it < -10)
     assert acceptable == @[-2.0, 24.5, 44.31]
     assert notAcceptable == @[-272.15, 99.9, -113.44]

   * keepItIf
          template keepItIf*(varSeq: seq; pred: expr)

     Convenience template around the 'keepIf' proc to reduce typing.

     Unlike the proc version, the predicate needs to be an expression
     using the 'it' variable for testing, like: 'keepItIf("abcxyz", it
     == 'x')'.  Example:
     var candidates = @["foo", "bar", "baz", "foobar"]
     keepItIf(candidates, it.len == 3 and it[0] == 'b')
     assert candidates == @["bar", "baz"]

   * allIt
          template allIt*(seq1, pred: expr): bool {.immediate.}

     Checks if every item fulfills the predicate.

     Example:
     let numbers = @[1, 4, 5, 8, 9, 7, 4]
     assert allIt(numbers, it < 10) == true
     assert allIt(numbers, it < 9) == false

   * anyIt
          template anyIt*(seq1, pred: expr): bool {.immediate.}

     Checks if some item fulfills the predicate.

     Example:
     let numbers = @[1, 4, 5, 8, 9, 7, 4]
     assert anyIt(numbers, it > 8) == true
     assert anyIt(numbers, it > 9) == false

   * toSeq
          template toSeq*(iter: expr): expr {.immediate.}

     Transforms any iterator into a sequence.

     Example:
     let
       numeric = @[1, 2, 3, 4, 5, 6, 7, 8, 9]
       odd_numbers = toSeq(filter(numeric) do (x: int) -> bool:
         if x mod 2 == 1:
           result = true)
     assert odd_numbers == @[1, 3, 5, 7, 9]

   * foldl
          template foldl*(sequence, operation: expr): expr

     Template to fold a sequence from left to right, returning the
     accumulation.

     The sequence is required to have at least a single element.  Debug
     versions of your program will assert in this situation but release
     versions will happily go ahead.  If the sequence has a single
     element it will be returned without applying 'operation'.

     The 'operation' parameter should be an expression which uses the
     variables 'a' and 'b' for each step of the fold.  Since this is a
     left fold, for non associative binary operations like subtraction
     think that the sequence of numbers 1, 2 and 3 will be parenthesized
     as (((1) - 2) - 3).  Example:
     let
       numbers = @[5, 9, 11]
       addition = foldl(numbers, a + b)
       subtraction = foldl(numbers, a - b)
       multiplication = foldl(numbers, a * b)
       words = @["nim", "is", "cool"]
       concatenation = foldl(words, a & b)
     assert addition == 25, "Addition is (((5)+9)+11)"
     assert subtraction == -15, "Subtraction is (((5)-9)-11)"
     assert multiplication == 495, "Multiplication is (((5)*9)*11)"
     assert concatenation == "nimiscool"

   * foldr
          template foldr*(sequence, operation: expr): expr

     Template to fold a sequence from right to left, returning the
     accumulation.

     The sequence is required to have at least a single element.  Debug
     versions of your program will assert in this situation but release
     versions will happily go ahead.  If the sequence has a single
     element it will be returned without applying 'operation'.

     The 'operation' parameter should be an expression which uses the
     variables 'a' and 'b' for each step of the fold.  Since this is a
     right fold, for non associative binary operations like subtraction
     think that the sequence of numbers 1, 2 and 3 will be parenthesized
     as (1 - (2 - (3))).  Example:
     let
       numbers = @[5, 9, 11]
       addition = foldr(numbers, a + b)
       subtraction = foldr(numbers, a - b)
       multiplication = foldr(numbers, a * b)
       words = @["nim", "is", "cool"]
       concatenation = foldr(words, a & b)
     assert addition == 25, "Addition is (5+(9+(11)))"
     assert subtraction == 7, "Subtraction is (5-(9-(11)))"
     assert multiplication == 495, "Multiplication is (5*(9*(11)))"
     assert concatenation == "nimiscool"

   * mapIt
          template mapIt*(seq1, typ, op: expr): expr {.deprecated.}

     Convenience template around the 'map' proc to reduce typing.

     The template injects the 'it' variable which you can use directly
     in an expression.  You also need to pass as typ the type of the
     expression, since the new returned sequence can have a different
     type than the original.  Example:
     let
       nums = @[1, 2, 3, 4]
       strings = nums.mapIt(string, $(4 * it))
     assert strings == @["4", "8", "12", "16"]

     *Deprecated since version 0.12.0:* Use the 'mapIt(seq1, op)'

          template instead.

   * mapIt
          template mapIt*(seq1, op: expr): expr

     Convenience template around the 'map' proc to reduce typing.

     The template injects the 'it' variable which you can use directly
     in an expression.  Example:
     let
       nums = @[1, 2, 3, 4]
       strings = nums.mapIt($(4 * it))
     assert strings == @["4", "8", "12", "16"]

   * applyIt
          template applyIt*(varSeq, op: expr)

     Convenience template around the mutable 'apply' proc to reduce
     typing.

     The template injects the 'it' variable which you can use directly
     in an expression.  The expression has to return the same type as
     the sequence you are mutating.  Example:
     var nums = @[1, 2, 3, 4]
     nums.applyIt(it * 3)
     assert nums[0] + nums[3] == 15

   * newSeqWith
          template newSeqWith*(len: int; init: expr): expr

     creates a new sequence, calling init to initialize each value.
     Example:
     var seq2D = newSeqWith(20, newSeq[bool](10))
     seq2D[0][0] = true
     seq2D[1][0] = true
     seq2D[0][1] = true

     import math
     var seqRand = newSeqWith(20, random(10))
     echo seqRand

251 Iterators
*************

   * filter
          iterator filter*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): T

     Iterates through a sequence and yields every item that fulfills the
     predicate.

     Example:
     let numbers = @[1, 4, 5, 8, 9, 7, 4]
     for n in filter(numbers, proc (x: int): bool = x mod 2 == 0):
       echo($n)
     # echoes 4, 8, 4 in separate lines


File: nim-ref-0.13.0.info,  Node: /pure/collections/sharedtables,  Next: /pure/collections/rtarrays,  Prev: /pure/collections/sequtils,  Up: Top

252 Types
*********

   * SharedTable data: KeyValuePairSeq[A, B] counter, dataLen: int lock:
     Lock

          SharedTable*[A, B] = object
            data: KeyValuePairSeq[A, B]
            counter, dataLen: int
            lock: Lock


     generic hash SharedTable

253 Procedures
**************

   * mget
          proc mget*[A, B](t: var SharedTable[A, B]; key: A): var B

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.

   * mgetOrPut
          proc mgetOrPut*[A, B](t: var SharedTable[A, B]; key: A; val: B): var B

     retrieves value at 't[key]' or puts 'val' if not present, either
     way returning a value which can be modified.  *Note*: This is
     inherently unsafe in the context of multi-threading since it
     returns a pointer to 'B'.

   * hasKeyOrPut
          proc hasKeyOrPut*[A, B](t: var SharedTable[A, B]; key: A; val: B): bool

     returns true iff key is in the table, otherwise inserts value.

   * '[]='
          proc `[]=`*[A, B](t: var SharedTable[A, B]; key: A; val: B)

     puts a (key, value)-pair into t.

   * add
          proc add*[A, B](t: var SharedTable[A, B]; key: A; val: B)

     puts a new (key, value)-pair into t even if 't[key]' already
     exists.

   * del
          proc del*[A, B](t: var SharedTable[A, B]; key: A)

     deletes key from hash table t.

   * initSharedTable
          proc initSharedTable*[A, B](initialSize = 64): SharedTable[A, B]

     creates a new hash table that is empty.

     initialSize needs to be a power of two.  If you need to accept
     runtime values for this you could use the 'nextPowerOfTwo' proc
     from the math (math.html) module or the 'rightSize' proc from this
     module.

   * deinitSharedTable
          proc deinitSharedTable*[A, B](t: var SharedTable[A, B])


File: nim-ref-0.13.0.info,  Node: /pure/collections/rtarrays,  Next: /pure/collections/tables,  Prev: /pure/collections/sharedtables,  Up: Top

254 Types
*********

   * UncheckedArray
          UncheckedArray* {.unchecked.}[T] = array[0 .. 100000000, T]

255 Procedures
**************

   * initRtArray
          proc initRtArray*[T](len: Natural): RtArray[T]

   * getRawData
          proc getRawData*[T](x: var RtArray[T]): ptr UncheckedArray[T]


File: nim-ref-0.13.0.info,  Node: /pure/collections/tables,  Next: /pure/collections/sharedstrings,  Prev: /pure/collections/rtarrays,  Up: Top

256 Types
*********

   * TableRef
          TableRef*[A, B] = ref Table[A, B]

   * OrderedTableRef
          OrderedTableRef*[A, B] = ref OrderedTable[A, B]

   * CountTableRef
          CountTableRef*[A] = ref CountTable[A]

257 Procedures
**************

   * rightSize
          proc rightSize*(count: Natural): int {.inline.}

     Return the value of initialSize to support count items.

     If more items are expected to be added, simply add that expected
     extra amount to the parameter before calling this.

     Internally, we want mustRehash(rightSize(x), x) == false.

   * len
          proc len*[A, B](t: Table[A, B]): int

     returns the number of keys in t.

   * '[]'
          proc `[]`*[A, B](t: Table[A, B]; key: A): B {.deprecatedGet.}

     retrieves the value at 't[key]'.  If key is not in t, the
     'KeyError' exception is raised.  One can check with 'hasKey'
     whether the key exists.

   * '[]'
          proc `[]`*[A, B](t: var Table[A, B]; key: A): var B {.deprecatedGet.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.

   * mget
          proc mget*[A, B](t: var Table[A, B]; key: A): var B {.deprecated.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.  Use "'[]"'
     instead.

   * getOrDefault
          proc getOrDefault*[A, B](t: Table[A, B]; key: A): B

   * hasKey
          proc hasKey*[A, B](t: Table[A, B]; key: A): bool

     returns true iff key is in the table t.

   * contains
          proc contains*[A, B](t: Table[A, B]; key: A): bool

     alias of hasKey for use with the in operator.

   * del
          proc del*[A, B](t: var Table[A, B]; key: A)

     deletes key from hash table t.

   * mgetOrPut
          proc mgetOrPut*[A, B](t: var Table[A, B]; key: A; val: B): var B

     retrieves value at 't[key]' or puts 'val' if not present, either
     way returning a value which can be modified.

   * hasKeyOrPut
          proc hasKeyOrPut*[A, B](t: var Table[A, B]; key: A; val: B): bool

     returns true iff key is in the table, otherwise inserts value.

   * '[]='
          proc `[]=`*[A, B](t: var Table[A, B]; key: A; val: B)

     puts a (key, value)-pair into t.

   * add
          proc add*[A, B](t: var Table[A, B]; key: A; val: B)

     puts a new (key, value)-pair into t even if 't[key]' already
     exists.

   * len
          proc len*[A, B](t: TableRef[A, B]): int

     returns the number of keys in t.

   * initTable
          proc initTable*[A, B](initialSize = 64): Table[A, B]

     creates a new hash table that is empty.

     initialSize needs to be a power of two.  If you need to accept
     runtime values for this you could use the 'nextPowerOfTwo' proc
     from the math (math.html) module or the 'rightSize' proc from this
     module.

   * toTable
          proc toTable*[A, B](pairs: openArray[(A, B)]): Table[A, B]

     creates a new hash table that contains the given pairs.

   * '$'
          proc `$`*[A, B](t: Table[A, B]): string

     The $ operator for hash tables.

   * hasKey
          proc hasKey*[A, B](t: TableRef[A, B]; key: A): bool

     returns true iff key is in the table t.

   * '=='
          proc `==`*[A, B](s, t: Table[A, B]): bool

   * indexBy
          proc indexBy*[A, B, C](collection: A; index: proc (x: B): C): Table[C, B]

     Index the collection with the proc provided.

   * '[]'
          proc `[]`*[A, B](t: TableRef[A, B]; key: A): var B {.deprecatedGet.}

     retrieves the value at 't[key]'.  If key is not in t, the
     'KeyError' exception is raised.  One can check with 'hasKey'
     whether the key exists.

   * mget
          proc mget*[A, B](t: TableRef[A, B]; key: A): var B {.deprecated.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.  Use "'[]"'
     instead.

   * getOrDefault
          proc getOrDefault*[A, B](t: TableRef[A, B]; key: A): B

   * mgetOrPut
          proc mgetOrPut*[A, B](t: TableRef[A, B]; key: A; val: B): var B

     retrieves value at 't[key]' or puts 'val' if not present, either
     way returning a value which can be modified.

   * hasKeyOrPut
          proc hasKeyOrPut*[A, B](t: var TableRef[A, B]; key: A; val: B): bool

     returns true iff key is in the table, otherwise inserts value.

   * contains
          proc contains*[A, B](t: TableRef[A, B]; key: A): bool

     alias of hasKey for use with the in operator.

   * '[]='
          proc `[]=`*[A, B](t: TableRef[A, B]; key: A; val: B)

     puts a (key, value)-pair into t.

   * add
          proc add*[A, B](t: TableRef[A, B]; key: A; val: B)

     puts a new (key, value)-pair into t even if 't[key]' already
     exists.

   * del
          proc del*[A, B](t: TableRef[A, B]; key: A)

     deletes key from hash table t.

   * newTable
          proc newTable*[A, B](initialSize = 64): TableRef[A, B]

   * newTable
          proc newTable*[A, B](pairs: openArray[(A, B)]): TableRef[A, B]

     creates a new hash table that contains the given pairs.

   * '$'
          proc `$`*[A, B](t: TableRef[A, B]): string

     The $ operator for hash tables.

   * '=='
          proc `==`*[A, B](s, t: TableRef[A, B]): bool

   * newTableFrom
          proc newTableFrom*[A, B, C](collection: A; index: proc (x: B): C): TableRef[C, B]

     Index the collection with the proc provided.

   * len
          proc len*[A, B](t: OrderedTable[A, B]): int {.inline.}

     returns the number of keys in t.

   * '[]'
          proc `[]`*[A, B](t: OrderedTable[A, B]; key: A): B {.deprecatedGet.}

     retrieves the value at 't[key]'.  If key is not in t, the
     'KeyError' exception is raised.  One can check with 'hasKey'
     whether the key exists.

   * '[]'
          proc `[]`*[A, B](t: var OrderedTable[A, B]; key: A): var B {.deprecatedGet.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.

   * mget
          proc mget*[A, B](t: var OrderedTable[A, B]; key: A): var B {.deprecated.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.  Use "'[]"'
     instead.

   * getOrDefault
          proc getOrDefault*[A, B](t: OrderedTable[A, B]; key: A): B

   * hasKey
          proc hasKey*[A, B](t: OrderedTable[A, B]; key: A): bool

     returns true iff key is in the table t.

   * contains
          proc contains*[A, B](t: OrderedTable[A, B]; key: A): bool

     alias of hasKey for use with the in operator.

   * '[]='
          proc `[]=`*[A, B](t: var OrderedTable[A, B]; key: A; val: B)

     puts a (key, value)-pair into t.

   * add
          proc add*[A, B](t: var OrderedTable[A, B]; key: A; val: B)

     puts a new (key, value)-pair into t even if 't[key]' already
     exists.

   * mgetOrPut
          proc mgetOrPut*[A, B](t: var OrderedTable[A, B]; key: A; val: B): var B

     retrieves value at 't[key]' or puts 'value' if not present, either
     way returning a value which can be modified.

   * hasKeyOrPut
          proc hasKeyOrPut*[A, B](t: var OrderedTable[A, B]; key: A; val: B): bool

     returns true iff key is in the table, otherwise inserts value.

   * initOrderedTable
          proc initOrderedTable*[A, B](initialSize = 64): OrderedTable[A, B]

     creates a new ordered hash table that is empty.

     initialSize needs to be a power of two.  If you need to accept
     runtime values for this you could use the 'nextPowerOfTwo' proc
     from the math (math.html) module or the 'rightSize' proc from this
     module.

   * toOrderedTable
          proc toOrderedTable*[A, B](pairs: openArray[(A, B)]): OrderedTable[A, B]

     creates a new ordered hash table that contains the given pairs.

   * '$'
          proc `$`*[A, B](t: OrderedTable[A, B]): string

     The $ operator for ordered hash tables.

   * sort
          proc sort*[A, B](t: var OrderedTable[A, B]; cmp: proc (x, y: (A, B)): int)

     sorts t according to cmp.  This modifies the internal list that
     kept the insertion order, so insertion order is lost after this
     call but key lookup and insertions remain possible after sort (in
     contrast to the sort for count tables).

   * len
          proc len*[A, B](t: OrderedTableRef[A, B]): int {.inline.}

     returns the number of keys in t.

   * '[]'
          proc `[]`*[A, B](t: OrderedTableRef[A, B]; key: A): var B

     retrieves the value at 't[key]'.  If key is not in t, the
     'KeyError' exception is raised.  One can check with 'hasKey'
     whether the key exists.

   * mget
          proc mget*[A, B](t: OrderedTableRef[A, B]; key: A): var B {.deprecated.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.  Use "'[]"'
     instead.

   * getOrDefault
          proc getOrDefault*[A, B](t: OrderedTableRef[A, B]; key: A): B

   * mgetOrPut
          proc mgetOrPut*[A, B](t: OrderedTableRef[A, B]; key: A; val: B): var B

     retrieves value at 't[key]' or puts 'val' if not present, either
     way returning a value which can be modified.

   * hasKeyOrPut
          proc hasKeyOrPut*[A, B](t: var OrderedTableRef[A, B]; key: A; val: B): bool

     returns true iff key is in the table, otherwise inserts val.

   * hasKey
          proc hasKey*[A, B](t: OrderedTableRef[A, B]; key: A): bool

     returns true iff key is in the table t.

   * contains
          proc contains*[A, B](t: OrderedTableRef[A, B]; key: A): bool

     alias of hasKey for use with the in operator.

   * '[]='
          proc `[]=`*[A, B](t: OrderedTableRef[A, B]; key: A; val: B)

     puts a (key, value)-pair into t.

   * add
          proc add*[A, B](t: OrderedTableRef[A, B]; key: A; val: B)

     puts a new (key, value)-pair into t even if 't[key]' already
     exists.

   * newOrderedTable
          proc newOrderedTable*[A, B](initialSize = 64): OrderedTableRef[A, B]

     creates a new ordered hash table that is empty.

     initialSize needs to be a power of two.  If you need to accept
     runtime values for this you could use the 'nextPowerOfTwo' proc
     from the math (math.html) module or the 'rightSize' proc from this
     module.

   * newOrderedTable
          proc newOrderedTable*[A, B](pairs: openArray[(A, B)]): OrderedTableRef[A, B]

     creates a new ordered hash table that contains the given pairs.

   * '$'
          proc `$`*[A, B](t: OrderedTableRef[A, B]): string

     The $ operator for ordered hash tables.

   * sort
          proc sort*[A, B](t: OrderedTableRef[A, B]; cmp: proc (x, y: (A, B)): int)

     sorts t according to cmp.  This modifies the internal list that
     kept the insertion order, so insertion order is lost after this
     call but key lookup and insertions remain possible after sort (in
     contrast to the sort for count tables).

   * len
          proc len*[A](t: CountTable[A]): int

     returns the number of keys in t.

   * '[]'
          proc `[]`*[A](t: CountTable[A]; key: A): int {.deprecatedGet.}

     retrieves the value at 't[key]'.  If key is not in t, the
     'KeyError' exception is raised.  One can check with 'hasKey'
     whether the key exists.

   * '[]'
          proc `[]`*[A](t: var CountTable[A]; key: A): var int {.deprecatedGet.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.

   * mget
          proc mget*[A](t: var CountTable[A]; key: A): var int {.deprecated.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.  Use "'[]"'
     instead.

   * getOrDefault
          proc getOrDefault*[A](t: CountTable[A]; key: A): int

   * hasKey
          proc hasKey*[A](t: CountTable[A]; key: A): bool

     returns true iff key is in the table t.

   * contains
          proc contains*[A](t: CountTable[A]; key: A): bool

     alias of hasKey for use with the in operator.

   * '[]='
          proc `[]=`*[A](t: var CountTable[A]; key: A; val: int)

     puts a (key, value)-pair into t.

   * initCountTable
          proc initCountTable*[A](initialSize = 64): CountTable[A]

     creates a new count table that is empty.

     initialSize needs to be a power of two.  If you need to accept
     runtime values for this you could use the 'nextPowerOfTwo' proc
     from the math (math.html) module or the 'rightSize' proc in this
     module.

   * toCountTable
          proc toCountTable*[A](keys: openArray[A]): CountTable[A]

     creates a new count table with every key in keys having a count of
     1.

   * '$'
          proc `$`*[A](t: CountTable[A]): string

     The $ operator for count tables.

   * inc
          proc inc*[A](t: var CountTable[A]; key: A; val = 1)

     increments t[key] by val.

   * smallest
          proc smallest*[A](t: CountTable[A]): tuple[key: A, val: int]

     returns the largest (key,val)-pair.  Efficiency: O(n)

   * largest
          proc largest*[A](t: CountTable[A]): tuple[key: A, val: int]

     returns the (key,val)-pair with the largest val.  Efficiency: O(n)

   * sort
          proc sort*[A](t: var CountTable[A])

     sorts the count table so that the entry with the highest counter
     comes first.  This is destructive!  You must not modify t
     afterwards!  You can use the iterators pairs, keys, and values to
     iterate over t in the sorted order.

   * len
          proc len*[A](t: CountTableRef[A]): int

     returns the number of keys in t.

   * '[]'
          proc `[]`*[A](t: CountTableRef[A]; key: A): var int {.deprecatedGet.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.

   * mget
          proc mget*[A](t: CountTableRef[A]; key: A): var int {.deprecated.}

     retrieves the value at 't[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.  Use "'[]"'
     instead.

   * getOrDefault
          proc getOrDefault*[A](t: CountTableRef[A]; key: A): int

   * hasKey
          proc hasKey*[A](t: CountTableRef[A]; key: A): bool

     returns true iff key is in the table t.

   * contains
          proc contains*[A](t: CountTableRef[A]; key: A): bool

     alias of hasKey for use with the in operator.

   * '[]='
          proc `[]=`*[A](t: CountTableRef[A]; key: A; val: int)

     puts a (key, value)-pair into t.  val has to be positive.

   * newCountTable
          proc newCountTable*[A](initialSize = 64): CountTableRef[A]

     creates a new count table that is empty.

     initialSize needs to be a power of two.  If you need to accept
     runtime values for this you could use the 'nextPowerOfTwo' proc
     from the math (math.html) module or the 'rightSize' method in this
     module.

   * newCountTable
          proc newCountTable*[A](keys: openArray[A]): CountTableRef[A]

     creates a new count table with every key in keys having a count of
     1.

   * '$'
          proc `$`*[A](t: CountTableRef[A]): string

     The $ operator for count tables.

   * inc
          proc inc*[A](t: CountTableRef[A]; key: A; val = 1)

     increments t[key] by val.

   * smallest
          proc smallest*[A](t: CountTableRef[A]): (A, int)

     returns the largest (key,val)-pair.  Efficiency: O(n)

   * largest
          proc largest*[A](t: CountTableRef[A]): (A, int)

     returns the (key,val)-pair with the largest val.  Efficiency: O(n)

   * sort
          proc sort*[A](t: CountTableRef[A])

     sorts the count table so that the entry with the highest counter
     comes first.  This is destructive!  You must not modify t
     afterwards!  You can use the iterators pairs, keys, and values to
     iterate over t in the sorted order.

   * merge
          proc merge*[A](s: var CountTable[A]; t: CountTable[A])

     merges the second table into the first one

   * merge
          proc merge*[A](s, t: CountTable[A]): CountTable[A]

     merges the two tables into a new one

   * merge
          proc merge*[A](s, t: CountTableRef[A])

     merges the second table into the first one

258 Iterators
*************

   * allValues
          iterator allValues*[A, B](t: Table[A, B]; key: A): B

     iterates over any value in the table t that belongs to the given
     key.

   * pairs
          iterator pairs*[A, B](t: Table[A, B]): (A, B)

     iterates over any (key, value) pair in the table t.

   * mpairs
          iterator mpairs*[A, B](t: var Table[A, B]): (A, var B)

     iterates over any (key, value) pair in the table t.  The values can
     be modified.

   * keys
          iterator keys*[A, B](t: Table[A, B]): A

     iterates over any key in the table t.

   * values
          iterator values*[A, B](t: Table[A, B]): B

     iterates over any value in the table t.

   * mvalues
          iterator mvalues*[A, B](t: var Table[A, B]): var B

     iterates over any value in the table t.  The values can be
     modified.

   * pairs
          iterator pairs*[A, B](t: TableRef[A, B]): (A, B)

     iterates over any (key, value) pair in the table t.

   * mpairs
          iterator mpairs*[A, B](t: TableRef[A, B]): (A, var B)

     iterates over any (key, value) pair in the table t.  The values can
     be modified.

   * keys
          iterator keys*[A, B](t: TableRef[A, B]): A

     iterates over any key in the table t.

   * values
          iterator values*[A, B](t: TableRef[A, B]): B

     iterates over any value in the table t.

   * mvalues
          iterator mvalues*[A, B](t: TableRef[A, B]): var B

     iterates over any value in the table t.  The values can be
     modified.

   * pairs
          iterator pairs*[A, B](t: OrderedTable[A, B]): (A, B)

     iterates over any (key, value) pair in the table t in insertion
     order.

   * mpairs
          iterator mpairs*[A, B](t: var OrderedTable[A, B]): (A, var B)

     iterates over any (key, value) pair in the table t in insertion
     order.  The values can be modified.

   * keys
          iterator keys*[A, B](t: OrderedTable[A, B]): A

     iterates over any key in the table t in insertion order.

   * values
          iterator values*[A, B](t: OrderedTable[A, B]): B

     iterates over any value in the table t in insertion order.

   * mvalues
          iterator mvalues*[A, B](t: var OrderedTable[A, B]): var B

     iterates over any value in the table t in insertion order.  The
     values can be modified.

   * pairs
          iterator pairs*[A, B](t: OrderedTableRef[A, B]): (A, B)

     iterates over any (key, value) pair in the table t in insertion
     order.

   * mpairs
          iterator mpairs*[A, B](t: OrderedTableRef[A, B]): (A, var B)

     iterates over any (key, value) pair in the table t in insertion
     order.  The values can be modified.

   * keys
          iterator keys*[A, B](t: OrderedTableRef[A, B]): A

     iterates over any key in the table t in insertion order.

   * values
          iterator values*[A, B](t: OrderedTableRef[A, B]): B

     iterates over any value in the table t in insertion order.

   * mvalues
          iterator mvalues*[A, B](t: OrderedTableRef[A, B]): var B

     iterates over any value in the table t in insertion order.  The
     values can be modified.

   * pairs
          iterator pairs*[A](t: CountTable[A]): (A, int)

     iterates over any (key, value) pair in the table t.

   * mpairs
          iterator mpairs*[A](t: var CountTable[A]): (A, var int)

     iterates over any (key, value) pair in the table t.  The values can
     be modified.

   * keys
          iterator keys*[A](t: CountTable[A]): A

     iterates over any key in the table t.

   * values
          iterator values*[A](t: CountTable[A]): int

     iterates over any value in the table t.

   * mvalues
          iterator mvalues*[A](t: CountTable[A]): var int

     iterates over any value in the table t.  The values can be
     modified.

   * pairs
          iterator pairs*[A](t: CountTableRef[A]): (A, int)

     iterates over any (key, value) pair in the table t.

   * mpairs
          iterator mpairs*[A](t: CountTableRef[A]): (A, var int)

     iterates over any (key, value) pair in the table t.  The values can
     be modified.

   * keys
          iterator keys*[A](t: CountTableRef[A]): A

     iterates over any key in the table t.

   * values
          iterator values*[A](t: CountTableRef[A]): int

     iterates over any value in the table t.

   * mvalues
          iterator mvalues*[A](t: CountTableRef[A]): var int

     iterates over any value in the table t.  The values can be
     modified.


File: nim-ref-0.13.0.info,  Node: /pure/collections/sharedstrings,  Next: /pure/collections/critbits,  Prev: /pure/collections/tables,  Up: Top

259 Types
*********

   * SharedString buffer: Buffer first, len: int

          SharedString* = object
            buffer: Buffer
            first, len: int


     A string that can be shared.  Slicing is O(1).

260 Procedures
**************

   * '=destroy'
          proc `= destroy`*(s: SharedString)

   * len
          proc len*(s: SharedString): int

   * '[]'
          proc `[]`*(s: SharedString; i: Natural): char

   * '[]='
          proc `[]=`*(s: var SharedString; i: Natural; value: char)

   * '[]'
          proc `[]`*(s: SharedString; ab: Slice[int]): SharedString

   * newSharedString
          proc newSharedString*(len: Natural): SharedString

   * newSharedString
          proc newSharedString*(s: string): SharedString

   * add
          proc add*(s: var SharedString; t: cstring; len: Natural)

   * add
          proc add*(s: var SharedString; t: string)

   * rawData
          proc rawData*(s: var SharedString): pointer

   * add
          proc add*(s: var SharedString; t: SharedString)

   * '$'
          proc `$`*(s: SharedString): string

   * '=='
          proc `==`*(s: SharedString; t: string): bool

   * '=='
          proc `==`*(s, t: SharedString): bool

   * hash
          proc hash*(s: SharedString): THash

261 Iterators
*************

   * items
          iterator items*(s: SharedString): char


File: nim-ref-0.13.0.info,  Node: /pure/collections/critbits,  Next: /pure/collections/intsets,  Prev: /pure/collections/sharedstrings,  Up: Top

262 Types
*********

   * CritBitTree root: Node[T] count: int

          CritBitTree*[T] = object
            root: Node[T]
            count: int


     The crit bit tree can either be used as a mapping from strings to
     some type 'T' or as a set of strings if 'T' is void.

263 Procedures
**************

   * len
          proc len*[T](c: CritBitTree[T]): int

     returns the number of elements in c in O(1).

   * contains
          proc contains*[T](c: CritBitTree[T]; key: string): bool {.inline.}

     returns true iff c contains the given key.

   * hasKey
          proc hasKey*[T](c: CritBitTree[T]; key: string): bool {.inline.}

     alias for contains.

   * containsOrIncl
          proc containsOrIncl*[T](c: var CritBitTree[T]; key: string; val: T): bool

     returns true iff c contains the given key.  If the key does not
     exist 'c[key] = val' is performed.

   * containsOrIncl
          proc containsOrIncl*(c: var CritBitTree[void]; key: string): bool

     returns true iff c contains the given key.  If the key does not
     exist it is inserted into c.

   * inc
          proc inc*(c: var CritBitTree[int]; key: string)

     counts the 'key'.

   * incl
          proc incl*(c: var CritBitTree[void]; key: string)

     includes key in c.

   * '[]='
          proc `[]=`*[T](c: var CritBitTree[T]; key: string; val: T)

     puts a (key, value)-pair into t.

   * '[]'
          proc `[]`*[T](c: CritBitTree[T]; key: string): T {.inline, deprecatedGet.}

     retrieves the value at 'c[key]'.  If key is not in t, the
     'KeyError' exception is raised.  One can check with 'hasKey'
     whether the key exists.

   * '[]'
          proc `[]`*[T](c: var CritBitTree[T]; key: string): var T {.inline, deprecatedGet.}

     retrieves the value at 'c[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.

   * mget
          proc mget*[T](c: var CritBitTree[T]; key: string): var T {.inline, deprecated.}

     retrieves the value at 'c[key]'.  The value can be modified.  If
     key is not in t, the 'KeyError' exception is raised.  Use "'[]"'
     instead.

   * excl
          proc excl*[T](c: var CritBitTree[T]; key: string)

     removes key (and its associated value) from the set c.  If the key
     does not exist, nothing happens.

   * '$'
          proc `$`*[T](c: CritBitTree[T]): string

     turns c into a string representation.  Example outputs: '{keyA:
     value, keyB: value}', '{:}' If T is void the outputs look like:
     '{keyA, keyB}', '{}'.

264 Iterators
*************

   * keys
          iterator keys*[T](c: CritBitTree[T]): string

     yields all keys in lexicographical order.

   * values
          iterator values*[T](c: CritBitTree[T]): T

     yields all values of c in the lexicographical order of the
     corresponding keys.

   * mvalues
          iterator mvalues*[T](c: var CritBitTree[T]): var T

     yields all values of c in the lexicographical order of the
     corresponding keys.  The values can be modified.

   * items
          iterator items*[T](c: CritBitTree[T]): string

     yields all keys in lexicographical order.

   * pairs
          iterator pairs*[T](c: CritBitTree[T]): tuple[key: string, val: T]

     yields all (key, value)-pairs of c.

   * mpairs
          iterator mpairs*[T](c: var CritBitTree[T]): tuple[key: string, val: var T]

     yields all (key, value)-pairs of c.  The yielded values can be
     modified.

   * itemsWithPrefix
          iterator itemsWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): string

     yields all keys starting with prefix.  If longestMatch is true, the
     longest match is returned, it doesn't have to be a complete match
     then.

   * keysWithPrefix
          iterator keysWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): string

     yields all keys starting with prefix.

   * valuesWithPrefix
          iterator valuesWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): T

     yields all values of c starting with prefix of the corresponding
     keys.

   * mvaluesWithPrefix longestMatch = false): var T
          iterator mvaluesWithPrefix*[T](c: var CritBitTree[T]; prefix: string;
                                        longestMatch = false): var T

     yields all values of c starting with prefix of the corresponding
     keys.  The values can be modified.

   * pairsWithPrefix key: string, val: T]
          iterator pairsWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): tuple[
              key: string, val: T]

     yields all (key, value)-pairs of c starting with prefix.

   * mpairsWithPrefix longestMatch = false): tuple[key: string, val: var
     T]
          iterator mpairsWithPrefix*[T](c: var CritBitTree[T]; prefix: string;
                                       longestMatch = false): tuple[key: string, val: var T]

     yields all (key, value)-pairs of c starting with prefix.  The
     yielded values can be modified.


File: nim-ref-0.13.0.info,  Node: /pure/collections/intsets,  Next: /pure/collections/tableimpl,  Prev: /pure/collections/critbits,  Up: Top

265 Types
*********

   * IntSet counter, max: int head: PTrunk data: TrunkSeq

          IntSet* = object
            counter, max: int
            head: PTrunk
            data: TrunkSeq


     an efficient set of 'int' implemented as a sparse bit set

266 Procedures
**************

   * contains
          proc contains*(s: IntSet; key: int): bool

     returns true iff key is in s.

   * incl
          proc incl*(s: var IntSet; key: int)

     includes an element key in s.

   * excl
          proc excl*(s: var IntSet; key: int)

     excludes key from the set s.

   * containsOrIncl
          proc containsOrIncl*(s: var IntSet; key: int): bool

     returns true if s contains key, otherwise key is included in s and
     false is returned.

   * initIntSet
          proc initIntSet*(): IntSet

     creates a new int set that is empty.

   * isNil
          proc isNil*(x: IntSet): bool {.inline.}

   * assign
          proc assign*(dest: var IntSet; src: IntSet)

     copies src to dest.  dest does not need to be initialized by
     initIntSet.

   * '$'
          proc `$`*(s: IntSet): string

     The $ operator for int sets.

   * empty
          proc empty*(s: IntSet): bool {.inline, deprecated.}

     returns true if s is empty.  This is safe to call even before the
     set has been initialized with initIntSet.  Note this never worked
     reliably and so is deprecated.

267 Iterators
*************

   * items
          iterator items*(s: IntSet): int {.inline.}

     iterates over any included element of s.


File: nim-ref-0.13.0.info,  Node: /pure/collections/tableimpl,  Next: /pure/collections/queues,  Prev: /pure/collections/intsets,  Up: Top


File: nim-ref-0.13.0.info,  Node: /pure/collections/queues,  Next: /pure/collections/sets,  Prev: /pure/collections/tableimpl,  Up: Top

268 Types
*********

   * Queue data: seq[T] rd, wr, count, mask: int

          Queue*[T] = object
            data: seq[T]
            rd, wr, count, mask: int


     a queue

269 Procedures
**************

   * initQueue
          proc initQueue*[T](initialSize = 4): Queue[T]

     creates a new queue.  initialSize needs to be a power of 2.

   * len
          proc len*[T](q: Queue[T]): int

     returns the number of elements of q.

   * add
          proc add*[T](q: var Queue[T]; item: T)

     adds an item to the end of the queue q.

   * enqueue
          proc enqueue*[T](q: var Queue[T]; item: T)

     alias for the 'add' operation.

   * dequeue
          proc dequeue*[T](q: var Queue[T]): T

     removes and returns the first element of the queue q.

   * '$'
          proc `$`*[T](q: Queue[T]): string

     turns a queue into its string representation.

270 Iterators
*************

   * items
          iterator items*[T](q: Queue[T]): T

     yields every element of q.

   * mitems
          iterator mitems*[T](q: var Queue[T]): var T

     yields every element of q.


File: nim-ref-0.13.0.info,  Node: /pure/collections/sets,  Next: /pure/collections/sharedlist,  Prev: /pure/collections/queues,  Up: Top

271 Types
*********

   * HashSet data: KeyValuePairSeq[A] counter: int

          HashSet* {.myShallow.}[A] = object
            data: KeyValuePairSeq[A]
            counter: int


     A generic hash set.

     Use init() (#init,HashSet[A],int) or initSet[type]() (#initSet)
     before calling other procs on it.

   * OrderedSet data: OrderedKeyValuePairSeq[A] counter, first, last:
     int

          OrderedSet* {.myShallow.}[A] = object
            data: OrderedKeyValuePairSeq[A]
            counter, first, last: int


     A generic hash set that remembers insertion order.

     Use init() (#init,OrderedSet[A],int) or initOrderedSet[type]()
     (#initOrderedSet) before calling other procs on it.

272 Procedures
**************

   * isValid
          proc isValid*[A](s: HashSet[A]): bool

     Returns true if the set has been initialized with initSet
     (#initSet).

     Most operations over an uninitialized set will crash at runtime and
     assert (system.html#assert) in debug builds.  You can use this proc
     in your own procs to verify that sets passed to your procs are
     correctly initialized.  Example:
     proc savePreferences(options: Set[string]) =
       assert options.isValid, "Pass an initialized set!"
       # Do stuff here, may crash in release builds!

   * len
          proc len*[A](s: HashSet[A]): int

     Returns the number of keys in s.

     Due to an implementation detail you can call this proc on variables
     which have not been initialized yet.  The proc will return zero as
     the length then.  Example:
     var values: Set[int]
     assert(not values.isValid)
     assert values.len == 0

   * card
          proc card*[A](s: HashSet[A]): int

     Alias for len() (#len,TSet[A]).

     Card stands for the cardinality
     (http://en.wikipedia.org/wiki/Cardinality) of a set.

   * rightSize
          proc rightSize*(count: Natural): int {.inline.}

     Return the value of initialSize to support count items.

     If more items are expected to be added, simply add that expected
     extra amount to the parameter before calling this.

     Internally, we want mustRehash(rightSize(x), x) == false.

   * '[]'
          proc `[]`*[A](s: var HashSet[A]; key: A): var A

     returns the element that is actually stored in 's' which has the
     same value as 'key' or raises the 'KeyError' exception.  This is
     useful when one overloaded 'hash' and '==' but still needs
     reference semantics for sharing.

   * mget
          proc mget*[A](s: var HashSet[A]; key: A): var A {.deprecated.}

     returns the element that is actually stored in 's' which has the
     same value as 'key' or raises the 'KeyError' exception.  This is
     useful when one overloaded 'hash' and '==' but still needs
     reference semantics for sharing.  Use "'[]"' instead.

   * contains
          proc contains*[A](s: HashSet[A]; key: A): bool

     Returns true iff key is in s.

     Example:
     var values = initSet[int]()
     assert(not values.contains(2))
     values.incl(2)
     assert values.contains(2)
     values.excl(2)
     assert(not values.contains(2))

   * incl
          proc incl*[A](s: var HashSet[A]; key: A)

     Includes an element key in s.

     This doesn't do anything if key is already in s.  Example:
     var values = initSet[int]()
     values.incl(2)
     values.incl(2)
     assert values.len == 1

   * incl
          proc incl*[A](s: var HashSet[A]; other: HashSet[A])

     Includes all elements from other into s.

     Example:
     var values = initSet[int]()
     values.incl(2)
     var others = toSet([6, 7])
     values.incl(others)
     assert values.len == 3

   * excl
          proc excl*[A](s: var HashSet[A]; key: A)

     Excludes key from the set s.

     This doesn't do anything if key is not found in s.  Example:
     var s = toSet([2, 3, 6, 7])
     s.excl(2)
     s.excl(2)
     assert s.len == 3

   * excl
          proc excl*[A](s: var HashSet[A]; other: HashSet[A])

     Excludes everything in other from s.

     Example:
     var
       numbers = toSet([1, 2, 3, 4, 5])
       even = toSet([2, 4, 6, 8])
     numbers.excl(even)
     echo numbers
     # --> {1, 3, 5}

   * containsOrIncl
          proc containsOrIncl*[A](s: var HashSet[A]; key: A): bool

     Includes key in the set s and tells if key was added to s.

     The difference with regards to the incl() (#incl,TSet[A],A) proc is
     that this proc returns true if key was already present in s.  The
     proc will return false if key was added as a new value to s during
     this call.  Example:
     var values = initSet[int]()
     assert values.containsOrIncl(2) == false
     assert values.containsOrIncl(2) == true

   * init
          proc init*[A](s: var HashSet[A]; initialSize = 64)

     Initializes a hash set.

     The initialSize parameter needs to be a power of two.  You can use
     math.nextPowerOfTwo() (math.html#nextPowerOfTwo) or rightSize to
     guarantee that at runtime.  All set variables must be initialized
     before use with other procs from this module with the exception of
     isValid() (#isValid,TSet[A]) and len() (#len,TSet[A]).

     You can call this proc on a previously initialized hash set, which
     will discard all its values.  This might be more convenient than
     iterating over existing values and calling excl() (#excl,TSet[A],A)
     on them.  Example:
     var a: Set[int]
     a.init(4)
     a.incl(2)
     a.init
     assert a.len == 0 and a.isValid

   * initSet
          proc initSet*[A](initialSize = 64): HashSet[A]

     Wrapper around init() (#init,TSet[A],int) for initialization of
     hash sets.

     Returns an empty hash set you can assign directly in 'var' blocks
     in a single line.  Example:
     var a = initSet[int](4)
     a.incl(2)

   * toSet
          proc toSet*[A](keys: openArray[A]): HashSet[A]

     Creates a new hash set that contains the given keys.

     Example:
     var numbers = toSet([1, 2, 3, 4, 5])
     assert numbers.contains(2)
     assert numbers.contains(4)

   * '$'
          proc `$`*[A](s: HashSet[A]): string

     Converts the set s to a string, mostly for logging purposes.

     Don't use this proc for serialization, the representation may
     change at any moment and values are not escaped.  Example:

     Example:
     echo toSet([2, 4, 5])
     # --> {2, 4, 5}
     echo toSet(["no", "esc'aping", "is \" provided"])
     # --> {no, esc'aping, is " provided}

   * union
          proc union*[A](s1, s2: HashSet[A]): HashSet[A]

     Returns the union of the sets s1 and s2.

     The union of two sets is represented mathematically as _A ∪ B_
     and is the set of all objects that are members of s1, s2 or both.
     Example:
     var
       a = toSet(["a", "b"])
       b = toSet(["b", "c"])
       c = union(a, b)
     assert c == toSet(["a", "b", "c"])

   * intersection
          proc intersection*[A](s1, s2: HashSet[A]): HashSet[A]

     Returns the intersection of the sets s1 and s2.

     The intersection of two sets is represented mathematically as _A
     ∩ B_ and is the set of all objects that are members of s1 and s2
     at the same time.  Example:
     var
       a = toSet(["a", "b"])
       b = toSet(["b", "c"])
       c = intersection(a, b)
     assert c == toSet(["b"])

   * difference
          proc difference*[A](s1, s2: HashSet[A]): HashSet[A]

     Returns the difference of the sets s1 and s2.

     The difference of two sets is represented mathematically as _A B_
     and is the set of all objects that are members of s1 and not
     members of s2.  Example:
     var
       a = toSet(["a", "b"])
       b = toSet(["b", "c"])
       c = difference(a, b)
     assert c == toSet(["a"])

   * symmetricDifference
          proc symmetricDifference*[A](s1, s2: HashSet[A]): HashSet[A]

     Returns the symmetric difference of the sets s1 and s2.

     The symmetric difference of two sets is represented mathematically
     as _A △ B_ or _A ⊖ B_ and is the set of all objects that are
     members of s1 or s2 but not both at the same time.  Example:
     var
       a = toSet(["a", "b"])
       b = toSet(["b", "c"])
       c = symmetricDifference(a, b)
     assert c == toSet(["a", "c"])

   * '+'
          proc `+`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

     Alias for union(s1, s2) (#union).

   * '*'
          proc `*`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

     Alias for intersection(s1, s2) (#intersection).

   * '-'
          proc `-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

     Alias for difference(s1, s2) (#difference).

   * '-+-'
          proc `-+-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}

     Alias for symmetricDifference(s1, s2) (#symmetricDifference).

   * disjoint
          proc disjoint*[A](s1, s2: HashSet[A]): bool

     Returns true iff the sets s1 and s2 have no items in common.

     Example:
     var
       a = toSet(["a", "b"])
       b = toSet(["b", "c"])
     assert disjoint(a, b) == false
     assert disjoint(a, b - a) == true

   * '&lt;'
          proc `<`*[A](s, t: HashSet[A]): bool

     Returns true if s is a strict or proper subset of t.

     A strict or proper subset s has all of its members in t but t has
     more elements than s.  Example:
     var
       a = toSet(["a", "b"])
       b = toSet(["b", "c"])
       c = intersection(a, b)
     assert c < a and c < b
     assert((a < a) == false)

   * '&lt;='
          proc `<=`*[A](s, t: HashSet[A]): bool

     Returns true if s is subset of t.

     A subset s has all of its members in t and t doesn't necessarily
     have more members than s.  That is, s can be equal to t.  Example:
     var
       a = toSet(["a", "b"])
       b = toSet(["b", "c"])
       c = intersection(a, b)
     assert c <= a and c <= b
     assert((a <= a))

   * '=='
          proc `==`*[A](s, t: HashSet[A]): bool

     Returns true if both s and t have the same members and set size.

     Example:
     var
       a = toSet([1, 2])
       b = toSet([1])
     b.incl(2)
     assert a == b

   * map
          proc map*[A, B](data: HashSet[A]; op: proc (x: A): B {.closure.}): HashSet[B]

     Returns a new set after applying op on each of the elements of
     data.

     You can use this proc to transform the elements from a set.
     Example:
     var a = toSet([1, 2, 3])
     var b = a.map(proc (x: int): string = $x)
     assert b == toSet(["1", "2", "3"])

   * isValid
          proc isValid*[A](s: OrderedSet[A]): bool

     Returns true if the ordered set has been initialized with initSet
     (#initOrderedSet).

     Most operations over an uninitialized ordered set will crash at
     runtime and assert (system.html#assert) in debug builds.  You can
     use this proc in your own procs to verify that ordered sets passed
     to your procs are correctly initialized.  Example:
     proc saveTarotCards(cards: OrderedSet[int]) =
       assert cards.isValid, "Pass an initialized set!"
       # Do stuff here, may crash in release builds!

   * len
          proc len*[A](s: OrderedSet[A]): int {.inline.}

     Returns the number of keys in s.

     Due to an implementation detail you can call this proc on variables
     which have not been initialized yet.  The proc will return zero as
     the length then.  Example:
     var values: OrderedSet[int]
     assert(not values.isValid)
     assert values.len == 0

   * card
          proc card*[A](s: OrderedSet[A]): int {.inline.}

     Alias for len() (#len,TOrderedSet[A]).

     Card stands for the cardinality
     (http://en.wikipedia.org/wiki/Cardinality) of a set.

   * contains
          proc contains*[A](s: OrderedSet[A]; key: A): bool

     Returns true iff key is in s.

     Example:
     var values = initOrderedSet[int]()
     assert(not values.contains(2))
     values.incl(2)
     assert values.contains(2)

   * incl
          proc incl*[A](s: var OrderedSet[A]; key: A)

     Includes an element key in s.

     This doesn't do anything if key is already in s.  Example:
     var values = initOrderedSet[int]()
     values.incl(2)
     values.incl(2)
     assert values.len == 1

   * incl
          proc incl*[A](s: var HashSet[A]; other: OrderedSet[A])

     Includes all elements from other into s.

     Example:
     var values = initOrderedSet[int]()
     values.incl(2)
     var others = toOrderedSet([6, 7])
     values.incl(others)
     assert values.len == 3

   * containsOrIncl
          proc containsOrIncl*[A](s: var OrderedSet[A]; key: A): bool

     Includes key in the set s and tells if key was added to s.

     The difference with regards to the incl() (#incl,TOrderedSet[A],A)
     proc is that this proc returns true if key was already present in
     s.  The proc will return false if key was added as a new value to s
     during this call.  Example:
     var values = initOrderedSet[int]()
     assert values.containsOrIncl(2) == false
     assert values.containsOrIncl(2) == true

   * init
          proc init*[A](s: var OrderedSet[A]; initialSize = 64)

     Initializes an ordered hash set.

     The initialSize parameter needs to be a power of two.  You can use
     math.nextPowerOfTwo() (math.html#nextPowerOfTwo) or rightSize to
     guarantee that at runtime.  All set variables must be initialized
     before use with other procs from this module with the exception of
     isValid() (#isValid,TOrderedSet[A]) and len()
     (#len,TOrderedSet[A]).

     You can call this proc on a previously initialized ordered hash set
     to discard its values.  At the moment this is the only proc to
     remove elements from an ordered hash set.  Example:
     var a: OrderedSet[int]
     a.init(4)
     a.incl(2)
     a.init
     assert a.len == 0 and a.isValid

   * initOrderedSet
          proc initOrderedSet*[A](initialSize = 64): OrderedSet[A]

     Wrapper around init() (#init,TOrderedSet[A],int) for initialization
     of ordered hash sets.

     Returns an empty ordered hash set you can assign directly in 'var'
     blocks in a single line.  Example:
     var a = initOrderedSet[int](4)
     a.incl(2)

   * toOrderedSet
          proc toOrderedSet*[A](keys: openArray[A]): OrderedSet[A]

     Creates a new ordered hash set that contains the given keys.

     Example:
     var numbers = toOrderedSet([1, 2, 3, 4, 5])
     assert numbers.contains(2)
     assert numbers.contains(4)

   * '$'
          proc `$`*[A](s: OrderedSet[A]): string

     Converts the ordered hash set s to a string, mostly for logging
     purposes.

     Don't use this proc for serialization, the representation may
     change at any moment and values are not escaped.  Example:

     Example:
     echo toOrderedSet([2, 4, 5])
     # --> {2, 4, 5}
     echo toOrderedSet(["no", "esc'aping", "is \" provided"])
     # --> {no, esc'aping, is " provided}

   * '=='
          proc `==`*[A](s, t: OrderedSet[A]): bool

     Equality for ordered sets.

273 Iterators
*************

   * items
          iterator items*[A](s: HashSet[A]): A

     Iterates over keys in the set s.

     If you need a sequence with the keys you can use sequtils.toSeq()
     (sequtils.html#toSeq) on the iterator.  Usage example:
     type
       pair = tuple[a, b: int]
     var
       a, b = initSet[pair]()
     a.incl((2, 3))
     a.incl((3, 2))
     a.incl((2, 3))
     for x, y in a.items:
       b.incl((x - 2, y + 1))
     assert a.len == 2
     echo b
     # --> {(a: 1, b: 3), (a: 0, b: 4)}

   * items
          iterator items*[A](s: OrderedSet[A]): A

     Iterates over keys in the ordered set s in insertion order.

     If you need a sequence with the keys you can use sequtils.toSeq()
     (sequtils.html#toSeq) on the iterator.  Usage example:
     var a = initOrderedSet[int]()
     for value in [9, 2, 1, 5, 1, 8, 4, 2]:
       a.incl(value)
     for value in a.items:
       echo "Got ", value
     # --> Got 9
     # --> Got 2
     # --> Got 1
     # --> Got 5
     # --> Got 8
     # --> Got 4


File: nim-ref-0.13.0.info,  Node: /pure/collections/sharedlist,  Next: /pure/collections/lists,  Prev: /pure/collections/sets,  Up: Top

274 Types
*********

   * SharedList head, tail: SharedListNode[A] lock: Lock

          SharedList*[A] = object
            head, tail: SharedListNode[A]
            lock: Lock


     generic shared list

275 Procedures
**************

   * add
          proc add*[A](x: var SharedList[A]; y: A)

   * initSharedList
          proc initSharedList*[A](): SharedList[A]

   * clear
          proc clear*[A](t: var SharedList[A])

   * deinitSharedList
          proc deinitSharedList*[A](t: var SharedList[A])

276 Iterators
*************

   * items
          iterator items*[A](x: var SharedList[A]): A


File: nim-ref-0.13.0.info,  Node: /pure/collections/lists,  Next: /deprecated/pure/rawsockets,  Prev: /pure/collections/sharedlist,  Up: Top

277 Types
*********

   * DoublyLinkedRing head*: DoublyLinkedNode[T]

          DoublyLinkedRing*[T] = object
            head*: DoublyLinkedNode[T]


     a doubly linked ring

278 Procedures
**************

   * initSinglyLinkedList
          proc initSinglyLinkedList*[T](): SinglyLinkedList[T]

     creates a new singly linked list that is empty.

   * initDoublyLinkedList
          proc initDoublyLinkedList*[T](): DoublyLinkedList[T]

     creates a new doubly linked list that is empty.

   * initSinglyLinkedRing
          proc initSinglyLinkedRing*[T](): SinglyLinkedRing[T]

     creates a new singly linked ring that is empty.

   * initDoublyLinkedRing
          proc initDoublyLinkedRing*[T](): DoublyLinkedRing[T]

     creates a new doubly linked ring that is empty.

   * newDoublyLinkedNode
          proc newDoublyLinkedNode*[T](value: T): DoublyLinkedNode[T]

     creates a new doubly linked node with the given value.

   * newSinglyLinkedNode
          proc newSinglyLinkedNode*[T](value: T): SinglyLinkedNode[T]

     creates a new singly linked node with the given value.

   * '$'
          proc `$`*[T](L: SinglyLinkedList[T]): string

     turns a list into its string representation.

   * '$'
          proc `$`*[T](L: DoublyLinkedList[T]): string

     turns a list into its string representation.

   * '$'
          proc `$`*[T](L: SinglyLinkedRing[T]): string

     turns a list into its string representation.

   * '$'
          proc `$`*[T](L: DoublyLinkedRing[T]): string

     turns a list into its string representation.

   * find
          proc find*[T](L: SinglyLinkedList[T]; value: T): SinglyLinkedNode[T]

     searches in the list for a value.  Returns nil if the value does
     not exist.

   * find
          proc find*[T](L: DoublyLinkedList[T]; value: T): DoublyLinkedNode[T]

     searches in the list for a value.  Returns nil if the value does
     not exist.

   * find
          proc find*[T](L: SinglyLinkedRing[T]; value: T): SinglyLinkedNode[T]

     searches in the list for a value.  Returns nil if the value does
     not exist.

   * find
          proc find*[T](L: DoublyLinkedRing[T]; value: T): DoublyLinkedNode[T]

     searches in the list for a value.  Returns nil if the value does
     not exist.

   * contains
          proc contains*[T](L: SinglyLinkedList[T]; value: T): bool {.inline.}

     searches in the list for a value.  Returns false if the value does
     not exist, true otherwise.

   * contains
          proc contains*[T](L: DoublyLinkedList[T]; value: T): bool {.inline.}

     searches in the list for a value.  Returns false if the value does
     not exist, true otherwise.

   * contains
          proc contains*[T](L: SinglyLinkedRing[T]; value: T): bool {.inline.}

     searches in the list for a value.  Returns false if the value does
     not exist, true otherwise.

   * contains
          proc contains*[T](L: DoublyLinkedRing[T]; value: T): bool {.inline.}

     searches in the list for a value.  Returns false if the value does
     not exist, true otherwise.

   * prepend
          proc prepend*[T](L: var SinglyLinkedList[T]; n: SinglyLinkedNode[T]) {.inline.}

     prepends a node to L. Efficiency: O(1).

   * prepend
          proc prepend*[T](L: var SinglyLinkedList[T]; value: T) {.inline.}

     prepends a node to L. Efficiency: O(1).

   * append
          proc append*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])

     appends a node n to L. Efficiency: O(1).

   * append
          proc append*[T](L: var DoublyLinkedList[T]; value: T)

     appends a value to L. Efficiency: O(1).

   * prepend
          proc prepend*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])

     prepends a node n to L. Efficiency: O(1).

   * prepend
          proc prepend*[T](L: var DoublyLinkedList[T]; value: T)

     prepends a value to L. Efficiency: O(1).

   * remove
          proc remove*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])

     removes n from L. Efficiency: O(1).

   * append
          proc append*[T](L: var SinglyLinkedRing[T]; n: SinglyLinkedNode[T])

     appends a node n to L. Efficiency: O(1).

   * append
          proc append*[T](L: var SinglyLinkedRing[T]; value: T)

     appends a value to L. Efficiency: O(1).

   * prepend
          proc prepend*[T](L: var SinglyLinkedRing[T]; n: SinglyLinkedNode[T])

     prepends a node n to L. Efficiency: O(1).

   * prepend
          proc prepend*[T](L: var SinglyLinkedRing[T]; value: T)

     prepends a value to L. Efficiency: O(1).

   * append
          proc append*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])

     appends a node n to L. Efficiency: O(1).

   * append
          proc append*[T](L: var DoublyLinkedRing[T]; value: T)

     appends a value to L. Efficiency: O(1).

   * prepend
          proc prepend*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])

     prepends a node n to L. Efficiency: O(1).

   * prepend
          proc prepend*[T](L: var DoublyLinkedRing[T]; value: T)

     prepends a value to L. Efficiency: O(1).

   * remove
          proc remove*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])

     removes n from L. Efficiency: O(1).

279 Iterators
*************

   * items
          iterator items*[T](L: DoublyLinkedList[T]): T

     yields every value of L.

   * items
          iterator items*[T](L: SinglyLinkedList[T]): T

     yields every value of L.

   * items
          iterator items*[T](L: SinglyLinkedRing[T]): T

     yields every value of L.

   * items
          iterator items*[T](L: DoublyLinkedRing[T]): T

     yields every value of L.

   * mitems
          iterator mitems*[T](L: var DoublyLinkedList[T]): var T

     yields every value of L so that you can modify it.

   * mitems
          iterator mitems*[T](L: var SinglyLinkedList[T]): var T

     yields every value of L so that you can modify it.

   * mitems
          iterator mitems*[T](L: var SinglyLinkedRing[T]): var T

     yields every value of L so that you can modify it.

   * mitems
          iterator mitems*[T](L: var DoublyLinkedRing[T]): var T

     yields every value of L so that you can modify it.

   * nodes
          iterator nodes*[T](L: SinglyLinkedList[T]): SinglyLinkedNode[T]

     iterates over every node of x.  Removing the current node from the
     list during traversal is supported.

   * nodes
          iterator nodes*[T](L: DoublyLinkedList[T]): DoublyLinkedNode[T]

     iterates over every node of x.  Removing the current node from the
     list during traversal is supported.

   * nodes
          iterator nodes*[T](L: SinglyLinkedRing[T]): SinglyLinkedNode[T]

     iterates over every node of x.  Removing the current node from the
     list during traversal is supported.

   * nodes
          iterator nodes*[T](L: DoublyLinkedRing[T]): DoublyLinkedNode[T]

     iterates over every node of x.  Removing the current node from the
     list during traversal is supported.


File: nim-ref-0.13.0.info,  Node: /deprecated/pure/rawsockets,  Next: /deprecated/pure/sockets,  Prev: /pure/collections/lists,  Up: Top

280 Templates
*************

   * newRawSocket
          template newRawSocket*(domain, sockType, protocol: cint): expr

   * newRawSocket protocol: Protocol = IPPROTO_TCP): expr
          template newRawSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
                                protocol: Protocol = IPPROTO_TCP): expr


File: nim-ref-0.13.0.info,  Node: /deprecated/pure/sockets,  Next: /deprecated/pure/parseurl,  Prev: /deprecated/pure/rawsockets,  Up: Top

281 Constant variables
**********************

   * BufferSize
          BufferSize*: int = 4000

     size of a buffered socket's buffer

282 Let variable
****************

   * invalidSocket
          invalidSocket*: Socket = nil

     invalid socket

283 Types
*********

   * SSLAcceptResult AcceptNoClient = 0, AcceptNoHandshake,
     AcceptSuccess
          SSLAcceptResult* = enum
            AcceptNoClient = 0, AcceptNoHandshake, AcceptSuccess

   * TimeoutError
          TimeoutError* = object of Exception

284 Procedures
**************

   * '=='
          proc `==`*(a, b: Port): bool {.borrow.}

     '==' for ports.

   * '$'
          proc `$`*(p: Port): string {.borrow.}

     returns the port number as a string

   * ntohl
          proc ntohl*(x: int32): int32

     Converts 32-bit integers from network to host byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 4-byte swap
     operation.

   * ntohs
          proc ntohs*(x: int16): int16

     Converts 16-bit integers from network to host byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 2-byte swap
     operation.

   * htonl
          proc htonl*(x: int32): int32

     Converts 32-bit integers from host to network byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 4-byte swap
     operation.

   * htons
          proc htons*(x: int16): int16

     Converts 16-bit positive integers from host to network byte order.
     On machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 2-byte swap
     operation.

   * socket protocol: Protocol = IPPROTO_TCP; buffered = true): Socket
          proc socket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM;
                      protocol: Protocol = IPPROTO_TCP; buffered = true): Socket

     Creates a new socket; returns InvalidSocket if an error occurs.

   * newContext keyFile = ""): SSLContext
          proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";
                          keyFile = ""): SSLContext

     Creates an SSL context.

     Protocol version specifies the protocol to use.  SSLv2, SSLv3,
     TLSv1 are are available with the addition of 'ProtSSLv23' which
     allows for compatibility with all of them.

     There are currently only two options for verify mode; one is
     'CVerifyNone' and with it certificates will not be verified the
     other is 'CVerifyPeer' and certificates will be verified for it,
     'CVerifyPeer' is the safest choice.

     The last two parameters specify the certificate file path and the
     key file path, a server socket will most likely not work without
     these.  Certificates can be generated using the following command:
     'openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout
     mycert.pem -out mycert.pem'.

   * wrapSocket
          proc wrapSocket*(ctx: SSLContext; socket: Socket)

     Wraps a socket in an SSL context.  This function effectively turns
     'socket' into an SSL socket.

     *Disclaimer*: This code is not well tested, may be very unsafe and
     prone to security vulnerabilities.

   * raiseSocketError
          proc raiseSocketError*(socket: Socket; err: int = - 1; async = false)

     Raises proper errors based on return values of 'recv' functions.

     If 'async' is 'True' no error will be thrown in the case when the
     error was caused by no data being available to be read.

     If 'err' is not lower than 0 no exception will be raised.

   * listen
          proc listen*(socket: Socket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}

     Marks 'socket' as accepting connections.  'Backlog' specifies the
     maximum length of the queue of pending connections.

   * parseIp4
          proc parseIp4*(s: string): BiggestInt

     parses an IP version 4 in dotted decimal form like "a.b.c.d".

     This is equivalent to inet_ntoa.

     Raises EInvalidValue in case of an error.

   * bindAddr
          proc bindAddr*(socket: Socket; port = Port(0); address = "") {.tags: [ReadIOEffect].}

     binds an address/port number to a socket.  Use address string in
     dotted decimal form like "a.b.c.d" or leave "" for any address.

   * getSockName
          proc getSockName*(socket: Socket): Port

     returns the socket's associated port number.

   * acceptAddr tags: [ReadIOEffect].}
          proc acceptAddr*(server: Socket; client: var Socket; address: var string) {.
              tags: [ReadIOEffect].}

     Blocks until a connection is being made from a client.  When a
     connection is made sets 'client' to the client socket and 'address'
     to the address of the connecting client.  If 'server' is
     non-blocking then this function returns immediately, and if there
     are no connections queued the returned socket will be
     'InvalidSocket'.  This function will raise EOS if an error occurs.

     The resulting client will inherit any properties of the server
     socket.  For example: whether the socket is buffered or not.

     *Note*: 'client' must be initialised (with 'new'), this function
     makes no effort to initialise the 'client' variable.

     *Warning:* When using SSL with non-blocking sockets, it is best to
     use the acceptAddrSSL procedure as this procedure will most likely
     block.

   * setBlocking
          proc setBlocking*(s: Socket; blocking: bool) {.tags: [], gcsafe.}

     Sets blocking mode on socket

   * acceptAddrSSL tags: [ReadIOEffect].}
          proc acceptAddrSSL*(server: Socket; client: var Socket; address: var string): SSLAcceptResult {.
              tags: [ReadIOEffect].}

     This procedure should only be used for non-blocking *SSL* sockets.
     It will immediately return with one of the following values:

     'AcceptSuccess' will be returned when a client has been
     successfully accepted and the handshake has been successfully
     performed between 'server' and the newly connected client.

     'AcceptNoHandshake' will be returned when a client has been
     accepted but no handshake could be performed.  This can happen when
     the client connects but does not yet initiate a handshake.  In this
     case 'acceptAddrSSL' should be called again with the same
     parameters.

     'AcceptNoClient' will be returned when no client is currently
     attempting to connect.

   * accept
          proc accept*(server: Socket; client: var Socket) {.tags: [ReadIOEffect].}

     Equivalent to 'acceptAddr' but doesn't return the address, only the
     socket.

     *Note*: 'client' must be initialised (with 'new'), this function
     makes no effort to initialise the 'client' variable.

   * acceptAddr tags: [ReadIOEffect].}
          proc acceptAddr*(server: Socket): tuple[client: Socket, address: string] {.deprecated,
              tags: [ReadIOEffect].}

     Slightly different version of 'acceptAddr'.

     *Deprecated since version 0.9.0:* Please use the function above.

   * accept
          proc accept*(server: Socket): Socket {.deprecated, tags: [ReadIOEffect].}

     *Deprecated since version 0.9.0:* Please use the function above.

   * close
          proc close*(socket: Socket)

     closes a socket.

   * getServByName
          proc getServByName*(name, proto: string): Servent {.tags: [ReadIOEffect].}

     Searches the database from the beginning and finds the first entry
     for which the service name specified by 'name' matches the s_name
     member and the protocol name specified by 'proto' matches the
     s_proto member.

     On posix this will search through the '/etc/services' file.

   * getServByPort
          proc getServByPort*(port: Port; proto: string): Servent {.tags: [ReadIOEffect].}

     Searches the database from the beginning and finds the first entry
     for which the port specified by 'port' matches the s_port member
     and the protocol name specified by 'proto' matches the s_proto
     member.

     On posix this will search through the '/etc/services' file.

   * getHostByAddr
          proc getHostByAddr*(ip: string): Hostent {.tags: [ReadIOEffect].}

     This function will lookup the hostname of an IP Address.

   * getHostByName
          proc getHostByName*(name: string): Hostent {.tags: [ReadIOEffect].}

     This function will lookup the IP address of a hostname.

   * getSockOptInt
          proc getSockOptInt*(socket: Socket; level, optname: int): int {.tags: [ReadIOEffect].}

     getsockopt for integer options.

   * setSockOptInt tags: [WriteIOEffect].}
          proc setSockOptInt*(socket: Socket; level, optname, optval: int) {.
              tags: [WriteIOEffect].}

     setsockopt for integer options.

   * getSockOpt tags: [ReadIOEffect].}
          proc getSockOpt*(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {.
              tags: [ReadIOEffect].}

     Retrieves option 'opt' as a boolean value.

   * setSockOpt tags: [WriteIOEffect].}
          proc setSockOpt*(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {.
              tags: [WriteIOEffect].}

     Sets option 'opt' to a boolean value specified by 'value'.

   * connect tags: [ReadIOEffect].}
          proc connect*(socket: Socket; address: string; port = Port(0); af: Domain = AF_INET) {.
              tags: [ReadIOEffect].}

     Connects socket to 'address':'port'.  'Address' can be an IP
     address or a host name.  If 'address' is a host name, this function
     will try each IP of that host name.  'htons' is already performed
     on 'port' so you must not do it.

     If 'socket' is an SSL socket a handshake will be automatically
     performed.

   * connectAsync tags: [ReadIOEffect].}
          proc connectAsync*(socket: Socket; name: string; port = Port(0); af: Domain = AF_INET) {.
              tags: [ReadIOEffect].}

     A variant of 'connect' for non-blocking sockets.

     This procedure will immediately return, it will not block until a
     connection is made.  It is up to the caller to make sure the
     connection has been established by checking (using 'select')
     whether the socket is writeable.

     *Note*: For SSL sockets, the 'handshake' procedure must be called
     whenever the socket successfully connects to a server.

   * handshake
          proc handshake*(socket: Socket): bool {.tags: [ReadIOEffect, WriteIOEffect].}

     This proc needs to be called on a socket after it connects.  This
     is only applicable when using 'connectAsync'.  This proc performs
     the SSL handshake.

     Returns 'False' whenever the socket is not yet ready for a
     handshake, 'True' whenever handshake completed successfully.

     A ESSL error is raised on any other errors.

   * gotHandshake
          proc gotHandshake*(socket: Socket): bool

     Determines whether a handshake has occurred between a client
     ('socket') and the server that 'socket' is connected to.

     Throws ESSL if 'socket' is not an SSL socket.

   * hasDataBuffered
          proc hasDataBuffered*(s: Socket): bool

     Determines whether a socket has data buffered.

   * select tags: [ReadIOEffect].}
          proc select*(readfds, writefds, exceptfds: var seq[Socket]; timeout = 500): int {.
              tags: [ReadIOEffect].}

     Traditional select function.  This function will return the number
     of sockets that are ready to be read from, written to, or which
     have errors.  If there are none; 0 is returned.  'Timeout' is in
     milliseconds and -1 can be specified for no timeout.

     Sockets which are *not* ready for reading, writing or which don't
     have errors waiting on them are removed from the 'readfds',
     'writefds', 'exceptfds' sequences respectively.

   * select tags: [ReadIOEffect].}
          proc select*(readfds, writefds: var seq[Socket]; timeout = 500): int {.
              tags: [ReadIOEffect].}

     Variant of select with only a read and write list.

   * selectWrite
          proc selectWrite*(writefds: var seq[Socket]; timeout = 500): int {.tags: [ReadIOEffect].}

     When a socket in 'writefds' is ready to be written to then a
     non-zero value will be returned specifying the count of the sockets
     which can be written to.  The sockets which *cannot* be written to
     will also be removed from 'writefds'.

     'timeout' is specified in milliseconds and '-1' can be specified
     for an unlimited time.

   * select
          proc select*(readfds: var seq[Socket]; timeout = 500): int

     variant of select with a read list only

   * recv
          proc recv*(socket: Socket; data: pointer; size: int): int {.tags: [ReadIOEffect].}

     Receives data from a socket.

     *Note*: This is a low-level function, you may be interested in the
     higher level versions of this function which are also named 'recv'.

   * recv tags: [ReadIOEffect, TimeEffect].}
          proc recv*(socket: Socket; data: pointer; size: int; timeout: int): int {.
              tags: [ReadIOEffect, TimeEffect].}

     overload with a 'timeout' parameter in milliseconds.

   * recv
          proc recv*(socket: Socket; data: var string; size: int; timeout = - 1): int

     Higher-level version of 'recv'.

     When 0 is returned the socket's connection has been closed.

     This function will throw an EOS exception when an error occurs.  A
     value lower than 0 is never returned.

     A timeout may be specified in milliseconds, if enough data is not
     received within the time specified an ETimeout exception will be
     raised.

     *Note*: 'data' must be initialised.

   * recvAsync
          proc recvAsync*(socket: Socket; data: var string; size: int): int

     Async version of 'recv'.

     When socket is non-blocking and no data is available on the socket,
     '-1' will be returned and 'data' will be '""'.

     *Note*: 'data' must be initialised.

   * recvLine tags: [ReadIOEffect, TimeEffect], deprecated.}
          proc recvLine*(socket: Socket; line: var TaintedString; timeout = - 1): bool {.
              tags: [ReadIOEffect, TimeEffect], deprecated.}

     Receive a line of data from 'socket'.

     If a full line is received '\r\L' is not added to 'line', however
     if solely '\r\L' is received then 'line' will be set to it.

     'True' is returned if data is available.  'False' suggests an
     error, EOS exceptions are not raised and 'False' is simply returned
     instead.

     If the socket is disconnected, 'line' will be set to '""' and
     'True' will be returned.

     A timeout can be specified in milliseconds, if data is not received
     within the specified time an ETimeout exception will be raised.

     *Deprecated since version 0.9.2*: This function has been deprecated
     in favour of readLine.

   * readLine tags: [ReadIOEffect, TimeEffect].}
          proc readLine*(socket: Socket; line: var TaintedString; timeout = - 1) {.
              tags: [ReadIOEffect, TimeEffect].}

     Reads a line of data from 'socket'.

     If a full line is read '\r\L' is not added to 'line', however if
     solely '\r\L' is read then 'line' will be set to it.

     If the socket is disconnected, 'line' will be set to '""'.

     An EOS exception will be raised in the case of a socket error.

     A timeout can be specified in milliseconds, if data is not received
     within the specified time an ETimeout exception will be raised.

   * recvLineAsync tags: [ReadIOEffect], deprecated.}
          proc recvLineAsync*(socket: Socket; line: var TaintedString): RecvLineResult {.
              tags: [ReadIOEffect], deprecated.}

     Similar to 'recvLine' but designed for non-blocking sockets.

     The values of the returned enum should be pretty self explanatory:

             * If a full line has been retrieved; 'RecvFullLine' is
               returned.
             * If some data has been retrieved; 'RecvPartialLine' is
               returned.
             * If the socket has been disconnected; 'RecvDisconnected'
               is returned.
             * If call to 'recv' failed; 'RecvFail' is returned.

     *Deprecated since version 0.9.2*: This function has been deprecated
     in favour of readLineAsync.

   * readLineAsync tags: [ReadIOEffect].}
          proc readLineAsync*(socket: Socket; line: var TaintedString): ReadLineResult {.
              tags: [ReadIOEffect].}

     Similar to 'recvLine' but designed for non-blocking sockets.

     The values of the returned enum should be pretty self explanatory:

             * If a full line has been retrieved; 'ReadFullLine' is
               returned.
             * If some data has been retrieved; 'ReadPartialLine' is
               returned.
             * If the socket has been disconnected; 'ReadDisconnected'
               is returned.
             * If no data could be retrieved; 'ReadNone' is returned.
             * If call to 'recv' failed; *an EOS exception is raised.*

   * recv
          proc recv*(socket: Socket): TaintedString {.tags: [ReadIOEffect], deprecated.}

     receives all the available data from the socket.  Socket errors
     will result in an 'EOS' error.  If socket is not a connectionless
     socket and socket is not connected '""' will be returned.

     *Deprecated since version 0.9.2*: This function is not safe for
     use.

   * recvTimeout deprecated.}
          proc recvTimeout*(socket: Socket; timeout: int): TaintedString {.tags: [ReadIOEffect],
              deprecated.}

     overloaded variant to support a 'timeout' parameter, the 'timeout'
     parameter specifies the amount of milliseconds to wait for data on
     the socket.

     *Deprecated since version 0.9.2*: This function is not safe for
     use.

   * recvAsync deprecated.}
          proc recvAsync*(socket: Socket; s: var TaintedString): bool {.tags: [ReadIOEffect],
              deprecated.}

     receives all the data from a non-blocking socket.  If socket is
     non-blocking and there are no messages available, False will be
     returned.  Other socket errors will result in an 'EOS' error.  If
     socket is not a connectionless socket and socket is not connected
     's' will be set to '""'.

     *Deprecated since version 0.9.2*: This function is not safe for
     use.

   * recvFrom port: var Port; flags = 0'i32): int {.tags:
     [ReadIOEffect].}
          proc recvFrom*(socket: Socket; data: var string; length: int; address: var string;
                        port: var Port; flags = 0'i32): int {.tags: [ReadIOEffect].}

     Receives data from 'socket'.  This function should normally be used
     with connection-less sockets (UDP sockets).

     If an error occurs the return value will be '-1'.  Otherwise the
     return value will be the length of data received.

     *Warning:* This function does not yet have a buffered
     implementation, so when 'socket' is buffered the non-buffered
     implementation will be used.  Therefore if 'socket' contains
     something in its buffer this function will make no effort to return
     it.

   * recvFromAsync port: var Port; flags = 0'i32): bool {.tags:
     [ReadIOEffect].}
          proc recvFromAsync*(socket: Socket; data: var string; length: int; address: var string;
                             port: var Port; flags = 0'i32): bool {.tags: [ReadIOEffect].}

     Variant of 'recvFrom' for non-blocking sockets.  Unlike 'recvFrom',
     this function will raise an EOS error whenever a socket error
     occurs.

     If there is no data to be read from the socket 'False' will be
     returned.

   * skip
          proc skip*(socket: Socket) {.tags: [ReadIOEffect], deprecated.}

     skips all the data that is pending for the socket

     *Deprecated since version 0.9.2*: This function is not safe for
     use.

   * skip
          proc skip*(socket: Socket; size: int; timeout = - 1)

     Skips 'size' amount of bytes.

     An optional timeout can be specified in milliseconds, if skipping
     the bytes takes longer than specified an ETimeout exception will be
     raised.

     Returns the number of skipped bytes.

   * send
          proc send*(socket: Socket; data: pointer; size: int): int {.tags: [WriteIOEffect].}

     sends data to a socket.

   * send
          proc send*(socket: Socket; data: string) {.tags: [WriteIOEffect].}

     sends data to a socket.

   * sendAsync
          proc sendAsync*(socket: Socket; data: string): int {.tags: [WriteIOEffect].}

     sends data to a non-blocking socket.  Returns '0' if no data could
     be sent, if data has been sent returns the amount of bytes of
     'data' that was successfully sent.  This number may not always be
     the length of 'data' but typically is.

     An EOS (or ESSL if socket is an SSL socket) exception is raised if
     an error occurs.

   * trySend
          proc trySend*(socket: Socket; data: string): bool {.tags: [WriteIOEffect].}

     safe alternative to 'send'.  Does not raise an EOS when an error
     occurs, and instead returns 'false' on failure.

   * sendTo af: Domain = AF_INET; flags = 0'i32): int {.tags:
     [WriteIOEffect].}
          proc sendTo*(socket: Socket; address: string; port: Port; data: pointer; size: int;
                      af: Domain = AF_INET; flags = 0'i32): int {.tags: [WriteIOEffect].}

     low-level sendTo proc.  This proc sends 'data' to the specified
     'address', which may be an IP address or a hostname, if a hostname
     is specified this function will try each IP of that hostname.

     *Note:* This proc is not available for SSL sockets.

   * sendTo tags: [WriteIOEffect].}
          proc sendTo*(socket: Socket; address: string; port: Port; data: string): int {.
              tags: [WriteIOEffect].}

     Friendlier version of the low-level 'sendTo'.

   * connect af: Domain = AF_INET) {.tags: [ReadIOEffect,
     WriteIOEffect].}
          proc connect*(socket: Socket; address: string; port = Port(0); timeout: int;
                       af: Domain = AF_INET) {.tags: [ReadIOEffect, WriteIOEffect].}

     Connects to server as specified by 'address' on port specified by
     'port'.

     The 'timeout' paremeter specifies the time in milliseconds to allow
     for the connection to the server to be made.

   * isSSL
          proc isSSL*(socket: Socket): bool

     Determines whether 'socket' is a SSL socket.

   * getFD
          proc getFD*(socket: Socket): SocketHandle

     Returns the socket's file descriptor

   * isBlocking
          proc isBlocking*(socket: Socket): bool

     Determines whether 'socket' is blocking.


File: nim-ref-0.13.0.info,  Node: /deprecated/pure/parseurl,  Next: /deprecated/pure/actors,  Prev: /deprecated/pure/sockets,  Up: Top

285 Types
*********

   * Url
          Url* = tuple[scheme, username, password, hostname, port, path, query, anchor: string]

     represents a _Uniform Resource Locator_ (URL) any optional
     component is "" if it does not exist

286 Procedures
**************

   * parseUrl
          proc parseUrl*(url: string): Url {.deprecated.}

   * '$'
          proc `$`*(u: Url): string {.deprecated.}

     turns the URL u into its string representation.


File: nim-ref-0.13.0.info,  Node: /deprecated/pure/actors,  Next: /deprecated/pure/asyncio,  Prev: /deprecated/pure/parseurl,  Up: Top

287 Types
*********

   * PActor
          PActor*[In, Out] = ptr Actor[In, Out]

     an actor

   * ActorPool actors: seq[PActor[In, Out]] when Out isnot void:
     outputs: Channel[Out]

          ActorPool*[In, Out] = object {.pure, final.}
            actors: seq[PActor[In, Out]]
            when Out isnot void:
                outputs: Channel[Out]



     an actor pool

288 Procedures
**************

   * spawn
          proc spawn*[In, Out](action: proc (self: PActor[In, Out]) {.thread.}): PActor[In, Out]

     creates an actor; that is a thread with an inbox.  The caller MUST
     call 'join' because that also frees the actor's associated
     resources.

   * inbox
          proc inbox*[In, Out](self: PActor[In, Out]): ptr Channel[In]

     gets a pointer to the associated inbox of the actor self.

   * running
          proc running*[In, Out](a: PActor[In, Out]): bool

     returns true if the actor a is running.

   * ready
          proc ready*[In, Out](a: PActor[In, Out]): bool

     returns true if the actor a is ready to process new messages.

   * join
          proc join*[In, Out](a: PActor[In, Out])

     joins an actor.

   * recv
          proc recv*[In, Out](a: PActor[In, Out]): Task[In, Out]

     receives a task from a's inbox.

   * send
          proc send*[In, Out, X, Y](receiver: PActor[In, Out]; msg: In; sender: PActor[X, Y])

     sends a message to a's inbox.

   * send
          proc send*[In, Out](receiver: PActor[In, Out]; msg: In; sender: ptr Channel[Out] = nil)

     sends a message to receiver's inbox.

   * sendShutdown
          proc sendShutdown*[In, Out](receiver: PActor[In, Out])

     send a shutdown message to receiver.

   * reply
          proc reply*[In, Out](t: Task[In, Out]; m: Out)

     sends a message to io's output message box.

   * '^'
          proc `^`*[T](f: ptr Channel[T]): T

     alias for 'recv'.

   * createActorPool
          proc createActorPool*[In, Out](a: var ActorPool[In, Out]; poolSize = 4)

     creates an actor pool.

   * sync
          proc sync*[In, Out](a: var ActorPool[In, Out]; polling = 50)

     waits for every actor of a to finish with its work.  Currently this
     is implemented as polling every polling ms and has a slight chance
     of failing since we check for every actor to be in ready state and
     not for messages still in ether.  This will change in a later
     version, however.

   * terminate
          proc terminate*[In, Out](a: var ActorPool[In, Out])

     terminates each actor in the actor pool a and frees the resources
     attached to a.

   * join
          proc join*[In, Out](a: var ActorPool[In, Out])

     short-cut for sync and then terminate.

   * spawn action: proc (input: In): Out {.thread.}): ptr Channel[Out]
          proc spawn*[In, Out](p: var ActorPool[In, Out]; input: In;
                             action: proc (input: In): Out {.thread.}): ptr Channel[Out]

     uses the actor pool to run 'action(input)' concurrently.  spawn is
     guaranteed to not block.

   * spawn action: proc (input: In) {.thread.})
          proc spawn*[In](p: var ActorPool[In, void]; input: In;
                         action: proc (input: In) {.thread.})

     uses the actor pool to run 'action(input)' concurrently.  spawn is
     guaranteed to not block.


File: nim-ref-0.13.0.info,  Node: /deprecated/pure/asyncio,  Next: /deprecated/pure/ftpclient,  Prev: /deprecated/pure/actors,  Up: Top

289 Types
*********

   * SocketStatus SockIdle, SockConnecting, SockConnected,
     SockListening, SockClosed, SockUDPBound
          SocketStatus* = enum
            SockIdle, SockConnecting, SockConnected, SockListening, SockClosed, SockUDPBound

290 Procedures
**************

   * newDelegate
          proc newDelegate*(): Delegate

     Creates a new delegate.

   * asyncSocket protocol: Protocol = IPPROTO_TCP; buffered = true):
     AsyncSocket
          proc asyncSocket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM;
                           protocol: Protocol = IPPROTO_TCP; buffered = true): AsyncSocket

     Initialises an AsyncSocket object.  If a socket cannot be
     initialised EOS is raised.

   * toAsyncSocket
          proc toAsyncSocket*(sock: Socket; state: SocketStatus = SockConnected): AsyncSocket

     Wraps an already initialized 'Socket' into a AsyncSocket.  This is
     useful if you want to use an already connected Socket as an
     asynchronous AsyncSocket in asyncio's event loop.

     'state' may be overriden, i.e.  if 'sock' is not connected it
     should be adjusted properly.  By default it will be assumed that
     the socket is connected.  Please note this is only applicable to
     TCP client sockets, if 'sock' is a different type of socket 'state'
     needs to be adjusted!!!

     Value            Meaning
     -----------------------------------------------------------------------------------
     SockIdle         Socket has only just been initialised, not connected or closed.
     SockConnected    Socket is connected to a server.
     SockConnecting   Socket is in the process of connecting to a server.
     SockListening    Socket is a server socket and is listening for connections.
     SockClosed       Socket has been closed.
     SockUDPBound     Socket is a UDP socket which is listening for data.

     *Warning*: If 'state' is set incorrectly the resulting
     'AsyncSocket' object may not work properly.

     *Note*: This will set 'sock' to be non-blocking.

   * close
          proc close*(sock: AsyncSocket) {.gcsafe.}

   * connect
          proc connect*(sock: AsyncSocket; name: string; port = Port(0); af: Domain = AF_INET)

     Begins connecting 'sock' to 'name':'port'.

   * close
          proc close*(sock: AsyncSocket)

     Closes 'sock'.  Terminates any current connections.

   * bindAddr
          proc bindAddr*(sock: AsyncSocket; port = Port(0); address = "")

     Equivalent to 'sockets.bindAddr'.

   * listen
          proc listen*(sock: AsyncSocket)

     Equivalent to 'sockets.listen'.

   * acceptAddr
          proc acceptAddr*(server: AsyncSocket; client: var AsyncSocket; address: var string)

     Equivalent to 'sockets.acceptAddr'.  This procedure should be
     called in a 'handleAccept' event handler *only* once.

     *Note*: 'client' needs to be initialised.

   * accept
          proc accept*(server: AsyncSocket; client: var AsyncSocket)

     Equivalent to 'sockets.accept'.

   * acceptAddr deprecated.}
          proc acceptAddr*(server: AsyncSocket): tuple[sock: AsyncSocket, address: string] {.
              deprecated.}

     Equivalent to 'sockets.acceptAddr'.

     *Deprecated since version 0.9.0:* Please use the function above.

   * accept
          proc accept*(server: AsyncSocket): AsyncSocket {.deprecated.}

     Equivalent to 'sockets.accept'.

     *Deprecated since version 0.9.0:* Please use the function above.

   * newDispatcher
          proc newDispatcher*(): Dispatcher

   * register
          proc register*(d: Dispatcher; deleg: Delegate)

     Registers delegate 'deleg' with dispatcher 'd'.

   * register
          proc register*(d: Dispatcher; sock: AsyncSocket): Delegate {.discardable.}

     Registers async socket 'sock' with dispatcher 'd'.

   * unregister
          proc unregister*(d: Dispatcher; deleg: Delegate)

     Unregisters deleg 'deleg' from dispatcher 'd'.

   * isWriteable
          proc isWriteable*(s: AsyncSocket): bool

     Determines whether socket 's' is ready to be written to.

   * isConnected
          proc isConnected*(s: AsyncSocket): bool

     Determines whether 's' is connected.

   * isListening
          proc isListening*(s: AsyncSocket): bool

     Determines whether 's' is listening for incoming connections.

   * isConnecting
          proc isConnecting*(s: AsyncSocket): bool

     Determines whether 's' is connecting.

   * isClosed
          proc isClosed*(s: AsyncSocket): bool

     Determines whether 's' has been closed.

   * isSendDataBuffered
          proc isSendDataBuffered*(s: AsyncSocket): bool

     Determines whether 's' has data waiting to be sent, i.e.  whether
     this socket's sendBuffer contains data.

   * setHandleWrite handleWrite: proc (s: AsyncSocket) {.closure,
     gcsafe.})
          proc setHandleWrite*(s: AsyncSocket;
                              handleWrite: proc (s: AsyncSocket) {.closure, gcsafe.})

     Setter for the 'handleWrite' event.

     To remove this event you should use the 'delHandleWrite' function.
     It is advised to use that function instead of just setting the
     event to 'proc (s: AsyncSocket) = nil' as that would mean that that
     function would be called constantly.

   * delHandleWrite
          proc delHandleWrite*(s: AsyncSocket)

     Removes the 'handleWrite' event handler on 's'.

   * recvLine
          proc recvLine*(s: AsyncSocket; line: var TaintedString): bool {.deprecated.}

     Behaves similar to 'sockets.recvLine', however it handles
     non-blocking sockets properly.  This function guarantees that
     'line' is a full line, if this function can only retrieve some
     data; it will save this data and add it to the result when a full
     line is retrieved.

     Unlike 'sockets.recvLine' this function will raise an EOS or ESSL
     exception if an error occurs.

     *Deprecated since version 0.9.2*: This function has been deprecated
     in favour of readLine.

   * readLine
          proc readLine*(s: AsyncSocket; line: var TaintedString): bool

     Behaves similar to 'sockets.readLine', however it handles
     non-blocking sockets properly.  This function guarantees that
     'line' is a full line, if this function can only retrieve some
     data; it will save this data and add it to the result when a full
     line is retrieved, when this happens False will be returned.  True
     will only be returned if a full line has been retrieved or the
     socket has been disconnected in which case 'line' will be set to
     "".

     This function will raise an EOS exception when a socket error
     occurs.

   * send
          proc send*(sock: AsyncSocket; data: string)

     Sends 'data' to socket 'sock'.  This is basically a nicer
     implementation of 'sockets.sendAsync'.

     If 'data' cannot be sent immediately it will be buffered and sent
     when 'sock' becomes writeable (during the 'handleWrite' event).
     It's possible that only a part of 'data' will be sent immediately,
     while the rest of it will be buffered and sent later.

   * poll
          proc poll*(d: Dispatcher; timeout: int = 500): bool

     This function checks for events on all the delegates in the
     PDispatcher.  It then proceeds to call the correct event handler.

     This function returns 'True' if there are file descriptors that are
     still open, otherwise 'False'.  File descriptors that have been
     closed are immediately removed from the dispatcher automatically.

     *Note:* Each delegate has a task associated with it.  This gets
     called after each select() call, if you set timeout to '-1' the
     tasks will only be executed after one or more file descriptors
     becomes readable or writeable.

   * len
          proc len*(disp: Dispatcher): int

     Retrieves the amount of delegates in 'disp'.

291 Converter
*************

   * getSocket
          converter getSocket*(s: AsyncSocket): Socket


File: nim-ref-0.13.0.info,  Node: /deprecated/pure/ftpclient,  Next: /deprecated/core/unsigned,  Prev: /deprecated/pure/asyncio,  Up: Top

292 Types
*********

   * FTPError
          FTPError* = object of IOError

293 Procedures
**************

   * ftpClient
          proc ftpClient*(address: string; port = Port(21); user, pass = ""): FtpClient

     Create a 'FtpClient' object.

   * send
          proc send*[T](ftp: FtpBase[T]; m: string): TaintedString

     Send a message to the server, and wait for a primary reply.  '\c\L'
     is added for you.

     *Note:* The server may return multiple lines of coded replies.

   * connect
          proc connect*[T](ftp: FtpBase[T])

     Connect to the FTP server specified by 'ftp'.

   * pwd
          proc pwd*[T](ftp: FtpBase[T]): string

     Returns the current working directory.

   * cd
          proc cd*[T](ftp: FtpBase[T]; dir: string)

     Changes the current directory on the remote FTP server to 'dir'.

   * cdup
          proc cdup*[T](ftp: FtpBase[T])

     Changes the current directory to the parent of the current
     directory.

   * listDirs
          proc listDirs*[T](ftp: FtpBase[T]; dir: string = ""; async = false): seq[string]

     Returns a list of filenames in the given directory.  If 'dir' is
     "", the current directory is used.  If 'async' is true, this
     function will return immediately and it will be your job to use
     asyncio's 'poll' to progress this operation.

   * fileExists
          proc fileExists*(ftp: FtpClient; file: string): bool {.deprecated.}

     *Deprecated since version 0.9.0:* Please use 'existsFile'.

     Determines whether 'file' exists.

     Warning: This function may block.  Especially on directories with
     many files, because a full list of file names must be retrieved.

   * existsFile
          proc existsFile*(ftp: FtpClient; file: string): bool

     Determines whether 'file' exists.

     Warning: This function may block.  Especially on directories with
     many files, because a full list of file names must be retrieved.

   * createDir
          proc createDir*[T](ftp: FtpBase[T]; dir: string; recursive: bool = false)

     Creates a directory 'dir'.  If 'recursive' is true, the topmost
     subdirectory of 'dir' will be created first, following the
     secondmost...  etc.  this allows you to give a full path as the
     'dir' without worrying about subdirectories not existing.

   * chmod
          proc chmod*[T](ftp: FtpBase[T]; path: string; permissions: set[FilePermission])

     Changes permission of 'path' to 'permissions'.

   * list
          proc list*[T](ftp: FtpBase[T]; dir: string = ""; async = false): string

     Lists all files in 'dir'.  If 'dir' is '""', uses the current
     working directory.  If 'async' is true, this function will return
     immediately and it will be your job to call asyncio's 'poll' to
     progress this operation.

   * retrText
          proc retrText*[T](ftp: FtpBase[T]; file: string; async = false): string

     Retrieves 'file'.  File must be ASCII text.  If 'async' is true,
     this function will return immediately and it will be your job to
     call asyncio's 'poll' to progress this operation.

   * retrFile
          proc retrFile*[T](ftp: FtpBase[T]; file, dest: string; async = false)

     Downloads 'file' and saves it to 'dest'.  Usage of this function
     asynchronously is recommended to view the progress of the download.
     The 'EvRetr' event is passed to the specified 'handleEvent'
     function when the download is finished, and the 'filename' field
     will be equal to 'file'.

   * store
          proc store*[T](ftp: FtpBase[T]; file, dest: string; async = false)

     Uploads 'file' to 'dest' on the remote FTP server.  Usage of this
     function asynchronously is recommended to view the progress of the
     download.  The 'EvStore' event is passed to the specified
     'handleEvent' function when the upload is finished, and the
     'filename' field will be equal to 'file'.

   * close
          proc close*[T](ftp: FtpBase[T])

     Terminates the connection to the server.

   * asyncFTPClient ftp: AsyncFTPClient; ev: FTPEvent) {.closure,
     gcsafe.} = (proc (ftp: AsyncFTPClient; ev: FTPEvent) = discard )):
     AsyncFTPClient
          proc asyncFTPClient*(address: string; port = Port(21); user, pass = ""; handleEvent: proc (
              ftp: AsyncFTPClient; ev: FTPEvent) {.closure, gcsafe.} = (proc (ftp: AsyncFTPClient;
              ev: FTPEvent) =
            discard )): AsyncFTPClient

     Create a 'AsyncFTPClient' object.

     Use this if you want to use asyncio's dispatcher.

   * register
          proc register*(d: Dispatcher; ftp: AsyncFTPClient): Delegate {.discardable.}

     Registers 'ftp' with dispatcher 'd'.


File: nim-ref-0.13.0.info,  Node: /deprecated/core/unsigned,  Next: /wrappers/libsvm,  Prev: /deprecated/pure/ftpclient,  Up: Top


File: nim-ref-0.13.0.info,  Node: /wrappers/libsvm,  Next: /wrappers/pcre,  Prev: /deprecated/core/unsigned,  Up: Top

294 Constant variables
**********************

   * LIBSVM_VERSION
          LIBSVM_VERSION* = 312

   * svmdll
          svmdll* = "libsvm.dll"

295 Types
*********

   * Parameter typ*: Type kernelType*: KernelType degree*: cint gamma*:
     cdouble coef0*: cdouble cache_size*: cdouble eps*: cdouble C*:
     cdouble nr_weight*: cint weight_label*: ptr cint weight*: ptr
     cdouble nu*: cdouble p*: cdouble shrinking*: cint probability*:
     cint

          Parameter* {.pure, final.} = object
            typ*: Type
            kernelType*: KernelType
            degree*: cint
            gamma*: cdouble
            coef0*: cdouble
            cache_size*: cdouble
            eps*: cdouble
            C*: cdouble
            nr_weight*: cint
            weight_label*: ptr cint
            weight*: ptr cdouble
            nu*: cdouble
            p*: cdouble
            shrinking*: cint
            probability*: cint


   * Model param*: Parameter nr_class*: cint L*: cint SV*: ptr ptr Node
     sv_coef*: ptr ptr cdouble rho*: ptr cdouble probA*: ptr cdouble
     probB*: ptr cdouble label*: ptr cint nSV*: ptr cint free_sv*: cint

          Model* {.pure, final.} = object
            param*: Parameter
            nr_class*: cint
            L*: cint
            SV*: ptr ptr Node
            sv_coef*: ptr ptr cdouble
            rho*: ptr cdouble
            probA*: ptr cdouble
            probB*: ptr cdouble
            label*: ptr cint
            nSV*: ptr cint
            free_sv*: cint


296 Procedures
**************

   * train importc: "svm_train", dynlib: svmdll.}
          proc train*(prob: ptr Problem; param: ptr Parameter): ptr Model {.cdecl,
              importc: "svm_train", dynlib: svmdll.}

   * cross_validation target: ptr cdouble) {.cdecl, importc:
     "svm_cross_validation", dynlib: svmdll.}
          proc cross_validation*(prob: ptr Problem; param: ptr Parameter; nr_fold: cint;
                                target: ptr cdouble) {.cdecl, importc: "svm_cross_validation",
              dynlib: svmdll.}

   * save_model importc: "svm_save_model", dynlib: svmdll.}
          proc save_model*(model_file_name: cstring; model: ptr Model): cint {.cdecl,
              importc: "svm_save_model", dynlib: svmdll.}

   * load_model importc: "svm_load_model", dynlib: svmdll.}
          proc load_model*(model_file_name: cstring): ptr Model {.cdecl,
              importc: "svm_load_model", dynlib: svmdll.}

   * get_svm_type dynlib: svmdll.}
          proc get_svm_type*(model: ptr Model): cint {.cdecl, importc: "svm_get_svm_type",
                                                  dynlib: svmdll.}

   * get_nr_class dynlib: svmdll.}
          proc get_nr_class*(model: ptr Model): cint {.cdecl, importc: "svm_get_nr_class",
                                                  dynlib: svmdll.}

   * get_labels dynlib: svmdll.}
          proc get_labels*(model: ptr Model; label: ptr cint) {.cdecl, importc: "svm_get_labels",
              dynlib: svmdll.}

   * get_svr_probability importc: "svm_get_svr_probability", dynlib:
     svmdll.}
          proc get_svr_probability*(model: ptr Model): cdouble {.cdecl,
              importc: "svm_get_svr_probability", dynlib: svmdll.}

   * predict_values cdecl, importc: "svm_predict_values", dynlib:
     svmdll.}
          proc predict_values*(model: ptr Model; x: ptr Node; dec_values: ptr cdouble): cdouble {.
              cdecl, importc: "svm_predict_values", dynlib: svmdll.}

   * predict dynlib: svmdll.}
          proc predict*(model: ptr Model; x: ptr Node): cdouble {.cdecl, importc: "svm_predict",
              dynlib: svmdll.}

   * predict_probability cdecl, importc: "svm_predict_probability",
     dynlib: svmdll.}
          proc predict_probability*(model: ptr Model; x: ptr Node; prob_estimates: ptr cdouble): cdouble {.
              cdecl, importc: "svm_predict_probability", dynlib: svmdll.}

   * free_model_content importc: "svm_free_model_content", dynlib:
     svmdll.}
          proc free_model_content*(model_ptr: ptr Model) {.cdecl,
              importc: "svm_free_model_content", dynlib: svmdll.}

   * free_and_destroy_model importc: "svm_free_and_destroy_model",
     dynlib: svmdll.}
          proc free_and_destroy_model*(model_ptr_ptr: ptr ptr Model) {.cdecl,
              importc: "svm_free_and_destroy_model", dynlib: svmdll.}

   * destroy_param dynlib: svmdll.}
          proc destroy_param*(param: ptr Parameter) {.cdecl, importc: "svm_destroy_param",
                                                  dynlib: svmdll.}

   * check_parameter importc: "svm_check_parameter", dynlib: svmdll.}
          proc check_parameter*(prob: ptr Problem; param: ptr Parameter): cstring {.cdecl,
              importc: "svm_check_parameter", dynlib: svmdll.}

   * check_probability_model importc: "svm_check_probability_model",
     dynlib: svmdll.}
          proc check_probability_model*(model: ptr Model): cint {.cdecl,
              importc: "svm_check_probability_model", dynlib: svmdll.}

   * set_print_string_function importc: "svm_set_print_string_function",
     dynlib: svmdll.}
          proc set_print_string_function*(print_func: proc (arg: cstring) {.cdecl.}) {.cdecl,
              importc: "svm_set_print_string_function", dynlib: svmdll.}


File: nim-ref-0.13.0.info,  Node: /wrappers/pcre,  Next: /wrappers/pdcurses,  Prev: /wrappers/libsvm,  Up: Top

297 Constant variables
**********************

   * PCRE_DATE
          PCRE_DATE* = "2014-09-26"

   * PARTIAL
          PARTIAL* = 0x00008000

   * DFA_SHORTEST
          DFA_SHORTEST* = 0x00010000

   * DFA_RESTART
          DFA_RESTART* = 0x00020000

   * UCP
          UCP* = 0x20000000

   * ERROR_UNSET
          ERROR_UNSET* = - 33

   * UTF8_ERR22
          UTF8_ERR22* = 22

   * UTF16_ERR4
          UTF16_ERR4* = 4

   * UTF32_ERR3
          UTF32_ERR3* = 3

   * INFO_MATCH_EMPTY
          INFO_MATCH_EMPTY* = 25

   * CONFIG_PARENS_LIMIT
          CONFIG_PARENS_LIMIT* = 13

   * STUDY_EXTRA_NEEDED
          STUDY_EXTRA_NEEDED* = 0x00000008

   * EXTRA_EXECUTABLE_JIT
          EXTRA_EXECUTABLE_JIT* = 0x00000040

298 Types
*********

   * JitStack32
          JitStack32* = object

   * ExtraData flags*: clong study_data*: pointer ## Opaque data from
     pcre_study() match_limit*: clong ## Maximum number of calls to
     match() callout_data*: pointer ## Data passed back in callouts
     tables*: pointer ## Pointer to character tables
     match_limit_recursion*: clong ## Max recursive calls to match()
     mark*: pointer ## For passing back a mark pointer executable_jit*:
     pointer ## Contains a pointer to a compiled jit code

          ExtraData* = object
            flags*: clong
            study_data*: pointer         ## Opaque data from pcre_study()
            match_limit*: clong          ## Maximum number of calls to match()
            callout_data*: pointer       ## Data passed back in callouts
            tables*: pointer             ## Pointer to character tables
            match_limit_recursion*: clong ## Max recursive calls to match()
            mark*: pointer               ## For passing back a mark pointer
            executable_jit*: pointer     ## Contains a pointer to a compiled jit code


     Bits for which fields are set

   * CalloutBlock version*: cint callout_number*: cint ## Number
     compiled into pattern offset_vector*: ptr cint ## The offset vector
     subject*: cstring ## The subject being matched subject_length*:
     cint ## The length of the subject start_match*: cint ## Offset to
     start of this match attempt current_position*: cint ## Where we
     currently are in the subject capture_top*: cint ## Max current
     capture capture_last*: cint ## Most recently closed capture
     callout_data*: pointer ## Data passed in with the call
     pattern_position*: cint ## Offset to next item in the pattern
     next_item_length*: cint ## Length of next item in the pattern
     mark*: pointer ## Pointer to current mark or NULL

          CalloutBlock* = object
            version*: cint
            callout_number*: cint        ## Number compiled into pattern
            offset_vector*: ptr cint      ## The offset vector
            subject*: cstring            ## The subject being matched
            subject_length*: cint        ## The length of the subject
            start_match*: cint           ## Offset to start of this match attempt
            current_position*: cint      ## Where we currently are in the subject
            capture_top*: cint           ## Max current capture
            capture_last*: cint          ## Most recently closed capture
            callout_data*: pointer       ## Data passed in with the call
            pattern_position*: cint      ## Offset to next item in the pattern
            next_item_length*: cint      ## Length of next item in the pattern
            mark*: pointer               ## Pointer to current mark or NULL


     Identifies version of block

   * JitCallback
          JitCallback* = proc (a: pointer): ptr JitStack {.cdecl.}

   * PJitStack
          PJitStack* {.deprecated.} = ptr JitStack

299 Procedures
**************

   * compile tableptr: pointer): ptr Pcre
          proc compile*(pattern: cstring; options: cint; errptr: ptr cstring; erroffset: ptr cint;
                       tableptr: pointer): ptr Pcre

   * compile2 errptr: ptr cstring; erroffset: ptr cint; tableptr:
     pointer): ptr Pcre
          proc compile2*(pattern: cstring; options: cint; errorcodeptr: ptr cint;
                        errptr: ptr cstring; erroffset: ptr cint; tableptr: pointer): ptr Pcre

   * config
          proc config*(what: cint; where: pointer): cint

   * copy_named_substring stringcount: cint; stringname: cstring;
     buffer: cstring; buffersize: cint): cint
          proc copy_named_substring*(code: ptr Pcre; subject: cstring; ovector: ptr cint;
                                    stringcount: cint; stringname: cstring; buffer: cstring;
                                    buffersize: cint): cint

   * copy_substring stringnumber: cint; buffer: cstring; buffersize:
     cint): cint
          proc copy_substring*(subject: cstring; ovector: ptr cint; stringcount: cint;
                              stringnumber: cint; buffer: cstring; buffersize: cint): cint

   * dfa_exec startoffset: cint; options: cint; ovector: ptr cint;
     ovecsize: cint; workspace: ptr cint; wscount: cint): cint
          proc dfa_exec*(code: ptr Pcre; extra: ptr ExtraData; subject: cstring; length: cint;
                        startoffset: cint; options: cint; ovector: ptr cint; ovecsize: cint;
                        workspace: ptr cint; wscount: cint): cint

   * exec startoffset: cint; options: cint; ovector: ptr cint; ovecsize:
     cint): cint
          proc exec*(code: ptr Pcre; extra: ptr ExtraData; subject: cstring; length: cint;
                    startoffset: cint; options: cint; ovector: ptr cint; ovecsize: cint): cint

   * jit_exec startoffset: cint; options: cint; ovector: ptr cint;
     ovecsize: cint; jstack: ptr JitStack): cint
          proc jit_exec*(code: ptr Pcre; extra: ptr ExtraData; subject: cstring; length: cint;
                        startoffset: cint; options: cint; ovector: ptr cint; ovecsize: cint;
                        jstack: ptr JitStack): cint

   * free_substring
          proc free_substring*(stringptr: cstring)

   * free_substring_list
          proc free_substring_list*(stringptr: cstringArray)

   * fullinfo
          proc fullinfo*(code: ptr Pcre; extra: ptr ExtraData; what: cint; where: pointer): cint

   * get_named_substring stringcount: cint; stringname: cstring;
     stringptr: cstringArray): cint
          proc get_named_substring*(code: ptr Pcre; subject: cstring; ovector: ptr cint;
                                   stringcount: cint; stringname: cstring;
                                   stringptr: cstringArray): cint

   * get_stringnumber
          proc get_stringnumber*(code: ptr Pcre; name: cstring): cint

   * get_stringtable_entries last: cstringArray): cint
          proc get_stringtable_entries*(code: ptr Pcre; name: cstring; first: cstringArray;
                                       last: cstringArray): cint

   * get_substring stringnumber: cint; stringptr: cstringArray): cint
          proc get_substring*(subject: cstring; ovector: ptr cint; stringcount: cint;
                             stringnumber: cint; stringptr: cstringArray): cint

   * get_substring_list listptr: ptr cstringArray): cint
          proc get_substring_list*(subject: cstring; ovector: ptr cint; stringcount: cint;
                                  listptr: ptr cstringArray): cint

   * maketables
          proc maketables*(): pointer

   * refcount
          proc refcount*(code: ptr Pcre; adjust: cint): cint

   * study
          proc study*(code: ptr Pcre; options: cint; errptr: ptr cstring): ptr ExtraData

   * free_study
          proc free_study*(extra: ptr ExtraData)

   * version
          proc version*(): cstring

   * pattern_to_host_byte_order
          proc pattern_to_host_byte_order*(code: ptr Pcre; extra: ptr ExtraData; tables: pointer): cint

   * jit_stack_alloc
          proc jit_stack_alloc*(startsize: cint; maxsize: cint): ptr JitStack

   * jit_stack_free
          proc jit_stack_free*(stack: ptr JitStack)

   * assign_jit_stack
          proc assign_jit_stack*(extra: ptr ExtraData; callback: JitCallback; data: pointer)

   * jit_free_unused_memory
          proc jit_free_unused_memory*()

   * study
          proc study*(code: ptr Pcre; options: cint; errptr: var cstring): ptr ExtraData {.deprecated.}


File: nim-ref-0.13.0.info,  Node: /wrappers/pdcurses,  Next: /wrappers/tinyc,  Prev: /wrappers/pcre,  Up: Top

300 Constant variables
**********************

   * KEY_MODIFIER_NUMLOCK
          KEY_MODIFIER_NUMLOCK* = 8

   * BUTTON_ALT
          BUTTON_ALT* = BUTTON_MODIFIER_ALT

   * ACS_SSSS
          ACS_SSSS* = ACS_PLUS

301 Variables
*************

   * ttytype
          ttytype* {.importc: "ttytype", dynlib: pdcursesdll.}: cstring

   * quick_edit
          quick_edit* {.importc: "pdc_quick_edit", dynlib: pdcursesdll.}: DWORD

302 Types
*********

   * PANEL win*: ptr WINDOW wstarty*: cint wendy*: cint wstartx*: cint
     wendx*: cint below*: ptr PANEL above*: ptr PANEL user*: pointer
     obscure*: ptr PANELOBS

          PANEL* {.pure, final.} = object
            win*: ptr WINDOW
            wstarty*: cint
            wendy*: cint
            wstartx*: cint
            wendx*: cint
            below*: ptr PANEL
            above*: ptr PANEL
            user*: pointer
            obscure*: ptr PANELOBS


   * SCREEN alive*: cunsignedchar autocr*: cunsignedchar cbreak*:
     cunsignedchar echo*: cunsignedchar raw_inp*: cunsignedchar
     raw_out*: cunsignedchar audible*: cunsignedchar mono*:
     cunsignedchar resized*: cunsignedchar orig_attr*: cunsignedchar
     orig_fore*: cshort orig_back*: cshort cursrow*: cint curscol*: cint
     visibility*: cint orig_cursor*: cint lines*: cint cols*: cint
     trap_mbe*: cunsignedlong map_mbe_to_key*: cunsignedlong
     mouse_wait*: cint slklines*: cint slk_winptr*: ptr WINDOW
     linesrippedoff*: cint linesrippedoffontop*: cint delaytenths*: cint
     preserve*: cunsignedchar restore*: cint save_key_modifiers*:
     cunsignedchar return_key_modifiers*: cunsignedchar key_code*:
     cunsignedchar XcurscrSize*: cint sb_on*: cunsignedchar
     sb_viewport_y*: cint sb_viewport_x*: cint sb_total_y*: cint
     sb_total_x*: cint sb_cur_y*: cint sb_cur_x*: cint line_color*:
     cshort

          SCREEN* {.pure, final.} = object
            alive*: cunsignedchar
            autocr*: cunsignedchar
            cbreak*: cunsignedchar
            echo*: cunsignedchar
            raw_inp*: cunsignedchar
            raw_out*: cunsignedchar
            audible*: cunsignedchar
            mono*: cunsignedchar
            resized*: cunsignedchar
            orig_attr*: cunsignedchar
            orig_fore*: cshort
            orig_back*: cshort
            cursrow*: cint
            curscol*: cint
            visibility*: cint
            orig_cursor*: cint
            lines*: cint
            cols*: cint
            trap_mbe*: cunsignedlong
            map_mbe_to_key*: cunsignedlong
            mouse_wait*: cint
            slklines*: cint
            slk_winptr*: ptr WINDOW
            linesrippedoff*: cint
            linesrippedoffontop*: cint
            delaytenths*: cint
            preserve*: cunsignedchar
            restore*: cint
            save_key_modifiers*: cunsignedchar
            return_key_modifiers*: cunsignedchar
            key_code*: cunsignedchar
            XcurscrSize*: cint
            sb_on*: cunsignedchar
            sb_viewport_y*: cint
            sb_viewport_x*: cint
            sb_total_y*: cint
            sb_total_x*: cint
            sb_cur_y*: cint
            sb_cur_x*: cint
            line_color*: cshort


303 Procedures
**************

   * addch
          proc addch*(a2: cunsignedlong): cint {.extdecl, importc: "addch", dynlib: pdcursesdll.}

   * addchnstr dynlib: pdcursesdll.}
          proc addchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "addchnstr",
              dynlib: pdcursesdll.}

   * addchstr dynlib: pdcursesdll.}
          proc addchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "addchstr",
              dynlib: pdcursesdll.}

   * addnstr dynlib: pdcursesdll.}
          proc addnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "addnstr",
                                                 dynlib: pdcursesdll.}

   * addstr
          proc addstr*(a2: cstring): cint {.extdecl, importc: "addstr", dynlib: pdcursesdll.}

   * attroff dynlib: pdcursesdll.}
          proc attroff*(a2: cunsignedlong): cint {.extdecl, importc: "attroff",
                                               dynlib: pdcursesdll.}

   * attron
          proc attron*(a2: cunsignedlong): cint {.extdecl, importc: "attron", dynlib: pdcursesdll.}

   * attrset dynlib: pdcursesdll.}
          proc attrset*(a2: cunsignedlong): cint {.extdecl, importc: "attrset",
                                               dynlib: pdcursesdll.}

   * attr_get importc: "attr_get", dynlib: pdcursesdll.}
          proc attr_get*(a2: ptr cunsignedlong; a3: ptr cshort; a4: pointer): cint {.extdecl,
              importc: "attr_get", dynlib: pdcursesdll.}

   * attr_off dynlib: pdcursesdll.}
          proc attr_off*(a2: cunsignedlong; a3: pointer): cint {.extdecl, importc: "attr_off",
              dynlib: pdcursesdll.}

   * attr_on dynlib: pdcursesdll.}
          proc attr_on*(a2: cunsignedlong; a3: pointer): cint {.extdecl, importc: "attr_on",
              dynlib: pdcursesdll.}

   * attr_set importc: "attr_set", dynlib: pdcursesdll.}
          proc attr_set*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl,
              importc: "attr_set", dynlib: pdcursesdll.}

   * baudrate
          proc baudrate*(): cint {.extdecl, importc: "baudrate", dynlib: pdcursesdll.}

   * beep
          proc beep*(): cint {.extdecl, importc: "beep", dynlib: pdcursesdll.}

   * bkgd
          proc bkgd*(a2: cunsignedlong): cint {.extdecl, importc: "bkgd", dynlib: pdcursesdll.}

   * bkgdset
          proc bkgdset*(a2: cunsignedlong) {.extdecl, importc: "bkgdset", dynlib: pdcursesdll.}

   * border a5: cunsignedlong; a6: cunsignedlong; a7: cunsignedlong; a8:
     cunsignedlong; a9: cunsignedlong): cint {.extdecl, importc:
     "border", dynlib: pdcursesdll.}
          proc border*(a2: cunsignedlong; a3: cunsignedlong; a4: cunsignedlong;
                      a5: cunsignedlong; a6: cunsignedlong; a7: cunsignedlong;
                      a8: cunsignedlong; a9: cunsignedlong): cint {.extdecl, importc: "border",
              dynlib: pdcursesdll.}

   * box importc: "box", dynlib: pdcursesdll.}
          proc box*(a2: ptr WINDOW; a3: cunsignedlong; a4: cunsignedlong): cint {.extdecl,
              importc: "box", dynlib: pdcursesdll.}

   * can_change_color dynlib: pdcursesdll.}
          proc can_change_color*(): cunsignedchar {.extdecl, importc: "can_change_color",
                                                 dynlib: pdcursesdll.}

   * cbreak
          proc cbreak*(): cint {.extdecl, importc: "cbreak", dynlib: pdcursesdll.}

   * chgat importc: "chgat", dynlib: pdcursesdll.}
          proc chgat*(a2: cint; a3: cunsignedlong; a4: cshort; a5: pointer): cint {.extdecl,
              importc: "chgat", dynlib: pdcursesdll.}

   * clearok dynlib: pdcursesdll.}
          proc clearok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "clearok",
              dynlib: pdcursesdll.}

   * clear
          proc clear*(): cint {.extdecl, importc: "clear", dynlib: pdcursesdll.}

   * clrtobot
          proc clrtobot*(): cint {.extdecl, importc: "clrtobot", dynlib: pdcursesdll.}

   * clrtoeol
          proc clrtoeol*(): cint {.extdecl, importc: "clrtoeol", dynlib: pdcursesdll.}

   * color_content extdecl, importc: "color_content", dynlib:
     pdcursesdll.}
          proc color_content*(a2: cshort; a3: ptr cshort; a4: ptr cshort; a5: ptr cshort): cint {.
              extdecl, importc: "color_content", dynlib: pdcursesdll.}

   * color_set dynlib: pdcursesdll.}
          proc color_set*(a2: cshort; a3: pointer): cint {.extdecl, importc: "color_set",
              dynlib: pdcursesdll.}

   * copywin a9: cint; a10: cint): cint {.extdecl, importc: "copywin",
     dynlib: pdcursesdll.}
          proc copywin*(a2: ptr WINDOW; a3: ptr WINDOW; a4: cint; a5: cint; a6: cint; a7: cint; a8: cint;
                       a9: cint; a10: cint): cint {.extdecl, importc: "copywin",
                                               dynlib: pdcursesdll.}

   * curs_set
          proc curs_set*(a2: cint): cint {.extdecl, importc: "curs_set", dynlib: pdcursesdll.}

   * def_prog_mode
          proc def_prog_mode*(): cint {.extdecl, importc: "def_prog_mode", dynlib: pdcursesdll.}

   * def_shell_mode
          proc def_shell_mode*(): cint {.extdecl, importc: "def_shell_mode", dynlib: pdcursesdll.}

   * delay_output dynlib: pdcursesdll.}
          proc delay_output*(a2: cint): cint {.extdecl, importc: "delay_output",
                                           dynlib: pdcursesdll.}

   * delch
          proc delch*(): cint {.extdecl, importc: "delch", dynlib: pdcursesdll.}

   * deleteln
          proc deleteln*(): cint {.extdecl, importc: "deleteln", dynlib: pdcursesdll.}

   * delscreen
          proc delscreen*(a2: ptr SCREEN) {.extdecl, importc: "delscreen", dynlib: pdcursesdll.}

   * delwin
          proc delwin*(a2: ptr WINDOW): cint {.extdecl, importc: "delwin", dynlib: pdcursesdll.}

   * derwin importc: "derwin", dynlib: pdcursesdll.}
          proc derwin*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr WINDOW {.extdecl,
              importc: "derwin", dynlib: pdcursesdll.}

   * doupdate
          proc doupdate*(): cint {.extdecl, importc: "doupdate", dynlib: pdcursesdll.}

   * dupwin dynlib: pdcursesdll.}
          proc dupwin*(a2: ptr WINDOW): ptr WINDOW {.extdecl, importc: "dupwin",
                                               dynlib: pdcursesdll.}

   * echochar dynlib: pdcursesdll.}
          proc echochar*(a2: cunsignedlong): cint {.extdecl, importc: "echochar",
                                                dynlib: pdcursesdll.}

   * echo
          proc echo*(): cint {.extdecl, importc: "echo", dynlib: pdcursesdll.}

   * endwin
          proc endwin*(): cint {.extdecl, importc: "endwin", dynlib: pdcursesdll.}

   * erasechar
          proc erasechar*(): char {.extdecl, importc: "erasechar", dynlib: pdcursesdll.}

   * erase
          proc erase*(): cint {.extdecl, importc: "erase", dynlib: pdcursesdll.}

   * filter
          proc filter*() {.extdecl, importc: "filter", dynlib: pdcursesdll.}

   * flash
          proc flash*(): cint {.extdecl, importc: "flash", dynlib: pdcursesdll.}

   * flushinp
          proc flushinp*(): cint {.extdecl, importc: "flushinp", dynlib: pdcursesdll.}

   * getbkgd dynlib: pdcursesdll.}
          proc getbkgd*(a2: ptr WINDOW): cunsignedlong {.extdecl, importc: "getbkgd",
              dynlib: pdcursesdll.}

   * getnstr dynlib: pdcursesdll.}
          proc getnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "getnstr",
                                                 dynlib: pdcursesdll.}

   * getstr
          proc getstr*(a2: cstring): cint {.extdecl, importc: "getstr", dynlib: pdcursesdll.}

   * getwin
          proc getwin*(a2: File): ptr WINDOW {.extdecl, importc: "getwin", dynlib: pdcursesdll.}

   * halfdelay
          proc halfdelay*(a2: cint): cint {.extdecl, importc: "halfdelay", dynlib: pdcursesdll.}

   * has_colors dynlib: pdcursesdll.}
          proc has_colors*(): cunsignedchar {.extdecl, importc: "has_colors",
                                           dynlib: pdcursesdll.}

   * has_ic
          proc has_ic*(): cunsignedchar {.extdecl, importc: "has_ic", dynlib: pdcursesdll.}

   * has_il
          proc has_il*(): cunsignedchar {.extdecl, importc: "has_il", dynlib: pdcursesdll.}

   * hline dynlib: pdcursesdll.}
          proc hline*(a2: cunsignedlong; a3: cint): cint {.extdecl, importc: "hline",
              dynlib: pdcursesdll.}

   * idcok dynlib: pdcursesdll.}
          proc idcok*(a2: ptr WINDOW; a3: cunsignedchar) {.extdecl, importc: "idcok",
              dynlib: pdcursesdll.}

   * idlok dynlib: pdcursesdll.}
          proc idlok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "idlok",
              dynlib: pdcursesdll.}

   * immedok dynlib: pdcursesdll.}
          proc immedok*(a2: ptr WINDOW; a3: cunsignedchar) {.extdecl, importc: "immedok",
              dynlib: pdcursesdll.}

   * inchnstr dynlib: pdcursesdll.}
          proc inchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "inchnstr",
              dynlib: pdcursesdll.}

   * inchstr dynlib: pdcursesdll.}
          proc inchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "inchstr",
                                                  dynlib: pdcursesdll.}

   * inch
          proc inch*(): cunsignedlong {.extdecl, importc: "inch", dynlib: pdcursesdll.}

   * init_color importc: "init_color", dynlib: pdcursesdll.}
          proc init_color*(a2: cshort; a3: cshort; a4: cshort; a5: cshort): cint {.extdecl,
              importc: "init_color", dynlib: pdcursesdll.}

   * init_pair importc: "init_pair", dynlib: pdcursesdll.}
          proc init_pair*(a2: cshort; a3: cshort; a4: cshort): cint {.extdecl,
              importc: "init_pair", dynlib: pdcursesdll.}

   * initscr
          proc initscr*(): ptr WINDOW {.extdecl, importc: "initscr", dynlib: pdcursesdll.}

   * innstr dynlib: pdcursesdll.}
          proc innstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "innstr",
                                                dynlib: pdcursesdll.}

   * insch
          proc insch*(a2: cunsignedlong): cint {.extdecl, importc: "insch", dynlib: pdcursesdll.}

   * insdelln
          proc insdelln*(a2: cint): cint {.extdecl, importc: "insdelln", dynlib: pdcursesdll.}

   * insertln
          proc insertln*(): cint {.extdecl, importc: "insertln", dynlib: pdcursesdll.}

   * insnstr dynlib: pdcursesdll.}
          proc insnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "insnstr",
                                                 dynlib: pdcursesdll.}

   * insstr
          proc insstr*(a2: cstring): cint {.extdecl, importc: "insstr", dynlib: pdcursesdll.}

   * instr
          proc instr*(a2: cstring): cint {.extdecl, importc: "instr", dynlib: pdcursesdll.}

   * intrflush importc: "intrflush", dynlib: pdcursesdll.}
          proc intrflush*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl,
              importc: "intrflush", dynlib: pdcursesdll.}

   * isendwin
          proc isendwin*(): cunsignedchar {.extdecl, importc: "isendwin", dynlib: pdcursesdll.}

   * is_linetouched importc: "is_linetouched", dynlib: pdcursesdll.}
          proc is_linetouched*(a2: ptr WINDOW; a3: cint): cunsignedchar {.extdecl,
              importc: "is_linetouched", dynlib: pdcursesdll.}

   * is_wintouched importc: "is_wintouched", dynlib: pdcursesdll.}
          proc is_wintouched*(a2: ptr WINDOW): cunsignedchar {.extdecl,
              importc: "is_wintouched", dynlib: pdcursesdll.}

   * keyname
          proc keyname*(a2: cint): cstring {.extdecl, importc: "keyname", dynlib: pdcursesdll.}

   * keypad dynlib: pdcursesdll.}
          proc keypad*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "keypad",
              dynlib: pdcursesdll.}

   * killchar
          proc killchar*(): char {.extdecl, importc: "killchar", dynlib: pdcursesdll.}

   * leaveok dynlib: pdcursesdll.}
          proc leaveok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "leaveok",
              dynlib: pdcursesdll.}

   * longname
          proc longname*(): cstring {.extdecl, importc: "longname", dynlib: pdcursesdll.}

   * meta dynlib: pdcursesdll.}
          proc meta*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "meta",
              dynlib: pdcursesdll.}

   * move
          proc move*(a2: cint; a3: cint): cint {.extdecl, importc: "move", dynlib: pdcursesdll.}

   * mvaddch dynlib: pdcursesdll.}
          proc mvaddch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, importc: "mvaddch",
              dynlib: pdcursesdll.}

   * mvaddchnstr importc: "mvaddchnstr", dynlib: pdcursesdll.}
          proc mvaddchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvaddchnstr", dynlib: pdcursesdll.}

   * mvaddchstr importc: "mvaddchstr", dynlib: pdcursesdll.}
          proc mvaddchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,
              importc: "mvaddchstr", dynlib: pdcursesdll.}

   * mvaddnstr importc: "mvaddnstr", dynlib: pdcursesdll.}
          proc mvaddnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,
              importc: "mvaddnstr", dynlib: pdcursesdll.}

   * mvaddstr dynlib: pdcursesdll.}
          proc mvaddstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvaddstr",
              dynlib: pdcursesdll.}

   * mvchgat extdecl, importc: "mvchgat", dynlib: pdcursesdll.}
          proc mvchgat*(a2: cint; a3: cint; a4: cint; a5: cunsignedlong; a6: cshort; a7: pointer): cint {.
              extdecl, importc: "mvchgat", dynlib: pdcursesdll.}

   * mvcur dynlib: pdcursesdll.}
          proc mvcur*(a2: cint; a3: cint; a4: cint; a5: cint): cint {.extdecl, importc: "mvcur",
              dynlib: pdcursesdll.}

   * mvdelch dynlib: pdcursesdll.}
          proc mvdelch*(a2: cint; a3: cint): cint {.extdecl, importc: "mvdelch",
                                              dynlib: pdcursesdll.}

   * mvderwin dynlib: pdcursesdll.}
          proc mvderwin*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvderwin",
              dynlib: pdcursesdll.}

   * mvgetch dynlib: pdcursesdll.}
          proc mvgetch*(a2: cint; a3: cint): cint {.extdecl, importc: "mvgetch",
                                              dynlib: pdcursesdll.}

   * mvgetnstr importc: "mvgetnstr", dynlib: pdcursesdll.}
          proc mvgetnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,
              importc: "mvgetnstr", dynlib: pdcursesdll.}

   * mvgetstr dynlib: pdcursesdll.}
          proc mvgetstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvgetstr",
              dynlib: pdcursesdll.}

   * mvhline importc: "mvhline", dynlib: pdcursesdll.}
          proc mvhline*(a2: cint; a3: cint; a4: cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvhline", dynlib: pdcursesdll.}

   * mvinch dynlib: pdcursesdll.}
          proc mvinch*(a2: cint; a3: cint): cunsignedlong {.extdecl, importc: "mvinch",
              dynlib: pdcursesdll.}

   * mvinchnstr importc: "mvinchnstr", dynlib: pdcursesdll.}
          proc mvinchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvinchnstr", dynlib: pdcursesdll.}

   * mvinchstr importc: "mvinchstr", dynlib: pdcursesdll.}
          proc mvinchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,
              importc: "mvinchstr", dynlib: pdcursesdll.}

   * mvinnstr importc: "mvinnstr", dynlib: pdcursesdll.}
          proc mvinnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,
              importc: "mvinnstr", dynlib: pdcursesdll.}

   * mvinsch dynlib: pdcursesdll.}
          proc mvinsch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, importc: "mvinsch",
              dynlib: pdcursesdll.}

   * mvinsnstr importc: "mvinsnstr", dynlib: pdcursesdll.}
          proc mvinsnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,
              importc: "mvinsnstr", dynlib: pdcursesdll.}

   * mvinsstr dynlib: pdcursesdll.}
          proc mvinsstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvinsstr",
              dynlib: pdcursesdll.}

   * mvinstr dynlib: pdcursesdll.}
          proc mvinstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvinstr",
              dynlib: pdcursesdll.}

   * mvprintw importc: "mvprintw", dynlib: pdcursesdll.}
          proc mvprintw*(a2: cint; a3: cint; a4: cstring): cint {.varargs, extdecl,
              importc: "mvprintw", dynlib: pdcursesdll.}

   * mvscanw importc: "mvscanw", dynlib: pdcursesdll.}
          proc mvscanw*(a2: cint; a3: cint; a4: cstring): cint {.varargs, extdecl,
              importc: "mvscanw", dynlib: pdcursesdll.}

   * mvvline importc: "mvvline", dynlib: pdcursesdll.}
          proc mvvline*(a2: cint; a3: cint; a4: cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvvline", dynlib: pdcursesdll.}

   * mvwaddchnstr extdecl, importc: "mvwaddchnstr", dynlib:
     pdcursesdll.}
          proc mvwaddchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwaddchnstr", dynlib: pdcursesdll.}

   * mvwaddchstr extdecl, importc: "mvwaddchstr", dynlib: pdcursesdll.}
          proc mvwaddchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.
              extdecl, importc: "mvwaddchstr", dynlib: pdcursesdll.}

   * mvwaddch importc: "mvwaddch", dynlib: pdcursesdll.}
          proc mvwaddch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,
              importc: "mvwaddch", dynlib: pdcursesdll.}

   * mvwaddnstr importc: "mvwaddnstr", dynlib: pdcursesdll.}
          proc mvwaddnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,
              importc: "mvwaddnstr", dynlib: pdcursesdll.}

   * mvwaddstr importc: "mvwaddstr", dynlib: pdcursesdll.}
          proc mvwaddstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,
              importc: "mvwaddstr", dynlib: pdcursesdll.}

   * mvwchgat a8: pointer): cint {.extdecl, importc: "mvwchgat", dynlib:
     pdcursesdll.}
          proc mvwchgat*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cunsignedlong; a7: cshort;
                        a8: pointer): cint {.extdecl, importc: "mvwchgat", dynlib: pdcursesdll.}

   * mvwdelch dynlib: pdcursesdll.}
          proc mvwdelch*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvwdelch",
              dynlib: pdcursesdll.}

   * mvwgetch dynlib: pdcursesdll.}
          proc mvwgetch*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvwgetch",
              dynlib: pdcursesdll.}

   * mvwgetnstr importc: "mvwgetnstr", dynlib: pdcursesdll.}
          proc mvwgetnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,
              importc: "mvwgetnstr", dynlib: pdcursesdll.}

   * mvwgetstr importc: "mvwgetstr", dynlib: pdcursesdll.}
          proc mvwgetstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,
              importc: "mvwgetstr", dynlib: pdcursesdll.}

   * mvwhline extdecl, importc: "mvwhline", dynlib: pdcursesdll.}
          proc mvwhline*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwhline", dynlib: pdcursesdll.}

   * mvwinchnstr extdecl, importc: "mvwinchnstr", dynlib: pdcursesdll.}
          proc mvwinchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwinchnstr", dynlib: pdcursesdll.}

   * mvwinchstr importc: "mvwinchstr", dynlib: pdcursesdll.}
          proc mvwinchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,
              importc: "mvwinchstr", dynlib: pdcursesdll.}

   * mvwinch importc: "mvwinch", dynlib: pdcursesdll.}
          proc mvwinch*(a2: ptr WINDOW; a3: cint; a4: cint): cunsignedlong {.extdecl,
              importc: "mvwinch", dynlib: pdcursesdll.}

   * mvwinnstr importc: "mvwinnstr", dynlib: pdcursesdll.}
          proc mvwinnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,
              importc: "mvwinnstr", dynlib: pdcursesdll.}

   * mvwinsch importc: "mvwinsch", dynlib: pdcursesdll.}
          proc mvwinsch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,
              importc: "mvwinsch", dynlib: pdcursesdll.}

   * mvwinsnstr importc: "mvwinsnstr", dynlib: pdcursesdll.}
          proc mvwinsnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,
              importc: "mvwinsnstr", dynlib: pdcursesdll.}

   * mvwinsstr importc: "mvwinsstr", dynlib: pdcursesdll.}
          proc mvwinsstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,
              importc: "mvwinsstr", dynlib: pdcursesdll.}

   * mvwinstr importc: "mvwinstr", dynlib: pdcursesdll.}
          proc mvwinstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,
              importc: "mvwinstr", dynlib: pdcursesdll.}

   * mvwin dynlib: pdcursesdll.}
          proc mvwin*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvwin",
              dynlib: pdcursesdll.}

   * mvwprintw importc: "mvwprintw", dynlib: pdcursesdll.}
          proc mvwprintw*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.varargs, extdecl,
              importc: "mvwprintw", dynlib: pdcursesdll.}

   * mvwscanw importc: "mvwscanw", dynlib: pdcursesdll.}
          proc mvwscanw*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.varargs, extdecl,
              importc: "mvwscanw", dynlib: pdcursesdll.}

   * mvwvline extdecl, importc: "mvwvline", dynlib: pdcursesdll.}
          proc mvwvline*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwvline", dynlib: pdcursesdll.}

   * napms
          proc napms*(a2: cint): cint {.extdecl, importc: "napms", dynlib: pdcursesdll.}

   * newpad dynlib: pdcursesdll.}
          proc newpad*(a2: cint; a3: cint): ptr WINDOW {.extdecl, importc: "newpad",
                                                  dynlib: pdcursesdll.}

   * newterm dynlib: pdcursesdll.}
          proc newterm*(a2: cstring; a3: File; a4: File): ptr SCREEN {.extdecl, importc: "newterm",
              dynlib: pdcursesdll.}

   * newwin importc: "newwin", dynlib: pdcursesdll.}
          proc newwin*(a2: cint; a3: cint; a4: cint; a5: cint): ptr WINDOW {.extdecl,
              importc: "newwin", dynlib: pdcursesdll.}

   * nl
          proc nl*(): cint {.extdecl, importc: "nl", dynlib: pdcursesdll.}

   * nocbreak
          proc nocbreak*(): cint {.extdecl, importc: "nocbreak", dynlib: pdcursesdll.}

   * nodelay dynlib: pdcursesdll.}
          proc nodelay*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "nodelay",
              dynlib: pdcursesdll.}

   * noecho
          proc noecho*(): cint {.extdecl, importc: "noecho", dynlib: pdcursesdll.}

   * nonl
          proc nonl*(): cint {.extdecl, importc: "nonl", dynlib: pdcursesdll.}

   * noqiflush
          proc noqiflush*() {.extdecl, importc: "noqiflush", dynlib: pdcursesdll.}

   * noraw
          proc noraw*(): cint {.extdecl, importc: "noraw", dynlib: pdcursesdll.}

   * notimeout importc: "notimeout", dynlib: pdcursesdll.}
          proc notimeout*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl,
              importc: "notimeout", dynlib: pdcursesdll.}

   * overlay dynlib: pdcursesdll.}
          proc overlay*(a2: ptr WINDOW; a3: ptr WINDOW): cint {.extdecl, importc: "overlay",
              dynlib: pdcursesdll.}

   * overwrite dynlib: pdcursesdll.}
          proc overwrite*(a2: ptr WINDOW; a3: ptr WINDOW): cint {.extdecl, importc: "overwrite",
              dynlib: pdcursesdll.}

   * pair_content importc: "pair_content", dynlib: pdcursesdll.}
          proc pair_content*(a2: cshort; a3: ptr cshort; a4: ptr cshort): cint {.extdecl,
              importc: "pair_content", dynlib: pdcursesdll.}

   * pechochar importc: "pechochar", dynlib: pdcursesdll.}
          proc pechochar*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,
              importc: "pechochar", dynlib: pdcursesdll.}

   * pnoutrefresh extdecl, importc: "pnoutrefresh", dynlib:
     pdcursesdll.}
          proc pnoutrefresh*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint; a7: cint; a8: cint): cint {.
              extdecl, importc: "pnoutrefresh", dynlib: pdcursesdll.}

   * prefresh extdecl, importc: "prefresh", dynlib: pdcursesdll.}
          proc prefresh*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint; a7: cint; a8: cint): cint {.
              extdecl, importc: "prefresh", dynlib: pdcursesdll.}

   * printw dynlib: pdcursesdll.}
          proc printw*(a2: cstring): cint {.varargs, extdecl, importc: "printw",
                                        dynlib: pdcursesdll.}

   * putwin dynlib: pdcursesdll.}
          proc putwin*(a2: ptr WINDOW; a3: File): cint {.extdecl, importc: "putwin",
                                                  dynlib: pdcursesdll.}

   * qiflush
          proc qiflush*() {.extdecl, importc: "qiflush", dynlib: pdcursesdll.}

   * raw
          proc raw*(): cint {.extdecl, importc: "raw", dynlib: pdcursesdll.}

   * redrawwin dynlib: pdcursesdll.}
          proc redrawwin*(a2: ptr WINDOW): cint {.extdecl, importc: "redrawwin",
                                             dynlib: pdcursesdll.}

   * refresh
          proc refresh*(): cint {.extdecl, importc: "refresh", dynlib: pdcursesdll.}

   * reset_prog_mode dynlib: pdcursesdll.}
          proc reset_prog_mode*(): cint {.extdecl, importc: "reset_prog_mode",
                                       dynlib: pdcursesdll.}

   * reset_shell_mode dynlib: pdcursesdll.}
          proc reset_shell_mode*(): cint {.extdecl, importc: "reset_shell_mode",
                                        dynlib: pdcursesdll.}

   * resetty
          proc resetty*(): cint {.extdecl, importc: "resetty", dynlib: pdcursesdll.}

   * savetty
          proc savetty*(): cint {.extdecl, importc: "savetty", dynlib: pdcursesdll.}

   * scanw
          proc scanw*(a2: cstring): cint {.varargs, extdecl, importc: "scanw", dynlib: pdcursesdll.}

   * scr_dump
          proc scr_dump*(a2: cstring): cint {.extdecl, importc: "scr_dump", dynlib: pdcursesdll.}

   * scr_init
          proc scr_init*(a2: cstring): cint {.extdecl, importc: "scr_init", dynlib: pdcursesdll.}

   * scr_restore dynlib: pdcursesdll.}
          proc scr_restore*(a2: cstring): cint {.extdecl, importc: "scr_restore",
                                             dynlib: pdcursesdll.}

   * scr_set
          proc scr_set*(a2: cstring): cint {.extdecl, importc: "scr_set", dynlib: pdcursesdll.}

   * scrl
          proc scrl*(a2: cint): cint {.extdecl, importc: "scrl", dynlib: pdcursesdll.}

   * scroll
          proc scroll*(a2: ptr WINDOW): cint {.extdecl, importc: "scroll", dynlib: pdcursesdll.}

   * scrollok dynlib: pdcursesdll.}
          proc scrollok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "scrollok",
              dynlib: pdcursesdll.}

   * set_term dynlib: pdcursesdll.}
          proc set_term*(a2: ptr SCREEN): ptr SCREEN {.extdecl, importc: "set_term",
                                                 dynlib: pdcursesdll.}

   * setscrreg dynlib: pdcursesdll.}
          proc setscrreg*(a2: cint; a3: cint): cint {.extdecl, importc: "setscrreg",
                                                dynlib: pdcursesdll.}

   * slk_attroff dynlib: pdcursesdll.}
          proc slk_attroff*(a2: cunsignedlong): cint {.extdecl, importc: "slk_attroff",
              dynlib: pdcursesdll.}

   * slk_attr_off importc: "slk_attr_off", dynlib: pdcursesdll.}
          proc slk_attr_off*(a2: cunsignedlong; a3: pointer): cint {.extdecl,
              importc: "slk_attr_off", dynlib: pdcursesdll.}

   * slk_attron dynlib: pdcursesdll.}
          proc slk_attron*(a2: cunsignedlong): cint {.extdecl, importc: "slk_attron",
                                                  dynlib: pdcursesdll.}

   * slk_attr_on importc: "slk_attr_on", dynlib: pdcursesdll.}
          proc slk_attr_on*(a2: cunsignedlong; a3: pointer): cint {.extdecl,
              importc: "slk_attr_on", dynlib: pdcursesdll.}

   * slk_attrset dynlib: pdcursesdll.}
          proc slk_attrset*(a2: cunsignedlong): cint {.extdecl, importc: "slk_attrset",
              dynlib: pdcursesdll.}

   * slk_attr_set importc: "slk_attr_set", dynlib: pdcursesdll.}
          proc slk_attr_set*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl,
              importc: "slk_attr_set", dynlib: pdcursesdll.}

   * slk_clear
          proc slk_clear*(): cint {.extdecl, importc: "slk_clear", dynlib: pdcursesdll.}

   * slk_color
          proc slk_color*(a2: cshort): cint {.extdecl, importc: "slk_color", dynlib: pdcursesdll.}

   * slk_init
          proc slk_init*(a2: cint): cint {.extdecl, importc: "slk_init", dynlib: pdcursesdll.}

   * slk_label
          proc slk_label*(a2: cint): cstring {.extdecl, importc: "slk_label", dynlib: pdcursesdll.}

   * slk_noutrefresh dynlib: pdcursesdll.}
          proc slk_noutrefresh*(): cint {.extdecl, importc: "slk_noutrefresh",
                                       dynlib: pdcursesdll.}

   * slk_refresh
          proc slk_refresh*(): cint {.extdecl, importc: "slk_refresh", dynlib: pdcursesdll.}

   * slk_restore
          proc slk_restore*(): cint {.extdecl, importc: "slk_restore", dynlib: pdcursesdll.}

   * slk_set dynlib: pdcursesdll.}
          proc slk_set*(a2: cint; a3: cstring; a4: cint): cint {.extdecl, importc: "slk_set",
              dynlib: pdcursesdll.}

   * slk_touch
          proc slk_touch*(): cint {.extdecl, importc: "slk_touch", dynlib: pdcursesdll.}

   * standend
          proc standend*(): cint {.extdecl, importc: "standend", dynlib: pdcursesdll.}

   * standout
          proc standout*(): cint {.extdecl, importc: "standout", dynlib: pdcursesdll.}

   * start_color
          proc start_color*(): cint {.extdecl, importc: "start_color", dynlib: pdcursesdll.}

   * subpad importc: "subpad", dynlib: pdcursesdll.}
          proc subpad*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr WINDOW {.extdecl,
              importc: "subpad", dynlib: pdcursesdll.}

   * subwin importc: "subwin", dynlib: pdcursesdll.}
          proc subwin*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr WINDOW {.extdecl,
              importc: "subwin", dynlib: pdcursesdll.}

   * syncok dynlib: pdcursesdll.}
          proc syncok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "syncok",
              dynlib: pdcursesdll.}

   * termattrs
          proc termattrs*(): cunsignedlong {.extdecl, importc: "termattrs", dynlib: pdcursesdll.}

   * termattrs2 dynlib: pdcursesdll.}
          proc termattrs2*(): cunsignedlong {.extdecl, importc: "term_attrs",
                                           dynlib: pdcursesdll.}

   * termname
          proc termname*(): cstring {.extdecl, importc: "termname", dynlib: pdcursesdll.}

   * timeout
          proc timeout*(a2: cint) {.extdecl, importc: "timeout", dynlib: pdcursesdll.}

   * touchline dynlib: pdcursesdll.}
          proc touchline*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "touchline",
              dynlib: pdcursesdll.}

   * touchwin
          proc touchwin*(a2: ptr WINDOW): cint {.extdecl, importc: "touchwin", dynlib: pdcursesdll.}

   * typeahead
          proc typeahead*(a2: cint): cint {.extdecl, importc: "typeahead", dynlib: pdcursesdll.}

   * untouchwin dynlib: pdcursesdll.}
          proc untouchwin*(a2: ptr WINDOW): cint {.extdecl, importc: "untouchwin",
                                              dynlib: pdcursesdll.}

   * use_env
          proc use_env*(a2: cunsignedchar) {.extdecl, importc: "use_env", dynlib: pdcursesdll.}

   * vidattr dynlib: pdcursesdll.}
          proc vidattr*(a2: cunsignedlong): cint {.extdecl, importc: "vidattr",
                                               dynlib: pdcursesdll.}

   * vid_attr importc: "vid_attr", dynlib: pdcursesdll.}
          proc vid_attr*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl,
              importc: "vid_attr", dynlib: pdcursesdll.}

   * vline dynlib: pdcursesdll.}
          proc vline*(a2: cunsignedlong; a3: cint): cint {.extdecl, importc: "vline",
              dynlib: pdcursesdll.}

   * vwprintw importc: "vw_printw", dynlib: pdcursesdll.}
          proc vwprintw*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs,
              importc: "vw_printw", dynlib: pdcursesdll.}

   * vwprintw2 importc: "vwprintw", dynlib: pdcursesdll.}
          proc vwprintw2*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs,
              importc: "vwprintw", dynlib: pdcursesdll.}

   * vwscanw dynlib: pdcursesdll.}
          proc vwscanw*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs, importc: "vw_scanw",
              dynlib: pdcursesdll.}

   * vwscanw2 dynlib: pdcursesdll.}
          proc vwscanw2*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs, importc: "vwscanw",
              dynlib: pdcursesdll.}

   * waddchnstr importc: "waddchnstr", dynlib: pdcursesdll.}
          proc waddchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,
              importc: "waddchnstr", dynlib: pdcursesdll.}

   * waddchstr importc: "waddchstr", dynlib: pdcursesdll.}
          proc waddchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "waddchstr", dynlib: pdcursesdll.}

   * waddch dynlib: pdcursesdll.}
          proc waddch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "waddch",
              dynlib: pdcursesdll.}

   * waddnstr importc: "waddnstr", dynlib: pdcursesdll.}
          proc waddnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,
              importc: "waddnstr", dynlib: pdcursesdll.}

   * waddstr dynlib: pdcursesdll.}
          proc waddstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "waddstr",
              dynlib: pdcursesdll.}

   * wattroff dynlib: pdcursesdll.}
          proc wattroff*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wattroff",
              dynlib: pdcursesdll.}

   * wattron dynlib: pdcursesdll.}
          proc wattron*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wattron",
              dynlib: pdcursesdll.}

   * wattrset dynlib: pdcursesdll.}
          proc wattrset*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wattrset",
              dynlib: pdcursesdll.}

   * wattr_get extdecl, importc: "wattr_get", dynlib: pdcursesdll.}
          proc wattr_get*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cshort; a5: pointer): cint {.
              extdecl, importc: "wattr_get", dynlib: pdcursesdll.}

   * wattr_off importc: "wattr_off", dynlib: pdcursesdll.}
          proc wattr_off*(a2: ptr WINDOW; a3: cunsignedlong; a4: pointer): cint {.extdecl,
              importc: "wattr_off", dynlib: pdcursesdll.}

   * wattr_on importc: "wattr_on", dynlib: pdcursesdll.}
          proc wattr_on*(a2: ptr WINDOW; a3: cunsignedlong; a4: pointer): cint {.extdecl,
              importc: "wattr_on", dynlib: pdcursesdll.}

   * wattr_set extdecl, importc: "wattr_set", dynlib: pdcursesdll.}
          proc wattr_set*(a2: ptr WINDOW; a3: cunsignedlong; a4: cshort; a5: pointer): cint {.
              extdecl, importc: "wattr_set", dynlib: pdcursesdll.}

   * wbkgdset dynlib: pdcursesdll.}
          proc wbkgdset*(a2: ptr WINDOW; a3: cunsignedlong) {.extdecl, importc: "wbkgdset",
              dynlib: pdcursesdll.}

   * wbkgd dynlib: pdcursesdll.}
          proc wbkgd*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wbkgd",
              dynlib: pdcursesdll.}

   * wborder a6: cunsignedlong; a7: cunsignedlong; a8: cunsignedlong;
     a9: cunsignedlong; a10: cunsignedlong): cint {.extdecl, importc:
     "wborder", dynlib: pdcursesdll.}
          proc wborder*(a2: ptr WINDOW; a3: cunsignedlong; a4: cunsignedlong; a5: cunsignedlong;
                       a6: cunsignedlong; a7: cunsignedlong; a8: cunsignedlong;
                       a9: cunsignedlong; a10: cunsignedlong): cint {.extdecl,
              importc: "wborder", dynlib: pdcursesdll.}

   * wchgat extdecl, importc: "wchgat", dynlib: pdcursesdll.}
          proc wchgat*(a2: ptr WINDOW; a3: cint; a4: cunsignedlong; a5: cshort; a6: pointer): cint {.
              extdecl, importc: "wchgat", dynlib: pdcursesdll.}

   * wclear
          proc wclear*(a2: ptr WINDOW): cint {.extdecl, importc: "wclear", dynlib: pdcursesdll.}

   * wclrtobot dynlib: pdcursesdll.}
          proc wclrtobot*(a2: ptr WINDOW): cint {.extdecl, importc: "wclrtobot",
                                             dynlib: pdcursesdll.}

   * wclrtoeol dynlib: pdcursesdll.}
          proc wclrtoeol*(a2: ptr WINDOW): cint {.extdecl, importc: "wclrtoeol",
                                             dynlib: pdcursesdll.}

   * wcolor_set importc: "wcolor_set", dynlib: pdcursesdll.}
          proc wcolor_set*(a2: ptr WINDOW; a3: cshort; a4: pointer): cint {.extdecl,
              importc: "wcolor_set", dynlib: pdcursesdll.}

   * wcursyncup
          proc wcursyncup*(a2: ptr WINDOW) {.extdecl, importc: "wcursyncup", dynlib: pdcursesdll.}

   * wdelch
          proc wdelch*(a2: ptr WINDOW): cint {.extdecl, importc: "wdelch", dynlib: pdcursesdll.}

   * wdeleteln dynlib: pdcursesdll.}
          proc wdeleteln*(a2: ptr WINDOW): cint {.extdecl, importc: "wdeleteln",
                                             dynlib: pdcursesdll.}

   * wechochar importc: "wechochar", dynlib: pdcursesdll.}
          proc wechochar*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,
              importc: "wechochar", dynlib: pdcursesdll.}

   * werase
          proc werase*(a2: ptr WINDOW): cint {.extdecl, importc: "werase", dynlib: pdcursesdll.}

   * wgetch
          proc wgetch*(a2: ptr WINDOW): cint {.extdecl, importc: "wgetch", dynlib: pdcursesdll.}

   * wgetnstr importc: "wgetnstr", dynlib: pdcursesdll.}
          proc wgetnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,
              importc: "wgetnstr", dynlib: pdcursesdll.}

   * wgetstr dynlib: pdcursesdll.}
          proc wgetstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "wgetstr",
              dynlib: pdcursesdll.}

   * whline importc: "whline", dynlib: pdcursesdll.}
          proc whline*(a2: ptr WINDOW; a3: cunsignedlong; a4: cint): cint {.extdecl,
              importc: "whline", dynlib: pdcursesdll.}

   * winchnstr importc: "winchnstr", dynlib: pdcursesdll.}
          proc winchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,
              importc: "winchnstr", dynlib: pdcursesdll.}

   * winchstr importc: "winchstr", dynlib: pdcursesdll.}
          proc winchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "winchstr", dynlib: pdcursesdll.}

   * winch dynlib: pdcursesdll.}
          proc winch*(a2: ptr WINDOW): cunsignedlong {.extdecl, importc: "winch",
                                                  dynlib: pdcursesdll.}

   * winnstr dynlib: pdcursesdll.}
          proc winnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl, importc: "winnstr",
              dynlib: pdcursesdll.}

   * winsch dynlib: pdcursesdll.}
          proc winsch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "winsch",
              dynlib: pdcursesdll.}

   * winsdelln dynlib: pdcursesdll.}
          proc winsdelln*(a2: ptr WINDOW; a3: cint): cint {.extdecl, importc: "winsdelln",
              dynlib: pdcursesdll.}

   * winsertln dynlib: pdcursesdll.}
          proc winsertln*(a2: ptr WINDOW): cint {.extdecl, importc: "winsertln",
                                             dynlib: pdcursesdll.}

   * winsnstr importc: "winsnstr", dynlib: pdcursesdll.}
          proc winsnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,
              importc: "winsnstr", dynlib: pdcursesdll.}

   * winsstr dynlib: pdcursesdll.}
          proc winsstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "winsstr",
              dynlib: pdcursesdll.}

   * winstr dynlib: pdcursesdll.}
          proc winstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "winstr",
              dynlib: pdcursesdll.}

   * wmove dynlib: pdcursesdll.}
          proc wmove*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "wmove",
              dynlib: pdcursesdll.}

   * wnoutrefresh dynlib: pdcursesdll.}
          proc wnoutrefresh*(a2: ptr WINDOW): cint {.extdecl, importc: "wnoutrefresh",
                                                dynlib: pdcursesdll.}

   * wprintw dynlib: pdcursesdll.}
          proc wprintw*(a2: ptr WINDOW; a3: cstring): cint {.varargs, extdecl, importc: "wprintw",
              dynlib: pdcursesdll.}

   * wredrawln dynlib: pdcursesdll.}
          proc wredrawln*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "wredrawln",
              dynlib: pdcursesdll.}

   * wrefresh
          proc wrefresh*(a2: ptr WINDOW): cint {.extdecl, importc: "wrefresh", dynlib: pdcursesdll.}

   * wscanw dynlib: pdcursesdll.}
          proc wscanw*(a2: ptr WINDOW; a3: cstring): cint {.varargs, extdecl, importc: "wscanw",
              dynlib: pdcursesdll.}

   * wscrl dynlib: pdcursesdll.}
          proc wscrl*(a2: ptr WINDOW; a3: cint): cint {.extdecl, importc: "wscrl",
                                                 dynlib: pdcursesdll.}

   * wsetscrreg importc: "wsetscrreg", dynlib: pdcursesdll.}
          proc wsetscrreg*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl,
              importc: "wsetscrreg", dynlib: pdcursesdll.}

   * wstandend dynlib: pdcursesdll.}
          proc wstandend*(a2: ptr WINDOW): cint {.extdecl, importc: "wstandend",
                                             dynlib: pdcursesdll.}

   * wstandout dynlib: pdcursesdll.}
          proc wstandout*(a2: ptr WINDOW): cint {.extdecl, importc: "wstandout",
                                             dynlib: pdcursesdll.}

   * wsyncdown
          proc wsyncdown*(a2: ptr WINDOW) {.extdecl, importc: "wsyncdown", dynlib: pdcursesdll.}

   * wsyncup
          proc wsyncup*(a2: ptr WINDOW) {.extdecl, importc: "wsyncup", dynlib: pdcursesdll.}

   * wtimeout dynlib: pdcursesdll.}
          proc wtimeout*(a2: ptr WINDOW; a3: cint) {.extdecl, importc: "wtimeout",
                                               dynlib: pdcursesdll.}

   * wtouchln importc: "wtouchln", dynlib: pdcursesdll.}
          proc wtouchln*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint): cint {.extdecl,
              importc: "wtouchln", dynlib: pdcursesdll.}

   * wvline importc: "wvline", dynlib: pdcursesdll.}
          proc wvline*(a2: ptr WINDOW; a3: cunsignedlong; a4: cint): cint {.extdecl,
              importc: "wvline", dynlib: pdcursesdll.}

   * addnwstr dynlib: pdcursesdll.}
          proc addnwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "addnwstr",
                                                  dynlib: pdcursesdll.}

   * addwstr
          proc addwstr*(a2: cstring): cint {.extdecl, importc: "addwstr", dynlib: pdcursesdll.}

   * add_wch dynlib: pdcursesdll.}
          proc add_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: "add_wch",
                                                  dynlib: pdcursesdll.}

   * add_wchnstr importc: "add_wchnstr", dynlib: pdcursesdll.}
          proc add_wchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl,
              importc: "add_wchnstr", dynlib: pdcursesdll.}

   * add_wchstr dynlib: pdcursesdll.}
          proc add_wchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "add_wchstr",
              dynlib: pdcursesdll.}

   * border_set a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr
     cunsignedlong; a8: ptr cunsignedlong; a9: ptr cunsignedlong): cint
     {.extdecl, importc: "border_set", dynlib: pdcursesdll.}
          proc border_set*(a2: ptr cunsignedlong; a3: ptr cunsignedlong; a4: ptr cunsignedlong;
                          a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr cunsignedlong;
                          a8: ptr cunsignedlong; a9: ptr cunsignedlong): cint {.extdecl,
              importc: "border_set", dynlib: pdcursesdll.}

   * box_set extdecl, importc: "box_set", dynlib: pdcursesdll.}
          proc box_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong): cint {.
              extdecl, importc: "box_set", dynlib: pdcursesdll.}

   * echo_wchar dynlib: pdcursesdll.}
          proc echo_wchar*(a2: ptr cunsignedlong): cint {.extdecl, importc: "echo_wchar",
              dynlib: pdcursesdll.}

   * erasewchar dynlib: pdcursesdll.}
          proc erasewchar*(a2: cstring): cint {.extdecl, importc: "erasewchar",
                                            dynlib: pdcursesdll.}

   * getbkgrnd dynlib: pdcursesdll.}
          proc getbkgrnd*(a2: ptr cunsignedlong): cint {.extdecl, importc: "getbkgrnd",
              dynlib: pdcursesdll.}

   * getcchar a6: pointer): cint {.extdecl, importc: "getcchar", dynlib:
     pdcursesdll.}
          proc getcchar*(a2: ptr cunsignedlong; a3: cstring; a4: ptr cunsignedlong; a5: ptr cshort;
                        a6: pointer): cint {.extdecl, importc: "getcchar", dynlib: pdcursesdll.}

   * getn_wstr dynlib: pdcursesdll.}
          proc getn_wstr*(a2: ptr cint; a3: cint): cint {.extdecl, importc: "getn_wstr",
              dynlib: pdcursesdll.}

   * get_wch
          proc get_wch*(a2: ptr cint): cint {.extdecl, importc: "get_wch", dynlib: pdcursesdll.}

   * get_wstr
          proc get_wstr*(a2: ptr cint): cint {.extdecl, importc: "get_wstr", dynlib: pdcursesdll.}

   * hline_set dynlib: pdcursesdll.}
          proc hline_set*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "hline_set",
              dynlib: pdcursesdll.}

   * innwstr dynlib: pdcursesdll.}
          proc innwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "innwstr",
                                                 dynlib: pdcursesdll.}

   * ins_nwstr dynlib: pdcursesdll.}
          proc ins_nwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "ins_nwstr",
              dynlib: pdcursesdll.}

   * ins_wch dynlib: pdcursesdll.}
          proc ins_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: "ins_wch",
                                                  dynlib: pdcursesdll.}

   * ins_wstr
          proc ins_wstr*(a2: cstring): cint {.extdecl, importc: "ins_wstr", dynlib: pdcursesdll.}

   * inwstr
          proc inwstr*(a2: cstring): cint {.extdecl, importc: "inwstr", dynlib: pdcursesdll.}

   * in_wch dynlib: pdcursesdll.}
          proc in_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: "in_wch",
                                                 dynlib: pdcursesdll.}

   * in_wchnstr importc: "in_wchnstr", dynlib: pdcursesdll.}
          proc in_wchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl,
              importc: "in_wchnstr", dynlib: pdcursesdll.}

   * in_wchstr dynlib: pdcursesdll.}
          proc in_wchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "in_wchstr",
              dynlib: pdcursesdll.}

   * key_name
          proc key_name*(a2: char): cstring {.extdecl, importc: "key_name", dynlib: pdcursesdll.}

   * killwchar
          proc killwchar*(a2: cstring): cint {.extdecl, importc: "killwchar", dynlib: pdcursesdll.}

   * mvaddnwstr importc: "mvaddnwstr", dynlib: pdcursesdll.}
          proc mvaddnwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,
              importc: "mvaddnwstr", dynlib: pdcursesdll.}

   * mvaddwstr dynlib: pdcursesdll.}
          proc mvaddwstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvaddwstr",
              dynlib: pdcursesdll.}

   * mvadd_wch importc: "mvadd_wch", dynlib: pdcursesdll.}
          proc mvadd_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,
              importc: "mvadd_wch", dynlib: pdcursesdll.}

   * mvadd_wchnstr importc: "mvadd_wchnstr", dynlib: pdcursesdll.}
          proc mvadd_wchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvadd_wchnstr", dynlib: pdcursesdll.}

   * mvadd_wchstr importc: "mvadd_wchstr", dynlib: pdcursesdll.}
          proc mvadd_wchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,
              importc: "mvadd_wchstr", dynlib: pdcursesdll.}

   * mvgetn_wstr importc: "mvgetn_wstr", dynlib: pdcursesdll.}
          proc mvgetn_wstr*(a2: cint; a3: cint; a4: ptr cint; a5: cint): cint {.extdecl,
              importc: "mvgetn_wstr", dynlib: pdcursesdll.}

   * mvget_wch dynlib: pdcursesdll.}
          proc mvget_wch*(a2: cint; a3: cint; a4: ptr cint): cint {.extdecl, importc: "mvget_wch",
              dynlib: pdcursesdll.}

   * mvget_wstr dynlib: pdcursesdll.}
          proc mvget_wstr*(a2: cint; a3: cint; a4: ptr cint): cint {.extdecl, importc: "mvget_wstr",
              dynlib: pdcursesdll.}

   * mvhline_set importc: "mvhline_set", dynlib: pdcursesdll.}
          proc mvhline_set*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvhline_set", dynlib: pdcursesdll.}

   * mvinnwstr importc: "mvinnwstr", dynlib: pdcursesdll.}
          proc mvinnwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,
              importc: "mvinnwstr", dynlib: pdcursesdll.}

   * mvins_nwstr importc: "mvins_nwstr", dynlib: pdcursesdll.}
          proc mvins_nwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,
              importc: "mvins_nwstr", dynlib: pdcursesdll.}

   * mvins_wch importc: "mvins_wch", dynlib: pdcursesdll.}
          proc mvins_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,
              importc: "mvins_wch", dynlib: pdcursesdll.}

   * mvins_wstr dynlib: pdcursesdll.}
          proc mvins_wstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvins_wstr",
              dynlib: pdcursesdll.}

   * mvinwstr dynlib: pdcursesdll.}
          proc mvinwstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvinwstr",
              dynlib: pdcursesdll.}

   * mvin_wch importc: "mvin_wch", dynlib: pdcursesdll.}
          proc mvin_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,
              importc: "mvin_wch", dynlib: pdcursesdll.}

   * mvin_wchnstr importc: "mvin_wchnstr", dynlib: pdcursesdll.}
          proc mvin_wchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvin_wchnstr", dynlib: pdcursesdll.}

   * mvin_wchstr importc: "mvin_wchstr", dynlib: pdcursesdll.}
          proc mvin_wchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,
              importc: "mvin_wchstr", dynlib: pdcursesdll.}

   * mvvline_set importc: "mvvline_set", dynlib: pdcursesdll.}
          proc mvvline_set*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,
              importc: "mvvline_set", dynlib: pdcursesdll.}

   * mvwaddnwstr importc: "mvwaddnwstr", dynlib: pdcursesdll.}
          proc mvwaddnwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,
              importc: "mvwaddnwstr", dynlib: pdcursesdll.}

   * mvwaddwstr importc: "mvwaddwstr", dynlib: pdcursesdll.}
          proc mvwaddwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,
              importc: "mvwaddwstr", dynlib: pdcursesdll.}

   * mvwadd_wch importc: "mvwadd_wch", dynlib: pdcursesdll.}
          proc mvwadd_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,
              importc: "mvwadd_wch", dynlib: pdcursesdll.}

   * mvwadd_wchnstr extdecl, importc: "mvwadd_wchnstr", dynlib:
     pdcursesdll.}
          proc mvwadd_wchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwadd_wchnstr", dynlib: pdcursesdll.}

   * mvwadd_wchstr extdecl, importc: "mvwadd_wchstr", dynlib:
     pdcursesdll.}
          proc mvwadd_wchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.
              extdecl, importc: "mvwadd_wchstr", dynlib: pdcursesdll.}

   * mvwgetn_wstr extdecl, importc: "mvwgetn_wstr", dynlib:
     pdcursesdll.}
          proc mvwgetn_wstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cint; a6: cint): cint {.
              extdecl, importc: "mvwgetn_wstr", dynlib: pdcursesdll.}

   * mvwget_wch importc: "mvwget_wch", dynlib: pdcursesdll.}
          proc mvwget_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cint): cint {.extdecl,
              importc: "mvwget_wch", dynlib: pdcursesdll.}

   * mvwget_wstr importc: "mvwget_wstr", dynlib: pdcursesdll.}
          proc mvwget_wstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cint): cint {.extdecl,
              importc: "mvwget_wstr", dynlib: pdcursesdll.}

   * mvwhline_set extdecl, importc: "mvwhline_set", dynlib:
     pdcursesdll.}
          proc mvwhline_set*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwhline_set", dynlib: pdcursesdll.}

   * mvwinnwstr importc: "mvwinnwstr", dynlib: pdcursesdll.}
          proc mvwinnwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,
              importc: "mvwinnwstr", dynlib: pdcursesdll.}

   * mvwins_nwstr extdecl, importc: "mvwins_nwstr", dynlib:
     pdcursesdll.}
          proc mvwins_nwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.
              extdecl, importc: "mvwins_nwstr", dynlib: pdcursesdll.}

   * mvwins_wch importc: "mvwins_wch", dynlib: pdcursesdll.}
          proc mvwins_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,
              importc: "mvwins_wch", dynlib: pdcursesdll.}

   * mvwins_wstr importc: "mvwins_wstr", dynlib: pdcursesdll.}
          proc mvwins_wstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,
              importc: "mvwins_wstr", dynlib: pdcursesdll.}

   * mvwin_wch importc: "mvwin_wch", dynlib: pdcursesdll.}
          proc mvwin_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,
              importc: "mvwin_wch", dynlib: pdcursesdll.}

   * mvwin_wchnstr extdecl, importc: "mvwin_wchnstr", dynlib:
     pdcursesdll.}
          proc mvwin_wchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwin_wchnstr", dynlib: pdcursesdll.}

   * mvwin_wchstr extdecl, importc: "mvwin_wchstr", dynlib:
     pdcursesdll.}
          proc mvwin_wchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.
              extdecl, importc: "mvwin_wchstr", dynlib: pdcursesdll.}

   * mvwinwstr importc: "mvwinwstr", dynlib: pdcursesdll.}
          proc mvwinwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,
              importc: "mvwinwstr", dynlib: pdcursesdll.}

   * mvwvline_set extdecl, importc: "mvwvline_set", dynlib:
     pdcursesdll.}
          proc mvwvline_set*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.
              extdecl, importc: "mvwvline_set", dynlib: pdcursesdll.}

   * pecho_wchar importc: "pecho_wchar", dynlib: pdcursesdll.}
          proc pecho_wchar*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "pecho_wchar", dynlib: pdcursesdll.}

   * setcchar a6: pointer): cint {.extdecl, importc: "setcchar", dynlib:
     pdcursesdll.}
          proc setcchar*(a2: ptr cunsignedlong; a3: cstring; a4: cunsignedlong; a5: cshort;
                        a6: pointer): cint {.extdecl, importc: "setcchar", dynlib: pdcursesdll.}

   * slk_wset dynlib: pdcursesdll.}
          proc slk_wset*(a2: cint; a3: cstring; a4: cint): cint {.extdecl, importc: "slk_wset",
              dynlib: pdcursesdll.}

   * unget_wch
          proc unget_wch*(a2: char): cint {.extdecl, importc: "unget_wch", dynlib: pdcursesdll.}

   * vline_set dynlib: pdcursesdll.}
          proc vline_set*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "vline_set",
              dynlib: pdcursesdll.}

   * waddnwstr importc: "waddnwstr", dynlib: pdcursesdll.}
          proc waddnwstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,
              importc: "waddnwstr", dynlib: pdcursesdll.}

   * waddwstr dynlib: pdcursesdll.}
          proc waddwstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "waddwstr",
              dynlib: pdcursesdll.}

   * wadd_wch importc: "wadd_wch", dynlib: pdcursesdll.}
          proc wadd_wch*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "wadd_wch", dynlib: pdcursesdll.}

   * wadd_wchnstr importc: "wadd_wchnstr", dynlib: pdcursesdll.}
          proc wadd_wchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,
              importc: "wadd_wchnstr", dynlib: pdcursesdll.}

   * wadd_wchstr importc: "wadd_wchstr", dynlib: pdcursesdll.}
          proc wadd_wchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "wadd_wchstr", dynlib: pdcursesdll.}

   * wbkgrnd dynlib: pdcursesdll.}
          proc wbkgrnd*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl, importc: "wbkgrnd",
              dynlib: pdcursesdll.}

   * wbkgrndset importc: "wbkgrndset", dynlib: pdcursesdll.}
          proc wbkgrndset*(a2: ptr WINDOW; a3: ptr cunsignedlong) {.extdecl,
              importc: "wbkgrndset", dynlib: pdcursesdll.}

   * wborder_set a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr
     cunsignedlong; a8: ptr cunsignedlong; a9: ptr cunsignedlong; a10:
     ptr cunsignedlong): cint {.  extdecl, importc: "wborder_set",
     dynlib: pdcursesdll.}
          proc wborder_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong;
                           a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr cunsignedlong;
                           a8: ptr cunsignedlong; a9: ptr cunsignedlong; a10: ptr cunsignedlong): cint {.
              extdecl, importc: "wborder_set", dynlib: pdcursesdll.}

   * wecho_wchar importc: "wecho_wchar", dynlib: pdcursesdll.}
          proc wecho_wchar*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "wecho_wchar", dynlib: pdcursesdll.}

   * wgetbkgrnd importc: "wgetbkgrnd", dynlib: pdcursesdll.}
          proc wgetbkgrnd*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "wgetbkgrnd", dynlib: pdcursesdll.}

   * wgetn_wstr importc: "wgetn_wstr", dynlib: pdcursesdll.}
          proc wgetn_wstr*(a2: ptr WINDOW; a3: ptr cint; a4: cint): cint {.extdecl,
              importc: "wgetn_wstr", dynlib: pdcursesdll.}

   * wget_wch dynlib: pdcursesdll.}
          proc wget_wch*(a2: ptr WINDOW; a3: ptr cint): cint {.extdecl, importc: "wget_wch",
              dynlib: pdcursesdll.}

   * wget_wstr dynlib: pdcursesdll.}
          proc wget_wstr*(a2: ptr WINDOW; a3: ptr cint): cint {.extdecl, importc: "wget_wstr",
              dynlib: pdcursesdll.}

   * whline_set importc: "whline_set", dynlib: pdcursesdll.}
          proc whline_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,
              importc: "whline_set", dynlib: pdcursesdll.}

   * winnwstr importc: "winnwstr", dynlib: pdcursesdll.}
          proc winnwstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,
              importc: "winnwstr", dynlib: pdcursesdll.}

   * wins_nwstr importc: "wins_nwstr", dynlib: pdcursesdll.}
          proc wins_nwstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,
              importc: "wins_nwstr", dynlib: pdcursesdll.}

   * wins_wch importc: "wins_wch", dynlib: pdcursesdll.}
          proc wins_wch*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "wins_wch", dynlib: pdcursesdll.}

   * wins_wstr dynlib: pdcursesdll.}
          proc wins_wstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "wins_wstr",
              dynlib: pdcursesdll.}

   * winwstr dynlib: pdcursesdll.}
          proc winwstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "winwstr",
              dynlib: pdcursesdll.}

   * win_wch dynlib: pdcursesdll.}
          proc win_wch*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl, importc: "win_wch",
              dynlib: pdcursesdll.}

   * win_wchnstr importc: "win_wchnstr", dynlib: pdcursesdll.}
          proc win_wchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,
              importc: "win_wchnstr", dynlib: pdcursesdll.}

   * win_wchstr importc: "win_wchstr", dynlib: pdcursesdll.}
          proc win_wchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,
              importc: "win_wchstr", dynlib: pdcursesdll.}

   * wunctrl dynlib: pdcursesdll.}
          proc wunctrl*(a2: ptr cunsignedlong): cstring {.extdecl, importc: "wunctrl",
              dynlib: pdcursesdll.}

   * wvline_set importc: "wvline_set", dynlib: pdcursesdll.}
          proc wvline_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,
              importc: "wvline_set", dynlib: pdcursesdll.}

   * getattrs dynlib: pdcursesdll.}
          proc getattrs*(a2: ptr WINDOW): cunsignedlong {.extdecl, importc: "getattrs",
              dynlib: pdcursesdll.}

   * getbegx
          proc getbegx*(a2: ptr WINDOW): cint {.extdecl, importc: "getbegx", dynlib: pdcursesdll.}

   * getbegy
          proc getbegy*(a2: ptr WINDOW): cint {.extdecl, importc: "getbegy", dynlib: pdcursesdll.}

   * getmaxx
          proc getmaxx*(a2: ptr WINDOW): cint {.extdecl, importc: "getmaxx", dynlib: pdcursesdll.}

   * getmaxy
          proc getmaxy*(a2: ptr WINDOW): cint {.extdecl, importc: "getmaxy", dynlib: pdcursesdll.}

   * getparx
          proc getparx*(a2: ptr WINDOW): cint {.extdecl, importc: "getparx", dynlib: pdcursesdll.}

   * getpary
          proc getpary*(a2: ptr WINDOW): cint {.extdecl, importc: "getpary", dynlib: pdcursesdll.}

   * getcurx
          proc getcurx*(a2: ptr WINDOW): cint {.extdecl, importc: "getcurx", dynlib: pdcursesdll.}

   * getcury
          proc getcury*(a2: ptr WINDOW): cint {.extdecl, importc: "getcury", dynlib: pdcursesdll.}

   * traceoff
          proc traceoff*() {.extdecl, importc: "traceoff", dynlib: pdcursesdll.}

   * traceon
          proc traceon*() {.extdecl, importc: "traceon", dynlib: pdcursesdll.}

   * unctrl dynlib: pdcursesdll.}
          proc unctrl*(a2: cunsignedlong): cstring {.extdecl, importc: "unctrl",
                                                 dynlib: pdcursesdll.}

   * crmode
          proc crmode*(): cint {.extdecl, importc: "crmode", dynlib: pdcursesdll.}

   * nocrmode
          proc nocrmode*(): cint {.extdecl, importc: "nocrmode", dynlib: pdcursesdll.}

   * draino
          proc draino*(a2: cint): cint {.extdecl, importc: "draino", dynlib: pdcursesdll.}

   * resetterm
          proc resetterm*(): cint {.extdecl, importc: "resetterm", dynlib: pdcursesdll.}

   * fixterm
          proc fixterm*(): cint {.extdecl, importc: "fixterm", dynlib: pdcursesdll.}

   * saveterm
          proc saveterm*(): cint {.extdecl, importc: "saveterm", dynlib: pdcursesdll.}

   * setsyx
          proc setsyx*(a2: cint; a3: cint): cint {.extdecl, importc: "setsyx", dynlib: pdcursesdll.}

   * mouse_set dynlib: pdcursesdll.}
          proc mouse_set*(a2: cunsignedlong): cint {.extdecl, importc: "mouse_set",
                                                 dynlib: pdcursesdll.}

   * mouse_on dynlib: pdcursesdll.}
          proc mouse_on*(a2: cunsignedlong): cint {.extdecl, importc: "mouse_on",
                                                dynlib: pdcursesdll.}

   * mouse_off dynlib: pdcursesdll.}
          proc mouse_off*(a2: cunsignedlong): cint {.extdecl, importc: "mouse_off",
                                                 dynlib: pdcursesdll.}

   * request_mouse_pos dynlib: pdcursesdll.}
          proc request_mouse_pos*(): cint {.extdecl, importc: "request_mouse_pos",
                                         dynlib: pdcursesdll.}

   * map_button dynlib: pdcursesdll.}
          proc map_button*(a2: cunsignedlong): cint {.extdecl, importc: "map_button",
                                                  dynlib: pdcursesdll.}

   * wmouse_position importc: "wmouse_position", dynlib: pdcursesdll.}
          proc wmouse_position*(a2: ptr WINDOW; a3: ptr cint; a4: ptr cint) {.extdecl,
              importc: "wmouse_position", dynlib: pdcursesdll.}

   * getmouse
          proc getmouse*(): cunsignedlong {.extdecl, importc: "getmouse", dynlib: pdcursesdll.}

   * getbmap
          proc getbmap*(): cunsignedlong {.extdecl, importc: "getbmap", dynlib: pdcursesdll.}

   * assume_default_colors importc: "assume_default_colors", dynlib:
     pdcursesdll.}
          proc assume_default_colors*(a2: cint; a3: cint): cint {.extdecl,
              importc: "assume_default_colors", dynlib: pdcursesdll.}

   * curses_version dynlib: pdcursesdll.}
          proc curses_version*(): cstring {.extdecl, importc: "curses_version",
                                         dynlib: pdcursesdll.}

   * has_key dynlib: pdcursesdll.}
          proc has_key*(a2: cint): cunsignedchar {.extdecl, importc: "has_key",
                                               dynlib: pdcursesdll.}

   * use_default_colors dynlib: pdcursesdll.}
          proc use_default_colors*(): cint {.extdecl, importc: "use_default_colors",
                                          dynlib: pdcursesdll.}

   * wresize dynlib: pdcursesdll.}
          proc wresize*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "wresize",
              dynlib: pdcursesdll.}

   * mouseinterval dynlib: pdcursesdll.}
          proc mouseinterval*(a2: cint): cint {.extdecl, importc: "mouseinterval",
                                            dynlib: pdcursesdll.}

   * mousemask importc: "mousemask", dynlib: pdcursesdll.}
          proc mousemask*(a2: cunsignedlong; a3: ptr cunsignedlong): cunsignedlong {.extdecl,
              importc: "mousemask", dynlib: pdcursesdll.}

   * mouse_trafo importc: "mouse_trafo", dynlib: pdcursesdll.}
          proc mouse_trafo*(a2: ptr cint; a3: ptr cint; a4: cunsignedchar): cunsignedchar {.extdecl,
              importc: "mouse_trafo", dynlib: pdcursesdll.}

   * nc_getmouse dynlib: pdcursesdll.}
          proc nc_getmouse*(a2: ptr MEVENT): cint {.extdecl, importc: "nc_getmouse",
                                               dynlib: pdcursesdll.}

   * ungetmouse dynlib: pdcursesdll.}
          proc ungetmouse*(a2: ptr MEVENT): cint {.extdecl, importc: "ungetmouse",
                                              dynlib: pdcursesdll.}

   * wenclose importc: "wenclose", dynlib: pdcursesdll.}
          proc wenclose*(a2: ptr WINDOW; a3: cint; a4: cint): cunsignedchar {.extdecl,
              importc: "wenclose", dynlib: pdcursesdll.}

   * wmouse_trafo extdecl, importc: "wmouse_trafo", dynlib:
     pdcursesdll.}
          proc wmouse_trafo*(a2: ptr WINDOW; a3: ptr cint; a4: ptr cint; a5: cunsignedchar): cunsignedchar {.
              extdecl, importc: "wmouse_trafo", dynlib: pdcursesdll.}

   * addrawch dynlib: pdcursesdll.}
          proc addrawch*(a2: cunsignedlong): cint {.extdecl, importc: "addrawch",
                                                dynlib: pdcursesdll.}

   * insrawch dynlib: pdcursesdll.}
          proc insrawch*(a2: cunsignedlong): cint {.extdecl, importc: "insrawch",
                                                dynlib: pdcursesdll.}

   * is_termresized dynlib: pdcursesdll.}
          proc is_termresized*(): cunsignedchar {.extdecl, importc: "is_termresized",
                                               dynlib: pdcursesdll.}

   * mvaddrawch importc: "mvaddrawch", dynlib: pdcursesdll.}
          proc mvaddrawch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl,
              importc: "mvaddrawch", dynlib: pdcursesdll.}

   * mvdeleteln dynlib: pdcursesdll.}
          proc mvdeleteln*(a2: cint; a3: cint): cint {.extdecl, importc: "mvdeleteln",
                                                 dynlib: pdcursesdll.}

   * mvinsertln dynlib: pdcursesdll.}
          proc mvinsertln*(a2: cint; a3: cint): cint {.extdecl, importc: "mvinsertln",
                                                 dynlib: pdcursesdll.}

   * mvinsrawch importc: "mvinsrawch", dynlib: pdcursesdll.}
          proc mvinsrawch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl,
              importc: "mvinsrawch", dynlib: pdcursesdll.}

   * mvwaddrawch importc: "mvwaddrawch", dynlib: pdcursesdll.}
          proc mvwaddrawch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,
              importc: "mvwaddrawch", dynlib: pdcursesdll.}

   * mvwdeleteln importc: "mvwdeleteln", dynlib: pdcursesdll.}
          proc mvwdeleteln*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl,
              importc: "mvwdeleteln", dynlib: pdcursesdll.}

   * mvwinsertln importc: "mvwinsertln", dynlib: pdcursesdll.}
          proc mvwinsertln*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl,
              importc: "mvwinsertln", dynlib: pdcursesdll.}

   * mvwinsrawch importc: "mvwinsrawch", dynlib: pdcursesdll.}
          proc mvwinsrawch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,
              importc: "mvwinsrawch", dynlib: pdcursesdll.}

   * raw_output dynlib: pdcursesdll.}
          proc raw_output*(a2: cunsignedchar): cint {.extdecl, importc: "raw_output",
                                                  dynlib: pdcursesdll.}

   * resize_term dynlib: pdcursesdll.}
          proc resize_term*(a2: cint; a3: cint): cint {.extdecl, importc: "resize_term",
                                                  dynlib: pdcursesdll.}

   * resize_window importc: "resize_window", dynlib: pdcursesdll.}
          proc resize_window*(a2: ptr WINDOW; a3: cint; a4: cint): ptr WINDOW {.extdecl,
              importc: "resize_window", dynlib: pdcursesdll.}

   * waddrawch importc: "waddrawch", dynlib: pdcursesdll.}
          proc waddrawch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,
              importc: "waddrawch", dynlib: pdcursesdll.}

   * winsrawch importc: "winsrawch", dynlib: pdcursesdll.}
          proc winsrawch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,
              importc: "winsrawch", dynlib: pdcursesdll.}

   * wordchar
          proc wordchar*(): char {.extdecl, importc: "wordchar", dynlib: pdcursesdll.}

   * slk_wlabel dynlib: pdcursesdll.}
          proc slk_wlabel*(a2: cint): cstring {.extdecl, importc: "slk_wlabel",
                                            dynlib: pdcursesdll.}

   * debug
          proc debug*(a2: cstring) {.varargs, extdecl, importc: "PDC_debug", dynlib: pdcursesdll.}

   * ungetch
          proc ungetch*(a2: cint): cint {.extdecl, importc: "PDC_ungetch", dynlib: pdcursesdll.}

   * set_blink dynlib: pdcursesdll.}
          proc set_blink*(a2: cunsignedchar): cint {.extdecl, importc: "PDC_set_blink",
                                                 dynlib: pdcursesdll.}

   * set_line_color dynlib: pdcursesdll.}
          proc set_line_color*(a2: cshort): cint {.extdecl, importc: "PDC_set_line_color",
                                               dynlib: pdcursesdll.}

   * set_title
          proc set_title*(a2: cstring) {.extdecl, importc: "PDC_set_title", dynlib: pdcursesdll.}

   * clearclipboard dynlib: pdcursesdll.}
          proc clearclipboard*(): cint {.extdecl, importc: "PDC_clearclipboard",
                                      dynlib: pdcursesdll.}

   * freeclipboard dynlib: pdcursesdll.}
          proc freeclipboard*(a2: cstring): cint {.extdecl, importc: "PDC_freeclipboard",
                                               dynlib: pdcursesdll.}

   * getclipboard importc: "PDC_getclipboard", dynlib: pdcursesdll.}
          proc getclipboard*(a2: cstringArray; a3: ptr clong): cint {.extdecl,
              importc: "PDC_getclipboard", dynlib: pdcursesdll.}

   * setclipboard importc: "PDC_setclipboard", dynlib: pdcursesdll.}
          proc setclipboard*(a2: cstring; a3: clong): cint {.extdecl,
              importc: "PDC_setclipboard", dynlib: pdcursesdll.}

   * get_input_fd dynlib: pdcursesdll.}
          proc get_input_fd*(): cunsignedlong {.extdecl, importc: "PDC_get_input_fd",
                                             dynlib: pdcursesdll.}

   * get_key_modifiers importc: "PDC_get_key_modifiers", dynlib:
     pdcursesdll.}
          proc get_key_modifiers*(): cunsignedlong {.extdecl,
                                                  importc: "PDC_get_key_modifiers",
                                                  dynlib: pdcursesdll.}

   * return_key_modifiers importc: "PDC_return_key_modifiers", dynlib:
     pdcursesdll.}
          proc return_key_modifiers*(a2: cunsignedchar): cint {.extdecl,
              importc: "PDC_return_key_modifiers", dynlib: pdcursesdll.}

   * save_key_modifiers importc: "PDC_save_key_modifiers", dynlib:
     pdcursesdll.}
          proc save_key_modifiers*(a2: cunsignedchar): cint {.extdecl,
              importc: "PDC_save_key_modifiers", dynlib: pdcursesdll.}

   * bottom_panel dynlib: pdcursesdll.}
          proc bottom_panel*(pan: ptr PANEL): cint {.extdecl, importc: "bottom_panel",
                                                dynlib: pdcursesdll.}

   * del_panel dynlib: pdcursesdll.}
          proc del_panel*(pan: ptr PANEL): cint {.extdecl, importc: "del_panel",
                                             dynlib: pdcursesdll.}

   * hide_panel dynlib: pdcursesdll.}
          proc hide_panel*(pan: ptr PANEL): cint {.extdecl, importc: "hide_panel",
                                              dynlib: pdcursesdll.}

   * move_panel importc: "move_panel", dynlib: pdcursesdll.}
          proc move_panel*(pan: ptr PANEL; starty: cint; startx: cint): cint {.extdecl,
              importc: "move_panel", dynlib: pdcursesdll.}

   * new_panel dynlib: pdcursesdll.}
          proc new_panel*(win: ptr WINDOW): ptr PANEL {.extdecl, importc: "new_panel",
                                                  dynlib: pdcursesdll.}

   * panel_above dynlib: pdcursesdll.}
          proc panel_above*(pan: ptr PANEL): ptr PANEL {.extdecl, importc: "panel_above",
              dynlib: pdcursesdll.}

   * panel_below dynlib: pdcursesdll.}
          proc panel_below*(pan: ptr PANEL): ptr PANEL {.extdecl, importc: "panel_below",
              dynlib: pdcursesdll.}

   * panel_hidden dynlib: pdcursesdll.}
          proc panel_hidden*(pan: ptr PANEL): cint {.extdecl, importc: "panel_hidden",
                                                dynlib: pdcursesdll.}

   * panel_userptr dynlib: pdcursesdll.}
          proc panel_userptr*(pan: ptr PANEL): pointer {.extdecl, importc: "panel_userptr",
              dynlib: pdcursesdll.}

   * panel_window dynlib: pdcursesdll.}
          proc panel_window*(pan: ptr PANEL): ptr WINDOW {.extdecl, importc: "panel_window",
              dynlib: pdcursesdll.}

   * replace_panel importc: "replace_panel", dynlib: pdcursesdll.}
          proc replace_panel*(pan: ptr PANEL; win: ptr WINDOW): cint {.extdecl,
              importc: "replace_panel", dynlib: pdcursesdll.}

   * set_panel_userptr importc: "set_panel_userptr", dynlib:
     pdcursesdll.}
          proc set_panel_userptr*(pan: ptr PANEL; uptr: pointer): cint {.extdecl,
              importc: "set_panel_userptr", dynlib: pdcursesdll.}

   * show_panel dynlib: pdcursesdll.}
          proc show_panel*(pan: ptr PANEL): cint {.extdecl, importc: "show_panel",
                                              dynlib: pdcursesdll.}

   * top_panel dynlib: pdcursesdll.}
          proc top_panel*(pan: ptr PANEL): cint {.extdecl, importc: "top_panel",
                                             dynlib: pdcursesdll.}

   * update_panels
          proc update_panels*() {.extdecl, importc: "update_panels", dynlib: pdcursesdll.}

   * Xinitscr dynlib: pdcursesdll.}
          proc Xinitscr*(a2: cint; a3: cstringArray): ptr WINDOW {.extdecl, importc: "Xinitscr",
              dynlib: pdcursesdll.}

   * XCursesExit
          proc XCursesExit*() {.extdecl, importc: "XCursesExit", dynlib: pdcursesdll.}

   * sb_init
          proc sb_init*(): cint {.extdecl, importc: "sb_init", dynlib: pdcursesdll.}

   * sb_set_horz dynlib: pdcursesdll.}
          proc sb_set_horz*(a2: cint; a3: cint; a4: cint): cint {.extdecl, importc: "sb_set_horz",
              dynlib: pdcursesdll.}

   * sb_set_vert dynlib: pdcursesdll.}
          proc sb_set_vert*(a2: cint; a3: cint; a4: cint): cint {.extdecl, importc: "sb_set_vert",
              dynlib: pdcursesdll.}

   * sb_get_horz importc: "sb_get_horz", dynlib: pdcursesdll.}
          proc sb_get_horz*(a2: ptr cint; a3: ptr cint; a4: ptr cint): cint {.extdecl,
              importc: "sb_get_horz", dynlib: pdcursesdll.}

   * sb_get_vert importc: "sb_get_vert", dynlib: pdcursesdll.}
          proc sb_get_vert*(a2: ptr cint; a3: ptr cint; a4: ptr cint): cint {.extdecl,
              importc: "sb_get_vert", dynlib: pdcursesdll.}

   * sb_refresh
          proc sb_refresh*(): cint {.extdecl, importc: "sb_refresh", dynlib: pdcursesdll.}

   * get_buffer_rows dynlib: pdcursesdll.}
          proc get_buffer_rows*(): cint {.extdecl, importc: "PDC_get_buffer_rows",
                                       dynlib: pdcursesdll.}

304 Templates
*************

   * BUTTON_CHANGED
          template BUTTON_CHANGED*(x: expr): expr

   * BUTTON_STATUS
          template BUTTON_STATUS*(x: expr): expr

   * ACS_PICK
          template ACS_PICK*(w, n: expr): expr

   * KEY_F
          template KEY_F*(n: expr): expr

   * COLOR_PAIR
          template COLOR_PAIR*(n: expr): expr

   * PAIR_NUMBER
          template PAIR_NUMBER*(n: expr): expr

   * getch
          template getch*(): expr

   * ungetch
          template ungetch*(ch: expr): expr

   * getbegyx
          template getbegyx*(w, y, x: expr): expr

   * getmaxyx
          template getmaxyx*(w, y, x: expr): expr

   * getparyx
          template getparyx*(w, y, x: expr): expr

   * getyx
          template getyx*(w, y, x: expr): expr

   * getsyx
          template getsyx*(y, x: expr): stmt

   * getmouse
          template getmouse*(x: expr): expr


File: nim-ref-0.13.0.info,  Node: /wrappers/tinyc,  Next: /wrappers/iup,  Prev: /wrappers/pdcurses,  Up: Top

305 Constant variables
**********************

   * OutputFormatCoff
          OutputFormatCoff*: cint = 2

     COFF

306 Types
*********

   * ErrorFunc
          ErrorFunc* = proc (opaque: pointer; msg: cstring) {.cdecl.}

307 Procedures
**************

   * openCCState
          proc openCCState*(): PccState {.importc: "tcc_new", cdecl.}

     create a new TCC compilation context

   * closeCCState
          proc closeCCState*(s: PccState) {.importc: "tcc_delete", cdecl.}

     free a TCC compilation context

   * enableDebug
          proc enableDebug*(s: PccState) {.importc: "tcc_enable_debug", cdecl.}

     add debug information in the generated code

   * setErrorFunc importc: "tcc_set_error_func".}
          proc setErrorFunc*(s: PccState; errorOpaque: pointer; errorFun: ErrorFunc) {.cdecl,
              importc: "tcc_set_error_func".}

     set error/warning display callback

   * setWarning importc: "tcc_set_warning".}
          proc setWarning*(s: PccState; warningName: cstring; value: int) {.cdecl,
              importc: "tcc_set_warning".}

     set/reset a warning

   * addIncludePath importc: "tcc_add_include_path".}
          proc addIncludePath*(s: PccState; pathname: cstring) {.cdecl,
              importc: "tcc_add_include_path".}

     add include path

   * addSysincludePath importc: "tcc_add_sysinclude_path".}
          proc addSysincludePath*(s: PccState; pathname: cstring) {.cdecl,
              importc: "tcc_add_sysinclude_path".}

     add in system include path

   * defineSymbol importc: "tcc_define_symbol".}
          proc defineSymbol*(s: PccState; sym, value: cstring) {.cdecl,
              importc: "tcc_define_symbol".}

     define preprocessor symbol 'sym'.  Can put optional value

   * undefineSymbol importc: "tcc_undefine_symbol".}
          proc undefineSymbol*(s: PccState; sym: cstring) {.cdecl,
              importc: "tcc_undefine_symbol".}

     undefine preprocess symbol 'sym'

   * addFile
          proc addFile*(s: PccState; filename: cstring): cint {.cdecl, importc: "tcc_add_file".}

     add a file (either a C file, dll, an object, a library or an ld
     script).  Return -1 if error.

   * compileString importc: "tcc_compile_string".}
          proc compileString*(s: PccState; buf: cstring): cint {.cdecl,
              importc: "tcc_compile_string".}

     compile a string containing a C source.  Return non zero if error.

   * setOutputType importc: "tcc_set_output_type".}
          proc setOutputType*(s: PCCState; outputType: cint): cint {.cdecl,
              importc: "tcc_set_output_type".}

     set output type.  MUST BE CALLED before any compilation

   * addLibraryPath importc: "tcc_add_library_path".}
          proc addLibraryPath*(s: PccState; pathname: cstring): cint {.cdecl,
              importc: "tcc_add_library_path".}

     equivalent to -Lpath option

   * addLibrary importc: "tcc_add_library".}
          proc addLibrary*(s: PCCState; libraryname: cstring): cint {.cdecl,
              importc: "tcc_add_library".}

     the library name is the same as the argument of the '-l' option

   * addSymbol importc: "tcc_add_symbol".}
          proc addSymbol*(s: PccState; name: cstring; val: pointer): cint {.cdecl,
              importc: "tcc_add_symbol".}

     add a symbol to the compiled program

   * outputFile importc: "tcc_output_file".}
          proc outputFile*(s: PccState; filename: cstring): cint {.cdecl,
              importc: "tcc_output_file".}

     output an executable, library or object file.  DO NOT call
     tcc_relocate() before.

   * run
          proc run*(s: PccState; argc: cint; argv: cstringArray): cint {.cdecl, importc: "tcc_run".}

     link and run main() function and return its value.  DO NOT call
     tcc_relocate() before.

   * relocate
          proc relocate*(s: PccState; p: pointer): cint {.cdecl, importc: "tcc_relocate".}

     copy code into memory passed in by the caller and do all
     relocations (needed before using tcc_get_symbol()).  returns -1 on
     error and required size if ptr is NULL

   * getSymbol
          proc getSymbol*(s: PccState; name: cstring): pointer {.cdecl, importc: "tcc_get_symbol".}

     return symbol value or NULL if not found

   * setLibPath
          proc setLibPath*(s: PccState; path: cstring) {.cdecl, importc: "tcc_set_lib_path".}

     set CONFIG_TCCDIR at runtime


File: nim-ref-0.13.0.info,  Node: /wrappers/iup,  Next: /wrappers/sqlite3,  Prev: /wrappers/tinyc,  Up: Top

308 Constant variables
**********************

   * constIUP_VERSION_DATE
          constIUP_VERSION_DATE* = "2009/07/18"

   * IUP_BUTTON5
          IUP_BUTTON5* = cint(ord('5'))

   * IUP_MASK_UINT
          IUP_MASK_UINT* = "/d+"

   * K_tilde
          K_tilde* = cint(ord('~'))

   * K_CR
          K_CR* = cint(13)

   * K_yAsterisk
          K_yAsterisk* = iUPyxCODE(K_asterisk)

   * IUP_SECONDARY
          IUP_SECONDARY* = - 2

309 Types
*********

   * Icallback
          Icallback* = proc (arg: PIhandle): cint {.cdecl.}

   * Iparamcb
          Iparamcb* = proc (dialog: PIhandle; paramIndex: cint; userData: pointer): cint {.cdecl.}

310 Procedures
**************

   * fileDlg
          proc fileDlg*(): PIhandle {.importc: "IupFileDlg", dynlib: dllname, cdecl.}

   * messageDlg
          proc messageDlg*(): PIhandle {.importc: "IupMessageDlg", dynlib: dllname, cdecl.}

   * colorDlg
          proc colorDlg*(): PIhandle {.importc: "IupColorDlg", dynlib: dllname, cdecl.}

   * fontDlg
          proc fontDlg*(): PIhandle {.importc: "IupFontDlg", dynlib: dllname, cdecl.}

   * getFile
          proc getFile*(arq: cstring): cint {.importc: "IupGetFile", dynlib: dllname, cdecl.}

   * message
          proc message*(title, msg: cstring) {.importc: "IupMessage", dynlib: dllname, cdecl.}

   * messagef varargs.}
          proc messagef*(title, format: cstring) {.importc: "IupMessagef", dynlib: dllname, cdecl,
                                               varargs.}

   * alarm cdecl.}
          proc alarm*(title, msg, b1, b2, b3: cstring): cint {.importc: "IupAlarm", dynlib: dllname,
              cdecl.}

   * scanf
          proc scanf*(format: cstring): cint {.importc: "IupScanf", dynlib: dllname, cdecl, varargs.}

   * listDialog op, maxCol, maxLin: cint; marks: ptr cint): cint {.
     importc: "IupListDialog", dynlib: dllname, cdecl.}
          proc listDialog*(theType: cint; title: cstring; size: cint; list: cstringArray;
                          op, maxCol, maxLin: cint; marks: ptr cint): cint {.
              importc: "IupListDialog", dynlib: dllname, cdecl.}

   * getText
          proc getText*(title, text: cstring): cint {.importc: "IupGetText", dynlib: dllname, cdecl.}

   * getColor dynlib: dllname, cdecl.}
          proc getColor*(x, y: cint; r, g, b: var byte): cint {.importc: "IupGetColor",
              dynlib: dllname, cdecl.}

   * getParam importc: "IupGetParam", cdecl, varargs, dynlib: dllname.}
          proc getParam*(title: cstring; action: Iparamcb; userData: pointer; format: cstring): cint {.
              importc: "IupGetParam", cdecl, varargs, dynlib: dllname.}

   * getParamv paramCount, paramExtra: cint; paramData: pointer): cint
     {.  importc: "IupGetParamv", cdecl, dynlib: dllname.}
          proc getParamv*(title: cstring; action: Iparamcb; userData: pointer; format: cstring;
                         paramCount, paramExtra: cint; paramData: pointer): cint {.
              importc: "IupGetParamv", cdecl, dynlib: dllname.}

   * open dynlib: dllname.}
          proc open*(argc: ptr cint; argv: ptr cstringArray): cint {.importc: "IupOpen", cdecl,
              dynlib: dllname.}

   * close
          proc close*() {.importc: "IupClose", cdecl, dynlib: dllname.}

   * imageLibOpen
          proc imageLibOpen*() {.importc: "IupImageLibOpen", cdecl, dynlib: dllname.}

   * mainLoop
          proc mainLoop*(): cint {.importc: "IupMainLoop", cdecl, dynlib: dllname, discardable.}

   * loopStep
          proc loopStep*(): cint {.importc: "IupLoopStep", cdecl, dynlib: dllname, discardable.}

   * mainLoopLevel discardable.}
          proc mainLoopLevel*(): cint {.importc: "IupMainLoopLevel", cdecl, dynlib: dllname,
                                     discardable.}

   * flush
          proc flush*() {.importc: "IupFlush", cdecl, dynlib: dllname.}

   * exitLoop
          proc exitLoop*() {.importc: "IupExitLoop", cdecl, dynlib: dllname.}

   * update
          proc update*(ih: PIhandle) {.importc: "IupUpdate", cdecl, dynlib: dllname.}

   * updateChildren dynlib: dllname.}
          proc updateChildren*(ih: PIhandle) {.importc: "IupUpdateChildren", cdecl,
                                            dynlib: dllname.}

   * redraw dynlib: dllname.}
          proc redraw*(ih: PIhandle; children: cint) {.importc: "IupRedraw", cdecl,
                                                  dynlib: dllname.}

   * refresh
          proc refresh*(ih: PIhandle) {.importc: "IupRefresh", cdecl, dynlib: dllname.}

   * mapFont dynlib: dllname.}
          proc mapFont*(iupfont: cstring): cstring {.importc: "IupMapFont", cdecl,
                                                 dynlib: dllname.}

   * unMapFont dynlib: dllname.}
          proc unMapFont*(driverfont: cstring): cstring {.importc: "IupUnMapFont", cdecl,
              dynlib: dllname.}

   * help
          proc help*(url: cstring): cint {.importc: "IupHelp", cdecl, dynlib: dllname.}

   * load
          proc load*(filename: cstring): cstring {.importc: "IupLoad", cdecl, dynlib: dllname.}

   * iupVersion
          proc iupVersion*(): cstring {.importc: "IupVersion", cdecl, dynlib: dllname.}

   * iupVersionDate
          proc iupVersionDate*(): cstring {.importc: "IupVersionDate", cdecl, dynlib: dllname.}

   * iupVersionNumber
          proc iupVersionNumber*(): cint {.importc: "IupVersionNumber", cdecl, dynlib: dllname.}

   * setLanguage
          proc setLanguage*(lng: cstring) {.importc: "IupSetLanguage", cdecl, dynlib: dllname.}

   * getLanguage
          proc getLanguage*(): cstring {.importc: "IupGetLanguage", cdecl, dynlib: dllname.}

   * destroy
          proc destroy*(ih: PIhandle) {.importc: "IupDestroy", cdecl, dynlib: dllname.}

   * detach
          proc detach*(child: PIhandle) {.importc: "IupDetach", cdecl, dynlib: dllname.}

   * append dynlib: dllname, discardable.}
          proc append*(ih, child: PIhandle): PIhandle {.importc: "IupAppend", cdecl,
              dynlib: dllname, discardable.}

   * insert dynlib: dllname, discardable.}
          proc insert*(ih, refChild, child: PIhandle): PIhandle {.importc: "IupInsert", cdecl,
              dynlib: dllname, discardable.}

   * getChild dynlib: dllname.}
          proc getChild*(ih: PIhandle; pos: cint): PIhandle {.importc: "IupGetChild", cdecl,
              dynlib: dllname.}

   * getChildPos dynlib: dllname.}
          proc getChildPos*(ih, child: PIhandle): cint {.importc: "IupGetChildPos", cdecl,
              dynlib: dllname.}

   * getChildCount dynlib: dllname.}
          proc getChildCount*(ih: PIhandle): cint {.importc: "IupGetChildCount", cdecl,
                                                dynlib: dllname.}

   * getNextChild dynlib: dllname.}
          proc getNextChild*(ih, child: PIhandle): PIhandle {.importc: "IupGetNextChild", cdecl,
              dynlib: dllname.}

   * getBrother dynlib: dllname.}
          proc getBrother*(ih: PIhandle): PIhandle {.importc: "IupGetBrother", cdecl,
                                                 dynlib: dllname.}

   * getParent dynlib: dllname.}
          proc getParent*(ih: PIhandle): PIhandle {.importc: "IupGetParent", cdecl,
                                                dynlib: dllname.}

   * getDialog dynlib: dllname.}
          proc getDialog*(ih: PIhandle): PIhandle {.importc: "IupGetDialog", cdecl,
                                                dynlib: dllname.}

   * getDialogChild importc: "IupGetDialogChild", cdecl, dynlib:
     dllname.}
          proc getDialogChild*(ih: PIhandle; name: cstring): PIhandle {.
              importc: "IupGetDialogChild", cdecl, dynlib: dllname.}

   * reparent dynlib: dllname.}
          proc reparent*(ih, newParent: PIhandle): cint {.importc: "IupReparent", cdecl,
              dynlib: dllname.}

   * popup discardable.}
          proc popup*(ih: PIhandle; x, y: cint): cint {.importc: "IupPopup", cdecl, dynlib: dllname,
                                                 discardable.}

   * show
          proc show*(ih: PIhandle): cint {.importc: "IupShow", cdecl, dynlib: dllname, discardable.}

   * showXY dynlib: dllname, discardable.}
          proc showXY*(ih: PIhandle; x, y: cint): cint {.importc: "IupShowXY", cdecl,
                                                  dynlib: dllname, discardable.}

   * hide
          proc hide*(ih: PIhandle): cint {.importc: "IupHide", cdecl, dynlib: dllname, discardable.}

   * map
          proc map*(ih: PIhandle): cint {.importc: "IupMap", cdecl, dynlib: dllname, discardable.}

   * unmap
          proc unmap*(ih: PIhandle) {.importc: "IupUnmap", cdecl, dynlib: dllname, discardable.}

   * setAttribute cdecl, dynlib: dllname.}
          proc setAttribute*(ih: PIhandle; name, value: cstring) {.importc: "IupSetAttribute",
              cdecl, dynlib: dllname.}

   * storeAttribute importc: "IupStoreAttribute", cdecl, dynlib:
     dllname.}
          proc storeAttribute*(ih: PIhandle; name, value: cstring) {.
              importc: "IupStoreAttribute", cdecl, dynlib: dllname.}

   * setAttributes importc: "IupSetAttributes", cdecl, dynlib: dllname.}
          proc setAttributes*(ih: PIhandle; str: cstring): PIhandle {.
              importc: "IupSetAttributes", cdecl, dynlib: dllname.}

   * getAttribute cdecl, dynlib: dllname.}
          proc getAttribute*(ih: PIhandle; name: cstring): cstring {.importc: "IupGetAttribute",
              cdecl, dynlib: dllname.}

   * getAttributes dynlib: dllname.}
          proc getAttributes*(ih: PIhandle): cstring {.importc: "IupGetAttributes", cdecl,
              dynlib: dllname.}

   * getInt dynlib: dllname.}
          proc getInt*(ih: PIhandle; name: cstring): cint {.importc: "IupGetInt", cdecl,
              dynlib: dllname.}

   * getInt2 dynlib: dllname.}
          proc getInt2*(ih: PIhandle; name: cstring): cint {.importc: "IupGetInt2", cdecl,
              dynlib: dllname.}

   * getIntInt importc: "IupGetIntInt", cdecl, dynlib: dllname.}
          proc getIntInt*(ih: PIhandle; name: cstring; i1, i2: var cint): cint {.
              importc: "IupGetIntInt", cdecl, dynlib: dllname.}

   * getFloat dynlib: dllname.}
          proc getFloat*(ih: PIhandle; name: cstring): cfloat {.importc: "IupGetFloat", cdecl,
              dynlib: dllname.}

   * setfAttribute importc: "IupSetfAttribute", cdecl, dynlib: dllname,
     varargs.}
          proc setfAttribute*(ih: PIhandle; name, format: cstring) {.
              importc: "IupSetfAttribute", cdecl, dynlib: dllname, varargs.}

   * getAllAttributes importc: "IupGetAllAttributes", cdecl, dynlib:
     dllname.}
          proc getAllAttributes*(ih: PIhandle; names: cstringArray; n: cint): cint {.
              importc: "IupGetAllAttributes", cdecl, dynlib: dllname.}

   * setAtt importc: "IupSetAtt", cdecl, dynlib: dllname, varargs,
     discardable.}
          proc setAtt*(handleName: cstring; ih: PIhandle; name: cstring): PIhandle {.
              importc: "IupSetAtt", cdecl, dynlib: dllname, varargs, discardable.}

   * setGlobal
          proc setGlobal*(name, value: cstring) {.importc: "IupSetGlobal", cdecl, dynlib: dllname.}

   * storeGlobal dynlib: dllname.}
          proc storeGlobal*(name, value: cstring) {.importc: "IupStoreGlobal", cdecl,
                                                dynlib: dllname.}

   * getGlobal dynlib: dllname.}
          proc getGlobal*(name: cstring): cstring {.importc: "IupGetGlobal", cdecl,
                                                dynlib: dllname.}

   * setFocus
          proc setFocus*(ih: PIhandle): PIhandle {.importc: "IupSetFocus", cdecl, dynlib: dllname.}

   * getFocus
          proc getFocus*(): PIhandle {.importc: "IupGetFocus", cdecl, dynlib: dllname.}

   * previousField dynlib: dllname.}
          proc previousField*(ih: PIhandle): PIhandle {.importc: "IupPreviousField", cdecl,
              dynlib: dllname.}

   * nextField dynlib: dllname.}
          proc nextField*(ih: PIhandle): PIhandle {.importc: "IupNextField", cdecl,
                                                dynlib: dllname.}

   * getCallback cdecl, dynlib: dllname.}
          proc getCallback*(ih: PIhandle; name: cstring): Icallback {.importc: "IupGetCallback",
              cdecl, dynlib: dllname.}

   * setCallback importc: "IupSetCallback", cdecl, dynlib: dllname,
     discardable.}
          proc setCallback*(ih: PIhandle; name: cstring; fn: Icallback): Icallback {.
              importc: "IupSetCallback", cdecl, dynlib: dllname, discardable.}

   * setCallbacks importc: "IupSetCallbacks", cdecl, dynlib: dllname,
     varargs, discardable.}
          proc setCallbacks*(ih: PIhandle; name: cstring; fn: Icallback): PIhandle {.
              importc: "IupSetCallbacks", cdecl, dynlib: dllname, varargs, discardable.}

   * getFunction dynlib: dllname.}
          proc getFunction*(name: cstring): Icallback {.importc: "IupGetFunction", cdecl,
              dynlib: dllname.}

   * setFunction importc: "IupSetFunction", cdecl, dynlib: dllname,
     discardable.}
          proc setFunction*(name: cstring; fn: Icallback): Icallback {.
              importc: "IupSetFunction", cdecl, dynlib: dllname, discardable.}

   * getActionName
          proc getActionName*(): cstring {.importc: "IupGetActionName", cdecl, dynlib: dllname.}

   * getHandle dynlib: dllname.}
          proc getHandle*(name: cstring): PIhandle {.importc: "IupGetHandle", cdecl,
                                                 dynlib: dllname.}

   * setHandle dynlib: dllname.}
          proc setHandle*(name: cstring; ih: PIhandle): PIhandle {.importc: "IupSetHandle", cdecl,
              dynlib: dllname.}

   * getAllNames cdecl, dynlib: dllname.}
          proc getAllNames*(names: cstringArray; n: cint): cint {.importc: "IupGetAllNames",
              cdecl, dynlib: dllname.}

   * getAllDialogs cdecl, dynlib: dllname.}
          proc getAllDialogs*(names: cstringArray; n: cint): cint {.importc: "IupGetAllDialogs",
              cdecl, dynlib: dllname.}

   * getName
          proc getName*(ih: PIhandle): cstring {.importc: "IupGetName", cdecl, dynlib: dllname.}

   * setAttributeHandle importc: "IupSetAttributeHandle", cdecl, dynlib:
     dllname.}
          proc setAttributeHandle*(ih: PIhandle; name: cstring; ihNamed: PIhandle) {.
              importc: "IupSetAttributeHandle", cdecl, dynlib: dllname.}

   * getAttributeHandle importc: "IupGetAttributeHandle", cdecl, dynlib:
     dllname.}
          proc getAttributeHandle*(ih: PIhandle; name: cstring): PIhandle {.
              importc: "IupGetAttributeHandle", cdecl, dynlib: dllname.}

   * getClassName dynlib: dllname.}
          proc getClassName*(ih: PIhandle): cstring {.importc: "IupGetClassName", cdecl,
                                                  dynlib: dllname.}

   * getClassType dynlib: dllname.}
          proc getClassType*(ih: PIhandle): cstring {.importc: "IupGetClassType", cdecl,
                                                  dynlib: dllname.}

   * getClassAttributes importc: "IupGetClassAttributes", cdecl, dynlib:
     dllname.}
          proc getClassAttributes*(classname: cstring; names: cstringArray; n: cint): cint {.
              importc: "IupGetClassAttributes", cdecl, dynlib: dllname.}

   * saveClassAttributes dynlib: dllname.}
          proc saveClassAttributes*(ih: PIhandle) {.importc: "IupSaveClassAttributes", cdecl,
                                                 dynlib: dllname.}

   * setClassDefaultAttribute importc: "IupSetClassDefaultAttribute",
     cdecl, dynlib: dllname.}
          proc setClassDefaultAttribute*(classname, name, value: cstring) {.
              importc: "IupSetClassDefaultAttribute", cdecl, dynlib: dllname.}

   * create dynlib: dllname.}
          proc create*(classname: cstring): PIhandle {.importc: "IupCreate", cdecl,
              dynlib: dllname.}

   * createv cdecl, dynlib: dllname.}
          proc createv*(classname: cstring; params: pointer): PIhandle {.importc: "IupCreatev",
              cdecl, dynlib: dllname.}

   * createp cdecl, dynlib: dllname, varargs.}
          proc createp*(classname: cstring; first: pointer): PIhandle {.importc: "IupCreatep",
              cdecl, dynlib: dllname, varargs.}

   * fill
          proc fill*(): PIhandle {.importc: "IupFill", cdecl, dynlib: dllname.}

   * radio
          proc radio*(child: PIhandle): PIhandle {.importc: "IupRadio", cdecl, dynlib: dllname.}

   * vbox varargs.}
          proc vbox*(child: PIhandle): PIhandle {.importc: "IupVbox", cdecl, dynlib: dllname,
                                              varargs.}

   * vboxv dynlib: dllname.}
          proc vboxv*(children: ptr PIhandle): PIhandle {.importc: "IupVboxv", cdecl,
              dynlib: dllname.}

   * zbox varargs.}
          proc zbox*(child: PIhandle): PIhandle {.importc: "IupZbox", cdecl, dynlib: dllname,
                                              varargs.}

   * zboxv dynlib: dllname.}
          proc zboxv*(children: ptr PIhandle): PIhandle {.importc: "IupZboxv", cdecl,
              dynlib: dllname.}

   * hbox varargs.}
          proc hbox*(child: PIhandle): PIhandle {.importc: "IupHbox", cdecl, dynlib: dllname,
                                              varargs.}

   * hboxv dynlib: dllname.}
          proc hboxv*(children: ptr PIhandle): PIhandle {.importc: "IupHboxv", cdecl,
              dynlib: dllname.}

   * normalizer dynlib: dllname, varargs.}
          proc normalizer*(ihFirst: PIhandle): PIhandle {.importc: "IupNormalizer", cdecl,
              dynlib: dllname, varargs.}

   * normalizerv dynlib: dllname.}
          proc normalizerv*(ihList: ptr PIhandle): PIhandle {.importc: "IupNormalizerv", cdecl,
              dynlib: dllname.}

   * cbox varargs.}
          proc cbox*(child: PIhandle): PIhandle {.importc: "IupCbox", cdecl, dynlib: dllname,
                                              varargs.}

   * cboxv dynlib: dllname.}
          proc cboxv*(children: ptr PIhandle): PIhandle {.importc: "IupCboxv", cdecl,
              dynlib: dllname.}

   * sbox
          proc sbox*(child: PIhandle): PIhandle {.importc: "IupSbox", cdecl, dynlib: dllname.}

   * frame
          proc frame*(child: PIhandle): PIhandle {.importc: "IupFrame", cdecl, dynlib: dllname.}

   * image dynlib: dllname.}
          proc image*(width, height: cint; pixmap: pointer): PIhandle {.importc: "IupImage", cdecl,
              dynlib: dllname.}

   * imageRGB importc: "IupImageRGB", cdecl, dynlib: dllname.}
          proc imageRGB*(width, height: cint; pixmap: pointer): PIhandle {.
              importc: "IupImageRGB", cdecl, dynlib: dllname.}

   * imageRGBA importc: "IupImageRGBA", cdecl, dynlib: dllname.}
          proc imageRGBA*(width, height: cint; pixmap: pointer): PIhandle {.
              importc: "IupImageRGBA", cdecl, dynlib: dllname.}

   * item dynlib: dllname.}
          proc item*(title, action: cstring): PIhandle {.importc: "IupItem", cdecl,
              dynlib: dllname.}

   * submenu dynlib: dllname.}
          proc submenu*(title: cstring; child: PIhandle): PIhandle {.importc: "IupSubmenu", cdecl,
              dynlib: dllname.}

   * separator
          proc separator*(): PIhandle {.importc: "IupSeparator", cdecl, dynlib: dllname.}

   * menu varargs.}
          proc menu*(child: PIhandle): PIhandle {.importc: "IupMenu", cdecl, dynlib: dllname,
                                              varargs.}

   * menuv dynlib: dllname.}
          proc menuv*(children: ptr PIhandle): PIhandle {.importc: "IupMenuv", cdecl,
              dynlib: dllname.}

   * button dynlib: dllname.}
          proc button*(title, action: cstring): PIhandle {.importc: "IupButton", cdecl,
              dynlib: dllname.}

   * link
          proc link*(url, title: cstring): PIhandle {.importc: "IupLink", cdecl, dynlib: dllname.}

   * canvas
          proc canvas*(action: cstring): PIhandle {.importc: "IupCanvas", cdecl, dynlib: dllname.}

   * dialog
          proc dialog*(child: PIhandle): PIhandle {.importc: "IupDialog", cdecl, dynlib: dllname.}

   * user
          proc user*(): PIhandle {.importc: "IupUser", cdecl, dynlib: dllname.}

   * label
          proc label*(title: cstring): PIhandle {.importc: "IupLabel", cdecl, dynlib: dllname.}

   * list
          proc list*(action: cstring): PIhandle {.importc: "IupList", cdecl, dynlib: dllname.}

   * text
          proc text*(action: cstring): PIhandle {.importc: "IupText", cdecl, dynlib: dllname.}

   * multiLine dynlib: dllname.}
          proc multiLine*(action: cstring): PIhandle {.importc: "IupMultiLine", cdecl,
              dynlib: dllname.}

   * toggle dynlib: dllname.}
          proc toggle*(title, action: cstring): PIhandle {.importc: "IupToggle", cdecl,
              dynlib: dllname.}

   * timer
          proc timer*(): PIhandle {.importc: "IupTimer", cdecl, dynlib: dllname.}

   * progressBar
          proc progressBar*(): PIhandle {.importc: "IupProgressBar", cdecl, dynlib: dllname.}

   * val
          proc val*(theType: cstring): PIhandle {.importc: "IupVal", cdecl, dynlib: dllname.}

   * tabs varargs.}
          proc tabs*(child: PIhandle): PIhandle {.importc: "IupTabs", cdecl, dynlib: dllname,
                                              varargs.}

   * tabsv dynlib: dllname.}
          proc tabsv*(children: ptr PIhandle): PIhandle {.importc: "IupTabsv", cdecl,
              dynlib: dllname.}

   * tree
          proc tree*(): PIhandle {.importc: "IupTree", cdecl, dynlib: dllname.}

   * spin
          proc spin*(): PIhandle {.importc: "IupSpin", cdecl, dynlib: dllname.}

   * spinbox dynlib: dllname.}
          proc spinbox*(child: PIhandle): PIhandle {.importc: "IupSpinbox", cdecl,
                                                 dynlib: dllname.}

   * textConvertLinColToPos importc: "IupTextConvertLinColToPos", cdecl,
     dynlib: dllname.}
          proc textConvertLinColToPos*(ih: PIhandle; lin, col: cint; pos: var cint) {.
              importc: "IupTextConvertLinColToPos", cdecl, dynlib: dllname.}

   * textConvertPosToLinCol importc: "IupTextConvertPosToLinCol", cdecl,
     dynlib: dllname.}
          proc textConvertPosToLinCol*(ih: PIhandle; pos: cint; lin, col: var cint) {.
              importc: "IupTextConvertPosToLinCol", cdecl, dynlib: dllname.}

   * convertXYToPos cdecl, dynlib: dllname.}
          proc convertXYToPos*(ih: PIhandle; x, y: cint): cint {.importc: "IupConvertXYToPos",
              cdecl, dynlib: dllname.}

   * treeSetUserId importc: "IupTreeSetUserId", cdecl, dynlib: dllname,
     discardable.}
          proc treeSetUserId*(ih: PIhandle; id: cint; userid: pointer): cint {.
              importc: "IupTreeSetUserId", cdecl, dynlib: dllname, discardable.}

   * treeGetUserId cdecl, dynlib: dllname.}
          proc treeGetUserId*(ih: PIhandle; id: cint): pointer {.importc: "IupTreeGetUserId",
              cdecl, dynlib: dllname.}

   * treeGetId dynlib: dllname.}
          proc treeGetId*(ih: PIhandle; userid: pointer): cint {.importc: "IupTreeGetId", cdecl,
              dynlib: dllname.}

   * treeSetAttribute importc: "IupTreeSetAttribute", cdecl, dynlib:
     dllname.}
          proc treeSetAttribute*(ih: PIhandle; name: cstring; id: cint; value: cstring) {.
              importc: "IupTreeSetAttribute", cdecl, dynlib: dllname.}

   * treeStoreAttribute importc: "IupTreeStoreAttribute", cdecl, dynlib:
     dllname.}
          proc treeStoreAttribute*(ih: PIhandle; name: cstring; id: cint; value: cstring) {.
              importc: "IupTreeStoreAttribute", cdecl, dynlib: dllname.}

   * treeGetAttribute importc: "IupTreeGetAttribute", cdecl, dynlib:
     dllname.}
          proc treeGetAttribute*(ih: PIhandle; name: cstring; id: cint): cstring {.
              importc: "IupTreeGetAttribute", cdecl, dynlib: dllname.}

   * treeGetInt importc: "IupTreeGetInt", cdecl, dynlib: dllname.}
          proc treeGetInt*(ih: PIhandle; name: cstring; id: cint): cint {.
              importc: "IupTreeGetInt", cdecl, dynlib: dllname.}

   * treeGetFloat importc: "IupTreeGetFloat", cdecl, dynlib: dllname.}
          proc treeGetFloat*(ih: PIhandle; name: cstring; id: cint): cfloat {.
              importc: "IupTreeGetFloat", cdecl, dynlib: dllname.}

   * treeSetfAttribute importc: "IupTreeSetfAttribute", cdecl, dynlib:
     dllname, varargs.}
          proc treeSetfAttribute*(ih: PIhandle; name: cstring; id: cint; format: cstring) {.
              importc: "IupTreeSetfAttribute", cdecl, dynlib: dllname, varargs.}

   * isShift
          proc isShift*(s: cstring): bool

   * isControl
          proc isControl*(s: cstring): bool

   * isButton1
          proc isButton1*(s: cstring): bool

   * isButton2
          proc isButton2*(s: cstring): bool

   * isbutton3
          proc isbutton3*(s: cstring): bool

   * isDouble
          proc isDouble*(s: cstring): bool

   * isAlt
          proc isAlt*(s: cstring): bool

   * isSys
          proc isSys*(s: cstring): bool

   * isButton4
          proc isButton4*(s: cstring): bool

   * isButton5
          proc isButton5*(s: cstring): bool

   * isPrint
          proc isPrint*(c: cint): bool

   * isXkey
          proc isXkey*(c: cint): bool

   * isShiftXkey
          proc isShiftXkey*(c: cint): bool

   * isCtrlXkey
          proc isCtrlXkey*(c: cint): bool

   * isAltXkey
          proc isAltXkey*(c: cint): bool

   * isSysXkey
          proc isSysXkey*(c: cint): bool

   * iUPxCODE
          proc iUPxCODE*(c: cint): cint

   * iUPsxCODE
          proc iUPsxCODE*(c: cint): cint

   * iUPcxCODE
          proc iUPcxCODE*(c: cint): cint

   * iUPmxCODE
          proc iUPmxCODE*(c: cint): cint

   * iUPyxCODE
          proc iUPyxCODE*(c: cint): cint

   * controlsOpen
          proc controlsOpen*(): cint {.cdecl, importc: "IupControlsOpen", dynlib: dllname.}

   * controlsClose
          proc controlsClose*() {.cdecl, importc: "IupControlsClose", dynlib: dllname.}

   * oldValOpen
          proc oldValOpen*() {.cdecl, importc: "IupOldValOpen", dynlib: dllname.}

   * oldTabsOpen
          proc oldTabsOpen*() {.cdecl, importc: "IupOldTabsOpen", dynlib: dllname.}

   * colorbar
          proc colorbar*(): PIhandle {.cdecl, importc: "IupColorbar", dynlib: dllname.}

   * cells
          proc cells*(): PIhandle {.cdecl, importc: "IupCells", dynlib: dllname.}

   * colorBrowser
          proc colorBrowser*(): PIhandle {.cdecl, importc: "IupColorBrowser", dynlib: dllname.}

   * gauge
          proc gauge*(): PIhandle {.cdecl, importc: "IupGauge", dynlib: dllname.}

   * dial
          proc dial*(theType: cstring): PIhandle {.cdecl, importc: "IupDial", dynlib: dllname.}

   * matrix
          proc matrix*(action: cstring): PIhandle {.cdecl, importc: "IupMatrix", dynlib: dllname.}

   * matSetAttribute cdecl, importc: "IupMatSetAttribute", dynlib:
     dllname.}
          proc matSetAttribute*(ih: PIhandle; name: cstring; lin, col: cint; value: cstring) {.
              cdecl, importc: "IupMatSetAttribute", dynlib: dllname.}

   * matStoreAttribute cdecl, importc: "IupMatStoreAttribute", dynlib:
     dllname.}
          proc matStoreAttribute*(ih: PIhandle; name: cstring; lin, col: cint; value: cstring) {.
              cdecl, importc: "IupMatStoreAttribute", dynlib: dllname.}

   * matGetAttribute importc: "IupMatGetAttribute", dynlib: dllname.}
          proc matGetAttribute*(ih: PIhandle; name: cstring; lin, col: cint): cstring {.cdecl,
              importc: "IupMatGetAttribute", dynlib: dllname.}

   * matGetInt importc: "IupMatGetInt", dynlib: dllname.}
          proc matGetInt*(ih: PIhandle; name: cstring; lin, col: cint): cint {.cdecl,
              importc: "IupMatGetInt", dynlib: dllname.}

   * matGetFloat importc: "IupMatGetFloat", dynlib: dllname.}
          proc matGetFloat*(ih: PIhandle; name: cstring; lin, col: cint): cfloat {.cdecl,
              importc: "IupMatGetFloat", dynlib: dllname.}

   * matSetfAttribute cdecl, importc: "IupMatSetfAttribute", dynlib:
     dllname, varargs.}
          proc matSetfAttribute*(ih: PIhandle; name: cstring; lin, col: cint; format: cstring) {.
              cdecl, importc: "IupMatSetfAttribute", dynlib: dllname, varargs.}

   * pPlotOpen
          proc pPlotOpen*() {.cdecl, importc: "IupPPlotOpen", dynlib: dllname.}

   * pPlot
          proc pPlot*(): PIhandle {.cdecl, importc: "IupPPlot", dynlib: dllname.}

   * pPlotBegin dynlib: dllname.}
          proc pPlotBegin*(ih: PIhandle; strXdata: cint) {.cdecl, importc: "IupPPlotBegin",
              dynlib: dllname.}

   * pPlotAdd dynlib: dllname.}
          proc pPlotAdd*(ih: PIhandle; x, y: cfloat) {.cdecl, importc: "IupPPlotAdd",
                                                 dynlib: dllname.}

   * pPlotAddStr importc: "IupPPlotAddStr", dynlib: dllname.}
          proc pPlotAddStr*(ih: PIhandle; x: cstring; y: cfloat) {.cdecl,
              importc: "IupPPlotAddStr", dynlib: dllname.}

   * pPlotEnd
          proc pPlotEnd*(ih: PIhandle): cint {.cdecl, importc: "IupPPlotEnd", dynlib: dllname.}

   * pPlotInsertStr cdecl, importc: "IupPPlotInsertStr", dynlib:
     dllname.}
          proc pPlotInsertStr*(ih: PIhandle; index, sampleIndex: cint; x: cstring; y: cfloat) {.
              cdecl, importc: "IupPPlotInsertStr", dynlib: dllname.}

   * pPlotInsert importc: "IupPPlotInsert", dynlib: dllname.}
          proc pPlotInsert*(ih: PIhandle; index, sampleIndex: cint; x, y: cfloat) {.cdecl,
              importc: "IupPPlotInsert", dynlib: dllname.}

   * pPlotTransform importc: "IupPPlotTransform", dynlib: dllname.}
          proc pPlotTransform*(ih: PIhandle; x, y: cfloat; ix, iy: var cint) {.cdecl,
              importc: "IupPPlotTransform", dynlib: dllname.}

   * pPlotPaintTo dynlib: dllname.}
          proc pPlotPaintTo*(ih: PIhandle; cnv: pointer) {.cdecl, importc: "IupPPlotPaintTo",
              dynlib: dllname.}


File: nim-ref-0.13.0.info,  Node: /wrappers/sqlite3,  Next: /wrappers/odbcsql,  Prev: /wrappers/iup,  Up: Top

311 Constant variables
**********************

   * SQLITE_DETERMINISTIC
          SQLITE_DETERMINISTIC* = 0x00000800

   * SQLITE_TRANSIENT
          SQLITE_TRANSIENT* = cast[pointer](- 1)

312 Types
*********

   * Collation_needed_func para4: cstring) {.cdecl.}
          Collation_needed_func* = proc (para1: pointer; para2: PSqlite3; eTextRep: int32;
                                      para4: cstring) {.cdecl.}

313 Procedures
**************

   * close
          proc close*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_close".}

   * exec errmsg: var cstring): int32 {.cdecl, dynlib: Lib, importc:
     "sqlite3_exec".}
          proc exec*(para1: PSqlite3; sql: cstring; para3: Callback; para4: pointer;
                    errmsg: var cstring): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_exec".}

   * last_insert_rowid importc: "sqlite3_last_insert_rowid".}
          proc last_insert_rowid*(para1: PSqlite3): int64 {.cdecl, dynlib: Lib,
              importc: "sqlite3_last_insert_rowid".}

   * changes
          proc changes*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_changes".}

   * total_changes importc: "sqlite3_total_changes".}
          proc total_changes*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_total_changes".}

   * interrupt
          proc interrupt*(para1: PSqlite3) {.cdecl, dynlib: Lib, importc: "sqlite3_interrupt".}

   * complete
          proc complete*(sql: cstring): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_complete".}

   * complete16 importc: "sqlite3_complete16".}
          proc complete16*(sql: pointer): int32 {.cdecl, dynlib: Lib,
                                              importc: "sqlite3_complete16".}

   * busy_handler para2: proc (para1: pointer; para2: int32): int32
     {.cdecl.}; para3: pointer): int32 {.cdecl, dynlib: Lib, importc:
     "sqlite3_busy_handler".}
          proc busy_handler*(para1: PSqlite3;
                            para2: proc (para1: pointer; para2: int32): int32 {.cdecl.};
                            para3: pointer): int32 {.cdecl, dynlib: Lib,
                                                  importc: "sqlite3_busy_handler".}

   * busy_timeout importc: "sqlite3_busy_timeout".}
          proc busy_timeout*(para1: PSqlite3; ms: int32): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_busy_timeout".}

   * get_table nrow, ncolumn: var cint; errmsg: ptr cstring): int32
     {.cdecl, dynlib: Lib, importc: "sqlite3_get_table".}
          proc get_table*(para1: PSqlite3; sql: cstring; resultp: var cstringArray;
                         nrow, ncolumn: var cint; errmsg: ptr cstring): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_get_table".}

   * free_table importc: "sqlite3_free_table".}
          proc free_table*(result: cstringArray) {.cdecl, dynlib: Lib,
                                                importc: "sqlite3_free_table".}

   * mprintf importc: "sqlite3_mprintf".}
          proc mprintf*(para1: cstring): cstring {.cdecl, varargs, dynlib: Lib,
                                               importc: "sqlite3_mprintf".}

   * free
          proc free*(z: cstring) {.cdecl, dynlib: Lib, importc: "sqlite3_free".}

   * snprintf dynlib: Lib, varargs, importc: "sqlite3_snprintf".}
          proc snprintf*(para1: int32; para2: cstring; para3: cstring): cstring {.cdecl,
              dynlib: Lib, varargs, importc: "sqlite3_snprintf".}

   * set_authorizer para3: cstring; para4: cstring; para5: cstring;
     para6: cstring): int32 {.cdecl.}; pUserData: pointer): int32
     {.cdecl, dynlib: Lib, importc: "sqlite3_set_authorizer".}
          proc set_authorizer*(para1: PSqlite3; xAuth: proc (para1: pointer; para2: int32;
              para3: cstring; para4: cstring; para5: cstring; para6: cstring): int32 {.cdecl.};
                              pUserData: pointer): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_set_authorizer".}

   * trace xTrace: proc (para1: pointer; para2: cstring) {.cdecl.};
     para3: pointer): pointer {.  cdecl, dynlib: Lib, importc:
     "sqlite3_trace".}
          proc trace*(para1: PSqlite3;
                     xTrace: proc (para1: pointer; para2: cstring) {.cdecl.}; para3: pointer): pointer {.
              cdecl, dynlib: Lib, importc: "sqlite3_trace".}

   * progress_handler para3: proc (para1: pointer): int32 {.cdecl.};
     para4: pointer) {.  cdecl, dynlib: Lib, importc:
     "sqlite3_progress_handler".}
          proc progress_handler*(para1: PSqlite3; para2: int32;
                                para3: proc (para1: pointer): int32 {.cdecl.}; para4: pointer) {.
              cdecl, dynlib: Lib, importc: "sqlite3_progress_handler".}

   * commit_hook para3: pointer): pointer {.cdecl, dynlib: Lib, importc:
     "sqlite3_commit_hook".}
          proc commit_hook*(para1: PSqlite3; para2: proc (para1: pointer): int32 {.cdecl.};
                           para3: pointer): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_commit_hook".}

   * open importc: "sqlite3_open".}
          proc open*(filename: cstring; ppDb: var PSqlite3): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_open".}

   * open16 importc: "sqlite3_open16".}
          proc open16*(filename: pointer; ppDb: var PSqlite3): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_open16".}

   * errcode
          proc errcode*(db: PSqlite3): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_errcode".}

   * errmsg
          proc errmsg*(para1: PSqlite3): cstring {.cdecl, dynlib: Lib, importc: "sqlite3_errmsg".}

   * errmsg16 importc: "sqlite3_errmsg16".}
          proc errmsg16*(para1: PSqlite3): pointer {.cdecl, dynlib: Lib,
                                                 importc: "sqlite3_errmsg16".}

   * prepare pzTail: ptr cstring): int32 {.cdecl, dynlib: Lib, importc:
     "sqlite3_prepare".}
          proc prepare*(db: PSqlite3; zSql: cstring; nBytes: int32; ppStmt: var Pstmt;
                       pzTail: ptr cstring): int32 {.cdecl, dynlib: Lib,
                                                 importc: "sqlite3_prepare".}

   * prepare_v2 pzTail: ptr cstring): cint {.importc:
     "sqlite3_prepare_v2", cdecl, dynlib: Lib.}
          proc prepare_v2*(db: PSqlite3; zSql: cstring; nByte: cint; ppStmt: var Pstmt;
                          pzTail: ptr cstring): cint {.importc: "sqlite3_prepare_v2", cdecl,
              dynlib: Lib.}

   * prepare16 pzTail: var pointer): int32 {.cdecl, dynlib: Lib,
     importc: "sqlite3_prepare16".}
          proc prepare16*(db: PSqlite3; zSql: pointer; nBytes: int32; ppStmt: var Pstmt;
                         pzTail: var pointer): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_prepare16".}

   * bind_blob para5: Tbind_destructor_func): int32 {.cdecl, dynlib:
     Lib, importc: "sqlite3_bind_blob".}
          proc bind_blob*(para1: Pstmt; para2: int32; para3: pointer; n: int32;
                         para5: Tbind_destructor_func): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_blob".}

   * bind_double dynlib: Lib, importc: "sqlite3_bind_double".}
          proc bind_double*(para1: Pstmt; para2: int32; para3: float64): int32 {.cdecl,
              dynlib: Lib, importc: "sqlite3_bind_double".}

   * bind_int importc: "sqlite3_bind_int".}
          proc bind_int*(para1: Pstmt; para2: int32; para3: int32): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_int".}

   * bind_int64 importc: "sqlite3_bind_int64".}
          proc bind_int64*(para1: Pstmt; para2: int32; para3: int64): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_int64".}

   * bind_null importc: "sqlite3_bind_null".}
          proc bind_null*(para1: Pstmt; para2: int32): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_null".}

   * bind_text para5: Tbind_destructor_func): int32 {.cdecl, dynlib:
     Lib, importc: "sqlite3_bind_text".}
          proc bind_text*(para1: Pstmt; para2: int32; para3: cstring; n: int32;
                         para5: Tbind_destructor_func): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_text".}

   * bind_text16 para5: Tbind_destructor_func): int32 {.cdecl, dynlib:
     Lib, importc: "sqlite3_bind_text16".}
          proc bind_text16*(para1: Pstmt; para2: int32; para3: pointer; para4: int32;
                           para5: Tbind_destructor_func): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_text16".}

   * bind_blob cdecl, dynlib: Lib, importc: "sqlite3_bind_blob".}
          proc bind_blob*(para1: Pstmt; para2: int32; para3: pointer; n: int32; para5: int32): int32 {.
              cdecl, dynlib: Lib, importc: "sqlite3_bind_blob".}

   * bind_text cdecl, dynlib: Lib, importc: "sqlite3_bind_text".}
          proc bind_text*(para1: Pstmt; para2: int32; para3: cstring; n: int32; para5: int32): int32 {.
              cdecl, dynlib: Lib, importc: "sqlite3_bind_text".}

   * bind_text16 cdecl, dynlib: Lib, importc: "sqlite3_bind_text16".}
          proc bind_text16*(para1: Pstmt; para2: int32; para3: pointer; para4: int32; para5: int32): int32 {.
              cdecl, dynlib: Lib, importc: "sqlite3_bind_text16".}

   * bind_parameter_count importc: "sqlite3_bind_parameter_count".}
          proc bind_parameter_count*(para1: Pstmt): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_parameter_count".}

   * bind_parameter_name importc: "sqlite3_bind_parameter_name".}
          proc bind_parameter_name*(para1: Pstmt; para2: int32): cstring {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_parameter_name".}

   * bind_parameter_index importc: "sqlite3_bind_parameter_index".}
          proc bind_parameter_index*(para1: Pstmt; zName: cstring): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_bind_parameter_index".}

   * column_count importc: "sqlite3_column_count".}
          proc column_count*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib,
                                                importc: "sqlite3_column_count".}

   * column_name importc: "sqlite3_column_name".}
          proc column_name*(para1: Pstmt; para2: int32): cstring {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_name".}

   * column_table_name importc: "sqlite3_column_table_name".}
          proc column_table_name*(para1: Pstmt; para2: int32): cstring {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_table_name".}

   * column_name16 importc: "sqlite3_column_name16".}
          proc column_name16*(para1: Pstmt; para2: int32): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_name16".}

   * column_decltype importc: "sqlite3_column_decltype".}
          proc column_decltype*(para1: Pstmt; i: int32): cstring {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_decltype".}

   * column_decltype16 importc: "sqlite3_column_decltype16".}
          proc column_decltype16*(para1: Pstmt; para2: int32): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_decltype16".}

   * step
          proc step*(para1: Pstmt): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_step".}

   * data_count importc: "sqlite3_data_count".}
          proc data_count*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib,
                                              importc: "sqlite3_data_count".}

   * column_blob importc: "sqlite3_column_blob".}
          proc column_blob*(para1: Pstmt; iCol: int32): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_blob".}

   * column_bytes importc: "sqlite3_column_bytes".}
          proc column_bytes*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_bytes".}

   * column_bytes16 importc: "sqlite3_column_bytes16".}
          proc column_bytes16*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_bytes16".}

   * column_double importc: "sqlite3_column_double".}
          proc column_double*(para1: Pstmt; iCol: int32): float64 {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_double".}

   * column_int importc: "sqlite3_column_int".}
          proc column_int*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_int".}

   * column_int64 importc: "sqlite3_column_int64".}
          proc column_int64*(para1: Pstmt; iCol: int32): int64 {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_int64".}

   * column_text importc: "sqlite3_column_text".}
          proc column_text*(para1: Pstmt; iCol: int32): cstring {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_text".}

   * column_text16 importc: "sqlite3_column_text16".}
          proc column_text16*(para1: Pstmt; iCol: int32): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_text16".}

   * column_type importc: "sqlite3_column_type".}
          proc column_type*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_column_type".}

   * finalize
          proc finalize*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_finalize".}

   * reset
          proc reset*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_reset".}

   * create_function eTextRep: int32; para5: pointer; xFunc:
     Create_function_func_func; xStep: Create_function_step_func;
     xFinal: Create_function_final_func): int32 {.cdecl, dynlib: Lib,
     importc: "sqlite3_create_function".}
          proc create_function*(para1: PSqlite3; zFunctionName: cstring; nArg: int32;
                               eTextRep: int32; para5: pointer;
                               xFunc: Create_function_func_func;
                               xStep: Create_function_step_func;
                               xFinal: Create_function_final_func): int32 {.cdecl,
              dynlib: Lib, importc: "sqlite3_create_function".}

   * create_function16 eTextRep: int32; para5: pointer; xFunc:
     Create_function_func_func; xStep: Create_function_step_func;
     xFinal: Create_function_final_func): int32 {.cdecl, dynlib: Lib,
     importc: "sqlite3_create_function16".}
          proc create_function16*(para1: PSqlite3; zFunctionName: pointer; nArg: int32;
                                 eTextRep: int32; para5: pointer;
                                 xFunc: Create_function_func_func;
                                 xStep: Create_function_step_func;
                                 xFinal: Create_function_final_func): int32 {.cdecl,
              dynlib: Lib, importc: "sqlite3_create_function16".}

   * aggregate_count importc: "sqlite3_aggregate_count".}
          proc aggregate_count*(para1: Pcontext): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_aggregate_count".}

   * value_blob importc: "sqlite3_value_blob".}
          proc value_blob*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,
                                                 importc: "sqlite3_value_blob".}

   * value_bytes importc: "sqlite3_value_bytes".}
          proc value_bytes*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,
                                                importc: "sqlite3_value_bytes".}

   * value_bytes16 importc: "sqlite3_value_bytes16".}
          proc value_bytes16*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,
                                                  importc: "sqlite3_value_bytes16".}

   * value_double importc: "sqlite3_value_double".}
          proc value_double*(para1: Pvalue): float64 {.cdecl, dynlib: Lib,
              importc: "sqlite3_value_double".}

   * value_int importc: "sqlite3_value_int".}
          proc value_int*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,
                                              importc: "sqlite3_value_int".}

   * value_int64 importc: "sqlite3_value_int64".}
          proc value_int64*(para1: Pvalue): int64 {.cdecl, dynlib: Lib,
                                                importc: "sqlite3_value_int64".}

   * value_text importc: "sqlite3_value_text".}
          proc value_text*(para1: Pvalue): cstring {.cdecl, dynlib: Lib,
                                                 importc: "sqlite3_value_text".}

   * value_text16 importc: "sqlite3_value_text16".}
          proc value_text16*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_value_text16".}

   * value_text16le importc: "sqlite3_value_text16le".}
          proc value_text16le*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_value_text16le".}

   * value_text16be importc: "sqlite3_value_text16be".}
          proc value_text16be*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_value_text16be".}

   * value_type importc: "sqlite3_value_type".}
          proc value_type*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,
                                               importc: "sqlite3_value_type".}

   * aggregate_context importc: "sqlite3_aggregate_context".}
          proc aggregate_context*(para1: Pcontext; nBytes: int32): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_aggregate_context".}

   * user_data importc: "sqlite3_user_data".}
          proc user_data*(para1: Pcontext): pointer {.cdecl, dynlib: Lib,
                                                  importc: "sqlite3_user_data".}

   * get_auxdata importc: "sqlite3_get_auxdata".}
          proc get_auxdata*(para1: Pcontext; para2: int32): pointer {.cdecl, dynlib: Lib,
              importc: "sqlite3_get_auxdata".}

   * set_auxdata para4: proc (para1: pointer) {.cdecl.}) {.cdecl,
     dynlib: Lib, importc: "sqlite3_set_auxdata".}
          proc set_auxdata*(para1: Pcontext; para2: int32; para3: pointer;
                           para4: proc (para1: pointer) {.cdecl.}) {.cdecl, dynlib: Lib,
              importc: "sqlite3_set_auxdata".}

   * result_blob cdecl, dynlib: Lib, importc: "sqlite3_result_blob".}
          proc result_blob*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.
              cdecl, dynlib: Lib, importc: "sqlite3_result_blob".}

   * result_double importc: "sqlite3_result_double".}
          proc result_double*(para1: Pcontext; para2: float64) {.cdecl, dynlib: Lib,
              importc: "sqlite3_result_double".}

   * result_error importc: "sqlite3_result_error".}
          proc result_error*(para1: Pcontext; para2: cstring; para3: int32) {.cdecl, dynlib: Lib,
              importc: "sqlite3_result_error".}

   * result_error16 dynlib: Lib, importc: "sqlite3_result_error16".}
          proc result_error16*(para1: Pcontext; para2: pointer; para3: int32) {.cdecl,
              dynlib: Lib, importc: "sqlite3_result_error16".}

   * result_int importc: "sqlite3_result_int".}
          proc result_int*(para1: Pcontext; para2: int32) {.cdecl, dynlib: Lib,
              importc: "sqlite3_result_int".}

   * result_int64 importc: "sqlite3_result_int64".}
          proc result_int64*(para1: Pcontext; para2: int64) {.cdecl, dynlib: Lib,
              importc: "sqlite3_result_int64".}

   * result_null importc: "sqlite3_result_null".}
          proc result_null*(para1: Pcontext) {.cdecl, dynlib: Lib,
                                            importc: "sqlite3_result_null".}

   * result_text cdecl, dynlib: Lib, importc: "sqlite3_result_text".}
          proc result_text*(para1: Pcontext; para2: cstring; para3: int32; para4: Result_func) {.
              cdecl, dynlib: Lib, importc: "sqlite3_result_text".}

   * result_text16 cdecl, dynlib: Lib, importc:
     "sqlite3_result_text16".}
          proc result_text16*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.
              cdecl, dynlib: Lib, importc: "sqlite3_result_text16".}

   * result_text16le cdecl, dynlib: Lib, importc:
     "sqlite3_result_text16le".}
          proc result_text16le*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.
              cdecl, dynlib: Lib, importc: "sqlite3_result_text16le".}

   * result_text16be cdecl, dynlib: Lib, importc:
     "sqlite3_result_text16be".}
          proc result_text16be*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.
              cdecl, dynlib: Lib, importc: "sqlite3_result_text16be".}

   * result_value importc: "sqlite3_result_value".}
          proc result_value*(para1: Pcontext; para2: Pvalue) {.cdecl, dynlib: Lib,
              importc: "sqlite3_result_value".}

   * create_collation para4: pointer; xCompare: Create_collation_func):
     int32 {.  cdecl, dynlib: Lib, importc: "sqlite3_create_collation".}
          proc create_collation*(para1: PSqlite3; zName: cstring; eTextRep: int32;
                                para4: pointer; xCompare: Create_collation_func): int32 {.
              cdecl, dynlib: Lib, importc: "sqlite3_create_collation".}

   * create_collation16 para4: pointer; xCompare:
     Create_collation_func): int32 {.  cdecl, dynlib: Lib, importc:
     "sqlite3_create_collation16".}
          proc create_collation16*(para1: PSqlite3; zName: cstring; eTextRep: int32;
                                  para4: pointer; xCompare: Create_collation_func): int32 {.
              cdecl, dynlib: Lib, importc: "sqlite3_create_collation16".}

   * collation_needed cdecl, dynlib: Lib, importc:
     "sqlite3_collation_needed".}
          proc collation_needed*(para1: PSqlite3; para2: pointer; para3: Collation_needed_func): int32 {.
              cdecl, dynlib: Lib, importc: "sqlite3_collation_needed".}

   * collation_needed16 para3: Collation_needed_func): int32 {.cdecl,
     dynlib: Lib, importc: "sqlite3_collation_needed16".}
          proc collation_needed16*(para1: PSqlite3; para2: pointer;
                                  para3: Collation_needed_func): int32 {.cdecl, dynlib: Lib,
              importc: "sqlite3_collation_needed16".}

   * libversion
          proc libversion*(): cstring {.cdecl, dynlib: Lib, importc: "sqlite3_libversion".}

   * version
          proc version*(): cstring {.cdecl, dynlib: Lib, importc: "sqlite3_libversion".}

   * libversion_number importc: "sqlite3_libversion_number".}
          proc libversion_number*(): int32 {.cdecl, dynlib: Lib,
                                          importc: "sqlite3_libversion_number".}


File: nim-ref-0.13.0.info,  Node: /wrappers/odbcsql,  Next: /wrappers/libuv,  Prev: /wrappers/sqlite3,  Up: Top

314 Constant variables
**********************

   * SQL_GUID
          SQL_GUID* = - 11

   * SQL_INTERVAL_MINUTE_TO_SECOND
          SQL_INTERVAL_MINUTE_TO_SECOND* = 100 + SQL_CODE_MINUTE_TO_SECOND

   * SQL_UNICODE_CHAR
          SQL_UNICODE_CHAR* = SQL_UNICODE

   * SQL_TYPE_NULL
          SQL_TYPE_NULL* = 0

   * SQL_TYPE_MAX
          SQL_TYPE_MAX* = SQL_VARCHAR

   * SQL_NO_TOTAL
          SQL_NO_TOTAL* = - 4

   * SQL_COLUMN_ALIAS
          SQL_COLUMN_ALIAS* = 87

315 Types
*********

   * PSQLHANDLE
          PSQLHANDLE* = ptr SqlHandle

   * PSQL_TIMESTAMP_STRUCT
          PSQL_TIMESTAMP_STRUCT* = ptr SQL_TIMESTAMP_STRUCT

316 Procedures
**************

   * SQLAllocHandle OutputHandlePtr: var SqlHandle): TSqlSmallInt
     {.dynlib: odbclib, importc.}
          proc SQLAllocHandle*(HandleType: TSqlSmallInt; InputHandle: SqlHandle;
                              OutputHandlePtr: var SqlHandle): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLSetEnvAttr Value: TSqlInteger; StringLength: TSqlInteger):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLSetEnvAttr*(EnvironmentHandle: SqlHEnv; Attribute: TSqlInteger;
                             Value: TSqlInteger; StringLength: TSqlInteger): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLGetEnvAttr Value: SqlPointer; BufferLength: TSqlInteger;
     StringLength: PSQLINTEGER): TSqlSmallInt {.dynlib: odbclib,
     importc.}
          proc SQLGetEnvAttr*(EnvironmentHandle: SqlHEnv; Attribute: TSqlInteger;
                             Value: SqlPointer; BufferLength: TSqlInteger;
                             StringLength: PSQLINTEGER): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLFreeHandle dynlib: odbclib, importc.}
          proc SQLFreeHandle*(HandleType: TSqlSmallInt; Handle: SqlHandle): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLGetDiagRec RecNumber: TSqlSmallInt; Sqlstate: PSQLCHAR;
     NativeError: var TSqlInteger; MessageText: PSQLCHAR; BufferLength:
     TSqlSmallInt; TextLength: var TSqlSmallInt): TSqlSmallInt {.
     dynlib: odbclib, importc.}
          proc SQLGetDiagRec*(HandleType: TSqlSmallInt; Handle: SqlHandle;
                             RecNumber: TSqlSmallInt; Sqlstate: PSQLCHAR;
                             NativeError: var TSqlInteger; MessageText: PSQLCHAR;
                             BufferLength: TSqlSmallInt; TextLength: var TSqlSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLGetDiagField RecNumber: TSqlSmallInt; DiagIdentifier:
     TSqlSmallInt; DiagInfoPtr: SqlPointer; BufferLength: TSqlSmallInt;
     StringLengthPtr: var TSqlSmallInt): TSqlSmallInt {.  dynlib:
     odbclib, importc.}
          proc SQLGetDiagField*(HandleType: TSqlSmallInt; Handle: SqlHandle;
                               RecNumber: TSqlSmallInt; DiagIdentifier: TSqlSmallInt;
                               DiagInfoPtr: SqlPointer; BufferLength: TSqlSmallInt;
                               StringLengthPtr: var TSqlSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLConnect NameLength1: TSqlSmallInt; UserName: PSQLCHAR;
     NameLength2: TSqlSmallInt; Authentication: PSQLCHAR; NameLength3:
     TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}
          proc SQLConnect*(ConnectionHandle: SqlHDBC; ServerName: PSQLCHAR;
                          NameLength1: TSqlSmallInt; UserName: PSQLCHAR;
                          NameLength2: TSqlSmallInt; Authentication: PSQLCHAR;
                          NameLength3: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLDisconnect importc.}
          proc SQLDisconnect*(ConnectionHandle: SqlHDBC): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLDriverConnect szCLen: TSqlSmallInt; szCsout: cstring; cbCSMax:
     TSqlSmallInt; cbCsOut: var TSqlSmallInt; f: SqlUSmallInt):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLDriverConnect*(hdbc: SqlHDBC; hwnd: SqlHWND; szCsin: cstring;
                                szCLen: TSqlSmallInt; szCsout: cstring; cbCSMax: TSqlSmallInt;
                                cbCsOut: var TSqlSmallInt; f: SqlUSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLBrowseConnect cbConnStrIn: TSqlSmallInt; szConnStrOut: PSQLCHAR;
     cbConnStrOutMax: TSqlSmallInt; cbConnStrOut: var TSqlSmallInt):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLBrowseConnect*(hdbc: SqlHDBC; szConnStrIn: PSQLCHAR;
                                cbConnStrIn: TSqlSmallInt; szConnStrOut: PSQLCHAR;
                                cbConnStrOutMax: TSqlSmallInt;
                                cbConnStrOut: var TSqlSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLExecDirect TextLength: TSqlInteger): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLExecDirect*(StatementHandle: SqlHStmt; StatementText: PSQLCHAR;
                             TextLength: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLExecDirectW TextLength: TSqlInteger): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLExecDirectW*(StatementHandle: SqlHStmt; StatementText: WideCString;
                              TextLength: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLPrepare TextLength: TSqlInteger): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLPrepare*(StatementHandle: SqlHStmt; StatementText: PSQLCHAR;
                          TextLength: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLPrepareW TextLength: TSqlInteger): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLPrepareW*(StatementHandle: SqlHStmt; StatementText: WideCString;
                           TextLength: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLCloseCursor importc.}
          proc SQLCloseCursor*(StatementHandle: SqlHStmt): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLExecute
          proc SQLExecute*(StatementHandle: SqlHStmt): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLFetch
          proc SQLFetch*(StatementHandle: SqlHStmt): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLNumResultCols dynlib: odbclib, importc.}
          proc SQLNumResultCols*(StatementHandle: SqlHStmt; ColumnCount: var TSqlSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLDescribeCol ColumnName: PSQLCHAR; BufferLength: TSqlSmallInt;
     NameLength: var TSqlSmallInt; DataType: var TSqlSmallInt;
     ColumnSize: var SqlUInteger; DecimalDigits: var TSqlSmallInt;
     Nullable: var TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib,
     importc.}
          proc SQLDescribeCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                              ColumnName: PSQLCHAR; BufferLength: TSqlSmallInt;
                              NameLength: var TSqlSmallInt; DataType: var TSqlSmallInt;
                              ColumnSize: var SqlUInteger; DecimalDigits: var TSqlSmallInt;
                              Nullable: var TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLFetchScroll FetchOffset: TSqlInteger): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLFetchScroll*(StatementHandle: SqlHStmt; FetchOrientation: TSqlSmallInt;
                              FetchOffset: TSqlInteger): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLExtendedFetch pcrow: PSQLUINTEGER; rgfRowStatus: PSQLUSMALLINT):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLExtendedFetch*(hstmt: SqlHStmt; fFetchType: SqlUSmallInt; irow: TSqlInteger;
                                pcrow: PSQLUINTEGER; rgfRowStatus: PSQLUSMALLINT): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLGetData TargetType: TSqlSmallInt; TargetValue: SqlPointer;
     BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLGetData*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                          TargetType: TSqlSmallInt; TargetValue: SqlPointer;
                          BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLSetStmtAttr Value: SqlPointer; StringLength: TSqlInteger):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLSetStmtAttr*(StatementHandle: SqlHStmt; Attribute: TSqlInteger;
                              Value: SqlPointer; StringLength: TSqlInteger): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLGetStmtAttr Value: SqlPointer; BufferLength: TSqlInteger;
     StringLength: PSQLINTEGER): TSqlSmallInt {.dynlib: odbclib,
     importc.}
          proc SQLGetStmtAttr*(StatementHandle: SqlHStmt; Attribute: TSqlInteger;
                              Value: SqlPointer; BufferLength: TSqlInteger;
                              StringLength: PSQLINTEGER): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLGetInfo InfoValue: SqlPointer; BufferLength: TSqlSmallInt;
     StringLength: PSQLSMALLINT): TSqlSmallInt {.dynlib: odbclib,
     importc.}
          proc SQLGetInfo*(ConnectionHandle: SqlHDBC; InfoType: SqlUSmallInt;
                          InfoValue: SqlPointer; BufferLength: TSqlSmallInt;
                          StringLength: PSQLSMALLINT): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLBulkOperations dynlib: odbclib, importc.}
          proc SQLBulkOperations*(StatementHandle: SqlHStmt; Operation: TSqlSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLPutData StrLen_or_Ind: TSqlInteger): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLPutData*(StatementHandle: SqlHStmt; Data: SqlPointer;
                          StrLen_or_Ind: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLBindCol TargetType: TSqlSmallInt; TargetValue: SqlPointer;
     BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLBindCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                          TargetType: TSqlSmallInt; TargetValue: SqlPointer;
                          BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLSetPos fLock: SqlUSmallInt): TSqlSmallInt {.dynlib: odbclib,
     importc.}
          proc SQLSetPos*(hstmt: SqlHStmt; irow: SqlUSmallInt; fOption: SqlUSmallInt;
                         fLock: SqlUSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLDataSources ServerName: PSQLCHAR; BufferLength1: TSqlSmallInt;
     NameLength1: PSQLSMALLINT; Description: PSQLCHAR; BufferLength2:
     TSqlSmallInt; NameLength2: PSQLSMALLINT): TSqlSmallInt {.  dynlib:
     odbclib, importc.}
          proc SQLDataSources*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;
                              ServerName: PSQLCHAR; BufferLength1: TSqlSmallInt;
                              NameLength1: PSQLSMALLINT; Description: PSQLCHAR;
                              BufferLength2: TSqlSmallInt; NameLength2: PSQLSMALLINT): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLDrivers DriverDescription: PSQLCHAR; BufferLength1:
     TSqlSmallInt; DescriptionLength1: PSQLSMALLINT; DriverAttributes:
     PSQLCHAR; BufferLength2: TSqlSmallInt; AttributesLength2:
     PSQLSMALLINT): TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLDrivers*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;
                          DriverDescription: PSQLCHAR; BufferLength1: TSqlSmallInt;
                          DescriptionLength1: PSQLSMALLINT; DriverAttributes: PSQLCHAR;
                          BufferLength2: TSqlSmallInt; AttributesLength2: PSQLSMALLINT): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLSetConnectAttr Value: SqlPointer; StringLength: TSqlInteger):
     TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLSetConnectAttr*(ConnectionHandle: SqlHDBC; Attribute: TSqlInteger;
                                 Value: SqlPointer; StringLength: TSqlInteger): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLGetCursorName BufferLength: TSqlSmallInt; NameLength:
     PSQLSMALLINT): TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLGetCursorName*(StatementHandle: SqlHStmt; CursorName: PSQLCHAR;
                                BufferLength: TSqlSmallInt; NameLength: PSQLSMALLINT): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLSetCursorName NameLength: TSqlSmallInt): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLSetCursorName*(StatementHandle: SqlHStmt; CursorName: PSQLCHAR;
                                NameLength: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLRowCount dynlib: odbclib, importc.}
          proc SQLRowCount*(StatementHandle: SqlHStmt; RowCount: var TSqlInteger): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLBindParameter fCType: TSqlSmallInt; fSqlType: TSqlSmallInt;
     cbColDef: SqlUInteger; ibScale: TSqlSmallInt; rgbValue: SqlPointer;
     cbValueMax: TSqlInteger; pcbValue: PSQLINTEGER): TSqlSmallInt
     {.dynlib: odbclib, importc.}
          proc SQLBindParameter*(hstmt: SqlHStmt; ipar: SqlUSmallInt; fParamType: TSqlSmallInt;
                                fCType: TSqlSmallInt; fSqlType: TSqlSmallInt;
                                cbColDef: SqlUInteger; ibScale: TSqlSmallInt;
                                rgbValue: SqlPointer; cbValueMax: TSqlInteger;
                                pcbValue: PSQLINTEGER): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLFreeStmt dynlib: odbclib, importc.}
          proc SQLFreeStmt*(StatementHandle: SqlHStmt; Option: SqlUSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLColAttribute FieldIdentifier: SqlUSmallInt; CharacterAttribute:
     PSQLCHAR; BufferLength: TSqlSmallInt; StringLength: PSQLSMALLINT;
     NumericAttribute: SqlPointer): TSqlSmallInt {.dynlib: odbclib,
     importc.}
          proc SQLColAttribute*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                               FieldIdentifier: SqlUSmallInt; CharacterAttribute: PSQLCHAR;
                               BufferLength: TSqlSmallInt; StringLength: PSQLSMALLINT;
                               NumericAttribute: SqlPointer): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLEndTran CompletionType: TSqlSmallInt): TSqlSmallInt {.dynlib:
     odbclib, importc.}
          proc SQLEndTran*(HandleType: TSqlSmallInt; Handle: SqlHandle;
                          CompletionType: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLTables cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
     cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR; cbTableName:
     TSqlSmallInt; szTableType: PSQLCHAR; cbTableType: TSqlSmallInt):
     TSqlSmallInt {.dynlib: odbclib, importc.}
          proc SQLTables*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
                         cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
                         cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
                         cbTableName: TSqlSmallInt; szTableType: PSQLCHAR;
                         cbTableType: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLColumns cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
     cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR; cbTableName:
     TSqlSmallInt; szColumnName: PSQLCHAR; cbColumnName: TSqlSmallInt):
     TSqlSmallInt {.dynlib: odbclib, importc.}
          proc SQLColumns*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
                          cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
                          cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
                          cbTableName: TSqlSmallInt; szColumnName: PSQLCHAR;
                          cbColumnName: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLSpecialColumns CatalogName: PSQLCHAR; NameLength1: TSqlSmallInt;
     SchemaName: PSQLCHAR; NameLength2: TSqlSmallInt; TableName:
     PSQLCHAR; NameLength3: TSqlSmallInt; Scope: SqlUSmallInt; Nullable:
     SqlUSmallInt): TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLSpecialColumns*(StatementHandle: SqlHStmt; IdentifierType: SqlUSmallInt;
                                 CatalogName: PSQLCHAR; NameLength1: TSqlSmallInt;
                                 SchemaName: PSQLCHAR; NameLength2: TSqlSmallInt;
                                 TableName: PSQLCHAR; NameLength3: TSqlSmallInt;
                                 Scope: SqlUSmallInt; Nullable: SqlUSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLProcedures cbTableQualifier: TSqlSmallInt; szTableOwner:
     PSQLCHAR; cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
     cbTableName: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib,
     importc.}
          proc SQLProcedures*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
                             cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
                             cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
                             cbTableName: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLPrimaryKeys NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
     NameLength2: TSqlSmallInt; TableName: PSQLCHAR; NameLength3:
     TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}
          proc SQLPrimaryKeys*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                              NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                              NameLength2: TSqlSmallInt; TableName: PSQLCHAR;
                              NameLength3: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib,
              importc.}

   * SQLProcedureColumns NameLength1: TSqlSmallInt; SchemaName:
     PSQLCHAR; NameLength2: TSqlSmallInt; ProcName: PSQLCHAR;
     NameLength3: TSqlSmallInt; ColumnName: PSQLCHAR; NameLength4:
     TSqlSmallInt): TSqlSmallInt {.  dynlib: odbclib, importc.}
          proc SQLProcedureColumns*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                                   NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                                   NameLength2: TSqlSmallInt; ProcName: PSQLCHAR;
                                   NameLength3: TSqlSmallInt; ColumnName: PSQLCHAR;
                                   NameLength4: TSqlSmallInt): TSqlSmallInt {.
              dynlib: odbclib, importc.}

   * SQLStatistics NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
     NameLength2: TSqlSmallInt; TableName: PSQLCHAR; NameLength3:
     TSqlSmallInt; Unique: SqlUSmallInt; Reserved: SqlUSmallInt):
     TSqlSmallInt {.dynlib: odbclib, importc.}
          proc SQLStatistics*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                             NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                             NameLength2: TSqlSmallInt; TableName: PSQLCHAR;
                             NameLength3: TSqlSmallInt; Unique: SqlUSmallInt;
                             Reserved: SqlUSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}

   * SQLErr szSqlState, pfNativeError, szErrorMsg: PSQLCHAR;
     cbErrorMsgMax: TSqlSmallInt; pcbErrorMsg: PSQLINTEGER):
     TSqlSmallInt {.  dynlib: odbclib, importc: "SQLError".}
          proc SQLErr*(henv: SqlHEnv; hdbc: SqlHDBC; hstmt: SqlHStmt;
                      szSqlState, pfNativeError, szErrorMsg: PSQLCHAR;
                      cbErrorMsgMax: TSqlSmallInt; pcbErrorMsg: PSQLINTEGER): TSqlSmallInt {.
              dynlib: odbclib, importc: "SQLError".}


File: nim-ref-0.13.0.info,  Node: /wrappers/libuv,  Next: /wrappers/joyent_http_parser,  Prev: /wrappers/odbcsql,  Up: Top

317 Types
*********

   * PAresChannel
          PAresChannel* = pointer

318 Procedures
**************

   * loop_new
          proc loop_new*(): PLoop {.importc: "uv_loop_new", header: "uv.h".}

   * loop_delete
          proc loop_delete*(a2: PLoop) {.importc: "uv_loop_delete", header: "uv.h".}

   * default_loop
          proc default_loop*(): PLoop {.importc: "uv_default_loop", header: "uv.h".}

   * run
          proc run*(a2: PLoop): cint {.importc: "uv_run", header: "uv.h".}

   * addref
          proc addref*(a2: PLoop) {.importc: "uv_ref", header: "uv.h".}

   * unref
          proc unref*(a2: PLoop) {.importc: "uv_unref", header: "uv.h".}

   * update_time
          proc update_time*(a2: PLoop) {.importc: "uv_update_time", header: "uv.h".}

   * now
          proc now*(a2: PLoop): int64 {.importc: "uv_now", header: "uv.h".}

   * last_error
          proc last_error*(a2: PLoop): Err {.importc: "uv_last_error", header: "uv.h".}

   * strerror
          proc strerror*(err: Err): cstring {.importc: "uv_strerror", header: "uv.h".}

   * err_name
          proc err_name*(err: Err): cstring {.importc: "uv_err_name", header: "uv.h".}

   * shutdown importc: "uv_shutdown", header: "uv.h".}
          proc shutdown*(req: PShutdown; handle: PStream; cb: ShutdownProc): cint {.
              importc: "uv_shutdown", header: "uv.h".}

   * is_active
          proc is_active*(handle: PHandle): cint {.importc: "uv_is_active", header: "uv.h".}

   * close
          proc close*(handle: PHandle; close_cb: CloseProc) {.importc: "uv_close", header: "uv.h".}

   * buf_init
          proc buf_init*(base: cstring; len: csize): Buf {.importc: "uv_buf_init", header: "uv.h".}

   * listen importc: "uv_listen", header: "uv.h".}
          proc listen*(stream: PStream; backlog: cint; cb: ConnectionProc): cint {.
              importc: "uv_listen", header: "uv.h".}

   * accept header: "uv.h".}
          proc accept*(server: PStream; client: PStream): cint {.importc: "uv_accept",
              header: "uv.h".}

   * read_start importc: "uv_read_start", header: "uv.h".}
          proc read_start*(a2: PStream; alloc_cb: AllocProc; read_cb: ReadProc): cint {.
              importc: "uv_read_start", header: "uv.h".}

   * read_start importc: "uv_read2_start", header: "uv.h".}
          proc read_start*(a2: PStream; alloc_cb: AllocProc; read_cb: ReadProc2): cint {.
              importc: "uv_read2_start", header: "uv.h".}

   * read_stop
          proc read_stop*(a2: PStream): cint {.importc: "uv_read_stop", header: "uv.h".}

   * write importc: "uv_write", header: "uv.h".}
          proc write*(req: PWrite; handle: PStream; bufs: ptr Buf; bufcnt: cint; cb: WriteProc): cint {.
              importc: "uv_write", header: "uv.h".}

   * write send_handle: PStream; cb: WriteProc): cint {.importc:
     "uv_write2", header: "uv.h".}
          proc write*(req: PWrite; handle: PStream; bufs: ptr Buf; bufcnt: cint;
                     send_handle: PStream; cb: WriteProc): cint {.importc: "uv_write2",
              header: "uv.h".}

   * tcp_init
          proc tcp_init*(a2: PLoop; handle: PTcp): cint {.importc: "uv_tcp_init", header: "uv.h".}

   * tcp_bind header: "uv.h".}
          proc tcp_bind*(handle: PTcp; a3: SockAddrIn): cint {.importc: "uv_tcp_bind",
              header: "uv.h".}

   * tcp_bind6 header: "uv.h".}
          proc tcp_bind6*(handle: PTcp; a3: TSockAddrIn6): cint {.importc: "uv_tcp_bind6",
              header: "uv.h".}

   * tcp_getsockname importc: "uv_tcp_getsockname", header: "uv.h".}
          proc tcp_getsockname*(handle: PTcp; name: ptr SockAddr; namelen: var cint): cint {.
              importc: "uv_tcp_getsockname", header: "uv.h".}

   * tcp_getpeername importc: "uv_tcp_getpeername", header: "uv.h".}
          proc tcp_getpeername*(handle: PTcp; name: ptr SockAddr; namelen: var cint): cint {.
              importc: "uv_tcp_getpeername", header: "uv.h".}

   * tcp_connect importc: "uv_tcp_connect", header: "uv.h".}
          proc tcp_connect*(req: PConnect; handle: PTcp; address: SockAddrIn; cb: ConnectProc): cint {.
              importc: "uv_tcp_connect", header: "uv.h".}

   * tcp_connect6 importc: "uv_tcp_connect6", header: "uv.h".}
          proc tcp_connect6*(req: PConnect; handle: PTcp; address: TSockAddrIn6; cb: ConnectProc): cint {.
              importc: "uv_tcp_connect6", header: "uv.h".}

   * udp_init
          proc udp_init*(a2: PLoop; handle: PUdp): cint {.importc: "uv_udp_init", header: "uv.h".}

   * udp_bind importc: "uv_udp_bind", header: "uv.h".}
          proc udp_bind*(handle: PUdp; adr: SockAddrIn; flags: cunsigned): cint {.
              importc: "uv_udp_bind", header: "uv.h".}

   * udp_bind6 importc: "uv_udp_bind6", header: "uv.h".}
          proc udp_bind6*(handle: PUdp; adr: TSockAddrIn6; flags: cunsigned): cint {.
              importc: "uv_udp_bind6", header: "uv.h".}

   * udp_getsockname importc: "uv_udp_getsockname", header: "uv.h".}
          proc udp_getsockname*(handle: PUdp; name: ptr SockAddr; namelen: var cint): cint {.
              importc: "uv_udp_getsockname", header: "uv.h".}

   * udp_send send_cb: UdpSendProc): cint {.importc: "uv_udp_send",
     header: "uv.h".}
          proc udp_send*(req: PUdpSend; handle: PUdp; bufs: ptr Buf; bufcnt: cint; adr: SockAddrIn;
                        send_cb: UdpSendProc): cint {.importc: "uv_udp_send", header: "uv.h".}

   * udp_send6 adr: TSockAddrIn6; send_cb: UdpSendProc): cint {.
     importc: "uv_udp_send6", header: "uv.h".}
          proc udp_send6*(req: PUdpSend; handle: PUdp; bufs: ptr Buf; bufcnt: cint;
                         adr: TSockAddrIn6; send_cb: UdpSendProc): cint {.
              importc: "uv_udp_send6", header: "uv.h".}

   * udp_recv_start importc: "uv_udp_recv_start", header: "uv.h".}
          proc udp_recv_start*(handle: PUdp; alloc_cb: AllocProc; recv_cb: UdpRecvProc): cint {.
              importc: "uv_udp_recv_start", header: "uv.h".}

   * udp_recv_stop
          proc udp_recv_stop*(handle: PUdp): cint {.importc: "uv_udp_recv_stop", header: "uv.h".}

   * tty_init header: "uv.h".}
          proc tty_init*(a2: PLoop; a3: pTTy; fd: File): cint {.importc: "uv_tty_init",
              header: "uv.h".}

   * tty_set_mode header: "uv.h".}
          proc tty_set_mode*(a2: pTTy; mode: cint): cint {.importc: "uv_tty_set_mode",
              header: "uv.h".}

   * tty_get_winsize importc: "uv_tty_get_winsize", header: "uv.h".}
          proc tty_get_winsize*(a2: pTTy; width: var cint; height: var cint): cint {.
              importc: "uv_tty_get_winsize", header: "uv.h".}

   * tty_reset_mode
          proc tty_reset_mode*() {.importc: "uv_tty_reset_mode", header: "uv.h".}

   * guess_handle header: "uv.h".}
          proc guess_handle*(file: File): HandleType {.importc: "uv_guess_handle",
              header: "uv.h".}

   * pipe_init header: "uv.h".}
          proc pipe_init*(a2: PLoop; handle: PPipe; ipc: int): cint {.importc: "uv_pipe_init",
              header: "uv.h".}

   * pipe_open
          proc pipe_open*(a2: PPipe; file: File) {.importc: "uv_pipe_open", header: "uv.h".}

   * pipe_bind header: "uv.h".}
          proc pipe_bind*(handle: PPipe; name: cstring): cint {.importc: "uv_pipe_bind",
              header: "uv.h".}

   * pipe_connect importc: "uv_pipe_connect", header: "uv.h".}
          proc pipe_connect*(req: PConnect; handle: PPipe; name: cstring; cb: ConnectProc): cint {.
              importc: "uv_pipe_connect", header: "uv.h".}

   * prepare_init header: "uv.h".}
          proc prepare_init*(a2: PLoop; prepare: PPrepare): cint {.importc: "uv_prepare_init",
              header: "uv.h".}

   * prepare_start importc: "uv_prepare_start", header: "uv.h".}
          proc prepare_start*(prepare: PPrepare; cb: PrepareProc): cint {.
              importc: "uv_prepare_start", header: "uv.h".}

   * prepare_stop header: "uv.h".}
          proc prepare_stop*(prepare: PPrepare): cint {.importc: "uv_prepare_stop",
              header: "uv.h".}

   * check_init header: "uv.h".}
          proc check_init*(a2: PLoop; check: PCheck): cint {.importc: "uv_check_init",
              header: "uv.h".}

   * check_start header: "uv.h".}
          proc check_start*(check: PCheck; cb: CheckProc): cint {.importc: "uv_check_start",
              header: "uv.h".}

   * check_stop
          proc check_stop*(check: PCheck): cint {.importc: "uv_check_stop", header: "uv.h".}

   * idle_init
          proc idle_init*(a2: PLoop; idle: PIdle): cint {.importc: "uv_idle_init", header: "uv.h".}

   * idle_start header: "uv.h".}
          proc idle_start*(idle: PIdle; cb: IdleProc): cint {.importc: "uv_idle_start",
              header: "uv.h".}

   * idle_stop
          proc idle_stop*(idle: PIdle): cint {.importc: "uv_idle_stop", header: "uv.h".}

   * async_init importc: "uv_async_init", header: "uv.h".}
          proc async_init*(a2: PLoop; async: PAsync; async_cb: AsyncProc): cint {.
              importc: "uv_async_init", header: "uv.h".}

   * async_send
          proc async_send*(async: PAsync): cint {.importc: "uv_async_send", header: "uv.h".}

   * timer_init header: "uv.h".}
          proc timer_init*(a2: PLoop; timer: PTimer): cint {.importc: "uv_timer_init",
              header: "uv.h".}

   * timer_start importc: "uv_timer_start", header: "uv.h".}
          proc timer_start*(timer: PTimer; cb: TimerProc; timeout: int64; repeat: int64): cint {.
              importc: "uv_timer_start", header: "uv.h".}

   * timer_stop
          proc timer_stop*(timer: PTimer): cint {.importc: "uv_timer_stop", header: "uv.h".}

   * timer_again
          proc timer_again*(timer: PTimer): cint {.importc: "uv_timer_again", header: "uv.h".}

   * timer_set_repeat importc: "uv_timer_set_repeat", header: "uv.h".}
          proc timer_set_repeat*(timer: PTimer; repeat: int64) {.
              importc: "uv_timer_set_repeat", header: "uv.h".}

   * timer_get_repeat header: "uv.h".}
          proc timer_get_repeat*(timer: PTimer): int64 {.importc: "uv_timer_get_repeat",
              header: "uv.h".}

   * ares_init_options optmask: cint): cint {.importc:
     "uv_ares_init_options", header: "uv.h".}
          proc ares_init_options*(a2: PLoop; channel: PAresChannel; options: PAresOptions;
                                 optmask: cint): cint {.importc: "uv_ares_init_options",
              header: "uv.h".}

   * ares_destroy header: "uv.h".}
          proc ares_destroy*(a2: PLoop; channel: PAresChannel) {.importc: "uv_ares_destroy",
              header: "uv.h".}

   * getaddrinfo node: cstring; service: cstring; hints: ptr AddrInfo):
     cint {.  importc: "uv_getaddrinfo", header: "uv.h".}
          proc getaddrinfo*(a2: PLoop; handle: PGetAddrInfo; getaddrinfo_cb: GetAddrInfoProc;
                           node: cstring; service: cstring; hints: ptr AddrInfo): cint {.
              importc: "uv_getaddrinfo", header: "uv.h".}

   * freeaddrinfo
          proc freeaddrinfo*(ai: ptr AddrInfo) {.importc: "uv_freeaddrinfo", header: "uv.h".}

   * spawn importc: "uv_spawn", header: "uv.h".}
          proc spawn*(a2: PLoop; a3: PProcess; options: ProcessOptions): cint {.
              importc: "uv_spawn", header: "uv.h".}

   * process_kill header: "uv.h".}
          proc process_kill*(a2: PProcess; signum: cint): cint {.importc: "uv_process_kill",
              header: "uv.h".}

   * queue_work after_work_cb: AfterWorkProc): cint {.importc:
     "uv_queue_work", header: "uv.h".}
          proc queue_work*(loop: PLoop; req: PWork; work_cb: WorkProc;
                          after_work_cb: AfterWorkProc): cint {.importc: "uv_queue_work",
              header: "uv.h".}

   * req_cleanup
          proc req_cleanup*(req: PFS) {.importc: "uv_fs_req_cleanup", header: "uv.h".}

   * close header: "uv.h".}
          proc close*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.importc: "uv_fs_close",
              header: "uv.h".}

   * open importc: "uv_fs_open", header: "uv.h".}
          proc open*(loop: PLoop; req: PFS; path: cstring; flags: cint; mode: cint; cb: FsProc): cint {.
              importc: "uv_fs_open", header: "uv.h".}

   * read cb: FsProc): cint {.importc: "uv_fs_read", header: "uv.h".}
          proc read*(loop: PLoop; req: PFS; file: File; buf: pointer; length: csize; offset: coff;
                    cb: FsProc): cint {.importc: "uv_fs_read", header: "uv.h".}

   * unlink importc: "uv_fs_unlink", header: "uv.h".}
          proc unlink*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.
              importc: "uv_fs_unlink", header: "uv.h".}

   * write cb: FsProc): cint {.importc: "uv_fs_write", header: "uv.h".}
          proc write*(loop: PLoop; req: PFS; file: File; buf: pointer; length: csize; offset: coff;
                     cb: FsProc): cint {.importc: "uv_fs_write", header: "uv.h".}

   * mkdir importc: "uv_fs_mkdir", header: "uv.h".}
          proc mkdir*(loop: PLoop; req: PFS; path: cstring; mode: cint; cb: FsProc): cint {.
              importc: "uv_fs_mkdir", header: "uv.h".}

   * rmdir importc: "uv_fs_rmdir", header: "uv.h".}
          proc rmdir*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.
              importc: "uv_fs_rmdir", header: "uv.h".}

   * readdir importc: "uv_fs_readdir", header: "uv.h".}
          proc readdir*(loop: PLoop; req: PFS; path: cstring; flags: cint; cb: FsProc): cint {.
              importc: "uv_fs_readdir", header: "uv.h".}

   * stat importc: "uv_fs_stat", header: "uv.h".}
          proc stat*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.
              importc: "uv_fs_stat", header: "uv.h".}

   * fstat header: "uv.h".}
          proc fstat*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.importc: "uv_fs_fstat",
              header: "uv.h".}

   * rename importc: "uv_fs_rename", header: "uv.h".}
          proc rename*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; cb: FsProc): cint {.
              importc: "uv_fs_rename", header: "uv.h".}

   * fsync header: "uv.h".}
          proc fsync*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.importc: "uv_fs_fsync",
              header: "uv.h".}

   * fdatasync importc: "uv_fs_fdatasync", header: "uv.h".}
          proc fdatasync*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.
              importc: "uv_fs_fdatasync", header: "uv.h".}

   * ftruncate importc: "uv_fs_ftruncate", header: "uv.h".}
          proc ftruncate*(loop: PLoop; req: PFS; file: File; offset: coff; cb: FsProc): cint {.
              importc: "uv_fs_ftruncate", header: "uv.h".}

   * sendfile length: csize; cb: FsProc): cint {.importc:
     "uv_fs_sendfile", header: "uv.h".}
          proc sendfile*(loop: PLoop; req: PFS; out_fd: File; in_fd: File; in_offset: coff;
                        length: csize; cb: FsProc): cint {.importc: "uv_fs_sendfile",
              header: "uv.h".}

   * chmod importc: "uv_fs_chmod", header: "uv.h".}
          proc chmod*(loop: PLoop; req: PFS; path: cstring; mode: cint; cb: FsProc): cint {.
              importc: "uv_fs_chmod", header: "uv.h".}

   * utime cb: FsProc): cint {.importc: "uv_fs_utime", header: "uv.h".}
          proc utime*(loop: PLoop; req: PFS; path: cstring; atime: cdouble; mtime: cdouble;
                     cb: FsProc): cint {.importc: "uv_fs_utime", header: "uv.h".}

   * futime importc: "uv_fs_futime", header: "uv.h".}
          proc futime*(loop: PLoop; req: PFS; file: File; atime: cdouble; mtime: cdouble; cb: FsProc): cint {.
              importc: "uv_fs_futime", header: "uv.h".}

   * lstat importc: "uv_fs_lstat", header: "uv.h".}
          proc lstat*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.
              importc: "uv_fs_lstat", header: "uv.h".}

   * link importc: "uv_fs_link", header: "uv.h".}
          proc link*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; cb: FsProc): cint {.
              importc: "uv_fs_link", header: "uv.h".}

   * symlink cb: FsProc): cint {.importc: "uv_fs_symlink", header:
     "uv.h".}
          proc symlink*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; flags: cint;
                       cb: FsProc): cint {.importc: "uv_fs_symlink", header: "uv.h".}

   * readlink importc: "uv_fs_readlink", header: "uv.h".}
          proc readlink*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.
              importc: "uv_fs_readlink", header: "uv.h".}

   * fchmod importc: "uv_fs_fchmod", header: "uv.h".}
          proc fchmod*(loop: PLoop; req: PFS; file: File; mode: cint; cb: FsProc): cint {.
              importc: "uv_fs_fchmod", header: "uv.h".}

   * chown importc: "uv_fs_chown", header: "uv.h".}
          proc chown*(loop: PLoop; req: PFS; path: cstring; uid: cint; gid: cint; cb: FsProc): cint {.
              importc: "uv_fs_chown", header: "uv.h".}

   * fchown importc: "uv_fs_fchown", header: "uv.h".}
          proc fchown*(loop: PLoop; req: PFS; file: File; uid: cint; gid: cint; cb: FsProc): cint {.
              importc: "uv_fs_fchown", header: "uv.h".}

   * event_init importc: "uv_fs_event_init", header: "uv.h".}
          proc event_init*(loop: PLoop; handle: PFSEvent; filename: cstring; cb: FsEventProc): cint {.
              importc: "uv_fs_event_init", header: "uv.h".}

   * ip4_addr header: "uv.h".}
          proc ip4_addr*(ip: cstring; port: cint): SockAddrIn {.importc: "uv_ip4_addr",
              header: "uv.h".}

   * ip6_addr header: "uv.h".}
          proc ip6_addr*(ip: cstring; port: cint): TSockAddrIn6 {.importc: "uv_ip6_addr",
              header: "uv.h".}

   * ip4_name importc: "uv_ip4_name", header: "uv.h".}
          proc ip4_name*(src: ptr SockAddrIn; dst: cstring; size: csize): cint {.
              importc: "uv_ip4_name", header: "uv.h".}

   * ip6_name importc: "uv_ip6_name", header: "uv.h".}
          proc ip6_name*(src: ptr TSockAddrIn6; dst: cstring; size: csize): cint {.
              importc: "uv_ip6_name", header: "uv.h".}

   * exepath header: "uv.h".}
          proc exepath*(buffer: cstring; size: var csize): cint {.importc: "uv_exepath",
              header: "uv.h".}

   * hrtime
          proc hrtime*(): uint64 {.importc: "uv_hrtime", header: "uv.h".}

   * loadavg
          proc loadavg*(load: var array[0 .. 2, cdouble]) {.importc: "uv_loadavg", header: "uv.h".}

   * get_free_memory
          proc get_free_memory*(): cdouble {.importc: "uv_get_free_memory", header: "uv.h".}

   * get_total_memory
          proc get_total_memory*(): cdouble {.importc: "uv_get_total_memory", header: "uv.h".}


File: nim-ref-0.13.0.info,  Node: /wrappers/joyent_http_parser,  Next: /wrappers/openssl,  Prev: /wrappers/libuv,  Up: Top

319 Types
*********

   * HttpParserSettings header: "http_parser.h".} = object
     on_message_begin* {.importc: "on_message_begin".}: HttpProc on_url*
     {.importc: "on_url".}: HttpDataProc on_header_field* {.importc:
     "on_header_field".}: HttpDataProc on_header_value* {.importc:
     "on_header_value".}: HttpDataProc on_headers_complete* {.importc:
     "on_headers_complete".}: HttpProc on_body* {.importc: "on_body".}:
     HttpDataProc on_message_complete* {.importc:
     "on_message_complete".}: HttpProc

          HttpParserSettings* {.pure, final, importc: "http_parser_settings",
                               header: "http_parser.h".} = object
            on_message_begin* {.importc: "on_message_begin".}: HttpProc
            on_url* {.importc: "on_url".}: HttpDataProc
            on_header_field* {.importc: "on_header_field".}: HttpDataProc
            on_header_value* {.importc: "on_header_value".}: HttpDataProc
            on_headers_complete* {.importc: "on_headers_complete".}: HttpProc
            on_body* {.importc: "on_body".}: HttpDataProc
            on_message_complete* {.importc: "on_message_complete".}: HttpProc


320 Procedures
**************

   * http_parser_init importc: "http_parser_init", header:
     "http_parser.h".}
          proc http_parser_init*(parser: var HttpParser; typ: HttpParserType) {.
              importc: "http_parser_init", header: "http_parser.h".}

   * http_parser_execute data: cstring; len: csize): csize {.  importc:
     "http_parser_execute", header: "http_parser.h".}
          proc http_parser_execute*(parser: var HttpParser; settings: var HttpParserSettings;
                                   data: cstring; len: csize): csize {.
              importc: "http_parser_execute", header: "http_parser.h".}

   * http_should_keep_alive importc: "http_should_keep_alive", header:
     "http_parser.h".}
          proc http_should_keep_alive*(parser: var HttpParser): cint {.
              importc: "http_should_keep_alive", header: "http_parser.h".}

   * http_method_str header: "http_parser.h".}
          proc http_method_str*(m: HttpMethod): cstring {.importc: "http_method_str",
              header: "http_parser.h".}

   * http_errno_name header: "http_parser.h".}
          proc http_errno_name*(err: HttpErrNo): cstring {.importc: "http_errno_name",
              header: "http_parser.h".}

   * http_errno_description importc: "http_errno_description", header:
     "http_parser.h".}
          proc http_errno_description*(err: HttpErrNo): cstring {.
              importc: "http_errno_description", header: "http_parser.h".}


File: nim-ref-0.13.0.info,  Node: /wrappers/openssl,  Next: /wrappers/postgres,  Prev: /wrappers/joyent_http_parser,  Up: Top

321 Constant variables
**********************

   * MD5_DIGEST_LENGTH
          MD5_DIGEST_LENGTH* = 16

322 Types
*********

   * des_key_schedule
          des_key_schedule* = array[1 .. 16, des_ks_struct]

   * MD5_LONG
          MD5_LONG* = cuint

   * MD5_CTX A, B, C, D, Nl, Nh: MD5_LONG data: array[MD5_LBLOCK,
     MD5_LONG] num: cuint

          MD5_CTX* = object
            A, B, C, D, Nl, Nh: MD5_LONG
            data: array[MD5_LBLOCK, MD5_LONG]
            num: cuint


323 Procedures
**************

   * SSL_library_init
          proc SSL_library_init*(): cInt {.cdecl, dynlib: DLLSSLName, importc, discardable.}

   * SSL_load_error_strings
          proc SSL_load_error_strings*() {.cdecl, dynlib: DLLSSLName, importc.}

   * ERR_load_BIO_strings
          proc ERR_load_BIO_strings*() {.cdecl, dynlib: DLLUtilName, importc.}

   * SSLv23_client_method
          proc SSLv23_client_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}

   * SSLv23_method
          proc SSLv23_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}

   * SSLv2_method
          proc SSLv2_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}

   * SSLv3_method
          proc SSLv3_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}

   * TLSv1_method
          proc TLSv1_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_new
          proc SSL_new*(context: SslCtx): SslPtr {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_free
          proc SSL_free*(ssl: SslPtr) {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_CTX_new
          proc SSL_CTX_new*(meth: PSSL_METHOD): SslCtx {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_CTX_load_verify_locations cdecl, dynlib: DLLSSLName, importc.}
          proc SSL_CTX_load_verify_locations*(ctx: SslCtx; CAfile: cstring; CApath: cstring): cInt {.
              cdecl, dynlib: DLLSSLName, importc.}

   * SSL_CTX_free
          proc SSL_CTX_free*(arg0: SslCtx) {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_CTX_set_verify cb: proc (a: int; b: pointer): int {.cdecl.})
     {.cdecl, dynlib: DLLSSLName, importc.}
          proc SSL_CTX_set_verify*(s: SslCtx; mode: int;
                                  cb: proc (a: int; b: pointer): int {.cdecl.}) {.cdecl,
              dynlib: DLLSSLName, importc.}

   * SSL_get_verify_result
          proc SSL_get_verify_result*(ssl: SslPtr): int {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_CTX_set_cipher_list dynlib: DLLSSLName, importc.}
          proc SSL_CTX_set_cipher_list*(s: SslCtx; ciphers: cstring): cint {.cdecl,
              dynlib: DLLSSLName, importc.}

   * SSL_CTX_use_certificate_file stdcall, dynlib: DLLSSLName, importc.}
          proc SSL_CTX_use_certificate_file*(ctx: SslCtx; filename: cstring; typ: cInt): cInt {.
              stdcall, dynlib: DLLSSLName, importc.}

   * SSL_CTX_use_certificate_chain_file stdcall, dynlib: DLLSSLName,
     importc.}
          proc SSL_CTX_use_certificate_chain_file*(ctx: SslCtx; filename: cstring): cInt {.
              stdcall, dynlib: DLLSSLName, importc.}

   * SSL_CTX_use_PrivateKey_file cdecl, dynlib: DLLSSLName, importc.}
          proc SSL_CTX_use_PrivateKey_file*(ctx: SslCtx; filename: cstring; typ: cInt): cInt {.
              cdecl, dynlib: DLLSSLName, importc.}

   * SSL_CTX_check_private_key
          proc SSL_CTX_check_private_key*(ctx: SslCtx): cInt {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_set_fd importc.}
          proc SSL_set_fd*(ssl: SslPtr; fd: SocketHandle): cint {.cdecl, dynlib: DLLSSLName,
              importc.}

   * SSL_shutdown
          proc SSL_shutdown*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_set_shutdown importc: "SSL_set_shutdown".}
          proc SSL_set_shutdown*(ssl: SslPtr; mode: cint) {.cdecl, dynlib: DLLSSLName,
              importc: "SSL_set_shutdown".}

   * SSL_get_shutdown importc: "SSL_get_shutdown".}
          proc SSL_get_shutdown*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName,
                                                  importc: "SSL_get_shutdown".}

   * SSL_connect
          proc SSL_connect*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_read importc.}
          proc SSL_read*(ssl: SslPtr; buf: pointer; num: int): cint {.cdecl, dynlib: DLLSSLName,
              importc.}

   * SSL_write importc.}
          proc SSL_write*(ssl: SslPtr; buf: cstring; num: int): cint {.cdecl, dynlib: DLLSSLName,
              importc.}

   * SSL_get_error
          proc SSL_get_error*(s: SslPtr; ret_code: cInt): cInt {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_accept
          proc SSL_accept*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}

   * SSL_pending
          proc SSL_pending*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}

   * BIO_new_ssl_connect
          proc BIO_new_ssl_connect*(ctx: SslCtx): BIO {.cdecl, dynlib: DLLSSLName, importc.}

   * BIO_ctrl dynlib: DLLSSLName, importc.}
          proc BIO_ctrl*(bio: BIO; cmd: cint; larg: int; arg: cstring): int {.cdecl,
              dynlib: DLLSSLName, importc.}

   * BIO_get_ssl
          proc BIO_get_ssl*(bio: BIO; ssl: ptr SslPtr): int

   * BIO_set_conn_hostname
          proc BIO_set_conn_hostname*(bio: BIO; name: cstring): int

   * BIO_do_handshake
          proc BIO_do_handshake*(bio: BIO): int

   * BIO_do_connect
          proc BIO_do_connect*(bio: BIO): int

   * BIO_read importc.}
          proc BIO_read*(b: BIO; data: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,
              importc.}

   * BIO_write importc.}
          proc BIO_write*(b: BIO; data: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,
              importc.}

   * BIO_free
          proc BIO_free*(b: BIO): cInt {.cdecl, dynlib: DLLUtilName, importc.}

   * ERR_print_errors_fp
          proc ERR_print_errors_fp*(fp: File) {.cdecl, dynlib: DLLSSLName, importc.}

   * ERR_error_string importc.}
          proc ERR_error_string*(e: cInt; buf: cstring): cstring {.cdecl, dynlib: DLLUtilName,
              importc.}

   * ERR_get_error
          proc ERR_get_error*(): cInt {.cdecl, dynlib: DLLUtilName, importc.}

   * ERR_peek_last_error
          proc ERR_peek_last_error*(): cInt {.cdecl, dynlib: DLLUtilName, importc.}

   * OpenSSL_add_all_algorithms importc:
     "OPENSSL_add_all_algorithms_conf".}
          proc OpenSSL_add_all_algorithms*() {.cdecl, dynlib: DLLUtilName,
                                             importc: "OPENSSL_add_all_algorithms_conf".}

   * OPENSSL_config
          proc OPENSSL_config*(configName: cstring) {.cdecl, dynlib: DLLSSLName, importc.}

   * CRYPTO_malloc_init
          proc CRYPTO_malloc_init*()

   * SSL_CTX_ctrl dynlib: DLLSSLName, importc.}
          proc SSL_CTX_ctrl*(ctx: SslCtx; cmd: cInt; larg: int; parg: pointer): int {.cdecl,
              dynlib: DLLSSLName, importc.}

   * SSLCTXSetMode
          proc SSLCTXSetMode*(ctx: SslCtx; mode: int): int

   * SSL_ctrl dynlib: DLLSSLName, importc.}
          proc SSL_ctrl*(ssl: SslPtr; cmd: cInt; larg: int; parg: pointer): int {.cdecl,
              dynlib: DLLSSLName, importc.}

   * SSL_set_tlsext_host_name
          proc SSL_set_tlsext_host_name*(ssl: SslPtr; name: cstring): int

     Set the SNI server name extension to be used in a client hello.
     Returns 1 if SNI was set, 0 if current SSL configuration doesn't
     support SNI.

   * SSL_get_servername cdecl, dynlib: DLLSSLName, importc.}
          proc SSL_get_servername*(ssl: SslPtr; typ: cInt = TLSEXT_NAMETYPE_host_name): cstring {.
              cdecl, dynlib: DLLSSLName, importc.}

     Retrieve the server name requested in the client hello.  This can
     be used in the callback set in
     SSL_CTX_set_tlsext_servername_callback to implement virtual
     hosting.  May return nil.

   * SSL_CTX_set_tlsext_servername_callback cb: proc (ssl: SslPtr;
     cb_id: int; arg: pointer): int {.cdecl.}): int
          proc SSL_CTX_set_tlsext_servername_callback*(ctx: SslCtx;
              cb: proc (ssl: SslPtr; cb_id: int; arg: pointer): int {.cdecl.}): int

     Set the callback to be used on listening SSL connections when the
     client hello is received.

     The callback should return one of:

        * SSL_TLSEXT_ERR_OK
        * SSL_TLSEXT_ERR_ALERT_WARNING
        * SSL_TLSEXT_ERR_ALERT_FATAL
        * SSL_TLSEXT_ERR_NOACK

   * SSL_CTX_set_tlsext_servername_arg
          proc SSL_CTX_set_tlsext_servername_arg*(ctx: SslCtx; arg: pointer): int

     Set the pointer to be used in the callback registered to
     'SSL_CTX_set_tlsext_servername_callback'.

   * bioNew
          proc bioNew*(b: PBIO_METHOD): BIO {.cdecl, dynlib: DLLUtilName, importc: "BIO_new".}

   * bioFreeAll
          proc bioFreeAll*(b: BIO) {.cdecl, dynlib: DLLUtilName, importc: "BIO_free_all".}

   * bioSMem
          proc bioSMem*(): PBIO_METHOD {.cdecl, dynlib: DLLUtilName, importc: "BIO_s_mem".}

   * bioCtrlPending importc: "BIO_ctrl_pending".}
          proc bioCtrlPending*(b: BIO): cInt {.cdecl, dynlib: DLLUtilName,
                                           importc: "BIO_ctrl_pending".}

   * bioRead importc: "BIO_read".}
          proc bioRead*(b: BIO; Buf: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,
              importc: "BIO_read".}

   * bioWrite importc: "BIO_write".}
          proc bioWrite*(b: BIO; Buf: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,
              importc: "BIO_write".}

   * sslSetConnectState importc: "SSL_set_connect_state".}
          proc sslSetConnectState*(s: SslPtr) {.cdecl, dynlib: DLLSSLName,
                                             importc: "SSL_set_connect_state".}

   * sslSetAcceptState importc: "SSL_set_accept_state".}
          proc sslSetAcceptState*(s: SslPtr) {.cdecl, dynlib: DLLSSLName,
                                            importc: "SSL_set_accept_state".}

   * sslRead importc: "SSL_read".}
          proc sslRead*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, dynlib: DLLSSLName,
              importc: "SSL_read".}

   * sslPeek importc: "SSL_peek".}
          proc sslPeek*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, dynlib: DLLSSLName,
              importc: "SSL_peek".}

   * sslWrite importc: "SSL_write".}
          proc sslWrite*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, dynlib: DLLSSLName,
              importc: "SSL_write".}

   * sslSetBio importc: "SSL_set_bio".}
          proc sslSetBio*(ssl: SslPtr; rbio, wbio: BIO) {.cdecl, dynlib: DLLSSLName,
              importc: "SSL_set_bio".}

   * sslDoHandshake importc: "SSL_do_handshake".}
          proc sslDoHandshake*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName,
                                                importc: "SSL_do_handshake".}

   * ErrClearError
          proc ErrClearError*() {.cdecl, dynlib: DLLUtilName, importc: "ERR_clear_error".}

   * ErrFreeStrings
          proc ErrFreeStrings*() {.cdecl, dynlib: DLLUtilName, importc: "ERR_free_strings".}

   * ErrRemoveState importc: "ERR_remove_state".}
          proc ErrRemoveState*(pid: cInt) {.cdecl, dynlib: DLLUtilName,
                                         importc: "ERR_remove_state".}

   * md5_Init
          proc md5_Init*(c: var MD5_CTX): cint {.ic.}

   * md5_Update
          proc md5_Update*(c: var MD5_CTX; data: pointer; len: csize): cint {.ic.}

   * md5_Final
          proc md5_Final*(md: cstring; c: var MD5_CTX): cint {.ic.}

   * md5
          proc md5*(d: ptr cuchar; n: csize; md: ptr cuchar): ptr cuchar {.ic.}

   * md5_Transform
          proc md5_Transform*(c: var MD5_CTX; b: ptr cuchar) {.ic.}

   * md5_File
          proc md5_File*(file: string): string {.raises: [IOError, Exception].}

     Generate MD5 hash for a file.  Result is a 32 character

   * md5_Str
          proc md5_Str*(str: string): string {.raises: [IOError].}

     Generate MD5 hash for a string.  Result is a 32 character


File: nim-ref-0.13.0.info,  Node: /wrappers/postgres,  Next: /wrappers/mysql,  Prev: /wrappers/openssl,  Up: Top

324 Constant variables
**********************

   * CMDSTATUS_LEN
          CMDSTATUS_LEN* = 40

325 Types
*********

   * Oid
          Oid* = int32

   * PQArgBlock length*: int32 isint*: int32 p*: pointer

          PQArgBlock* {.pure, final.} = object
            length*: int32
            isint*: int32
            p*: pointer


326 Procedures
**************

   * pqconnectStart importc: "PQconnectStart".}
          proc pqconnectStart*(conninfo: cstring): PPGconn {.cdecl, dynlib: dllName,
              importc: "PQconnectStart".}

   * pqconnectPoll dynlib: dllName, importc: "PQconnectPoll".}
          proc pqconnectPoll*(conn: PPGconn): PostgresPollingStatusType {.cdecl,
              dynlib: dllName, importc: "PQconnectPoll".}

   * pqconnectdb importc: "PQconnectdb".}
          proc pqconnectdb*(conninfo: cstring): PPGconn {.cdecl, dynlib: dllName,
              importc: "PQconnectdb".}

   * pqsetdbLogin pgtty: cstring; dbName: cstring; login: cstring; pwd:
     cstring): PPGconn {.  cdecl, dynlib: dllName, importc:
     "PQsetdbLogin".}
          proc pqsetdbLogin*(pghost: cstring; pgport: cstring; pgoptions: cstring;
                            pgtty: cstring; dbName: cstring; login: cstring; pwd: cstring): PPGconn {.
              cdecl, dynlib: dllName, importc: "PQsetdbLogin".}

   * pqsetdb
          proc pqsetdb*(M_PGHOST, M_PGPORT, M_PGOPT, M_PGTTY, M_DBNAME: cstring): Ppgconn

   * pqfinish
          proc pqfinish*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: "PQfinish".}

   * pqconndefaults importc: "PQconndefaults".}
          proc pqconndefaults*(): PPQconninfoOption {.cdecl, dynlib: dllName,
              importc: "PQconndefaults".}

   * pqconninfoFree importc: "PQconninfoFree".}
          proc pqconninfoFree*(connOptions: PPQconninfoOption) {.cdecl, dynlib: dllName,
              importc: "PQconninfoFree".}

   * pqresetStart importc: "PQresetStart".}
          proc pqresetStart*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,
                                                 importc: "PQresetStart".}

   * pqresetPoll importc: "PQresetPoll".}
          proc pqresetPoll*(conn: PPGconn): PostgresPollingStatusType {.cdecl, dynlib: dllName,
              importc: "PQresetPoll".}

   * pqreset
          proc pqreset*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: "PQreset".}

   * pqrequestCancel importc: "PQrequestCancel".}
          proc pqrequestCancel*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,
              importc: "PQrequestCancel".}

   * pqdb
          proc pqdb*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQdb".}

   * pquser
          proc pquser*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQuser".}

   * pqpass
          proc pqpass*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQpass".}

   * pqhost
          proc pqhost*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQhost".}

   * pqport
          proc pqport*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQport".}

   * pqtty
          proc pqtty*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQtty".}

   * pqoptions
          proc pqoptions*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQoptions".}

   * pqstatus importc: "PQstatus".}
          proc pqstatus*(conn: PPGconn): ConnStatusType {.cdecl, dynlib: dllName,
              importc: "PQstatus".}

   * pqtransactionStatus dynlib: dllName, importc:
     "PQtransactionStatus".}
          proc pqtransactionStatus*(conn: PPGconn): PGTransactionStatusType {.cdecl,
              dynlib: dllName, importc: "PQtransactionStatus".}

   * pqparameterStatus dynlib: dllName, importc: "PQparameterStatus".}
          proc pqparameterStatus*(conn: PPGconn; paramName: cstring): cstring {.cdecl,
              dynlib: dllName, importc: "PQparameterStatus".}

   * pqprotocolVersion importc: "PQprotocolVersion".}
          proc pqprotocolVersion*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,
              importc: "PQprotocolVersion".}

   * pqerrorMessage importc: "PQerrorMessage".}
          proc pqerrorMessage*(conn: PPGconn): cstring {.cdecl, dynlib: dllName,
              importc: "PQerrorMessage".}

   * pqsocket
          proc pqsocket*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQsocket".}

   * pqbackendPID importc: "PQbackendPID".}
          proc pqbackendPID*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,
                                                 importc: "PQbackendPID".}

   * pqclientEncoding importc: "PQclientEncoding".}
          proc pqclientEncoding*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,
              importc: "PQclientEncoding".}

   * pqsetClientEncoding dynlib: dllName, importc:
     "PQsetClientEncoding".}
          proc pqsetClientEncoding*(conn: PPGconn; encoding: cstring): int32 {.cdecl,
              dynlib: dllName, importc: "PQsetClientEncoding".}

   * pqgetssl
          proc pqgetssl*(conn: PPGconn): PSSL {.cdecl, dynlib: dllName, importc: "PQgetssl".}

   * pqsetErrorVerbosity dynlib: dllName, importc:
     "PQsetErrorVerbosity".}
          proc pqsetErrorVerbosity*(conn: PPGconn; verbosity: PGVerbosity): PGVerbosity {.cdecl,
              dynlib: dllName, importc: "PQsetErrorVerbosity".}

   * pqtrace importc: "PQtrace".}
          proc pqtrace*(conn: PPGconn; debug_port: File) {.cdecl, dynlib: dllName,
              importc: "PQtrace".}

   * pquntrace
          proc pquntrace*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: "PQuntrace".}

   * pqsetNoticeReceiver cdecl, dynlib: dllName, importc:
     "PQsetNoticeReceiver".}
          proc pqsetNoticeReceiver*(conn: PPGconn; theProc: PQnoticeReceiver; arg: pointer): PQnoticeReceiver {.
              cdecl, dynlib: dllName, importc: "PQsetNoticeReceiver".}

   * pqsetNoticeProcessor cdecl, dynlib: dllName, importc:
     "PQsetNoticeProcessor".}
          proc pqsetNoticeProcessor*(conn: PPGconn; theProc: PQnoticeProcessor; arg: pointer): PQnoticeProcessor {.
              cdecl, dynlib: dllName, importc: "PQsetNoticeProcessor".}

   * pqexec importc: "PQexec".}
          proc pqexec*(conn: PPGconn; query: cstring): PPGresult {.cdecl, dynlib: dllName,
              importc: "PQexec".}

   * pqexecParams paramValues: cstringArray; paramLengths, paramFormats:
     ptr int32; resultFormat: int32): PPGresult {.  cdecl, dynlib:
     dllName, importc: "PQexecParams".}
          proc pqexecParams*(conn: PPGconn; command: cstring; nParams: int32; paramTypes: POid;
                            paramValues: cstringArray;
                            paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult {.
              cdecl, dynlib: dllName, importc: "PQexecParams".}

   * pqprepare paramTypes: POid): PPGresult {.cdecl, dynlib: dllName,
     importc: "PQprepare".}
          proc pqprepare*(conn: PPGconn; stmtName, query: cstring; nParams: int32;
                         paramTypes: POid): PPGresult {.cdecl, dynlib: dllName,
              importc: "PQprepare".}

   * pqexecPrepared paramValues: cstringArray; paramLengths,
     paramFormats: ptr int32; resultFormat: int32): PPGresult {.  cdecl,
     dynlib: dllName, importc: "PQexecPrepared".}
          proc pqexecPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;
                              paramValues: cstringArray;
                              paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult {.
              cdecl, dynlib: dllName, importc: "PQexecPrepared".}

   * pqsendQuery importc: "PQsendQuery".}
          proc pqsendQuery*(conn: PPGconn; query: cstring): int32 {.cdecl, dynlib: dllName,
              importc: "PQsendQuery".}

   * pqsendQueryParams paramTypes: POid; paramValues: cstringArray;
     paramLengths, paramFormats: ptr int32; resultFormat: int32): int32
     {.  cdecl, dynlib: dllName, importc: "PQsendQueryParams".}
          proc pqsendQueryParams*(conn: PPGconn; command: cstring; nParams: int32;
                                 paramTypes: POid; paramValues: cstringArray;
                                 paramLengths, paramFormats: ptr int32; resultFormat: int32): int32 {.
              cdecl, dynlib: dllName, importc: "PQsendQueryParams".}

   * pqsendQueryPrepared paramValues: cstringArray; paramLengths,
     paramFormats: ptr int32; resultFormat: int32): int32 {.  cdecl,
     dynlib: dllName, importc: "PQsendQueryPrepared".}
          proc pqsendQueryPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;
                                   paramValues: cstringArray;
                                   paramLengths, paramFormats: ptr int32; resultFormat: int32): int32 {.
              cdecl, dynlib: dllName, importc: "PQsendQueryPrepared".}

   * pqgetResult importc: "PQgetResult".}
          proc pqgetResult*(conn: PPGconn): PPGresult {.cdecl, dynlib: dllName,
              importc: "PQgetResult".}

   * pqisBusy
          proc pqisBusy*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQisBusy".}

   * pqconsumeInput importc: "PQconsumeInput".}
          proc pqconsumeInput*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,
              importc: "PQconsumeInput".}

   * pqnotifies importc: "PQnotifies".}
          proc pqnotifies*(conn: PPGconn): PPGnotify {.cdecl, dynlib: dllName,
              importc: "PQnotifies".}

   * pqputCopyData dynlib: dllName, importc: "PQputCopyData".}
          proc pqputCopyData*(conn: PPGconn; buffer: cstring; nbytes: int32): int32 {.cdecl,
              dynlib: dllName, importc: "PQputCopyData".}

   * pqputCopyEnd importc: "PQputCopyEnd".}
          proc pqputCopyEnd*(conn: PPGconn; errormsg: cstring): int32 {.cdecl, dynlib: dllName,
              importc: "PQputCopyEnd".}

   * pqgetCopyData dynlib: dllName, importc: "PQgetCopyData".}
          proc pqgetCopyData*(conn: PPGconn; buffer: cstringArray; async: int32): int32 {.cdecl,
              dynlib: dllName, importc: "PQgetCopyData".}

   * pqgetline importc: "PQgetline".}
          proc pqgetline*(conn: PPGconn; str: cstring; len: int32): int32 {.cdecl, dynlib: dllName,
              importc: "PQgetline".}

   * pqputline importc: "PQputline".}
          proc pqputline*(conn: PPGconn; str: cstring): int32 {.cdecl, dynlib: dllName,
              importc: "PQputline".}

   * pqgetlineAsync dynlib: dllName, importc: "PQgetlineAsync".}
          proc pqgetlineAsync*(conn: PPGconn; buffer: cstring; bufsize: int32): int32 {.cdecl,
              dynlib: dllName, importc: "PQgetlineAsync".}

   * pqputnbytes dynlib: dllName, importc: "PQputnbytes".}
          proc pqputnbytes*(conn: PPGconn; buffer: cstring; nbytes: int32): int32 {.cdecl,
              dynlib: dllName, importc: "PQputnbytes".}

   * pqendcopy
          proc pqendcopy*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQendcopy".}

   * pqsetnonblocking importc: "PQsetnonblocking".}
          proc pqsetnonblocking*(conn: PPGconn; arg: int32): int32 {.cdecl, dynlib: dllName,
              importc: "PQsetnonblocking".}

   * pqisnonblocking importc: "PQisnonblocking".}
          proc pqisnonblocking*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,
              importc: "PQisnonblocking".}

   * pqflush
          proc pqflush*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQflush".}

   * pqfn result_is_int: int32; args: PPQArgBlock; nargs: int32):
     PPGresult {.cdecl, dynlib: dllName, importc: "PQfn".}
          proc pqfn*(conn: PPGconn; fnid: int32; result_buf, result_len: ptr int32;
                    result_is_int: int32; args: PPQArgBlock; nargs: int32): PPGresult {.cdecl,
              dynlib: dllName, importc: "PQfn".}

   * pqresultStatus importc: "PQresultStatus".}
          proc pqresultStatus*(res: PPGresult): ExecStatusType {.cdecl, dynlib: dllName,
              importc: "PQresultStatus".}

   * pqresStatus importc: "PQresStatus".}
          proc pqresStatus*(status: ExecStatusType): cstring {.cdecl, dynlib: dllName,
              importc: "PQresStatus".}

   * pqresultErrorMessage importc: "PQresultErrorMessage".}
          proc pqresultErrorMessage*(res: PPGresult): cstring {.cdecl, dynlib: dllName,
              importc: "PQresultErrorMessage".}

   * pqresultErrorField dynlib: dllName, importc: "PQresultErrorField".}
          proc pqresultErrorField*(res: PPGresult; fieldcode: int32): cstring {.cdecl,
              dynlib: dllName, importc: "PQresultErrorField".}

   * pqntuples
          proc pqntuples*(res: PPGresult): int32 {.cdecl, dynlib: dllName, importc: "PQntuples".}

   * pqnfields
          proc pqnfields*(res: PPGresult): int32 {.cdecl, dynlib: dllName, importc: "PQnfields".}

   * pqbinaryTuples importc: "PQbinaryTuples".}
          proc pqbinaryTuples*(res: PPGresult): int32 {.cdecl, dynlib: dllName,
              importc: "PQbinaryTuples".}

   * pqfname importc: "PQfname".}
          proc pqfname*(res: PPGresult; field_num: int32): cstring {.cdecl, dynlib: dllName,
              importc: "PQfname".}

   * pqfnumber importc: "PQfnumber".}
          proc pqfnumber*(res: PPGresult; field_name: cstring): int32 {.cdecl, dynlib: dllName,
              importc: "PQfnumber".}

   * pqftable importc: "PQftable".}
          proc pqftable*(res: PPGresult; field_num: int32): Oid {.cdecl, dynlib: dllName,
              importc: "PQftable".}

   * pqftablecol importc: "PQftablecol".}
          proc pqftablecol*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,
              importc: "PQftablecol".}

   * pqfformat importc: "PQfformat".}
          proc pqfformat*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,
              importc: "PQfformat".}

   * pqftype importc: "PQftype".}
          proc pqftype*(res: PPGresult; field_num: int32): Oid {.cdecl, dynlib: dllName,
              importc: "PQftype".}

   * pqfsize importc: "PQfsize".}
          proc pqfsize*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,
              importc: "PQfsize".}

   * pqfmod importc: "PQfmod".}
          proc pqfmod*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,
              importc: "PQfmod".}

   * pqcmdStatus importc: "PQcmdStatus".}
          proc pqcmdStatus*(res: PPGresult): cstring {.cdecl, dynlib: dllName,
              importc: "PQcmdStatus".}

   * pqoidStatus importc: "PQoidStatus".}
          proc pqoidStatus*(res: PPGresult): cstring {.cdecl, dynlib: dllName,
              importc: "PQoidStatus".}

   * pqoidValue
          proc pqoidValue*(res: PPGresult): Oid {.cdecl, dynlib: dllName, importc: "PQoidValue".}

   * pqcmdTuples importc: "PQcmdTuples".}
          proc pqcmdTuples*(res: PPGresult): cstring {.cdecl, dynlib: dllName,
              importc: "PQcmdTuples".}

   * pqgetvalue dynlib: dllName, importc: "PQgetvalue".}
          proc pqgetvalue*(res: PPGresult; tup_num: int32; field_num: int32): cstring {.cdecl,
              dynlib: dllName, importc: "PQgetvalue".}

   * pqgetlength dynlib: dllName, importc: "PQgetlength".}
          proc pqgetlength*(res: PPGresult; tup_num: int32; field_num: int32): int32 {.cdecl,
              dynlib: dllName, importc: "PQgetlength".}

   * pqgetisnull dynlib: dllName, importc: "PQgetisnull".}
          proc pqgetisnull*(res: PPGresult; tup_num: int32; field_num: int32): int32 {.cdecl,
              dynlib: dllName, importc: "PQgetisnull".}

   * pqclear
          proc pqclear*(res: PPGresult) {.cdecl, dynlib: dllName, importc: "PQclear".}

   * pqfreemem
          proc pqfreemem*(p: pointer) {.cdecl, dynlib: dllName, importc: "PQfreemem".}

   * pqmakeEmptyPGresult dynlib: dllName, importc:
     "PQmakeEmptyPGresult".}
          proc pqmakeEmptyPGresult*(conn: PPGconn; status: ExecStatusType): PPGresult {.cdecl,
              dynlib: dllName, importc: "PQmakeEmptyPGresult".}

   * pqescapeString importc: "PQescapeString".}
          proc pqescapeString*(till, `from`: cstring; len: int): int {.cdecl, dynlib: dllName,
              importc: "PQescapeString".}

   * pqescapeBytea dynlib: dllName, importc: "PQescapeBytea".}
          proc pqescapeBytea*(bintext: cstring; binlen: int; bytealen: var int): cstring {.cdecl,
              dynlib: dllName, importc: "PQescapeBytea".}

   * pqunescapeBytea dynlib: dllName, importc: "PQunescapeBytea".}
          proc pqunescapeBytea*(strtext: cstring; retbuflen: var int): cstring {.cdecl,
              dynlib: dllName, importc: "PQunescapeBytea".}

   * pqprint importc: "PQprint".}
          proc pqprint*(fout: File; res: PPGresult; ps: PPQprintOpt) {.cdecl, dynlib: dllName,
              importc: "PQprint".}

   * pqdisplayTuples printHeader: int32; quiet: int32) {.cdecl, dynlib:
     dllName, importc: "PQdisplayTuples".}
          proc pqdisplayTuples*(res: PPGresult; fp: File; fillAlign: int32; fieldSep: cstring;
                               printHeader: int32; quiet: int32) {.cdecl, dynlib: dllName,
              importc: "PQdisplayTuples".}

   * pqprintTuples terseOutput: int32; width: int32) {.cdecl, dynlib:
     dllName, importc: "PQprintTuples".}
          proc pqprintTuples*(res: PPGresult; fout: File; printAttName: int32;
                             terseOutput: int32; width: int32) {.cdecl, dynlib: dllName,
              importc: "PQprintTuples".}

   * lo_open importc: "lo_open".}
          proc lo_open*(conn: PPGconn; lobjId: Oid; mode: int32): int32 {.cdecl, dynlib: dllName,
              importc: "lo_open".}

   * lo_close importc: "lo_close".}
          proc lo_close*(conn: PPGconn; fd: int32): int32 {.cdecl, dynlib: dllName,
              importc: "lo_close".}

   * lo_read dynlib: dllName, importc: "lo_read".}
          proc lo_read*(conn: PPGconn; fd: int32; buf: cstring; length: int): int32 {.cdecl,
              dynlib: dllName, importc: "lo_read".}

   * lo_write dynlib: dllName, importc: "lo_write".}
          proc lo_write*(conn: PPGconn; fd: int32; buf: cstring; length: int): int32 {.cdecl,
              dynlib: dllName, importc: "lo_write".}

   * lo_lseek dynlib: dllName, importc: "lo_lseek".}
          proc lo_lseek*(conn: PPGconn; fd: int32; offset: int32; whence: int32): int32 {.cdecl,
              dynlib: dllName, importc: "lo_lseek".}

   * lo_creat importc: "lo_creat".}
          proc lo_creat*(conn: PPGconn; mode: int32): Oid {.cdecl, dynlib: dllName,
              importc: "lo_creat".}

   * lo_tell importc: "lo_tell".}
          proc lo_tell*(conn: PPGconn; fd: int32): int32 {.cdecl, dynlib: dllName,
              importc: "lo_tell".}

   * lo_unlink importc: "lo_unlink".}
          proc lo_unlink*(conn: PPGconn; lobjId: Oid): int32 {.cdecl, dynlib: dllName,
              importc: "lo_unlink".}

   * lo_import importc: "lo_import".}
          proc lo_import*(conn: PPGconn; filename: cstring): Oid {.cdecl, dynlib: dllName,
              importc: "lo_import".}

   * lo_export dynlib: dllName, importc: "lo_export".}
          proc lo_export*(conn: PPGconn; lobjId: Oid; filename: cstring): int32 {.cdecl,
              dynlib: dllName, importc: "lo_export".}

   * pqmblen importc: "PQmblen".}
          proc pqmblen*(s: cstring; encoding: int32): int32 {.cdecl, dynlib: dllName,
              importc: "PQmblen".}

   * pqenv2encoding
          proc pqenv2encoding*(): int32 {.cdecl, dynlib: dllName, importc: "PQenv2encoding".}


File: nim-ref-0.13.0.info,  Node: /wrappers/mysql,  Next: /wrappers/linenoise/linenoise,  Prev: /wrappers/postgres,  Up: Top

327 Constant variables
**********************

   * LOCAL_HOST_NAMEDPIPE
          LOCAL_HOST_NAMEDPIPE* = '.'

   * SERVICENAME
          SERVICENAME* = "MySQL"

   * ONLY_KILL_QUERY
          ONLY_KILL_QUERY* = 1

   * MAX_BLOB_WIDTH
          MAX_BLOB_WIDTH* = 8192

   * packet_error
          packet_error* = - 1

   * SHUTDOWN_KILLABLE_UPDATE
          SHUTDOWN_KILLABLE_UPDATE* = chr(1 shl 3)

   * COMP_HEADER_SIZE
          COMP_HEADER_SIZE* = 3

   * NULL_LENGTH
          NULL_LENGTH*: int = int(not (0))

   * LONG_DATA_HEADER
          LONG_DATA_HEADER* = 6

   * CLIENT_NET_WRITE_TIMEOUT
          CLIENT_NET_WRITE_TIMEOUT* = 365 * 24 * 3600

   * COUNT_ERROR
          COUNT_ERROR* = not (my_ulonglong(0))

   * ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP
          ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP* = 10

   * MANAGER_INTERNAL_ERR
          MANAGER_INTERNAL_ERR* = 500

   * LOCAL_INFILE_ERROR_LEN
          LOCAL_INFILE_ERROR_LEN* = 512

   * DATA_TRUNCATED
          DATA_TRUNCATED* = 101

328 Types
*********

   * cuint
          cuint* = cint

   * Enum_server_command COM_SLEEP, COM_QUIT, COM_INIT_DB, COM_QUERY,
     COM_FIELD_LIST, COM_CREATE_DB, COM_DROP_DB, COM_REFRESH,
     COM_SHUTDOWN, COM_STATISTICS, COM_PROCESS_INFO, COM_CONNECT,
     COM_PROCESS_KILL, COM_DEBUG, COM_PING, COM_TIME,
     COM_DELAYED_INSERT, COM_CHANGE_USER, COM_BINLOG_DUMP,
     COM_TABLE_DUMP, COM_CONNECT_OUT, COM_REGISTER_SLAVE,
     COM_STMT_PREPARE, COM_STMT_EXECUTE, COM_STMT_SEND_LONG_DATA,
     COM_STMT_CLOSE, COM_STMT_RESET, COM_SET_OPTION, COM_STMT_FETCH,
     COM_END
          Enum_server_command* = enum
            COM_SLEEP, COM_QUIT, COM_INIT_DB, COM_QUERY, COM_FIELD_LIST, COM_CREATE_DB,
            COM_DROP_DB, COM_REFRESH, COM_SHUTDOWN, COM_STATISTICS, COM_PROCESS_INFO,
            COM_CONNECT, COM_PROCESS_KILL, COM_DEBUG, COM_PING, COM_TIME, COM_DELAYED_INSERT,
            COM_CHANGE_USER, COM_BINLOG_DUMP, COM_TABLE_DUMP, COM_CONNECT_OUT,
            COM_REGISTER_SLAVE, COM_STMT_PREPARE, COM_STMT_EXECUTE, COM_STMT_SEND_LONG_DATA,
            COM_STMT_CLOSE, COM_STMT_RESET, COM_SET_OPTION, COM_STMT_FETCH, COM_END

   * PNET
          PNET* = ptr NET

   * Enum_field_types TYPE_DECIMAL, TYPE_TINY, TYPE_SHORT, TYPE_LONG,
     TYPE_FLOAT, TYPE_DOUBLE, TYPE_NULL, TYPE_TIMESTAMP, TYPE_LONGLONG,
     TYPE_INT24, TYPE_DATE, TYPE_TIME, TYPE_DATETIME, TYPE_YEAR,
     TYPE_NEWDATE, TYPE_VARCHAR, TYPE_BIT, TYPE_NEWDECIMAL = 246,
     TYPE_ENUM = 247, TYPE_SET = 248, TYPE_TINY_BLOB = 249,
     TYPE_MEDIUM_BLOB = 250, TYPE_LONG_BLOB = 251, TYPE_BLOB = 252,
     TYPE_VAR_STRING = 253, TYPE_STRING = 254, TYPE_GEOMETRY = 255
          Enum_field_types* = enum
            TYPE_DECIMAL, TYPE_TINY, TYPE_SHORT, TYPE_LONG, TYPE_FLOAT, TYPE_DOUBLE, TYPE_NULL,
            TYPE_TIMESTAMP, TYPE_LONGLONG, TYPE_INT24, TYPE_DATE, TYPE_TIME, TYPE_DATETIME,
            TYPE_YEAR, TYPE_NEWDATE, TYPE_VARCHAR, TYPE_BIT, TYPE_NEWDECIMAL = 246,
            TYPE_ENUM = 247, TYPE_SET = 248, TYPE_TINY_BLOB = 249, TYPE_MEDIUM_BLOB = 250,
            TYPE_LONG_BLOB = 251, TYPE_BLOB = 252, TYPE_VAR_STRING = 253, TYPE_STRING = 254,
            TYPE_GEOMETRY = 255

   * Enum_mysql_set_option OPTION_MULTI_STATEMENTS_ON,
     OPTION_MULTI_STATEMENTS_OFF
          Enum_mysql_set_option* = enum
            OPTION_MULTI_STATEMENTS_ON, OPTION_MULTI_STATEMENTS_OFF

   * Sockaddr
          Sockaddr* {.final.} = object

   * PUDF_INIT
          PUDF_INIT* = ptr UDF_INIT

   * FIELD_OFFSET
          FIELD_OFFSET* = cuint

   * Pmy_ulonglong
          Pmy_ulonglong* = ptr my_ulonglong

   * ROW_OFFSET
          ROW_OFFSET* = ROWS

   * PMEM_ROOT
          PMEM_ROOT* = ptr MEM_ROOT

   * Option OPT_CONNECT_TIMEOUT, OPT_COMPRESS, OPT_NAMED_PIPE,
     INIT_COMMAND, READ_DEFAULT_FILE, READ_DEFAULT_GROUP,
     SET_CHARSET_DIR, SET_CHARSET_NAME, OPT_LOCAL_INFILE, OPT_PROTOCOL,
     SHARED_MEMORY_BASE_NAME, OPT_READ_TIMEOUT, OPT_WRITE_TIMEOUT,
     OPT_USE_RESULT, OPT_USE_REMOTE_CONNECTION,
     OPT_USE_EMBEDDED_CONNECTION, OPT_GUESS_CONNECTION, SET_CLIENT_IP,
     SECURE_AUTH, REPORT_DATA_TRUNCATION, OPT_RECONNECT
          Option* = enum
            OPT_CONNECT_TIMEOUT, OPT_COMPRESS, OPT_NAMED_PIPE, INIT_COMMAND,
            READ_DEFAULT_FILE, READ_DEFAULT_GROUP, SET_CHARSET_DIR, SET_CHARSET_NAME,
            OPT_LOCAL_INFILE, OPT_PROTOCOL, SHARED_MEMORY_BASE_NAME, OPT_READ_TIMEOUT,
            OPT_WRITE_TIMEOUT, OPT_USE_RESULT, OPT_USE_REMOTE_CONNECTION,
            OPT_USE_EMBEDDED_CONNECTION, OPT_GUESS_CONNECTION, SET_CLIENT_IP, SECURE_AUTH,
            REPORT_DATA_TRUNCATION, OPT_RECONNECT

   * Enum_stmt_attr_type STMT_ATTR_UPDATE_MAX_LENGTH,
     STMT_ATTR_CURSOR_TYPE, STMT_ATTR_PREFETCH_ROWS
          Enum_stmt_attr_type* = enum
            STMT_ATTR_UPDATE_MAX_LENGTH, STMT_ATTR_CURSOR_TYPE, STMT_ATTR_PREFETCH_ROWS

329 Procedures
**************

   * my_net_init importc: "my_net_init".}
          proc my_net_init*(net: PNET; vio: PVio): my_bool {.cdecl, dynlib: lib,
              importc: "my_net_init".}

   * my_net_local_init
          proc my_net_local_init*(net: PNET) {.cdecl, dynlib: lib, importc: "my_net_local_init".}

   * net_end
          proc net_end*(net: PNET) {.cdecl, dynlib: lib, importc: "net_end".}

   * net_clear
          proc net_clear*(net: PNET) {.cdecl, dynlib: lib, importc: "net_clear".}

   * net_realloc importc: "net_realloc".}
          proc net_realloc*(net: PNET; len: int): my_bool {.cdecl, dynlib: lib,
              importc: "net_realloc".}

   * net_flush
          proc net_flush*(net: PNET): my_bool {.cdecl, dynlib: lib, importc: "net_flush".}

   * my_net_write dynlib: lib, importc: "my_net_write".}
          proc my_net_write*(net: PNET; packet: cstring; length: int): my_bool {.cdecl,
              dynlib: lib, importc: "my_net_write".}

   * net_write_command packet: cstring; length: int): my_bool {.cdecl,
     dynlib: lib, importc: "net_write_command".}
          proc net_write_command*(net: PNET; command: char; header: cstring; head_len: int;
                                 packet: cstring; length: int): my_bool {.cdecl, dynlib: lib,
              importc: "net_write_command".}

   * net_real_write importc: "net_real_write".}
          proc net_real_write*(net: PNET; packet: cstring; length: int): cint {.cdecl, dynlib: lib,
              importc: "net_real_write".}

   * my_net_read
          proc my_net_read*(net: PNET): int {.cdecl, dynlib: lib, importc: "my_net_read".}

   * my_connect cdecl, dynlib: lib, importc: "my_connect".}
          proc my_connect*(s: my_socket; name: Psockaddr; namelen: cuint; timeout: cuint): cint {.
              cdecl, dynlib: lib, importc: "my_connect".}

   * randominit importc: "randominit".}
          proc randominit*(para1: Prand_struct; seed1: int; seed2: int) {.cdecl, dynlib: lib,
              importc: "randominit".}

   * my_rnd
          proc my_rnd*(para1: Prand_struct): cdouble {.cdecl, dynlib: lib, importc: "my_rnd".}

   * create_random_string dynlib: lib, importc: "create_random_string".}
          proc create_random_string*(fto: cstring; len: cuint; rand_st: Prand_struct) {.cdecl,
              dynlib: lib, importc: "create_random_string".}

   * hash_password dynlib: lib, importc: "hash_password".}
          proc hash_password*(fto: int; password: cstring; password_len: cuint) {.cdecl,
              dynlib: lib, importc: "hash_password".}

   * make_scrambled_password_323 dynlib: lib, importc:
     "make_scrambled_password_323".}
          proc make_scrambled_password_323*(fto: cstring; password: cstring) {.cdecl,
              dynlib: lib, importc: "make_scrambled_password_323".}

   * scramble_323 dynlib: lib, importc: "scramble_323".}
          proc scramble_323*(fto: cstring; message: cstring; password: cstring) {.cdecl,
              dynlib: lib, importc: "scramble_323".}

   * check_scramble_323 dynlib: lib, importc: "check_scramble_323".}
          proc check_scramble_323*(para1: cstring; message: cstring; salt: int): my_bool {.cdecl,
              dynlib: lib, importc: "check_scramble_323".}

   * get_salt_from_password_323 importc: "get_salt_from_password_323".}
          proc get_salt_from_password_323*(res: ptr int; password: cstring) {.cdecl, dynlib: lib,
              importc: "get_salt_from_password_323".}

   * make_password_from_salt_323 importc:
     "make_password_from_salt_323".}
          proc make_password_from_salt_323*(fto: cstring; salt: ptr int) {.cdecl, dynlib: lib,
              importc: "make_password_from_salt_323".}

   * octet2hex importc: "octet2hex".}
          proc octet2hex*(fto: cstring; str: cstring; length: cuint): cstring {.cdecl, dynlib: lib,
              importc: "octet2hex".}

   * make_scrambled_password importc: "make_scrambled_password".}
          proc make_scrambled_password*(fto: cstring; password: cstring) {.cdecl, dynlib: lib,
              importc: "make_scrambled_password".}

   * scramble importc: "scramble".}
          proc scramble*(fto: cstring; message: cstring; password: cstring) {.cdecl, dynlib: lib,
              importc: "scramble".}

   * check_scramble cdecl, dynlib: lib, importc: "check_scramble".}
          proc check_scramble*(reply: cstring; message: cstring; hash_stage2: pointer): my_bool {.
              cdecl, dynlib: lib, importc: "check_scramble".}

   * get_salt_from_password importc: "get_salt_from_password".}
          proc get_salt_from_password*(res: pointer; password: cstring) {.cdecl, dynlib: lib,
              importc: "get_salt_from_password".}

   * make_password_from_salt dynlib: lib, importc:
     "make_password_from_salt".}
          proc make_password_from_salt*(fto: cstring; hash_stage2: pointer) {.cdecl,
              dynlib: lib, importc: "make_password_from_salt".}

   * get_tty_password importc: "get_tty_password".}
          proc get_tty_password*(opt_message: cstring): cstring {.cdecl, dynlib: lib,
              importc: "get_tty_password".}

   * errno_to_sqlstate importc: "mysql_errno_to_sqlstate".}
          proc errno_to_sqlstate*(errno: cuint): cstring {.cdecl, dynlib: lib,
              importc: "mysql_errno_to_sqlstate".}

   * modify_defaults_file option_value: cstring; section_name: cstring;
     remove_option: cint): cint {.cdecl, dynlib: lib, importc:
     "load_defaults".}
          proc modify_defaults_file*(file_location: cstring; option: cstring;
                                    option_value: cstring; section_name: cstring;
                                    remove_option: cint): cint {.cdecl, dynlib: lib,
              importc: "load_defaults".}

   * load_defaults argv: ptr cstringArray): cint {.cdecl, dynlib: lib,
     importc: "load_defaults".}
          proc load_defaults*(conf_file: cstring; groups: cstringArray; argc: ptr cint;
                             argv: ptr cstringArray): cint {.cdecl, dynlib: lib,
              importc: "load_defaults".}

   * my_init
          proc my_init*(): my_bool {.cdecl, dynlib: lib, importc: "my_init".}

   * my_thread_init
          proc my_thread_init*(): my_bool {.cdecl, dynlib: lib, importc: "my_thread_init".}

   * my_thread_end
          proc my_thread_end*() {.cdecl, dynlib: lib, importc: "my_thread_end".}

   * IS_PRI_KEY
          proc IS_PRI_KEY*(n: int32): bool

   * IS_NOT_NULL
          proc IS_NOT_NULL*(n: int32): bool

   * IS_BLOB
          proc IS_BLOB*(n: int32): bool

   * IS_NUM
          proc IS_NUM*(t: Enum_field_types): bool

   * INTERNAL_NUM_FIELD
          proc INTERNAL_NUM_FIELD*(f: Pst_mysql_field): bool

   * IS_NUM_FIELD
          proc IS_NUM_FIELD*(f: Pst_mysql_field): bool

   * server_init dynlib: lib, importc: "mysql_server_init".}
          proc server_init*(argc: cint; argv: cstringArray; groups: cstringArray): cint {.cdecl,
              dynlib: lib, importc: "mysql_server_init".}

   * server_end
          proc server_end*() {.cdecl, dynlib: lib, importc: "mysql_server_end".}

   * library_init dynlib: lib, importc: "mysql_server_init".}
          proc library_init*(argc: cint; argv: cstringArray; groups: cstringArray): cint {.cdecl,
              dynlib: lib, importc: "mysql_server_init".}

   * library_end
          proc library_end*() {.cdecl, dynlib: lib, importc: "mysql_server_end".}

   * get_parameters importc: "mysql_get_parameters".}
          proc get_parameters*(): PPARAMETERS {.stdcall, dynlib: lib,
                                             importc: "mysql_get_parameters".}

   * thread_init
          proc thread_init*(): my_bool {.stdcall, dynlib: lib, importc: "mysql_thread_init".}

   * thread_end
          proc thread_end*() {.stdcall, dynlib: lib, importc: "mysql_thread_end".}

   * num_rows importc: "mysql_num_rows".}
          proc num_rows*(res: PRES): my_ulonglong {.stdcall, dynlib: lib,
                                                importc: "mysql_num_rows".}

   * num_fields
          proc num_fields*(res: PRES): cuint {.stdcall, dynlib: lib, importc: "mysql_num_fields".}

   * eof
          proc eof*(res: PRES): my_bool {.stdcall, dynlib: lib, importc: "mysql_eof".}

   * fetch_field_direct importc: "mysql_fetch_field_direct".}
          proc fetch_field_direct*(res: PRES; fieldnr: cuint): PFIELD {.stdcall, dynlib: lib,
              importc: "mysql_fetch_field_direct".}

   * fetch_fields importc: "mysql_fetch_fields".}
          proc fetch_fields*(res: PRES): PFIELD {.stdcall, dynlib: lib,
                                              importc: "mysql_fetch_fields".}

   * row_tell
          proc row_tell*(res: PRES): ROW_OFFSET {.stdcall, dynlib: lib, importc: "mysql_row_tell".}

   * field_tell importc: "mysql_field_tell".}
          proc field_tell*(res: PRES): FIELD_OFFSET {.stdcall, dynlib: lib,
                                                  importc: "mysql_field_tell".}

   * field_count importc: "mysql_field_count".}
          proc field_count*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib,
                                                importc: "mysql_field_count".}

   * affected_rows importc: "mysql_affected_rows".}
          proc affected_rows*(MySQL: PMySQL): my_ulonglong {.stdcall, dynlib: lib,
              importc: "mysql_affected_rows".}

   * insert_id importc: "mysql_insert_id".}
          proc insert_id*(MySQL: PMySQL): my_ulonglong {.stdcall, dynlib: lib,
              importc: "mysql_insert_id".}

   * errno
          proc errno*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib, importc: "mysql_errno".}

   * error
          proc error*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: "mysql_error".}

   * sqlstate importc: "mysql_sqlstate".}
          proc sqlstate*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,
                                               importc: "mysql_sqlstate".}

   * warning_count importc: "mysql_warning_count".}
          proc warning_count*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib,
                                                  importc: "mysql_warning_count".}

   * info
          proc info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: "mysql_info".}

   * thread_id
          proc thread_id*(MySQL: PMySQL): int {.stdcall, dynlib: lib, importc: "mysql_thread_id".}

   * character_set_name importc: "mysql_character_set_name".}
          proc character_set_name*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,
              importc: "mysql_character_set_name".}

   * set_character_set importc: "mysql_set_character_set".}
          proc set_character_set*(MySQL: PMySQL; csname: cstring): int32 {.stdcall, dynlib: lib,
              importc: "mysql_set_character_set".}

   * init
          proc init*(MySQL: PMySQL): PMySQL {.stdcall, dynlib: lib, importc: "mysql_init".}

   * ssl_set cipher: cstring): my_bool {.stdcall, dynlib: lib, importc:
     "mysql_ssl_set".}
          proc ssl_set*(MySQL: PMySQL; key: cstring; cert: cstring; ca: cstring; capath: cstring;
                       cipher: cstring): my_bool {.stdcall, dynlib: lib,
                                                importc: "mysql_ssl_set".}

   * change_user stdcall, dynlib: lib, importc: "mysql_change_user".}
          proc change_user*(MySQL: PMySQL; user: cstring; passwd: cstring; db: cstring): my_bool {.
              stdcall, dynlib: lib, importc: "mysql_change_user".}

   * real_connect db: cstring; port: cuint; unix_socket: cstring;
     clientflag: int): PMySQL {.  stdcall, dynlib: lib, importc:
     "mysql_real_connect".}
          proc real_connect*(MySQL: PMySQL; host: cstring; user: cstring; passwd: cstring;
                            db: cstring; port: cuint; unix_socket: cstring; clientflag: int): PMySQL {.
              stdcall, dynlib: lib, importc: "mysql_real_connect".}

   * select_db importc: "mysql_select_db".}
          proc select_db*(MySQL: PMySQL; db: cstring): cint {.stdcall, dynlib: lib,
              importc: "mysql_select_db".}

   * query importc: "mysql_query".}
          proc query*(MySQL: PMySQL; q: cstring): cint {.stdcall, dynlib: lib,
              importc: "mysql_query".}

   * send_query importc: "mysql_send_query".}
          proc send_query*(MySQL: PMySQL; q: cstring; len: int): cint {.stdcall, dynlib: lib,
              importc: "mysql_send_query".}

   * real_query importc: "mysql_real_query".}
          proc real_query*(MySQL: PMySQL; q: cstring; len: int): cint {.stdcall, dynlib: lib,
              importc: "mysql_real_query".}

   * store_result importc: "mysql_store_result".}
          proc store_result*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib,
                                                importc: "mysql_store_result".}

   * use_result importc: "mysql_use_result".}
          proc use_result*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib,
                                              importc: "mysql_use_result".}

   * master_query importc: "mysql_master_query".}
          proc master_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_master_query".}

   * master_send_query dynlib: lib, importc: "mysql_master_send_query".}
          proc master_send_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall,
              dynlib: lib, importc: "mysql_master_send_query".}

   * slave_query importc: "mysql_slave_query".}
          proc slave_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_slave_query".}

   * slave_send_query dynlib: lib, importc: "mysql_slave_send_query".}
          proc slave_send_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall,
              dynlib: lib, importc: "mysql_slave_send_query".}

   * get_character_set_info dynlib: lib, importc:
     "mysql_get_character_set_info".}
          proc get_character_set_info*(MySQL: PMySQL; charset: PMY_CHARSET_INFO) {.stdcall,
              dynlib: lib, importc: "mysql_get_character_set_info".}

   * set_local_infile_default importc:
     "mysql_set_local_infile_default".}
          proc set_local_infile_default*(MySQL: PMySQL) {.cdecl, dynlib: lib,
              importc: "mysql_set_local_infile_default".}

   * enable_rpl_parse importc: "mysql_enable_rpl_parse".}
          proc enable_rpl_parse*(MySQL: PMySQL) {.stdcall, dynlib: lib,
                                               importc: "mysql_enable_rpl_parse".}

   * disable_rpl_parse importc: "mysql_disable_rpl_parse".}
          proc disable_rpl_parse*(MySQL: PMySQL) {.stdcall, dynlib: lib,
                                                importc: "mysql_disable_rpl_parse".}

   * rpl_parse_enabled importc: "mysql_rpl_parse_enabled".}
          proc rpl_parse_enabled*(MySQL: PMySQL): cint {.stdcall, dynlib: lib,
              importc: "mysql_rpl_parse_enabled".}

   * enable_reads_from_master importc:
     "mysql_enable_reads_from_master".}
          proc enable_reads_from_master*(MySQL: PMySQL) {.stdcall, dynlib: lib,
              importc: "mysql_enable_reads_from_master".}

   * disable_reads_from_master importc:
     "mysql_disable_reads_from_master".}
          proc disable_reads_from_master*(MySQL: PMySQL) {.stdcall, dynlib: lib,
              importc: "mysql_disable_reads_from_master".}

   * reads_from_master_enabled importc:
     "mysql_reads_from_master_enabled".}
          proc reads_from_master_enabled*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_reads_from_master_enabled".}

   * rpl_query_type importc: "mysql_rpl_query_type".}
          proc rpl_query_type*(q: cstring; length: cint): Rpl_type {.stdcall, dynlib: lib,
              importc: "mysql_rpl_query_type".}

   * rpl_probe importc: "mysql_rpl_probe".}
          proc rpl_probe*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,
                                                importc: "mysql_rpl_probe".}

   * set_master passwd: cstring): cint {.stdcall, dynlib: lib, importc:
     "mysql_set_master".}
          proc set_master*(MySQL: PMySQL; host: cstring; port: cuint; user: cstring;
                          passwd: cstring): cint {.stdcall, dynlib: lib,
                                                importc: "mysql_set_master".}

   * add_slave stdcall, dynlib: lib, importc: "mysql_add_slave".}
          proc add_slave*(MySQL: PMySQL; host: cstring; port: cuint; user: cstring; passwd: cstring): cint {.
              stdcall, dynlib: lib, importc: "mysql_add_slave".}

   * shutdown dynlib: lib, importc: "mysql_shutdown".}
          proc shutdown*(MySQL: PMySQL; shutdown_level: Enum_shutdown_level): cint {.stdcall,
              dynlib: lib, importc: "mysql_shutdown".}

   * dump_debug_info importc: "mysql_dump_debug_info".}
          proc dump_debug_info*(MySQL: PMySQL): cint {.stdcall, dynlib: lib,
              importc: "mysql_dump_debug_info".}

   * refresh importc: "mysql_refresh".}
          proc refresh*(sql: PMySQL; refresh_options: cuint): cint {.stdcall, dynlib: lib,
              importc: "mysql_refresh".}

   * kill
          proc kill*(MySQL: PMySQL; pid: int): cint {.stdcall, dynlib: lib, importc: "mysql_kill".}

   * set_server_option dynlib: lib, importc: "mysql_set_server_option".}
          proc set_server_option*(MySQL: PMySQL; option: Enum_mysql_set_option): cint {.stdcall,
              dynlib: lib, importc: "mysql_set_server_option".}

   * ping
          proc ping*(MySQL: PMySQL): cint {.stdcall, dynlib: lib, importc: "mysql_ping".}

   * stat
          proc stat*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: "mysql_stat".}

   * get_server_info importc: "mysql_get_server_info".}
          proc get_server_info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,
              importc: "mysql_get_server_info".}

   * get_client_info importc: "mysql_get_client_info".}
          proc get_client_info*(): cstring {.stdcall, dynlib: lib,
                                          importc: "mysql_get_client_info".}

   * get_client_version importc: "mysql_get_client_version".}
          proc get_client_version*(): int {.stdcall, dynlib: lib,
                                         importc: "mysql_get_client_version".}

   * get_host_info importc: "mysql_get_host_info".}
          proc get_host_info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,
              importc: "mysql_get_host_info".}

   * get_server_version importc: "mysql_get_server_version".}
          proc get_server_version*(MySQL: PMySQL): int {.stdcall, dynlib: lib,
              importc: "mysql_get_server_version".}

   * get_proto_info importc: "mysql_get_proto_info".}
          proc get_proto_info*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib,
              importc: "mysql_get_proto_info".}

   * list_dbs importc: "mysql_list_dbs".}
          proc list_dbs*(MySQL: PMySQL; wild: cstring): PRES {.stdcall, dynlib: lib,
              importc: "mysql_list_dbs".}

   * list_tables importc: "mysql_list_tables".}
          proc list_tables*(MySQL: PMySQL; wild: cstring): PRES {.stdcall, dynlib: lib,
              importc: "mysql_list_tables".}

   * list_processes importc: "mysql_list_processes".}
          proc list_processes*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib,
                                                  importc: "mysql_list_processes".}

   * options importc: "mysql_options".}
          proc options*(MySQL: PMySQL; option: Option; arg: cstring): cint {.stdcall, dynlib: lib,
              importc: "mysql_options".}

   * free_result
          proc free_result*(result: PRES) {.stdcall, dynlib: lib, importc: "mysql_free_result".}

   * data_seek importc: "mysql_data_seek".}
          proc data_seek*(result: PRES; offset: my_ulonglong) {.stdcall, dynlib: lib,
              importc: "mysql_data_seek".}

   * row_seek importc: "mysql_row_seek".}
          proc row_seek*(result: PRES; offset: ROW_OFFSET): ROW_OFFSET {.stdcall, dynlib: lib,
              importc: "mysql_row_seek".}

   * field_seek dynlib: lib, importc: "mysql_field_seek".}
          proc field_seek*(result: PRES; offset: FIELD_OFFSET): FIELD_OFFSET {.stdcall,
              dynlib: lib, importc: "mysql_field_seek".}

   * fetch_row
          proc fetch_row*(result: PRES): ROW {.stdcall, dynlib: lib, importc: "mysql_fetch_row".}

   * fetch_lengths importc: "mysql_fetch_lengths".}
          proc fetch_lengths*(result: PRES): ptr int {.stdcall, dynlib: lib,
                                                  importc: "mysql_fetch_lengths".}

   * fetch_field importc: "mysql_fetch_field".}
          proc fetch_field*(result: PRES): PFIELD {.stdcall, dynlib: lib,
                                                importc: "mysql_fetch_field".}

   * list_fields dynlib: lib, importc: "mysql_list_fields".}
          proc list_fields*(MySQL: PMySQL; table: cstring; wild: cstring): PRES {.stdcall,
              dynlib: lib, importc: "mysql_list_fields".}

   * escape_string dynlib: lib, importc: "mysql_escape_string".}
          proc escape_string*(fto: cstring; `from`: cstring; from_length: int): int {.stdcall,
              dynlib: lib, importc: "mysql_escape_string".}

   * hex_string dynlib: lib, importc: "mysql_hex_string".}
          proc hex_string*(fto: cstring; `from`: cstring; from_length: int): int {.stdcall,
              dynlib: lib, importc: "mysql_hex_string".}

   * real_escape_string stdcall, dynlib: lib, importc:
     "mysql_real_escape_string".}
          proc real_escape_string*(MySQL: PMySQL; fto: cstring; `from`: cstring; len: int): int {.
              stdcall, dynlib: lib, importc: "mysql_real_escape_string".}

   * debug
          proc debug*(debug: cstring) {.stdcall, dynlib: lib, importc: "mysql_debug".}

   * myodbc_remove_escape importc: "myodbc_remove_escape".}
          proc myodbc_remove_escape*(MySQL: PMySQL; name: cstring) {.stdcall, dynlib: lib,
              importc: "myodbc_remove_escape".}

   * thread_safe
          proc thread_safe*(): cuint {.stdcall, dynlib: lib, importc: "mysql_thread_safe".}

   * embedded
          proc embedded*(): my_bool {.stdcall, dynlib: lib, importc: "mysql_embedded".}

   * manager_init importc: "mysql_manager_init".}
          proc manager_init*(con: PMANAGER): PMANAGER {.stdcall, dynlib: lib,
              importc: "mysql_manager_init".}

   * manager_connect port: cuint): PMANAGER {.stdcall, dynlib: lib,
     importc: "mysql_manager_connect".}
          proc manager_connect*(con: PMANAGER; host: cstring; user: cstring; passwd: cstring;
                               port: cuint): PMANAGER {.stdcall, dynlib: lib,
              importc: "mysql_manager_connect".}

   * manager_close importc: "mysql_manager_close".}
          proc manager_close*(con: PMANAGER) {.stdcall, dynlib: lib,
                                            importc: "mysql_manager_close".}

   * manager_command dynlib: lib, importc: "mysql_manager_command".}
          proc manager_command*(con: PMANAGER; cmd: cstring; cmd_len: cint): cint {.stdcall,
              dynlib: lib, importc: "mysql_manager_command".}

   * manager_fetch_line stdcall, dynlib: lib, importc:
     "mysql_manager_fetch_line".}
          proc manager_fetch_line*(con: PMANAGER; res_buf: cstring; res_buf_size: cint): cint {.
              stdcall, dynlib: lib, importc: "mysql_manager_fetch_line".}

   * read_query_result importc: "mysql_read_query_result".}
          proc read_query_result*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_read_query_result".}

   * stmt_init importc: "mysql_stmt_init".}
          proc stmt_init*(MySQL: PMySQL): PSTMT {.stdcall, dynlib: lib,
                                              importc: "mysql_stmt_init".}

   * stmt_prepare importc: "mysql_stmt_prepare".}
          proc stmt_prepare*(stmt: PSTMT; query: cstring; len: int): cint {.stdcall, dynlib: lib,
              importc: "mysql_stmt_prepare".}

   * stmt_execute importc: "mysql_stmt_execute".}
          proc stmt_execute*(stmt: PSTMT): cint {.stdcall, dynlib: lib,
                                              importc: "mysql_stmt_execute".}

   * stmt_fetch
          proc stmt_fetch*(stmt: PSTMT): cint {.stdcall, dynlib: lib, importc: "mysql_stmt_fetch".}

   * stmt_fetch_column stdcall, dynlib: lib, importc:
     "mysql_stmt_fetch_column".}
          proc stmt_fetch_column*(stmt: PSTMT; `bind`: PBIND; column: cuint; offset: int): cint {.
              stdcall, dynlib: lib, importc: "mysql_stmt_fetch_column".}

   * stmt_store_result importc: "mysql_stmt_store_result".}
          proc stmt_store_result*(stmt: PSTMT): cint {.stdcall, dynlib: lib,
              importc: "mysql_stmt_store_result".}

   * stmt_param_count importc: "mysql_stmt_param_count".}
          proc stmt_param_count*(stmt: PSTMT): int {.stdcall, dynlib: lib,
                                                 importc: "mysql_stmt_param_count".}

   * stmt_attr_set stdcall, dynlib: lib, importc:
     "mysql_stmt_attr_set".}
          proc stmt_attr_set*(stmt: PSTMT; attr_type: Enum_stmt_attr_type; attr: pointer): my_bool {.
              stdcall, dynlib: lib, importc: "mysql_stmt_attr_set".}

   * stmt_attr_get stdcall, dynlib: lib, importc:
     "mysql_stmt_attr_get".}
          proc stmt_attr_get*(stmt: PSTMT; attr_type: Enum_stmt_attr_type; attr: pointer): my_bool {.
              stdcall, dynlib: lib, importc: "mysql_stmt_attr_get".}

   * stmt_bind_param importc: "mysql_stmt_bind_param".}
          proc stmt_bind_param*(stmt: PSTMT; bnd: PBIND): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_stmt_bind_param".}

   * stmt_bind_result importc: "mysql_stmt_bind_result".}
          proc stmt_bind_result*(stmt: PSTMT; bnd: PBIND): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_stmt_bind_result".}

   * stmt_close importc: "mysql_stmt_close".}
          proc stmt_close*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib,
                                               importc: "mysql_stmt_close".}

   * stmt_reset importc: "mysql_stmt_reset".}
          proc stmt_reset*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib,
                                               importc: "mysql_stmt_reset".}

   * stmt_free_result importc: "mysql_stmt_free_result".}
          proc stmt_free_result*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_stmt_free_result".}

   * stmt_send_long_data stdcall, dynlib: lib, importc:
     "mysql_stmt_send_long_data".}
          proc stmt_send_long_data*(stmt: PSTMT; param_number: cuint; data: cstring; len: int): my_bool {.
              stdcall, dynlib: lib, importc: "mysql_stmt_send_long_data".}

   * stmt_result_metadata importc: "mysql_stmt_result_metadata".}
          proc stmt_result_metadata*(stmt: PSTMT): PRES {.stdcall, dynlib: lib,
              importc: "mysql_stmt_result_metadata".}

   * stmt_param_metadata importc: "mysql_stmt_param_metadata".}
          proc stmt_param_metadata*(stmt: PSTMT): PRES {.stdcall, dynlib: lib,
              importc: "mysql_stmt_param_metadata".}

   * stmt_errno importc: "mysql_stmt_errno".}
          proc stmt_errno*(stmt: PSTMT): cuint {.stdcall, dynlib: lib,
                                             importc: "mysql_stmt_errno".}

   * stmt_error importc: "mysql_stmt_error".}
          proc stmt_error*(stmt: PSTMT): cstring {.stdcall, dynlib: lib,
                                               importc: "mysql_stmt_error".}

   * stmt_sqlstate importc: "mysql_stmt_sqlstate".}
          proc stmt_sqlstate*(stmt: PSTMT): cstring {.stdcall, dynlib: lib,
                                                  importc: "mysql_stmt_sqlstate".}

   * stmt_row_seek dynlib: lib, importc: "mysql_stmt_row_seek".}
          proc stmt_row_seek*(stmt: PSTMT; offset: ROW_OFFSET): ROW_OFFSET {.stdcall,
              dynlib: lib, importc: "mysql_stmt_row_seek".}

   * stmt_row_tell importc: "mysql_stmt_row_tell".}
          proc stmt_row_tell*(stmt: PSTMT): ROW_OFFSET {.stdcall, dynlib: lib,
              importc: "mysql_stmt_row_tell".}

   * stmt_data_seek importc: "mysql_stmt_data_seek".}
          proc stmt_data_seek*(stmt: PSTMT; offset: my_ulonglong) {.stdcall, dynlib: lib,
              importc: "mysql_stmt_data_seek".}

   * stmt_num_rows importc: "mysql_stmt_num_rows".}
          proc stmt_num_rows*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib,
              importc: "mysql_stmt_num_rows".}

   * stmt_affected_rows importc: "mysql_stmt_affected_rows".}
          proc stmt_affected_rows*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib,
              importc: "mysql_stmt_affected_rows".}

   * stmt_insert_id importc: "mysql_stmt_insert_id".}
          proc stmt_insert_id*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib,
              importc: "mysql_stmt_insert_id".}

   * stmt_field_count importc: "mysql_stmt_field_count".}
          proc stmt_field_count*(stmt: PSTMT): cuint {.stdcall, dynlib: lib,
              importc: "mysql_stmt_field_count".}

   * commit
          proc commit*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, importc: "mysql_commit".}

   * rollback importc: "mysql_rollback".}
          proc rollback*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,
                                               importc: "mysql_rollback".}

   * autocommit importc: "mysql_autocommit".}
          proc autocommit*(MySQL: PMySQL; auto_mode: my_bool): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_autocommit".}

   * more_results importc: "mysql_more_results".}
          proc more_results*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,
              importc: "mysql_more_results".}

   * next_result importc: "mysql_next_result".}
          proc next_result*(MySQL: PMySQL): cint {.stdcall, dynlib: lib,
                                               importc: "mysql_next_result".}

   * close
          proc close*(sock: PMySQL) {.stdcall, dynlib: lib, importc: "mysql_close".}

   * reload
          proc reload*(x: PMySQL): cint

   * connect stdcall, dynlib: lib, importc: "mysql_connect".}
          proc connect*(MySQL: PMySQL; host: cstring; user: cstring; passwd: cstring): PMySQL {.
              stdcall, dynlib: lib, importc: "mysql_connect".}

   * create_db importc: "mysql_create_db".}
          proc create_db*(MySQL: PMySQL; DB: cstring): cint {.stdcall, dynlib: lib,
              importc: "mysql_create_db".}

   * drop_db importc: "mysql_drop_db".}
          proc drop_db*(MySQL: PMySQL; DB: cstring): cint {.stdcall, dynlib: lib,
              importc: "mysql_drop_db".}

   * net_safe_read importc: "net_safe_read".}
          proc net_safe_read*(MySQL: PMySQL): cuint {.cdecl, dynlib: lib,
                                                  importc: "net_safe_read".}


File: nim-ref-0.13.0.info,  Node: /wrappers/linenoise/linenoise,  Next: /windows/winlean,  Prev: /wrappers/mysql,  Up: Top

330 Types
*********

   * CompletionCallback
          CompletionCallback* = proc (a2: cstring; a3: ptr Completions) {.cdecl.}

331 Procedures
**************

   * setCompletionCallback importc: "linenoiseSetCompletionCallback".}
          proc setCompletionCallback*(a2: ptr CompletionCallback) {.
              importc: "linenoiseSetCompletionCallback".}

   * addCompletion importc: "linenoiseAddCompletion".}
          proc addCompletion*(a2: ptr Completions; a3: cstring) {.
              importc: "linenoiseAddCompletion".}

   * readLine
          proc readLine*(prompt: cstring): cstring {.importc: "linenoise".}

   * historyAdd
          proc historyAdd*(line: cstring): cint {.importc: "linenoiseHistoryAdd", discardable.}

   * historySetMaxLen
          proc historySetMaxLen*(len: cint): cint {.importc: "linenoiseHistorySetMaxLen".}

   * historySave
          proc historySave*(filename: cstring): cint {.importc: "linenoiseHistorySave".}

   * historyLoad
          proc historyLoad*(filename: cstring): cint {.importc: "linenoiseHistoryLoad".}

   * clearScreen
          proc clearScreen*() {.importc: "linenoiseClearScreen".}

   * setMultiLine
          proc setMultiLine*(ml: cint) {.importc: "linenoiseSetMultiLine".}

   * printKeyCodes
          proc printKeyCodes*() {.importc: "linenoisePrintKeyCodes".}

   * free
          proc free*(s: cstring) {.importc: "free", header: "<stdlib.h>".}


File: nim-ref-0.13.0.info,  Node: /windows/winlean,  Next: /js/dom,  Prev: /wrappers/linenoise/linenoise,  Up: Top

332 Constant variables
**********************

   * useWinUnicode
          useWinUnicode* = not defined(useWinAnsi)

   * CREATE_NO_WINDOW
          CREATE_NO_WINDOW* = 0x08000000'i32

   * MAX_PATH
          MAX_PATH* = 260

   * WSAEINPROGRESS
          WSAEINPROGRESS* = 10036

   * MAXIMUM_WAIT_OBJECTS
          MAXIMUM_WAIT_OBJECTS* = 0x00000040

   * FILE_WRITE_DATA
          FILE_WRITE_DATA* = 0x00000002

   * ERROR_HANDLE_EOF
          ERROR_HANDLE_EOF* = 38

   * ERROR_NETNAME_DELETED
          ERROR_NETNAME_DELETED* = 64

   * IOC_INOUT
          IOC_INOUT* = IOC_IN or IOC_OUT

   * AF_INET6
          AF_INET6* = 23

333 Variables
*************

   * SO_ERROR
          SO_ERROR* {.importc, header: "winsock2.h".}: cint

   * WSAID_GETACCEPTEXSOCKADDRS D3: 0x000011CF, D4: [0x95'i8, 0xCA'i8,
     0x00'i8, 0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])
          WSAID_GETACCEPTEXSOCKADDRS*: GUID = GUID(D1: 0xB5367DF2'i32, D2: 0xCBAC'i16,
                                                D3: 0x000011CF, D4: [0x95'i8, 0xCA'i8, 0x00'i8,
              0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])

334 Types
*********

   * BY_HANDLE_FILE_INFORMATION dwFileAttributes*: DWORD
     ftCreationTime*: FILETIME ftLastAccessTime*: FILETIME
     ftLastWriteTime*: FILETIME dwVolumeSerialNumber*: DWORD
     nFileSizeHigh*: DWORD nFileSizeLow*: DWORD nNumberOfLinks*: DWORD
     nFileIndexHigh*: DWORD nFileIndexLow*: DWORD

          BY_HANDLE_FILE_INFORMATION* {.final, pure.} = object
            dwFileAttributes*: DWORD
            ftCreationTime*: FILETIME
            ftLastAccessTime*: FILETIME
            ftLastWriteTime*: FILETIME
            dwVolumeSerialNumber*: DWORD
            nFileSizeHigh*: DWORD
            nFileSizeLow*: DWORD
            nNumberOfLinks*: DWORD
            nFileIndexHigh*: DWORD
            nFileIndexLow*: DWORD


   * WinChar
          WinChar* = Utf16Char

   * WIN32_FIND_DATA dwFileAttributes*: int32 ftCreationTime*: FILETIME
     ftLastAccessTime*: FILETIME ftLastWriteTime*: FILETIME
     nFileSizeHigh*: int32 nFileSizeLow*: int32 dwReserved0: int32
     dwReserved1: int32 cFileName*: array[0 ..  (MAX_PATH) - 1, WinChar]
     cAlternateFileName*: array[0 ..  13, WinChar]

          WIN32_FIND_DATA* {.pure.} = object
            dwFileAttributes*: int32
            ftCreationTime*: FILETIME
            ftLastAccessTime*: FILETIME
            ftLastWriteTime*: FILETIME
            nFileSizeHigh*: int32
            nFileSizeLow*: int32
            dwReserved0: int32
            dwReserved1: int32
            cFileName*: array[0 .. (MAX_PATH) - 1, WinChar]
            cAlternateFileName*: array[0 .. 13, WinChar]


   * SocketHandle
          SocketHandle* = distinct int

   * SockLen
          SockLen* = cuint

   * PWOHandleArray
          PWOHandleArray* = ptr WOHandleArray

   * GUID D1*: int32 D2*: int16 D3*: int16 D4*: array[0 ..  7, int8]

          GUID* {.final, pure.} = object
            D1*: int32
            D2*: int16
            D3*: int16
            D4*: array[0 .. 7, int8]


   * TWSABuf len*: ULONG buf*: cstring

          TWSABuf* {.importc: "WSABUF", header: "winsock2.h".} = object
            len*: ULONG
            buf*: cstring


335 Procedures
**************

   * closeHandle importc: "CloseHandle".}
          proc closeHandle*(hObject: Handle): WINBOOL {.stdcall, dynlib: "kernel32",
              importc: "CloseHandle".}

   * readFile lpNumberOfBytesRead: ptr int32; lpOverlapped: pointer):
     WINBOOL {.  stdcall, dynlib: "kernel32", importc: "ReadFile".}
          proc readFile*(hFile: Handle; Buffer: pointer; nNumberOfBytesToRead: int32;
                        lpNumberOfBytesRead: ptr int32; lpOverlapped: pointer): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "ReadFile".}

   * writeFile lpNumberOfBytesWritten: ptr int32; lpOverlapped:
     pointer): WINBOOL {.  stdcall, dynlib: "kernel32", importc:
     "WriteFile".}
          proc writeFile*(hFile: Handle; Buffer: pointer; nNumberOfBytesToWrite: int32;
                         lpNumberOfBytesWritten: ptr int32; lpOverlapped: pointer): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "WriteFile".}

   * createPipe lpPipeAttributes: var SECURITY_ATTRIBUTES; nSize:
     int32): WINBOOL {.  stdcall, dynlib: "kernel32", importc:
     "CreatePipe".}
          proc createPipe*(hReadPipe, hWritePipe: var Handle;
                          lpPipeAttributes: var SECURITY_ATTRIBUTES; nSize: int32): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "CreatePipe".}

   * createNamedPipe nOutBufferSize, nInBufferSize, nDefaultTimeOut:
     int32; lpSecurityAttributes: ptr SECURITY_ATTRIBUTES): Handle {.
     stdcall, dynlib: "kernel32", importc: "CreateNamedPipeW".}
          proc createNamedPipe*(lpName: WideCString; dwOpenMode, dwPipeMode, nMaxInstances,
                                                  nOutBufferSize, nInBufferSize,
                                                  nDefaultTimeOut: int32;
                               lpSecurityAttributes: ptr SECURITY_ATTRIBUTES): Handle {.
              stdcall, dynlib: "kernel32", importc: "CreateNamedPipeW".}

   * peekNamedPipe nBufferSize: int32 = 0; lpBytesRead: ptr int32 = nil;
     lpTotalBytesAvail: ptr int32 = nil; lpBytesLeftThisMessage: ptr
     int32 = nil): bool {.stdcall, dynlib: "kernel32", importc:
     "PeekNamedPipe".}
          proc peekNamedPipe*(hNamedPipe: Handle; lpBuffer: pointer = nil;
                             nBufferSize: int32 = 0; lpBytesRead: ptr int32 = nil;
                             lpTotalBytesAvail: ptr int32 = nil;
                             lpBytesLeftThisMessage: ptr int32 = nil): bool {.stdcall,
              dynlib: "kernel32", importc: "PeekNamedPipe".}

   * createProcessW lpProcessAttributes: ptr SECURITY_ATTRIBUTES;
     lpThreadAttributes: ptr SECURITY_ATTRIBUTES; bInheritHandles:
     WINBOOL; dwCreationFlags: int32; lpEnvironment, lpCurrentDirectory:
     WideCString; lpStartupInfo: var STARTUPINFO; lpProcessInformation:
     var PROCESS_INFORMATION): WINBOOL {.  stdcall, dynlib: "kernel32",
     importc: "CreateProcessW".}
          proc createProcessW*(lpApplicationName, lpCommandLine: WideCString;
                              lpProcessAttributes: ptr SECURITY_ATTRIBUTES;
                              lpThreadAttributes: ptr SECURITY_ATTRIBUTES;
                              bInheritHandles: WINBOOL; dwCreationFlags: int32;
                              lpEnvironment, lpCurrentDirectory: WideCString;
                              lpStartupInfo: var STARTUPINFO;
                              lpProcessInformation: var PROCESS_INFORMATION): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "CreateProcessW".}

   * suspendThread importc: "SuspendThread".}
          proc suspendThread*(hThread: Handle): int32 {.stdcall, dynlib: "kernel32",
              importc: "SuspendThread".}

   * resumeThread importc: "ResumeThread".}
          proc resumeThread*(hThread: Handle): int32 {.stdcall, dynlib: "kernel32",
              importc: "ResumeThread".}

   * waitForSingleObject dynlib: "kernel32", importc:
     "WaitForSingleObject".}
          proc waitForSingleObject*(hHandle: Handle; dwMilliseconds: int32): int32 {.stdcall,
              dynlib: "kernel32", importc: "WaitForSingleObject".}

   * terminateProcess dynlib: "kernel32", importc: "TerminateProcess".}
          proc terminateProcess*(hProcess: Handle; uExitCode: int): WINBOOL {.stdcall,
              dynlib: "kernel32", importc: "TerminateProcess".}

   * getExitCodeProcess dynlib: "kernel32", importc:
     "GetExitCodeProcess".}
          proc getExitCodeProcess*(hProcess: Handle; lpExitCode: var int32): WINBOOL {.stdcall,
              dynlib: "kernel32", importc: "GetExitCodeProcess".}

   * getStdHandle importc: "GetStdHandle".}
          proc getStdHandle*(nStdHandle: int32): Handle {.stdcall, dynlib: "kernel32",
              importc: "GetStdHandle".}

   * setStdHandle dynlib: "kernel32", importc: "SetStdHandle".}
          proc setStdHandle*(nStdHandle: int32; hHandle: Handle): WINBOOL {.stdcall,
              dynlib: "kernel32", importc: "SetStdHandle".}

   * flushFileBuffers importc: "FlushFileBuffers".}
          proc flushFileBuffers*(hFile: Handle): WINBOOL {.stdcall, dynlib: "kernel32",
              importc: "FlushFileBuffers".}

   * getLastError
          proc getLastError*(): int32 {.importc: "GetLastError", stdcall, dynlib: "kernel32".}

   * formatMessageW dwMessageId, dwLanguageId: int32; lpBuffer: pointer;
     nSize: int32; Arguments: pointer): int32 {.  importc:
     "FormatMessageW", stdcall, dynlib: "kernel32".}
          proc formatMessageW*(dwFlags: int32; lpSource: pointer;
                              dwMessageId, dwLanguageId: int32; lpBuffer: pointer;
                              nSize: int32; Arguments: pointer): int32 {.
              importc: "FormatMessageW", stdcall, dynlib: "kernel32".}

   * localFree
          proc localFree*(p: pointer) {.importc: "LocalFree", stdcall, dynlib: "kernel32".}

   * getCurrentDirectoryW importc: "GetCurrentDirectoryW", dynlib:
     "kernel32", stdcall.}
          proc getCurrentDirectoryW*(nBufferLength: int32; lpBuffer: WideCString): int32 {.
              importc: "GetCurrentDirectoryW", dynlib: "kernel32", stdcall.}

   * setCurrentDirectoryW importc: "SetCurrentDirectoryW", dynlib:
     "kernel32", stdcall.}
          proc setCurrentDirectoryW*(lpPathName: WideCString): int32 {.
              importc: "SetCurrentDirectoryW", dynlib: "kernel32", stdcall.}

   * createDirectoryW importc: "CreateDirectoryW", dynlib: "kernel32",
     stdcall.}
          proc createDirectoryW*(pathName: WideCString; security: pointer = nil): int32 {.
              importc: "CreateDirectoryW", dynlib: "kernel32", stdcall.}

   * removeDirectoryW importc: "RemoveDirectoryW", dynlib: "kernel32",
     stdcall.}
          proc removeDirectoryW*(lpPathName: WideCString): int32 {.
              importc: "RemoveDirectoryW", dynlib: "kernel32", stdcall.}

   * setEnvironmentVariableW dynlib: "kernel32", importc:
     "SetEnvironmentVariableW".}
          proc setEnvironmentVariableW*(lpName, lpValue: WideCString): int32 {.stdcall,
              dynlib: "kernel32", importc: "SetEnvironmentVariableW".}

   * getModuleFileNameW importc: "GetModuleFileNameW", dynlib:
     "kernel32", stdcall.}
          proc getModuleFileNameW*(handle: Handle; buf: WideCString; size: int32): int32 {.
              importc: "GetModuleFileNameW", dynlib: "kernel32", stdcall.}

   * createSymbolicLinkW flags: DWORD): int32 {.importc:
     "CreateSymbolicLinkW", dynlib: "kernel32", stdcall.}
          proc createSymbolicLinkW*(lpSymlinkFileName, lpTargetFileName: WideCString;
                                   flags: DWORD): int32 {.importc: "CreateSymbolicLinkW",
              dynlib: "kernel32", stdcall.}

   * createHardLinkW security: pointer = nil): int32 {.importc:
     "CreateHardLinkW", dynlib: "kernel32", stdcall.}
          proc createHardLinkW*(lpFileName, lpExistingFileName: WideCString;
                               security: pointer = nil): int32 {.importc: "CreateHardLinkW",
              dynlib: "kernel32", stdcall.}

   * findFirstFileW stdcall, dynlib: "kernel32", importc:
     "FindFirstFileW".}
          proc findFirstFileW*(lpFileName: WideCString; lpFindFileData: var WIN32_FIND_DATA): Handle {.
              stdcall, dynlib: "kernel32", importc: "FindFirstFileW".}

   * findNextFileW stdcall, dynlib: "kernel32", importc:
     "FindNextFileW".}
          proc findNextFileW*(hFindFile: Handle; lpFindFileData: var WIN32_FIND_DATA): int32 {.
              stdcall, dynlib: "kernel32", importc: "FindNextFileW".}

   * findClose
          proc findClose*(hFindFile: Handle) {.stdcall, dynlib: "kernel32", importc: "FindClose".}

   * getFullPathNameW lpBuffer: WideCString; lpFilePart: var
     WideCString): int32 {.  stdcall, dynlib: "kernel32", importc:
     "GetFullPathNameW".}
          proc getFullPathNameW*(lpFileName: WideCString; nBufferLength: int32;
                                lpBuffer: WideCString; lpFilePart: var WideCString): int32 {.
              stdcall, dynlib: "kernel32", importc: "GetFullPathNameW".}

   * getFileAttributesW dynlib: "kernel32", importc:
     "GetFileAttributesW".}
          proc getFileAttributesW*(lpFileName: WideCString): int32 {.stdcall,
              dynlib: "kernel32", importc: "GetFileAttributesW".}

   * setFileAttributesW stdcall, dynlib: "kernel32", importc:
     "SetFileAttributesW".}
          proc setFileAttributesW*(lpFileName: WideCString; dwFileAttributes: int32): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "SetFileAttributesW".}

   * copyFileW importc: "CopyFileW", stdcall, dynlib: "kernel32".}
          proc copyFileW*(lpExistingFileName, lpNewFileName: WideCString; bFailIfExists: cint): cint {.
              importc: "CopyFileW", stdcall, dynlib: "kernel32".}

   * moveFileW importc: "MoveFileW", stdcall, dynlib: "kernel32".}
          proc moveFileW*(lpExistingFileName, lpNewFileName: WideCString; bFailIfExists: cint): cint {.
              importc: "MoveFileW", stdcall, dynlib: "kernel32".}

   * getEnvironmentStringsW importc: "GetEnvironmentStringsW".}
          proc getEnvironmentStringsW*(): WideCString {.stdcall, dynlib: "kernel32",
              importc: "GetEnvironmentStringsW".}

   * freeEnvironmentStringsW dynlib: "kernel32", importc:
     "FreeEnvironmentStringsW".}
          proc freeEnvironmentStringsW*(para1: WideCString): int32 {.stdcall,
              dynlib: "kernel32", importc: "FreeEnvironmentStringsW".}

   * getCommandLineW dynlib: "kernel32".}
          proc getCommandLineW*(): WideCString {.importc: "GetCommandLineW", stdcall,
                                              dynlib: "kernel32".}

   * rdFileTime
          proc rdFileTime*(f: FILETIME): int64

   * rdFileSize
          proc rdFileSize*(f: WIN32_FIND_DATA): int64

   * getSystemTimeAsFileTime importc: "GetSystemTimeAsFileTime", dynlib:
     "kernel32", stdcall.}
          proc getSystemTimeAsFileTime*(lpSystemTimeAsFileTime: var FILETIME) {.
              importc: "GetSystemTimeAsFileTime", dynlib: "kernel32", stdcall.}

   * sleep
          proc sleep*(dwMilliseconds: int32) {.stdcall, dynlib: "kernel32", importc: "Sleep".}

   * shellExecuteW lpOperation, lpFile, lpParameters, lpDirectory:
     WideCString; nShowCmd: int32): Handle {.stdcall, dynlib:
     "shell32.dll", importc: "ShellExecuteW".}
          proc shellExecuteW*(HWND: Handle;
                             lpOperation, lpFile, lpParameters, lpDirectory: WideCString;
                             nShowCmd: int32): Handle {.stdcall, dynlib: "shell32.dll",
              importc: "ShellExecuteW".}

   * getFileInformationByHandle stdcall, dynlib: "kernel32", importc:
     "GetFileInformationByHandle".}
          proc getFileInformationByHandle*(hFile: Handle; lpFileInformation: ptr BY_HANDLE_FILE_INFORMATION): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "GetFileInformationByHandle".}

   * wsaGetLastError
          proc wsaGetLastError*(): cint {.importc: "WSAGetLastError", dynlib: ws2dll.}

   * '=='
          proc `==`*(x, y: SocketHandle): bool {.borrow.}

   * getservbyname importc: "getservbyname", dynlib: ws2dll.}
          proc getservbyname*(name, proto: cstring): ptr Servent {.stdcall,
              importc: "getservbyname", dynlib: ws2dll.}

   * getservbyport importc: "getservbyport", dynlib: ws2dll.}
          proc getservbyport*(port: cint; proto: cstring): ptr Servent {.stdcall,
              importc: "getservbyport", dynlib: ws2dll.}

   * gethostbyaddr importc: "gethostbyaddr", dynlib: ws2dll.}
          proc gethostbyaddr*(ip: ptr InAddr; len: cuint; theType: cint): ptr Hostent {.stdcall,
              importc: "gethostbyaddr", dynlib: ws2dll.}

   * gethostbyname dynlib: ws2dll.}
          proc gethostbyname*(name: cstring): ptr Hostent {.stdcall, importc: "gethostbyname",
              dynlib: ws2dll.}

   * socket dynlib: ws2dll.}
          proc socket*(af, typ, protocol: cint): SocketHandle {.stdcall, importc: "socket",
              dynlib: ws2dll.}

   * closesocket dynlib: ws2dll.}
          proc closesocket*(s: SocketHandle): cint {.stdcall, importc: "closesocket",
                                                 dynlib: ws2dll.}

   * accept stdcall, importc: "accept", dynlib: ws2dll.}
          proc accept*(s: SocketHandle; a: ptr SockAddr; addrlen: ptr SockLen): SocketHandle {.
              stdcall, importc: "accept", dynlib: ws2dll.}

   * bindSocket importc: "bind", dynlib: ws2dll.}
          proc bindSocket*(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.stdcall,
              importc: "bind", dynlib: ws2dll.}

   * connect importc: "connect", dynlib: ws2dll.}
          proc connect*(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.stdcall,
              importc: "connect", dynlib: ws2dll.}

   * getsockname stdcall, importc: "getsockname", dynlib: ws2dll.}
          proc getsockname*(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {.
              stdcall, importc: "getsockname", dynlib: ws2dll.}

   * getpeername stdcall, importc, dynlib: ws2dll.}
          proc getpeername*(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {.
              stdcall, importc, dynlib: ws2dll.}

   * getsockopt optlen: ptr SockLen): cint {.stdcall, importc:
     "getsockopt", dynlib: ws2dll.}
          proc getsockopt*(s: SocketHandle; level, optname: cint; optval: pointer;
                          optlen: ptr SockLen): cint {.stdcall, importc: "getsockopt",
              dynlib: ws2dll.}

   * setsockopt stdcall, importc: "setsockopt", dynlib: ws2dll.}
          proc setsockopt*(s: SocketHandle; level, optname: cint; optval: pointer; optlen: SockLen): cint {.
              stdcall, importc: "setsockopt", dynlib: ws2dll.}

   * listen dynlib: ws2dll.}
          proc listen*(s: SocketHandle; backlog: cint): cint {.stdcall, importc: "listen",
              dynlib: ws2dll.}

   * recv importc: "recv", dynlib: ws2dll.}
          proc recv*(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall,
              importc: "recv", dynlib: ws2dll.}

   * recvfrom fromlen: ptr SockLen): cint {.stdcall, importc:
     "recvfrom", dynlib: ws2dll.}
          proc recvfrom*(s: SocketHandle; buf: cstring; len, flags: cint; fromm: ptr SockAddr;
                        fromlen: ptr SockLen): cint {.stdcall, importc: "recvfrom",
                                                  dynlib: ws2dll.}

   * select stdcall, importc: "select", dynlib: ws2dll.}
          proc select*(nfds: cint; readfds, writefds, exceptfds: ptr TFdSet; timeout: ptr Timeval): cint {.
              stdcall, importc: "select", dynlib: ws2dll.}

   * send importc: "send", dynlib: ws2dll.}
          proc send*(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall,
              importc: "send", dynlib: ws2dll.}

   * sendto tolen: SockLen): cint {.stdcall, importc: "sendto", dynlib:
     ws2dll.}
          proc sendto*(s: SocketHandle; buf: pointer; len, flags: cint; to: ptr SockAddr;
                      tolen: SockLen): cint {.stdcall, importc: "sendto", dynlib: ws2dll.}

   * shutdown dynlib: ws2dll.}
          proc shutdown*(s: SocketHandle; how: cint): cint {.stdcall, importc: "shutdown",
              dynlib: ws2dll.}

   * getnameinfo a6: SockLen; a7: cint): cint {.stdcall, importc:
     "getnameinfo", dynlib: ws2dll.}
          proc getnameinfo*(a1: ptr SockAddr; a2: SockLen; a3: cstring; a4: SockLen; a5: cstring;
                           a6: SockLen; a7: cint): cint {.stdcall, importc: "getnameinfo",
              dynlib: ws2dll.}

   * inet_addr
          proc inet_addr*(cp: cstring): int32 {.stdcall, importc: "inet_addr", dynlib: ws2dll.}

   * FD_ISSET
          proc FD_ISSET*(socket: SocketHandle; set: var TFdSet): cint

   * FD_SET
          proc FD_SET*(socket: SocketHandle; s: var TFdSet)

   * FD_ZERO
          proc FD_ZERO*(s: var TFdSet)

   * wsaStartup importc: "WSAStartup", dynlib: ws2dll.}
          proc wsaStartup*(wVersionRequired: int16; WSData: ptr WSAData): cint {.stdcall,
              importc: "WSAStartup", dynlib: ws2dll.}

   * getaddrinfo res: var ptr AddrInfo): cint {.stdcall, importc:
     "getaddrinfo", dynlib: ws2dll.}
          proc getaddrinfo*(nodename, servname: cstring; hints: ptr AddrInfo;
                           res: var ptr AddrInfo): cint {.stdcall, importc: "getaddrinfo",
              dynlib: ws2dll.}

   * freeaddrinfo
          proc freeaddrinfo*(ai: ptr AddrInfo) {.stdcall, importc: "freeaddrinfo", dynlib: ws2dll.}

   * inet_ntoa
          proc inet_ntoa*(i: InAddr): cstring {.stdcall, importc, dynlib: ws2dll.}

   * inet_ntop stringBufSize: int32): cstring {.stdcall, importc,
     dynlib: ws2dll.}
          proc inet_ntop*(family: cint; paddr: pointer; pStringBuffer: cstring;
                         stringBufSize: int32): cstring {.stdcall, importc, dynlib: ws2dll.}

   * waitForMultipleObjects bWaitAll: WINBOOL; dwMilliseconds: DWORD):
     DWORD {.  stdcall, dynlib: "kernel32", importc:
     "WaitForMultipleObjects".}
          proc waitForMultipleObjects*(nCount: DWORD; lpHandles: PWOHandleArray;
                                      bWaitAll: WINBOOL; dwMilliseconds: DWORD): DWORD {.
              stdcall, dynlib: "kernel32", importc: "WaitForMultipleObjects".}

   * duplicateHandle hTargetProcessHandle: HANDLE; lpTargetHandle: ptr
     HANDLE; dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; dwOptions:
     DWORD): WINBOOL {.stdcall, dynlib: "kernel32", importc:
     "DuplicateHandle".}
          proc duplicateHandle*(hSourceProcessHandle: HANDLE; hSourceHandle: HANDLE;
                               hTargetProcessHandle: HANDLE; lpTargetHandle: ptr HANDLE;
                               dwDesiredAccess: DWORD; bInheritHandle: WINBOOL;
                               dwOptions: DWORD): WINBOOL {.stdcall, dynlib: "kernel32",
              importc: "DuplicateHandle".}

   * getCurrentProcess importc: "GetCurrentProcess".}
          proc getCurrentProcess*(): HANDLE {.stdcall, dynlib: "kernel32",
                                           importc: "GetCurrentProcess".}

   * createFileW lpSecurityAttributes: pointer; dwCreationDisposition,
     dwFlagsAndAttributes: DWORD; hTemplateFile: Handle): Handle
     {.stdcall, dynlib: "kernel32", importc: "CreateFileW".}
          proc createFileW*(lpFileName: WideCString; dwDesiredAccess, dwShareMode: DWORD;
                           lpSecurityAttributes: pointer;
                           dwCreationDisposition, dwFlagsAndAttributes: DWORD;
                           hTemplateFile: Handle): Handle {.stdcall, dynlib: "kernel32",
              importc: "CreateFileW".}

   * deleteFileW dynlib: "kernel32", stdcall.}
          proc deleteFileW*(pathName: WideCString): int32 {.importc: "DeleteFileW",
              dynlib: "kernel32", stdcall.}

   * setEndOfFile importc: "SetEndOfFile".}
          proc setEndOfFile*(hFile: Handle): WINBOOL {.stdcall, dynlib: "kernel32",
              importc: "SetEndOfFile".}

   * setFilePointer lpDistanceToMoveHigh: ptr LONG; dwMoveMethod:
     DWORD): DWORD {.  stdcall, dynlib: "kernel32", importc:
     "SetFilePointer".}
          proc setFilePointer*(hFile: Handle; lDistanceToMove: LONG;
                              lpDistanceToMoveHigh: ptr LONG; dwMoveMethod: DWORD): DWORD {.
              stdcall, dynlib: "kernel32", importc: "SetFilePointer".}

   * getFileSize dynlib: "kernel32", importc: "GetFileSize".}
          proc getFileSize*(hFile: Handle; lpFileSizeHigh: ptr DWORD): DWORD {.stdcall,
              dynlib: "kernel32", importc: "GetFileSize".}

   * mapViewOfFileEx dwFileOffsetHigh, dwFileOffsetLow: DWORD;
     dwNumberOfBytesToMap: DWORD; lpBaseAddress: pointer): pointer {.
     stdcall, dynlib: "kernel32", importc: "MapViewOfFileEx".}
          proc mapViewOfFileEx*(hFileMappingObject: Handle; dwDesiredAccess: DWORD;
                               dwFileOffsetHigh, dwFileOffsetLow: DWORD;
                               dwNumberOfBytesToMap: DWORD; lpBaseAddress: pointer): pointer {.
              stdcall, dynlib: "kernel32", importc: "MapViewOfFileEx".}

   * createFileMappingW flProtect, dwMaximumSizeHigh: DWORD;
     dwMaximumSizeLow: DWORD; lpName: pointer): Handle {.stdcall,
     dynlib: "kernel32", importc: "CreateFileMappingW".}
          proc createFileMappingW*(hFile: Handle; lpFileMappingAttributes: pointer;
                                  flProtect, dwMaximumSizeHigh: DWORD;
                                  dwMaximumSizeLow: DWORD; lpName: pointer): Handle {.stdcall,
              dynlib: "kernel32", importc: "CreateFileMappingW".}

   * createFileMappingA flProtect, dwMaximumSizeHigh: DWORD;
     dwMaximumSizeLow: DWORD; lpName: cstring): THANDLE {.stdcall,
     dynlib: "kernel32", importc: "CreateFileMappingA".}
          proc createFileMappingA*(hFile: THANDLE; lpFileMappingAttributes: pointer;
                                  flProtect, dwMaximumSizeHigh: DWORD;
                                  dwMaximumSizeLow: DWORD; lpName: cstring): THANDLE {.stdcall,
              dynlib: "kernel32", importc: "CreateFileMappingA".}

   * unmapViewOfFile importc: "UnmapViewOfFile".}
          proc unmapViewOfFile*(lpBaseAddress: pointer): WINBOOL {.stdcall, dynlib: "kernel32",
              importc: "UnmapViewOfFile".}

   * createIoCompletionPort CompletionKey: DWORD;
     NumberOfConcurrentThreads: DWORD): Handle {.  stdcall, dynlib:
     "kernel32", importc: "CreateIoCompletionPort".}
          proc createIoCompletionPort*(FileHandle: Handle; ExistingCompletionPort: Handle;
                                      CompletionKey: DWORD; NumberOfConcurrentThreads: DWORD): Handle {.
              stdcall, dynlib: "kernel32", importc: "CreateIoCompletionPort".}

   * getQueuedCompletionStatus lpNumberOfBytesTransferred: PDWORD;
     lpCompletionKey: PULONG; lpOverlapped: ptr POVERLAPPED;
     dwMilliseconds: DWORD): WINBOOL {.  stdcall, dynlib: "kernel32",
     importc: "GetQueuedCompletionStatus".}
          proc getQueuedCompletionStatus*(CompletionPort: Handle;
                                         lpNumberOfBytesTransferred: PDWORD;
                                         lpCompletionKey: PULONG;
                                         lpOverlapped: ptr POVERLAPPED; dwMilliseconds: DWORD): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "GetQueuedCompletionStatus".}

   * getOverlappedResult lpNumberOfBytesTransferred: var DWORD; bWait:
     WINBOOL): WINBOOL {.  stdcall, dynlib: "kernel32", importc:
     "GetOverlappedResult".}
          proc getOverlappedResult*(hFile: Handle; lpOverlapped: OVERLAPPED;
                                   lpNumberOfBytesTransferred: var DWORD; bWait: WINBOOL): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "GetOverlappedResult".}

   * WSAIoctl cbInBuffer: DWORD; lpvOutBuffer: pointer; cbOutBuffer:
     DWORD; lpcbBytesReturned: PDWORD; lpOverlapped: POVERLAPPED;
     lpCompletionRoutine: POVERLAPPED_COMPLETION_ROUTINE): cint
     {.stdcall, importc: "WSAIoctl", dynlib: "Ws2_32.dll".}
          proc WSAIoctl*(s: SocketHandle; dwIoControlCode: DWORD; lpvInBuffer: pointer;
                        cbInBuffer: DWORD; lpvOutBuffer: pointer; cbOutBuffer: DWORD;
                        lpcbBytesReturned: PDWORD; lpOverlapped: POVERLAPPED;
                        lpCompletionRoutine: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall,
              importc: "WSAIoctl", dynlib: "Ws2_32.dll".}

   * WSARecv bytesReceived, flags: PDWORD; lpOverlapped: POVERLAPPED;
     completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall,
     importc: "WSARecv", dynlib: "Ws2_32.dll".}
          proc WSARecv*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
                       bytesReceived, flags: PDWORD; lpOverlapped: POVERLAPPED;
                       completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall,
              importc: "WSARecv", dynlib: "Ws2_32.dll".}

   * WSASend flags: DWORD; lpOverlapped: POVERLAPPED; completionProc:
     POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall, importc:
     "WSASend", dynlib: "Ws2_32.dll".}
          proc WSASend*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; bytesSent: PDWORD;
                       flags: DWORD; lpOverlapped: POVERLAPPED;
                       completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall,
              importc: "WSASend", dynlib: "Ws2_32.dll".}

   * get_osfhandle header: "<io.h>".}
          proc get_osfhandle*(fd: FileHandle): Handle {.importc: "_get_osfhandle",
              header: "<io.h>".}

   * getSystemTimes stdcall, dynlib: "kernel32", importc:
     "GetSystemTimes".}
          proc getSystemTimes*(lpIdleTime, lpKernelTime, lpUserTime: var FILETIME): WINBOOL {.
              stdcall, dynlib: "kernel32", importc: "GetSystemTimes".}

   * getProcessTimes lpUserTime: var FILETIME): WINBOOL {.stdcall,
     dynlib: "kernel32", importc: "GetProcessTimes".}
          proc getProcessTimes*(hProcess: Handle; lpCreationTime, lpExitTime, lpKernelTime,
                                               lpUserTime: var FILETIME): WINBOOL {.stdcall,
              dynlib: "kernel32", importc: "GetProcessTimes".}

336 Templates
*************

   * WSAIORW
          template WSAIORW*(x, y): expr


File: nim-ref-0.13.0.info,  Node: /js/dom,  Next: /posix/inotify,  Prev: /windows/winlean,  Up: Top

337 Variables
*************

   * screen
          screen* {.importc, nodecl.}: Screen

338 Types
*********

   * TInterval
          TInterval* {.importc.} = object of RootObj

   * TApplet
          TApplet* {.importc, deprecated.} = object of RootObj

339 Procedures
**************

   * addEventListener useCapture: bool = false)
          proc addEventListener*(et: EventTarget; ev: cstring; cb: proc (ev: Event);
                                useCapture: bool = false)

   * alert
          proc alert*(w: Window; msg: cstring)

   * back
          proc back*(w: Window)

   * blur
          proc blur*(w: Window)

   * captureEvents
          proc captureEvents*(w: Window; eventMask: int) {.deprecated.}

   * clearInterval
          proc clearInterval*(w: Window; interval: ref TInterval)

   * clearTimeout
          proc clearTimeout*(w: Window; timeout: ref TTimeOut)

   * close
          proc close*(w: Window)

   * confirm
          proc confirm*(w: Window; msg: cstring): bool

   * disableExternalCapture
          proc disableExternalCapture*(w: Window)

   * enableExternalCapture
          proc enableExternalCapture*(w: Window)

   * find
          proc find*(w: Window; text: cstring; caseSensitive = false; backwards = false)

   * focus
          proc focus*(w: Window)

   * forward
          proc forward*(w: Window)

   * handleEvent
          proc handleEvent*(w: Window; e: Event)

   * home
          proc home*(w: Window)

   * moveBy
          proc moveBy*(w: Window; x, y: int)

   * moveTo
          proc moveTo*(w: Window; x, y: int)

   * open
          proc open*(w: Window; uri, windowname: cstring; properties: cstring = nil): Window

   * print
          proc print*(w: Window)

   * prompt
          proc prompt*(w: Window; text, default: cstring): cstring

   * releaseEvents
          proc releaseEvents*(w: Window; eventMask: int) {.deprecated.}

   * resizeBy
          proc resizeBy*(w: Window; x, y: int)

   * resizeTo
          proc resizeTo*(w: Window; x, y: int)

   * routeEvent
          proc routeEvent*(w: Window; event: Event)

   * scrollBy
          proc scrollBy*(w: Window; x, y: int)

   * scrollTo
          proc scrollTo*(w: Window; x, y: int)

   * setInterval
          proc setInterval*(w: Window; code: cstring; pause: int): ref TInterval

   * setTimeout
          proc setTimeout*(w: Window; code: cstring; pause: int): ref TTimeOut

   * stop
          proc stop*(w: Window)

   * appendChild
          proc appendChild*(n, child: Node)

   * appendData
          proc appendData*(n: Node; data: cstring)

   * cloneNode
          proc cloneNode*(n: Node; copyContent: bool): Node

   * deleteData
          proc deleteData*(n: Node; start, len: int)

   * getAttribute
          proc getAttribute*(n: Node; attr: cstring): cstring

   * getAttributeNode
          proc getAttributeNode*(n: Node; attr: cstring): Node

   * hasChildNodes
          proc hasChildNodes*(n: Node): bool

   * insertBefore
          proc insertBefore*(n, newNode, before: Node)

   * insertData
          proc insertData*(n: Node; position: int; data: cstring)

   * removeAttribute
          proc removeAttribute*(n: Node; attr: cstring)

   * removeAttributeNode
          proc removeAttributeNode*(n, attr: Node)

   * removeChild
          proc removeChild*(n, child: Node)

   * replaceChild
          proc replaceChild*(n, newNode, oldNode: Node)

   * replaceData
          proc replaceData*(n: Node; start, len: int; text: cstring)

   * scrollIntoView
          proc scrollIntoView*(n: Node)

   * setAttribute
          proc setAttribute*(n: Node; name, value: cstring)

   * setAttributeNode
          proc setAttributeNode*(n: Node; attr: Node)

   * captureEvents
          proc captureEvents*(d: Document; eventMask: int) {.deprecated.}

   * createAttribute
          proc createAttribute*(d: Document; identifier: cstring): Node

   * createElement
          proc createElement*(d: Document; identifier: cstring): Element

   * createTextNode
          proc createTextNode*(d: Document; identifier: cstring): Node

   * getElementById
          proc getElementById*(d: Document; id: cstring): Element

   * getElementsByName
          proc getElementsByName*(d: Document; name: cstring): seq[Element]

   * getElementsByTagName
          proc getElementsByTagName*(d: Document; name: cstring): seq[Element]

   * getElementsByClassName
          proc getElementsByClassName*(d: Document; name: cstring): seq[Element]

   * getSelection
          proc getSelection*(d: Document): cstring

   * handleEvent
          proc handleEvent*(d: Document; event: Event)

   * open
          proc open*(d: Document)

   * releaseEvents
          proc releaseEvents*(d: Document; eventMask: int) {.deprecated.}

   * routeEvent
          proc routeEvent*(d: Document; event: Event)

   * write
          proc write*(d: Document; text: cstring)

   * writeln
          proc writeln*(d: Document; text: cstring)

   * blur
          proc blur*(e: Element)

   * click
          proc click*(e: Element)

   * focus
          proc focus*(e: Element)

   * handleEvent
          proc handleEvent*(e: Element; event: Event)

   * select
          proc select*(e: Element)

   * getElementsByTagName
          proc getElementsByTagName*(e: Element; name: cstring): seq[Element]

   * getElementsByClassName
          proc getElementsByClassName*(e: Element; name: cstring): seq[Element]

   * reset
          proc reset*(f: FormElement)

   * submit
          proc submit*(f: FormElement)

   * play
          proc play*(e: EmbedElement)

   * stop
          proc stop*(e: EmbedElement)

   * reload
          proc reload*(loc: Location)

   * replace
          proc replace*(loc: Location; s: cstring)

   * back
          proc back*(h: History)

   * forward
          proc forward*(h: History)

   * go
          proc go*(h: History; pagesToJump: int)

   * javaEnabled
          proc javaEnabled*(h: Navigator): bool

   * add
          proc add*(c: ClassList; class: cstring)

   * remove
          proc remove*(c: ClassList; class: cstring)

   * contains
          proc contains*(c: ClassList; class: cstring): bool

   * toggle
          proc toggle*(c: ClassList; class: cstring)

   * getAttribute
          proc getAttribute*(s: Style; attr: cstring; caseSensitive = false): cstring

   * removeAttribute
          proc removeAttribute*(s: Style; attr: cstring; caseSensitive = false)

   * setAttribute
          proc setAttribute*(s: Style; attr, value: cstring; caseSensitive = false)

   * decodeURI
          proc decodeURI*(uri: cstring): cstring {.importc, nodecl.}

   * encodeURI
          proc encodeURI*(uri: cstring): cstring {.importc, nodecl.}

   * escape
          proc escape*(uri: cstring): cstring {.importc, nodecl.}

   * unescape
          proc unescape*(uri: cstring): cstring {.importc, nodecl.}

   * decodeURIComponent
          proc decodeURIComponent*(uri: cstring): cstring {.importc, nodecl.}

   * encodeURIComponent
          proc encodeURIComponent*(uri: cstring): cstring {.importc, nodecl.}

   * isFinite
          proc isFinite*(x: BiggestFloat): bool {.importc, nodecl.}

   * isNaN
          proc isNaN*(x: BiggestFloat): bool {.importc, nodecl.}

   * parseFloat
          proc parseFloat*(s: cstring): BiggestFloat {.importc, nodecl.}

   * parseInt
          proc parseInt*(s: cstring): int {.importc, nodecl.}

   * parseInt
          proc parseInt*(s: cstring; radix: int): int {.importc, nodecl.}


File: nim-ref-0.13.0.info,  Node: /posix/inotify,  Next: /posix/linux,  Prev: /js/dom,  Up: Top

340 Constant variables
**********************

   * IN_MOVE_SELF
          IN_MOVE_SELF* = 0x00000800

   * IN_IGNORED
          IN_IGNORED* = 0x00008000

   * IN_ONESHOT
          IN_ONESHOT* = 0x0000000080000000'i64

   * IN_ALL_EVENTS IN_CLOSE_NOWRITE or IN_OPEN or IN_MOVED_FROM or
     IN_MOVED_TO or IN_CREATE or IN_DELETE or IN_DELETE_SELF or
     IN_MOVE_SELF)
          IN_ALL_EVENTS* = (IN_ACCESS or IN_MODIFY or IN_ATTRIB or IN_CLOSE_WRITE or
              IN_CLOSE_NOWRITE or IN_OPEN or IN_MOVED_FROM or IN_MOVED_TO or IN_CREATE or
              IN_DELETE or IN_DELETE_SELF or IN_MOVE_SELF)

341 Types
*********

   * InotifyEvent header: "<sys/inotify.h>".} = object wd* {.importc:
     "wd".}: cint mask* {.importc: "mask".}: uint32 cookie* {.importc:
     "cookie".}: uint32 len* {.importc: "len".}: uint32 name* {.importc:
     "name".}: char

          InotifyEvent* {.pure, final, importc: "struct inotify_event",
                         header: "<sys/inotify.h>".} = object
            wd* {.importc: "wd".}: cint
            mask* {.importc: "mask".}: uint32
            cookie* {.importc: "cookie".}: uint32
            len* {.importc: "len".}: uint32
            name* {.importc: "name".}: char


342 Procedures
**************

   * inotify_init
          proc inotify_init*(): cint {.cdecl, importc: "inotify_init", header: "<sys/inotify.h>".}

   * inotify_init1 header: "<sys/inotify.h>".}
          proc inotify_init1*(flags: cint): cint {.cdecl, importc: "inotify_init1",
                                               header: "<sys/inotify.h>".}

   * inotify_add_watch importc: "inotify_add_watch", header:
     "<sys/inotify.h>".}
          proc inotify_add_watch*(fd: cint; name: cstring; mask: uint32): cint {.cdecl,
              importc: "inotify_add_watch", header: "<sys/inotify.h>".}

   * inotify_rm_watch header: "<sys/inotify.h>".}
          proc inotify_rm_watch*(fd: cint; wd: cint): cint {.cdecl, importc: "inotify_rm_watch",
              header: "<sys/inotify.h>".}


File: nim-ref-0.13.0.info,  Node: /posix/linux,  Next: /posix/posix,  Prev: /posix/inotify,  Up: Top

343 Constant variables
**********************

   * CLONE_STOPPED
          CLONE_STOPPED* = 0x02000000

344 Procedures
**************

   * clone tls: pointer; ctid: ptr Pid): cint {.importc, header:
     "<sched.h>".}
          proc clone*(fn: pointer; child_stack: pointer; flags: cint; arg: pointer; ptid: ptr Pid;
                     tls: pointer; ctid: ptr Pid): cint {.importc, header: "<sched.h>".}


File: nim-ref-0.13.0.info,  Node: /posix/posix,  Next: /posix/termios,  Prev: /posix/linux,  Up: Top

345 Constant variables
**********************

   * DT_WHT
          DT_WHT* = 14

   * MSG_NOSIGNAL
          MSG_NOSIGNAL* = 0'i32

   * POSIX_SPAWN_USEVFORK
          POSIX_SPAWN_USEVFORK* = cint(0x00000040)

   * INVALID_SOCKET
          INVALID_SOCKET* = SocketHandle(- 1)

346 Variables
*************

   * timezone
          timezone* {.importc, header: "<time.h>".}: int

   * LIO_WRITE
          LIO_WRITE* {.importc, header: "<aio.h>".}: cint

     A lio_listio() element operation option requesting a write.

   * POSIX_FADV_NOREUSE
          POSIX_FADV_NOREUSE* {.importc, header: "<fcntl.h>".}: cint

     The application expects to access the specified data once and then
     not reuse it thereafter.

   * MM_NOCON
          MM_NOCON* {.importc, header: "<fmtmsg.h>".}: cint

     The function was unable to generate a console message, but
     otherwise succeeded.

   * MSG_OOB
          MSG_OOB* {.importc, header: "<sys/socket.h>".}: cint

     Out-of-band data.

   * MAP_POPULATE
          MAP_POPULATE* {.importc, header: "<sys/mman.h>".}: cint

     Populate (prefault) page tables for a mapping.

   * SO_NOSIGPIPE
          SO_NOSIGPIPE* {.importc, header: "<sys/socket.h>".}: cint

   * POLLNVAL
          POLLNVAL* {.importc, header: "<poll.h>".}: cshort

     Invalid fd member (revents only).

   * POSIX_SPAWN_SETSIGMASK
          POSIX_SPAWN_SETSIGMASK* {.importc, header: "<spawn.h>".}: cint

   * in6addr_loopback
          in6addr_loopback* {.importc, header: "<netinet/in.h>".}: In6Addr

347 Types
*********

   * DIR

          DIR* {.importc: "DIR", header: "<dirent.h>", incompleteStruct.} = object


     A type representing a directory stream.

   * SocketHandle
          SocketHandle* = distinct cint

   * Ucontext uc_link*: ptr Ucontext ## Pointer to the context that is
     resumed ## when this context returns.  uc_sigmask*: Sigset ## The
     set of signals that are blocked when this ## context is active.
     uc_stack*: Stack ## The stack used by this context.  uc_mcontext*:
     Mcontext ## A machine-specific representation of the saved ##
     context.

          Ucontext* {.importc: "ucontext_t", header: "<ucontext.h>", final, pure.} = object
            uc_link*: ptr Ucontext        ## Pointer to the context that is resumed
                                ## when this context returns.
            uc_sigmask*: Sigset          ## The set of signals that are blocked when this
                              ## context is active.
            uc_stack*: Stack             ## The stack used by this context.
            uc_mcontext*: Mcontext       ## A machine-specific representation of the saved
                                 ## context.


     ucontext_t

   * Taiocb aio_fildes*: cint ## File descriptor.  aio_offset*: Off ##
     File offset.  aio_buf*: pointer ## Location of buffer.
     aio_nbytes*: int ## Length of transfer.  aio_reqprio*: cint ##
     Request priority offset.  aio_sigevent*: SigEvent ## Signal number
     and value.  aio_lio_opcode: cint ## Operation to be performed.

          Taiocb* {.importc: "struct aiocb", header: "<aio.h>", final, pure.} = object
            aio_fildes*: cint            ## File descriptor.
            aio_offset*: Off             ## File offset.
            aio_buf*: pointer            ## Location of buffer.
            aio_nbytes*: int             ## Length of transfer.
            aio_reqprio*: cint           ## Request priority offset.
            aio_sigevent*: SigEvent      ## Signal number and value.
            aio_lio_opcode: cint         ## Operation to be performed.


     struct aiocb

   * Tposix_spawn_file_actions header: "<spawn.h>", final, pure.} =
     object
          Tposix_spawn_file_actions* {.importc: "posix_spawn_file_actions_t",
                                      header: "<spawn.h>", final, pure.} = object

   * Tnfds
          Tnfds* {.importc: "nfds_t", header: "<poll.h>".} = cint

348 Procedures
**************

   * WIFCONTINUED
          proc WIFCONTINUED*(s: cint): bool {.importc, header: "<sys/wait.h>".}

     True if child has been continued.

   * WIFEXITED
          proc WIFEXITED*(s: cint): bool {.importc, header: "<sys/wait.h>".}

     True if child exited normally.

   * WIFSIGNALED
          proc WIFSIGNALED*(s: cint): bool {.importc, header: "<sys/wait.h>".}

     True if child exited due to uncaught signal.

   * WIFSTOPPED
          proc WIFSTOPPED*(s: cint): bool {.importc, header: "<sys/wait.h>".}

     True if child is currently stopped.

   * aio_cancel
          proc aio_cancel*(a1: cint; a2: ptr Taiocb): cint {.importc, header: "<aio.h>".}

   * aio_error
          proc aio_error*(a1: ptr Taiocb): cint {.importc, header: "<aio.h>".}

   * aio_fsync
          proc aio_fsync*(a1: cint; a2: ptr Taiocb): cint {.importc, header: "<aio.h>".}

   * aio_read
          proc aio_read*(a1: ptr Taiocb): cint {.importc, header: "<aio.h>".}

   * aio_return
          proc aio_return*(a1: ptr Taiocb): int {.importc, header: "<aio.h>".}

   * aio_suspend header: "<aio.h>".}
          proc aio_suspend*(a1: ptr ptr Taiocb; a2: cint; a3: ptr Timespec): cint {.importc,
              header: "<aio.h>".}

   * aio_write
          proc aio_write*(a1: ptr Taiocb): cint {.importc, header: "<aio.h>".}

   * lio_listio header: "<aio.h>".}
          proc lio_listio*(a1: cint; a2: ptr ptr Taiocb; a3: cint; a4: ptr SigEvent): cint {.importc,
              header: "<aio.h>".}

   * htonl
          proc htonl*(a1: int32): int32 {.importc, header: "<arpa/inet.h>".}

   * htons
          proc htons*(a1: int16): int16 {.importc, header: "<arpa/inet.h>".}

   * ntohl
          proc ntohl*(a1: int32): int32 {.importc, header: "<arpa/inet.h>".}

   * ntohs
          proc ntohs*(a1: int16): int16 {.importc, header: "<arpa/inet.h>".}

   * inet_addr
          proc inet_addr*(a1: cstring): InAddrT {.importc, header: "<arpa/inet.h>".}

   * inet_ntoa
          proc inet_ntoa*(a1: InAddr): cstring {.importc, header: "<arpa/inet.h>".}

   * inet_ntop importc: "(char *)$1", header: "<arpa/inet.h>".}
          proc inet_ntop*(a1: cint; a2: pointer; a3: cstring; a4: int32): cstring {.
              importc: "(char *)$1", header: "<arpa/inet.h>".}

   * inet_pton header: "<arpa/inet.h>".}
          proc inet_pton*(a1: cint; a2: cstring; a3: pointer): cint {.importc,
              header: "<arpa/inet.h>".}

   * IN6ADDR_ANY_INIT
          proc IN6ADDR_ANY_INIT*(): In6Addr {.importc, header: "<netinet/in.h>".}

   * IN6ADDR_LOOPBACK_INIT
          proc IN6ADDR_LOOPBACK_INIT*(): In6Addr {.importc, header: "<netinet/in.h>".}

   * closedir
          proc closedir*(a1: ptr DIR): cint {.importc, header: "<dirent.h>".}

   * opendir
          proc opendir*(a1: cstring): ptr DIR {.importc, header: "<dirent.h>".}

   * readdir
          proc readdir*(a1: ptr DIR): ptr Dirent {.importc, header: "<dirent.h>".}

   * readdir_r header: "<dirent.h>".}
          proc readdir_r*(a1: ptr DIR; a2: ptr Dirent; a3: ptr ptr Dirent): cint {.importc,
              header: "<dirent.h>".}

   * rewinddir
          proc rewinddir*(a1: ptr DIR) {.importc, header: "<dirent.h>".}

   * seekdir
          proc seekdir*(a1: ptr DIR; a2: int) {.importc, header: "<dirent.h>".}

   * telldir
          proc telldir*(a1: ptr DIR): int {.importc, header: "<dirent.h>".}

   * dlclose
          proc dlclose*(a1: pointer): cint {.importc, header: "<dlfcn.h>".}

   * dlerror
          proc dlerror*(): cstring {.importc, header: "<dlfcn.h>".}

   * dlopen
          proc dlopen*(a1: cstring; a2: cint): pointer {.importc, header: "<dlfcn.h>".}

   * dlsym
          proc dlsym*(a1: pointer; a2: cstring): pointer {.importc, header: "<dlfcn.h>".}

   * creat
          proc creat*(a1: cstring; a2: Mode): cint {.importc, header: "<fcntl.h>".}

   * fcntl header: "<fcntl.h>".}
          proc fcntl*(a1: cint | SocketHandle; a2: cint): cint {.varargs, importc,
              header: "<fcntl.h>".}

   * open
          proc open*(a1: cstring; a2: cint): cint {.varargs, importc, header: "<fcntl.h>".}

   * posix_fadvise
          proc posix_fadvise*(a1: cint; a2, a3: Off; a4: cint): cint {.importc, header: "<fcntl.h>".}

   * posix_fallocate
          proc posix_fallocate*(a1: cint; a2, a3: Off): cint {.importc, header: "<fcntl.h>".}

   * fmtmsg header: "<fmtmsg.h>".}
          proc fmtmsg*(a1: int; a2: cstring; a3: cint; a4, a5, a6: cstring): cint {.importc,
              header: "<fmtmsg.h>".}

   * fnmatch
          proc fnmatch*(a1, a2: cstring; a3: cint): cint {.importc, header: "<fnmatch.h>".}

   * ftw a2: proc (x1: cstring; x2: ptr Stat; x3: cint): cint
     {.noconv.}; a3: cint): cint {.  importc, header: "<ftw.h>".}
          proc ftw*(a1: cstring;
                   a2: proc (x1: cstring; x2: ptr Stat; x3: cint): cint {.noconv.}; a3: cint): cint {.
              importc, header: "<ftw.h>".}

   * nftw noconv.}; a3: cint; a4: cint): cint {.importc, header:
     "<ftw.h>".}
          proc nftw*(a1: cstring; a2: proc (x1: cstring; x2: ptr Stat; x3: cint; x4: ptr FTW): cint {.
              noconv.}; a3: cint; a4: cint): cint {.importc, header: "<ftw.h>".}

   * glob a4: ptr Glob): cint {.importc, header: "<glob.h>".}
          proc glob*(a1: cstring; a2: cint; a3: proc (x1: cstring; x2: cint): cint {.noconv.};
                    a4: ptr Glob): cint {.importc, header: "<glob.h>".}

   * globfree
          proc globfree*(a1: ptr Glob) {.importc, header: "<glob.h>".}

   * getgrgid
          proc getgrgid*(a1: Gid): ptr Group {.importc, header: "<grp.h>".}

   * getgrnam
          proc getgrnam*(a1: cstring): ptr Group {.importc, header: "<grp.h>".}

   * getgrgid_r importc, header: "<grp.h>".}
          proc getgrgid_r*(a1: Gid; a2: ptr Group; a3: cstring; a4: int; a5: ptr ptr Group): cint {.
              importc, header: "<grp.h>".}

   * getgrnam_r importc, header: "<grp.h>".}
          proc getgrnam_r*(a1: cstring; a2: ptr Group; a3: cstring; a4: int; a5: ptr ptr Group): cint {.
              importc, header: "<grp.h>".}

   * getgrent
          proc getgrent*(): ptr Group {.importc, header: "<grp.h>".}

   * endgrent
          proc endgrent*() {.importc, header: "<grp.h>".}

   * setgrent
          proc setgrent*() {.importc, header: "<grp.h>".}

   * iconv_open
          proc iconv_open*(a1, a2: cstring): Iconv {.importc, header: "<iconv.h>".}

   * iconv importc, header: "<iconv.h>".}
          proc iconv*(a1: Iconv; a2: var cstring; a3: var int; a4: var cstring; a5: var int): int {.
              importc, header: "<iconv.h>".}

   * iconv_close
          proc iconv_close*(a1: Iconv): cint {.importc, header: "<iconv.h>".}

   * nl_langinfo
          proc nl_langinfo*(a1: Nl_item): cstring {.importc, header: "<langinfo.h>".}

   * basename
          proc basename*(a1: cstring): cstring {.importc, header: "<libgen.h>".}

   * dirname
          proc dirname*(a1: cstring): cstring {.importc, header: "<libgen.h>".}

   * localeconv
          proc localeconv*(): ptr Lconv {.importc, header: "<locale.h>".}

   * setlocale
          proc setlocale*(a1: cint; a2: cstring): cstring {.importc, header: "<locale.h>".}

   * strfmon header: "<monetary.h>".}
          proc strfmon*(a1: cstring; a2: int; a3: cstring): int {.varargs, importc,
              header: "<monetary.h>".}

   * mq_close
          proc mq_close*(a1: Mqd): cint {.importc, header: "<mqueue.h>".}

   * mq_getattr
          proc mq_getattr*(a1: Mqd; a2: ptr MqAttr): cint {.importc, header: "<mqueue.h>".}

   * mq_notify
          proc mq_notify*(a1: Mqd; a2: ptr SigEvent): cint {.importc, header: "<mqueue.h>".}

   * mq_open
          proc mq_open*(a1: cstring; a2: cint): Mqd {.varargs, importc, header: "<mqueue.h>".}

   * mq_receive header: "<mqueue.h>".}
          proc mq_receive*(a1: Mqd; a2: cstring; a3: int; a4: var int): int {.importc,
              header: "<mqueue.h>".}

   * mq_send
          proc mq_send*(a1: Mqd; a2: cstring; a3: int; a4: int): cint {.importc, header: "<mqueue.h>".}

   * mq_setattr
          proc mq_setattr*(a1: Mqd; a2, a3: ptr MqAttr): cint {.importc, header: "<mqueue.h>".}

   * mq_timedreceive importc, header: "<mqueue.h>".}
          proc mq_timedreceive*(a1: Mqd; a2: cstring; a3: int; a4: int; a5: ptr Timespec): int {.
              importc, header: "<mqueue.h>".}

   * mq_timedsend header: "<mqueue.h>".}
          proc mq_timedsend*(a1: Mqd; a2: cstring; a3: int; a4: int; a5: ptr Timespec): cint {.importc,
              header: "<mqueue.h>".}

   * mq_unlink
          proc mq_unlink*(a1: cstring): cint {.importc, header: "<mqueue.h>".}

   * getpwnam
          proc getpwnam*(a1: cstring): ptr Passwd {.importc, header: "<pwd.h>".}

   * getpwuid
          proc getpwuid*(a1: Uid): ptr Passwd {.importc, header: "<pwd.h>".}

   * getpwnam_r importc, header: "<pwd.h>".}
          proc getpwnam_r*(a1: cstring; a2: ptr Passwd; a3: cstring; a4: int; a5: ptr ptr Passwd): cint {.
              importc, header: "<pwd.h>".}

   * getpwuid_r importc, header: "<pwd.h>".}
          proc getpwuid_r*(a1: Uid; a2: ptr Passwd; a3: cstring; a4: int; a5: ptr ptr Passwd): cint {.
              importc, header: "<pwd.h>".}

   * endpwent
          proc endpwent*() {.importc, header: "<pwd.h>".}

   * getpwent
          proc getpwent*(): ptr Passwd {.importc, header: "<pwd.h>".}

   * setpwent
          proc setpwent*() {.importc, header: "<pwd.h>".}

   * uname
          proc uname*(a1: var Utsname): cint {.importc, header: "<sys/utsname.h>".}

   * pthread_atfork header: "<pthread.h>".}
          proc pthread_atfork*(a1, a2, a3: proc () {.noconv.}): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_destroy
          proc pthread_attr_destroy*(a1: ptr PthreadAttr): cint {.importc, header: "<pthread.h>".}

   * pthread_attr_getdetachstate header: "<pthread.h>".}
          proc pthread_attr_getdetachstate*(a1: ptr PthreadAttr; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_getguardsize header: "<pthread.h>".}
          proc pthread_attr_getguardsize*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_getinheritsched header: "<pthread.h>".}
          proc pthread_attr_getinheritsched*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_getschedparam importc, header: "<pthread.h>".}
          proc pthread_attr_getschedparam*(a1: ptr PthreadAttr; a2: ptr Sched_param): cint {.
              importc, header: "<pthread.h>".}

   * pthread_attr_getschedpolicy header: "<pthread.h>".}
          proc pthread_attr_getschedpolicy*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_getscope header: "<pthread.h>".}
          proc pthread_attr_getscope*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_getstack importc, header: "<pthread.h>".}
          proc pthread_attr_getstack*(a1: ptr PthreadAttr; a2: var pointer; a3: var int): cint {.
              importc, header: "<pthread.h>".}

   * pthread_attr_getstackaddr header: "<pthread.h>".}
          proc pthread_attr_getstackaddr*(a1: ptr PthreadAttr; a2: var pointer): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_getstacksize header: "<pthread.h>".}
          proc pthread_attr_getstacksize*(a1: ptr PthreadAttr; a2: var int): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_init
          proc pthread_attr_init*(a1: ptr PthreadAttr): cint {.importc, header: "<pthread.h>".}

   * pthread_attr_setdetachstate header: "<pthread.h>".}
          proc pthread_attr_setdetachstate*(a1: ptr PthreadAttr; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_setguardsize header: "<pthread.h>".}
          proc pthread_attr_setguardsize*(a1: ptr PthreadAttr; a2: int): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_setinheritsched header: "<pthread.h>".}
          proc pthread_attr_setinheritsched*(a1: ptr PthreadAttr; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_setschedparam importc, header: "<pthread.h>".}
          proc pthread_attr_setschedparam*(a1: ptr PthreadAttr; a2: ptr Sched_param): cint {.
              importc, header: "<pthread.h>".}

   * pthread_attr_setschedpolicy header: "<pthread.h>".}
          proc pthread_attr_setschedpolicy*(a1: ptr PthreadAttr; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_setscope header: "<pthread.h>".}
          proc pthread_attr_setscope*(a1: ptr PthreadAttr; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_setstack header: "<pthread.h>".}
          proc pthread_attr_setstack*(a1: ptr PthreadAttr; a2: pointer; a3: int): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_setstackaddr header: "<pthread.h>".}
          proc pthread_attr_setstackaddr*(a1: ptr PthreadAttr; a2: pointer): cint {.importc,
              header: "<pthread.h>".}

   * pthread_attr_setstacksize header: "<pthread.h>".}
          proc pthread_attr_setstacksize*(a1: ptr PthreadAttr; a2: int): cint {.importc,
              header: "<pthread.h>".}

   * pthread_barrier_destroy header: "<pthread.h>".}
          proc pthread_barrier_destroy*(a1: ptr Pthread_barrier): cint {.importc,
              header: "<pthread.h>".}

   * pthread_barrier_init a3: cint): cint {.importc, header:
     "<pthread.h>".}
          proc pthread_barrier_init*(a1: ptr Pthread_barrier; a2: ptr Pthread_barrierattr;
                                    a3: cint): cint {.importc, header: "<pthread.h>".}

   * pthread_barrier_wait header: "<pthread.h>".}
          proc pthread_barrier_wait*(a1: ptr Pthread_barrier): cint {.importc,
              header: "<pthread.h>".}

   * pthread_barrierattr_destroy header: "<pthread.h>".}
          proc pthread_barrierattr_destroy*(a1: ptr Pthread_barrierattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_barrierattr_getpshared importc, header: "<pthread.h>".}
          proc pthread_barrierattr_getpshared*(a1: ptr Pthread_barrierattr; a2: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_barrierattr_init header: "<pthread.h>".}
          proc pthread_barrierattr_init*(a1: ptr Pthread_barrierattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_barrierattr_setpshared importc, header: "<pthread.h>".}
          proc pthread_barrierattr_setpshared*(a1: ptr Pthread_barrierattr; a2: cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_cancel
          proc pthread_cancel*(a1: Pthread): cint {.importc, header: "<pthread.h>".}

   * pthread_cleanup_push header: "<pthread.h>".}
          proc pthread_cleanup_push*(a1: proc (x: pointer) {.noconv.}; a2: pointer) {.importc,
              header: "<pthread.h>".}

   * pthread_cleanup_pop
          proc pthread_cleanup_pop*(a1: cint) {.importc, header: "<pthread.h>".}

   * pthread_cond_broadcast header: "<pthread.h>".}
          proc pthread_cond_broadcast*(a1: ptr Pthread_cond): cint {.importc,
              header: "<pthread.h>".}

   * pthread_cond_destroy header: "<pthread.h>".}
          proc pthread_cond_destroy*(a1: ptr Pthread_cond): cint {.importc,
              header: "<pthread.h>".}

   * pthread_cond_init header: "<pthread.h>".}
          proc pthread_cond_init*(a1: ptr Pthread_cond; a2: ptr Pthread_condattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_cond_signal
          proc pthread_cond_signal*(a1: ptr Pthread_cond): cint {.importc, header: "<pthread.h>".}

   * pthread_cond_timedwait a3: ptr Timespec): cint {.importc, header:
     "<pthread.h>".}
          proc pthread_cond_timedwait*(a1: ptr Pthread_cond; a2: ptr Pthread_mutex;
                                      a3: ptr Timespec): cint {.importc, header: "<pthread.h>".}

   * pthread_cond_wait header: "<pthread.h>".}
          proc pthread_cond_wait*(a1: ptr Pthread_cond; a2: ptr Pthread_mutex): cint {.importc,
              header: "<pthread.h>".}

   * pthread_condattr_destroy header: "<pthread.h>".}
          proc pthread_condattr_destroy*(a1: ptr Pthread_condattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_condattr_getclock importc, header: "<pthread.h>".}
          proc pthread_condattr_getclock*(a1: ptr Pthread_condattr; a2: var ClockId): cint {.
              importc, header: "<pthread.h>".}

   * pthread_condattr_getpshared importc, header: "<pthread.h>".}
          proc pthread_condattr_getpshared*(a1: ptr Pthread_condattr; a2: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_condattr_init header: "<pthread.h>".}
          proc pthread_condattr_init*(a1: ptr Pthread_condattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_condattr_setclock header: "<pthread.h>".}
          proc pthread_condattr_setclock*(a1: ptr Pthread_condattr; a2: ClockId): cint {.importc,
              header: "<pthread.h>".}

   * pthread_condattr_setpshared header: "<pthread.h>".}
          proc pthread_condattr_setpshared*(a1: ptr Pthread_condattr; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_create a3: proc (x: pointer): pointer {.noconv.}; a4:
     pointer): cint {.  importc, header: "<pthread.h>".}
          proc pthread_create*(a1: ptr Pthread; a2: ptr PthreadAttr;
                              a3: proc (x: pointer): pointer {.noconv.}; a4: pointer): cint {.
              importc, header: "<pthread.h>".}

   * pthread_detach
          proc pthread_detach*(a1: Pthread): cint {.importc, header: "<pthread.h>".}

   * pthread_equal
          proc pthread_equal*(a1, a2: Pthread): cint {.importc, header: "<pthread.h>".}

   * pthread_exit
          proc pthread_exit*(a1: pointer) {.importc, header: "<pthread.h>".}

   * pthread_getconcurrency
          proc pthread_getconcurrency*(): cint {.importc, header: "<pthread.h>".}

   * pthread_getcpuclockid header: "<pthread.h>".}
          proc pthread_getcpuclockid*(a1: Pthread; a2: var ClockId): cint {.importc,
              header: "<pthread.h>".}

   * pthread_getschedparam importc, header: "<pthread.h>".}
          proc pthread_getschedparam*(a1: Pthread; a2: var cint; a3: ptr Sched_param): cint {.
              importc, header: "<pthread.h>".}

   * pthread_getspecific
          proc pthread_getspecific*(a1: Pthread_key): pointer {.importc, header: "<pthread.h>".}

   * pthread_join
          proc pthread_join*(a1: Pthread; a2: ptr pointer): cint {.importc, header: "<pthread.h>".}

   * pthread_key_create importc, header: "<pthread.h>".}
          proc pthread_key_create*(a1: ptr Pthread_key; a2: proc (x: pointer) {.noconv.}): cint {.
              importc, header: "<pthread.h>".}

   * pthread_key_delete
          proc pthread_key_delete*(a1: Pthread_key): cint {.importc, header: "<pthread.h>".}

   * pthread_mutex_destroy header: "<pthread.h>".}
          proc pthread_mutex_destroy*(a1: ptr Pthread_mutex): cint {.importc,
              header: "<pthread.h>".}

   * pthread_mutex_getprioceiling header: "<pthread.h>".}
          proc pthread_mutex_getprioceiling*(a1: ptr Pthread_mutex; a2: var cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_mutex_init importc, header: "<pthread.h>".}
          proc pthread_mutex_init*(a1: ptr Pthread_mutex; a2: ptr Pthread_mutexattr): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutex_lock
          proc pthread_mutex_lock*(a1: ptr Pthread_mutex): cint {.importc, header: "<pthread.h>".}

   * pthread_mutex_setprioceiling importc, header: "<pthread.h>".}
          proc pthread_mutex_setprioceiling*(a1: ptr Pthread_mutex; a2: cint; a3: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutex_timedlock header: "<pthread.h>".}
          proc pthread_mutex_timedlock*(a1: ptr Pthread_mutex; a2: ptr Timespec): cint {.importc,
              header: "<pthread.h>".}

   * pthread_mutex_trylock header: "<pthread.h>".}
          proc pthread_mutex_trylock*(a1: ptr Pthread_mutex): cint {.importc,
              header: "<pthread.h>".}

   * pthread_mutex_unlock header: "<pthread.h>".}
          proc pthread_mutex_unlock*(a1: ptr Pthread_mutex): cint {.importc,
              header: "<pthread.h>".}

   * pthread_mutexattr_destroy header: "<pthread.h>".}
          proc pthread_mutexattr_destroy*(a1: ptr Pthread_mutexattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_mutexattr_getprioceiling importc, header: "<pthread.h>".}
          proc pthread_mutexattr_getprioceiling*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutexattr_getprotocol importc, header: "<pthread.h>".}
          proc pthread_mutexattr_getprotocol*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutexattr_getpshared importc, header: "<pthread.h>".}
          proc pthread_mutexattr_getpshared*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutexattr_gettype importc, header: "<pthread.h>".}
          proc pthread_mutexattr_gettype*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutexattr_init header: "<pthread.h>".}
          proc pthread_mutexattr_init*(a1: ptr Pthread_mutexattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_mutexattr_setprioceiling importc, header: "<pthread.h>".}
          proc pthread_mutexattr_setprioceiling*(a1: ptr Pthread_mutexattr; a2: cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutexattr_setprotocol importc, header: "<pthread.h>".}
          proc pthread_mutexattr_setprotocol*(a1: ptr Pthread_mutexattr; a2: cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutexattr_setpshared importc, header: "<pthread.h>".}
          proc pthread_mutexattr_setpshared*(a1: ptr Pthread_mutexattr; a2: cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_mutexattr_settype header: "<pthread.h>".}
          proc pthread_mutexattr_settype*(a1: ptr Pthread_mutexattr; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_once header: "<pthread.h>".}
          proc pthread_once*(a1: ptr Pthread_once; a2: proc () {.noconv.}): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlock_destroy header: "<pthread.h>".}
          proc pthread_rwlock_destroy*(a1: ptr Pthread_rwlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlock_init importc, header: "<pthread.h>".}
          proc pthread_rwlock_init*(a1: ptr Pthread_rwlock; a2: ptr Pthread_rwlockattr): cint {.
              importc, header: "<pthread.h>".}

   * pthread_rwlock_rdlock header: "<pthread.h>".}
          proc pthread_rwlock_rdlock*(a1: ptr Pthread_rwlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlock_timedrdlock importc, header: "<pthread.h>".}
          proc pthread_rwlock_timedrdlock*(a1: ptr Pthread_rwlock; a2: ptr Timespec): cint {.
              importc, header: "<pthread.h>".}

   * pthread_rwlock_timedwrlock importc, header: "<pthread.h>".}
          proc pthread_rwlock_timedwrlock*(a1: ptr Pthread_rwlock; a2: ptr Timespec): cint {.
              importc, header: "<pthread.h>".}

   * pthread_rwlock_tryrdlock header: "<pthread.h>".}
          proc pthread_rwlock_tryrdlock*(a1: ptr Pthread_rwlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlock_trywrlock header: "<pthread.h>".}
          proc pthread_rwlock_trywrlock*(a1: ptr Pthread_rwlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlock_unlock header: "<pthread.h>".}
          proc pthread_rwlock_unlock*(a1: ptr Pthread_rwlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlock_wrlock header: "<pthread.h>".}
          proc pthread_rwlock_wrlock*(a1: ptr Pthread_rwlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlockattr_destroy header: "<pthread.h>".}
          proc pthread_rwlockattr_destroy*(a1: ptr Pthread_rwlockattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlockattr_getpshared importc, header: "<pthread.h>".}
          proc pthread_rwlockattr_getpshared*(a1: ptr Pthread_rwlockattr; a2: var cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_rwlockattr_init header: "<pthread.h>".}
          proc pthread_rwlockattr_init*(a1: ptr Pthread_rwlockattr): cint {.importc,
              header: "<pthread.h>".}

   * pthread_rwlockattr_setpshared importc, header: "<pthread.h>".}
          proc pthread_rwlockattr_setpshared*(a1: ptr Pthread_rwlockattr; a2: cint): cint {.
              importc, header: "<pthread.h>".}

   * pthread_self
          proc pthread_self*(): Pthread {.importc, header: "<pthread.h>".}

   * pthread_setcancelstate header: "<pthread.h>".}
          proc pthread_setcancelstate*(a1: cint; a2: var cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_setcanceltype header: "<pthread.h>".}
          proc pthread_setcanceltype*(a1: cint; a2: var cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_setconcurrency
          proc pthread_setconcurrency*(a1: cint): cint {.importc, header: "<pthread.h>".}

   * pthread_setschedparam header: "<pthread.h>".}
          proc pthread_setschedparam*(a1: Pthread; a2: cint; a3: ptr Sched_param): cint {.importc,
              header: "<pthread.h>".}

   * pthread_setschedprio header: "<pthread.h>".}
          proc pthread_setschedprio*(a1: Pthread; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_setspecific header: "<pthread.h>".}
          proc pthread_setspecific*(a1: Pthread_key; a2: pointer): cint {.importc,
              header: "<pthread.h>".}

   * pthread_spin_destroy header: "<pthread.h>".}
          proc pthread_spin_destroy*(a1: ptr Pthread_spinlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_spin_init header: "<pthread.h>".}
          proc pthread_spin_init*(a1: ptr Pthread_spinlock; a2: cint): cint {.importc,
              header: "<pthread.h>".}

   * pthread_spin_lock header: "<pthread.h>".}
          proc pthread_spin_lock*(a1: ptr Pthread_spinlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_spin_trylock header: "<pthread.h>".}
          proc pthread_spin_trylock*(a1: ptr Pthread_spinlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_spin_unlock header: "<pthread.h>".}
          proc pthread_spin_unlock*(a1: ptr Pthread_spinlock): cint {.importc,
              header: "<pthread.h>".}

   * pthread_testcancel
          proc pthread_testcancel*() {.importc, header: "<pthread.h>".}

   * exitnow
          proc exitnow*(code: int): void {.importc: "_exit", header: "<unistd.h>".}

   * access
          proc access*(a1: cstring; a2: cint): cint {.importc, header: "<unistd.h>".}

   * alarm
          proc alarm*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * chdir
          proc chdir*(a1: cstring): cint {.importc, header: "<unistd.h>".}

   * chown
          proc chown*(a1: cstring; a2: Uid; a3: Gid): cint {.importc, header: "<unistd.h>".}

   * close
          proc close*(a1: cint | SocketHandle): cint {.importc, header: "<unistd.h>".}

   * confstr
          proc confstr*(a1: cint; a2: cstring; a3: int): int {.importc, header: "<unistd.h>".}

   * crypt
          proc crypt*(a1, a2: cstring): cstring {.importc, header: "<unistd.h>".}

   * ctermid
          proc ctermid*(a1: cstring): cstring {.importc, header: "<unistd.h>".}

   * dup
          proc dup*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * dup2
          proc dup2*(a1, a2: cint): cint {.importc, header: "<unistd.h>".}

   * encrypt
          proc encrypt*(a1: array[0 .. 63, char]; a2: cint) {.importc, header: "<unistd.h>".}

   * execl
          proc execl*(a1, a2: cstring): cint {.varargs, importc, header: "<unistd.h>".}

   * execle
          proc execle*(a1, a2: cstring): cint {.varargs, importc, header: "<unistd.h>".}

   * execlp
          proc execlp*(a1, a2: cstring): cint {.varargs, importc, header: "<unistd.h>".}

   * execv
          proc execv*(a1: cstring; a2: cstringArray): cint {.importc, header: "<unistd.h>".}

   * execve
          proc execve*(a1: cstring; a2, a3: cstringArray): cint {.importc, header: "<unistd.h>".}

   * execvp
          proc execvp*(a1: cstring; a2: cstringArray): cint {.importc, header: "<unistd.h>".}

   * execvpe header: "<unistd.h>".}
          proc execvpe*(a1: cstring; a2: cstringArray; a3: cstringArray): cint {.importc,
              header: "<unistd.h>".}

   * fchown
          proc fchown*(a1: cint; a2: Uid; a3: Gid): cint {.importc, header: "<unistd.h>".}

   * fchdir
          proc fchdir*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * fdatasync
          proc fdatasync*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * fork
          proc fork*(): Pid {.importc, header: "<unistd.h>".}

   * fpathconf
          proc fpathconf*(a1, a2: cint): int {.importc, header: "<unistd.h>".}

   * fsync
          proc fsync*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * ftruncate
          proc ftruncate*(a1: cint; a2: Off): cint {.importc, header: "<unistd.h>".}

   * getcwd
          proc getcwd*(a1: cstring; a2: int): cstring {.importc, header: "<unistd.h>".}

   * getegid
          proc getegid*(): Gid {.importc, header: "<unistd.h>".}

   * geteuid
          proc geteuid*(): Uid {.importc, header: "<unistd.h>".}

   * getgid
          proc getgid*(): Gid {.importc, header: "<unistd.h>".}

   * getgroups header: "<unistd.h>".}
          proc getgroups*(a1: cint; a2: ptr array[0 .. 255, Gid]): cint {.importc,
              header: "<unistd.h>".}

   * gethostid
          proc gethostid*(): int {.importc, header: "<unistd.h>".}

   * gethostname
          proc gethostname*(a1: cstring; a2: int): cint {.importc, header: "<unistd.h>".}

   * getlogin
          proc getlogin*(): cstring {.importc, header: "<unistd.h>".}

   * getlogin_r
          proc getlogin_r*(a1: cstring; a2: int): cint {.importc, header: "<unistd.h>".}

   * getopt header: "<unistd.h>".}
          proc getopt*(a1: cint; a2: cstringArray; a3: cstring): cint {.importc,
              header: "<unistd.h>".}

   * getpgid
          proc getpgid*(a1: Pid): Pid {.importc, header: "<unistd.h>".}

   * getpgrp
          proc getpgrp*(): Pid {.importc, header: "<unistd.h>".}

   * getpid
          proc getpid*(): Pid {.importc, header: "<unistd.h>".}

   * getppid
          proc getppid*(): Pid {.importc, header: "<unistd.h>".}

   * getsid
          proc getsid*(a1: Pid): Pid {.importc, header: "<unistd.h>".}

   * getuid
          proc getuid*(): Uid {.importc, header: "<unistd.h>".}

   * getwd
          proc getwd*(a1: cstring): cstring {.importc, header: "<unistd.h>".}

   * isatty
          proc isatty*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * lchown
          proc lchown*(a1: cstring; a2: Uid; a3: Gid): cint {.importc, header: "<unistd.h>".}

   * link
          proc link*(a1, a2: cstring): cint {.importc, header: "<unistd.h>".}

   * lockf
          proc lockf*(a1, a2: cint; a3: Off): cint {.importc, header: "<unistd.h>".}

   * lseek
          proc lseek*(a1: cint; a2: Off; a3: cint): Off {.importc, header: "<unistd.h>".}

   * nice
          proc nice*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * pathconf
          proc pathconf*(a1: cstring; a2: cint): int {.importc, header: "<unistd.h>".}

   * pause
          proc pause*(): cint {.importc, header: "<unistd.h>".}

   * pclose
          proc pclose*(a: File): cint {.importc, header: "<stdio.h>".}

   * pipe
          proc pipe*(a: array[0 .. 1, cint]): cint {.importc, header: "<unistd.h>".}

   * popen
          proc popen*(a1, a2: cstring): File {.importc, header: "<stdio.h>".}

   * pread
          proc pread*(a1: cint; a2: pointer; a3: int; a4: Off): int {.importc, header: "<unistd.h>".}

   * pwrite
          proc pwrite*(a1: cint; a2: pointer; a3: int; a4: Off): int {.importc, header: "<unistd.h>".}

   * read
          proc read*(a1: cint; a2: pointer; a3: int): int {.importc, header: "<unistd.h>".}

   * readlink
          proc readlink*(a1, a2: cstring; a3: int): int {.importc, header: "<unistd.h>".}

   * ioctl header: "<sys/ioctl.h>", varargs, tags: [WriteIOEffect].}
          proc ioctl*(f: FileHandle; device: uint): int {.importc: "ioctl",
              header: "<sys/ioctl.h>", varargs, tags: [WriteIOEffect].}

     A system call for device-specific input/output operations and other
     operations which cannot be expressed by regular system calls

   * rmdir
          proc rmdir*(a1: cstring): cint {.importc, header: "<unistd.h>".}

   * setegid
          proc setegid*(a1: Gid): cint {.importc, header: "<unistd.h>".}

   * seteuid
          proc seteuid*(a1: Uid): cint {.importc, header: "<unistd.h>".}

   * setgid
          proc setgid*(a1: Gid): cint {.importc, header: "<unistd.h>".}

   * setpgid
          proc setpgid*(a1, a2: Pid): cint {.importc, header: "<unistd.h>".}

   * setpgrp
          proc setpgrp*(): Pid {.importc, header: "<unistd.h>".}

   * setregid
          proc setregid*(a1, a2: Gid): cint {.importc, header: "<unistd.h>".}

   * setreuid
          proc setreuid*(a1, a2: Uid): cint {.importc, header: "<unistd.h>".}

   * setsid
          proc setsid*(): Pid {.importc, header: "<unistd.h>".}

   * setuid
          proc setuid*(a1: Uid): cint {.importc, header: "<unistd.h>".}

   * sleep
          proc sleep*(a1: cint): cint {.importc, header: "<unistd.h>".}

   * swab
          proc swab*(a1, a2: pointer; a3: int) {.importc, header: "<unistd.h>".}

   * symlink
          proc symlink*(a1, a2: cstring): cint {.importc, header: "<unistd.h>".}

   * sync
          proc sync*() {.importc, header: "<unistd.h>".}

   * sysconf
          proc sysconf*(a1: cint): int {.importc, header: "<unistd.h>".}

   * tcgetpgrp
          proc tcgetpgrp*(a1: cint): Pid {.importc, header: "<unistd.h>".}

   * tcsetpgrp
          proc tcsetpgrp*(a1: cint; a2: Pid): cint {.importc, header: "<unistd.h>".}

   * truncate
          proc truncate*(a1: cstring; a2: Off): cint {.importc, header: "<unistd.h>".}

   * ttyname
          proc ttyname*(a1: cint): cstring {.importc, header: "<unistd.h>".}

   * ttyname_r
          proc ttyname_r*(a1: cint; a2: cstring; a3: int): cint {.importc, header: "<unistd.h>".}

   * ualarm
          proc ualarm*(a1, a2: Useconds): Useconds {.importc, header: "<unistd.h>".}

   * unlink
          proc unlink*(a1: cstring): cint {.importc, header: "<unistd.h>".}

   * usleep
          proc usleep*(a1: Useconds): cint {.importc, header: "<unistd.h>".}

   * vfork
          proc vfork*(): Pid {.importc, header: "<unistd.h>".}

   * write
          proc write*(a1: cint; a2: pointer; a3: int): int {.importc, header: "<unistd.h>".}

   * sem_close
          proc sem_close*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}

   * sem_destroy
          proc sem_destroy*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}

   * sem_getvalue
          proc sem_getvalue*(a1: ptr Sem; a2: var cint): cint {.importc, header: "<semaphore.h>".}

   * sem_init
          proc sem_init*(a1: ptr Sem; a2: cint; a3: cint): cint {.importc, header: "<semaphore.h>".}

   * sem_open header: "<semaphore.h>".}
          proc sem_open*(a1: cstring; a2: cint): ptr Sem {.varargs, importc,
              header: "<semaphore.h>".}

   * sem_post
          proc sem_post*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}

   * sem_timedwait header: "<semaphore.h>".}
          proc sem_timedwait*(a1: ptr Sem; a2: ptr Timespec): cint {.importc,
              header: "<semaphore.h>".}

   * sem_trywait
          proc sem_trywait*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}

   * sem_unlink
          proc sem_unlink*(a1: cstring): cint {.importc, header: "<semaphore.h>".}

   * sem_wait
          proc sem_wait*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}

   * ftok
          proc ftok*(a1: cstring; a2: cint): Key {.importc, header: "<sys/ipc.h>".}

   * statvfs
          proc statvfs*(a1: cstring; a2: var Statvfs): cint {.importc, header: "<sys/statvfs.h>".}

   * fstatvfs
          proc fstatvfs*(a1: cint; a2: var Statvfs): cint {.importc, header: "<sys/statvfs.h>".}

   * chmod
          proc chmod*(a1: cstring; a2: Mode): cint {.importc, header: "<sys/stat.h>".}

   * fchmod
          proc fchmod*(a1: cint; a2: Mode): cint {.importc, header: "<sys/stat.h>".}

   * fstat
          proc fstat*(a1: cint; a2: var Stat): cint {.importc, header: "<sys/stat.h>".}

   * lstat
          proc lstat*(a1: cstring; a2: var Stat): cint {.importc, header: "<sys/stat.h>".}

   * mkdir
          proc mkdir*(a1: cstring; a2: Mode): cint {.importc, header: "<sys/stat.h>".}

   * mkfifo
          proc mkfifo*(a1: cstring; a2: Mode): cint {.importc, header: "<sys/stat.h>".}

   * mknod
          proc mknod*(a1: cstring; a2: Mode; a3: Dev): cint {.importc, header: "<sys/stat.h>".}

   * stat
          proc stat*(a1: cstring; a2: var Stat): cint {.importc, header: "<sys/stat.h>".}

   * umask
          proc umask*(a1: Mode): Mode {.importc, header: "<sys/stat.h>".}

   * S_ISBLK
          proc S_ISBLK*(m: Mode): bool {.importc, header: "<sys/stat.h>".}

     Test for a block special file.

   * S_ISCHR
          proc S_ISCHR*(m: Mode): bool {.importc, header: "<sys/stat.h>".}

     Test for a character special file.

   * S_ISDIR
          proc S_ISDIR*(m: Mode): bool {.importc, header: "<sys/stat.h>".}

     Test for a directory.

   * S_ISFIFO
          proc S_ISFIFO*(m: Mode): bool {.importc, header: "<sys/stat.h>".}

     Test for a pipe or FIFO special file.

   * S_ISREG
          proc S_ISREG*(m: Mode): bool {.importc, header: "<sys/stat.h>".}

     Test for a regular file.

   * S_ISLNK
          proc S_ISLNK*(m: Mode): bool {.importc, header: "<sys/stat.h>".}

     Test for a symbolic link.

   * S_ISSOCK
          proc S_ISSOCK*(m: Mode): bool {.importc, header: "<sys/stat.h>".}

     Test for a socket.

   * S_TYPEISMQ
          proc S_TYPEISMQ*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}

     Test for a message queue.

   * S_TYPEISSEM
          proc S_TYPEISSEM*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}

     Test for a semaphore.

   * S_TYPEISSHM
          proc S_TYPEISSHM*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}

     Test for a shared memory object.

   * S_TYPEISTMO
          proc S_TYPEISTMO*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}

     Test macro for a typed memory object.

   * mlock
          proc mlock*(a1: pointer; a2: int): cint {.importc, header: "<sys/mman.h>".}

   * mlockall
          proc mlockall*(a1: cint): cint {.importc, header: "<sys/mman.h>".}

   * mmap header: "<sys/mman.h>".}
          proc mmap*(a1: pointer; a2: int; a3, a4, a5: cint; a6: Off): pointer {.importc,
              header: "<sys/mman.h>".}

   * mprotect
          proc mprotect*(a1: pointer; a2: int; a3: cint): cint {.importc, header: "<sys/mman.h>".}

   * msync
          proc msync*(a1: pointer; a2: int; a3: cint): cint {.importc, header: "<sys/mman.h>".}

   * munlock
          proc munlock*(a1: pointer; a2: int): cint {.importc, header: "<sys/mman.h>".}

   * munlockall
          proc munlockall*(): cint {.importc, header: "<sys/mman.h>".}

   * munmap
          proc munmap*(a1: pointer; a2: int): cint {.importc, header: "<sys/mman.h>".}

   * posix_madvise header: "<sys/mman.h>".}
          proc posix_madvise*(a1: pointer; a2: int; a3: cint): cint {.importc,
              header: "<sys/mman.h>".}

   * posix_mem_offset importc, header: "<sys/mman.h>".}
          proc posix_mem_offset*(a1: pointer; a2: int; a3: var Off; a4: var int; a5: var cint): cint {.
              importc, header: "<sys/mman.h>".}

   * posix_typed_mem_get_info header: "<sys/mman.h>".}
          proc posix_typed_mem_get_info*(a1: cint; a2: var Posix_typed_mem_info): cint {.importc,
              header: "<sys/mman.h>".}

   * posix_typed_mem_open header: "<sys/mman.h>".}
          proc posix_typed_mem_open*(a1: cstring; a2, a3: cint): cint {.importc,
              header: "<sys/mman.h>".}

   * shm_open
          proc shm_open*(a1: cstring; a2: cint; a3: Mode): cint {.importc, header: "<sys/mman.h>".}

   * shm_unlink
          proc shm_unlink*(a1: cstring): cint {.importc, header: "<sys/mman.h>".}

   * asctime
          proc asctime*(a1: var Tm): cstring {.importc, header: "<time.h>".}

   * asctime_r
          proc asctime_r*(a1: var Tm; a2: cstring): cstring {.importc, header: "<time.h>".}

   * clock
          proc clock*(): Clock {.importc, header: "<time.h>".}

   * clock_getcpuclockid
          proc clock_getcpuclockid*(a1: Pid; a2: var ClockId): cint {.importc, header: "<time.h>".}

   * clock_getres
          proc clock_getres*(a1: ClockId; a2: var Timespec): cint {.importc, header: "<time.h>".}

   * clock_gettime
          proc clock_gettime*(a1: ClockId; a2: var Timespec): cint {.importc, header: "<time.h>".}

   * clock_nanosleep importc, header: "<time.h>".}
          proc clock_nanosleep*(a1: ClockId; a2: cint; a3: var Timespec; a4: var Timespec): cint {.
              importc, header: "<time.h>".}

   * clock_settime
          proc clock_settime*(a1: ClockId; a2: var Timespec): cint {.importc, header: "<time.h>".}

   * ctime
          proc ctime*(a1: var Time): cstring {.importc, header: "<time.h>".}

   * ctime_r
          proc ctime_r*(a1: var Time; a2: cstring): cstring {.importc, header: "<time.h>".}

   * difftime
          proc difftime*(a1, a2: Time): cdouble {.importc, header: "<time.h>".}

   * getdate
          proc getdate*(a1: cstring): ptr Tm {.importc, header: "<time.h>".}

   * gmtime
          proc gmtime*(a1: var Time): ptr Tm {.importc, header: "<time.h>".}

   * gmtime_r
          proc gmtime_r*(a1: var Time; a2: var Tm): ptr Tm {.importc, header: "<time.h>".}

   * localtime
          proc localtime*(a1: var Time): ptr Tm {.importc, header: "<time.h>".}

   * localtime_r
          proc localtime_r*(a1: var Time; a2: var Tm): ptr Tm {.importc, header: "<time.h>".}

   * mktime
          proc mktime*(a1: var Tm): Time {.importc, header: "<time.h>".}

   * timegm
          proc timegm*(a1: var Tm): Time {.importc, header: "<time.h>".}

   * nanosleep
          proc nanosleep*(a1, a2: var Timespec): cint {.importc, header: "<time.h>".}

   * strftime header: "<time.h>".}
          proc strftime*(a1: cstring; a2: int; a3: cstring; a4: var Tm): int {.importc,
              header: "<time.h>".}

   * strptime
          proc strptime*(a1, a2: cstring; a3: var Tm): cstring {.importc, header: "<time.h>".}

   * time
          proc time*(a1: var Time): Time {.importc, header: "<time.h>".}

   * timer_create header: "<time.h>".}
          proc timer_create*(a1: var ClockId; a2: var SigEvent; a3: var Timer): cint {.importc,
              header: "<time.h>".}

   * timer_delete
          proc timer_delete*(a1: var Timer): cint {.importc, header: "<time.h>".}

   * timer_gettime
          proc timer_gettime*(a1: Timer; a2: var Itimerspec): cint {.importc, header: "<time.h>".}

   * timer_getoverrun
          proc timer_getoverrun*(a1: Timer): cint {.importc, header: "<time.h>".}

   * timer_settime importc, header: "<time.h>".}
          proc timer_settime*(a1: Timer; a2: cint; a3: var Itimerspec; a4: var Itimerspec): cint {.
              importc, header: "<time.h>".}

   * tzset
          proc tzset*() {.importc, header: "<time.h>".}

   * wait
          proc wait*(a1: ptr cint): Pid {.importc, discardable, header: "<sys/wait.h>".}

   * waitid header: "<sys/wait.h>".}
          proc waitid*(a1: cint; a2: Id; a3: var SigInfo; a4: cint): cint {.importc,
              header: "<sys/wait.h>".}

   * waitpid
          proc waitpid*(a1: Pid; a2: var cint; a3: cint): Pid {.importc, header: "<sys/wait.h>".}

   * bsd_signal header: "<signal.h>".}
          proc bsd_signal*(a1: cint; a2: proc (x: pointer) {.noconv.}) {.importc,
              header: "<signal.h>".}

   * kill
          proc kill*(a1: Pid; a2: cint): cint {.importc, header: "<signal.h>".}

   * killpg
          proc killpg*(a1: Pid; a2: cint): cint {.importc, header: "<signal.h>".}

   * pthread_kill
          proc pthread_kill*(a1: Pthread; a2: cint): cint {.importc, header: "<signal.h>".}

   * pthread_sigmask
          proc pthread_sigmask*(a1: cint; a2, a3: var Sigset): cint {.importc, header: "<signal.h>".}

   * 'raise'
          proc `raise`*(a1: cint): cint {.importc, header: "<signal.h>".}

   * sigaction
          proc sigaction*(a1: cint; a2, a3: var Sigaction): cint {.importc, header: "<signal.h>".}

   * sigaddset
          proc sigaddset*(a1: var Sigset; a2: cint): cint {.importc, header: "<signal.h>".}

   * sigaltstack
          proc sigaltstack*(a1, a2: var Stack): cint {.importc, header: "<signal.h>".}

   * sigdelset
          proc sigdelset*(a1: var Sigset; a2: cint): cint {.importc, header: "<signal.h>".}

   * sigemptyset
          proc sigemptyset*(a1: var Sigset): cint {.importc, header: "<signal.h>".}

   * sigfillset
          proc sigfillset*(a1: var Sigset): cint {.importc, header: "<signal.h>".}

   * sighold
          proc sighold*(a1: cint): cint {.importc, header: "<signal.h>".}

   * sigignore
          proc sigignore*(a1: cint): cint {.importc, header: "<signal.h>".}

   * siginterrupt
          proc siginterrupt*(a1, a2: cint): cint {.importc, header: "<signal.h>".}

   * sigismember
          proc sigismember*(a1: var Sigset; a2: cint): cint {.importc, header: "<signal.h>".}

   * signal
          proc signal*(a1: cint; a2: proc (x: cint) {.noconv.}) {.importc, header: "<signal.h>".}

   * sigpause
          proc sigpause*(a1: cint): cint {.importc, header: "<signal.h>".}

   * sigpending
          proc sigpending*(a1: var Sigset): cint {.importc, header: "<signal.h>".}

   * sigprocmask
          proc sigprocmask*(a1: cint; a2, a3: var Sigset): cint {.importc, header: "<signal.h>".}

   * sigqueue
          proc sigqueue*(a1: Pid; a2: cint; a3: SigVal): cint {.importc, header: "<signal.h>".}

   * sigrelse
          proc sigrelse*(a1: cint): cint {.importc, header: "<signal.h>".}

   * sigset
          proc sigset*(a1: int; a2: proc (x: cint) {.noconv.}) {.importc, header: "<signal.h>".}

   * sigsuspend
          proc sigsuspend*(a1: var Sigset): cint {.importc, header: "<signal.h>".}

   * sigtimedwait header: "<signal.h>".}
          proc sigtimedwait*(a1: var Sigset; a2: var SigInfo; a3: var Timespec): cint {.importc,
              header: "<signal.h>".}

   * sigwait
          proc sigwait*(a1: var Sigset; a2: var cint): cint {.importc, header: "<signal.h>".}

   * sigwaitinfo
          proc sigwaitinfo*(a1: var Sigset; a2: var SigInfo): cint {.importc, header: "<signal.h>".}

   * catclose
          proc catclose*(a1: Nl_catd): cint {.importc, header: "<nl_types.h>".}

   * catgets header: "<nl_types.h>".}
          proc catgets*(a1: Nl_catd; a2, a3: cint; a4: cstring): cstring {.importc,
              header: "<nl_types.h>".}

   * catopen
          proc catopen*(a1: cstring; a2: cint): Nl_catd {.importc, header: "<nl_types.h>".}

   * sched_get_priority_max
          proc sched_get_priority_max*(a1: cint): cint {.importc, header: "<sched.h>".}

   * sched_get_priority_min
          proc sched_get_priority_min*(a1: cint): cint {.importc, header: "<sched.h>".}

   * sched_getparam
          proc sched_getparam*(a1: Pid; a2: var Sched_param): cint {.importc, header: "<sched.h>".}

   * sched_getscheduler
          proc sched_getscheduler*(a1: Pid): cint {.importc, header: "<sched.h>".}

   * sched_rr_get_interval header: "<sched.h>".}
          proc sched_rr_get_interval*(a1: Pid; a2: var Timespec): cint {.importc,
              header: "<sched.h>".}

   * sched_setparam
          proc sched_setparam*(a1: Pid; a2: var Sched_param): cint {.importc, header: "<sched.h>".}

   * sched_setscheduler header: "<sched.h>".}
          proc sched_setscheduler*(a1: Pid; a2: cint; a3: var Sched_param): cint {.importc,
              header: "<sched.h>".}

   * sched_yield
          proc sched_yield*(): cint {.importc, header: "<sched.h>".}

   * strerror
          proc strerror*(errnum: cint): cstring {.importc, header: "<string.h>".}

   * hstrerror
          proc hstrerror*(herrnum: cint): cstring {.importc: "(char *)$1", header: "<netdb.h>".}

   * FD_CLR
          proc FD_CLR*(a1: cint; a2: var TFdSet) {.importc, header: "<sys/select.h>".}

   * FD_ISSET header: "<sys/select.h>".}
          proc FD_ISSET*(a1: cint | SocketHandle; a2: var TFdSet): cint {.importc,
              header: "<sys/select.h>".}

   * FD_SET header: "<sys/select.h>".}
          proc FD_SET*(a1: cint | SocketHandle; a2: var TFdSet) {.importc: "FD_SET",
              header: "<sys/select.h>".}

   * FD_ZERO
          proc FD_ZERO*(a1: var TFdSet) {.importc, header: "<sys/select.h>".}

   * pselect importc, header: "<sys/select.h>".}
          proc pselect*(a1: cint; a2, a3, a4: ptr TFdSet; a5: ptr Timespec; a6: var Sigset): cint {.
              importc, header: "<sys/select.h>".}

   * select importc, header: "<sys/select.h>".}
          proc select*(a1: cint | SocketHandle; a2, a3, a4: ptr TFdSet; a5: ptr Timeval): cint {.
              importc, header: "<sys/select.h>".}

   * posix_spawn a4: var Tposix_spawnattr; a5, a6: cstringArray): cint
     {.importc, header: "<spawn.h>".}
          proc posix_spawn*(a1: var Pid; a2: cstring; a3: var Tposix_spawn_file_actions;
                           a4: var Tposix_spawnattr; a5, a6: cstringArray): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawn_file_actions_addclose importc, header: "<spawn.h>".}
          proc posix_spawn_file_actions_addclose*(a1: var Tposix_spawn_file_actions; a2: cint): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawn_file_actions_adddup2 a2, a3: cint): cint {.importc,
     header: "<spawn.h>".}
          proc posix_spawn_file_actions_adddup2*(a1: var Tposix_spawn_file_actions;
                                                a2, a3: cint): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawn_file_actions_addopen a3: cstring; a4: cint; a5: Mode):
     cint {.importc, header: "<spawn.h>".}
          proc posix_spawn_file_actions_addopen*(a1: var Tposix_spawn_file_actions; a2: cint;
                                                a3: cstring; a4: cint; a5: Mode): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawn_file_actions_destroy importc, header: "<spawn.h>".}
          proc posix_spawn_file_actions_destroy*(a1: var Tposix_spawn_file_actions): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawn_file_actions_init importc, header: "<spawn.h>".}
          proc posix_spawn_file_actions_init*(a1: var Tposix_spawn_file_actions): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_destroy header: "<spawn.h>".}
          proc posix_spawnattr_destroy*(a1: var Tposix_spawnattr): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawnattr_getsigdefault importc, header: "<spawn.h>".}
          proc posix_spawnattr_getsigdefault*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_getflags importc, header: "<spawn.h>".}
          proc posix_spawnattr_getflags*(a1: var Tposix_spawnattr; a2: var cshort): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_getpgroup header: "<spawn.h>".}
          proc posix_spawnattr_getpgroup*(a1: var Tposix_spawnattr; a2: var Pid): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawnattr_getschedparam importc, header: "<spawn.h>".}
          proc posix_spawnattr_getschedparam*(a1: var Tposix_spawnattr; a2: var Sched_param): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_getschedpolicy importc, header: "<spawn.h>".}
          proc posix_spawnattr_getschedpolicy*(a1: var Tposix_spawnattr; a2: var cint): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_getsigmask importc, header: "<spawn.h>".}
          proc posix_spawnattr_getsigmask*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_init header: "<spawn.h>".}
          proc posix_spawnattr_init*(a1: var Tposix_spawnattr): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawnattr_setsigdefault importc, header: "<spawn.h>".}
          proc posix_spawnattr_setsigdefault*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_setflags header: "<spawn.h>".}
          proc posix_spawnattr_setflags*(a1: var Tposix_spawnattr; a2: cint): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawnattr_setpgroup header: "<spawn.h>".}
          proc posix_spawnattr_setpgroup*(a1: var Tposix_spawnattr; a2: Pid): cint {.importc,
              header: "<spawn.h>".}

   * posix_spawnattr_setschedparam importc, header: "<spawn.h>".}
          proc posix_spawnattr_setschedparam*(a1: var Tposix_spawnattr; a2: var Sched_param): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_setschedpolicy importc, header: "<spawn.h>".}
          proc posix_spawnattr_setschedpolicy*(a1: var Tposix_spawnattr; a2: cint): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnattr_setsigmask importc, header: "<spawn.h>".}
          proc posix_spawnattr_setsigmask*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.
              importc, header: "<spawn.h>".}

   * posix_spawnp a4: var Tposix_spawnattr; a5, a6: cstringArray): cint
     {.importc, header: "<spawn.h>".}
          proc posix_spawnp*(a1: var Pid; a2: cstring; a3: var Tposix_spawn_file_actions;
                            a4: var Tposix_spawnattr; a5, a6: cstringArray): cint {.importc,
              header: "<spawn.h>".}

   * getcontext
          proc getcontext*(a1: var Ucontext): cint {.importc, header: "<ucontext.h>".}

   * makecontext header: "<ucontext.h>".}
          proc makecontext*(a1: var Ucontext; a4: proc () {.noconv.}; a3: cint) {.varargs, importc,
              header: "<ucontext.h>".}

   * setcontext
          proc setcontext*(a1: var Ucontext): cint {.importc, header: "<ucontext.h>".}

   * swapcontext
          proc swapcontext*(a1, a2: var Ucontext): cint {.importc, header: "<ucontext.h>".}

   * readv
          proc readv*(a1: cint; a2: ptr IOVec; a3: cint): int {.importc, header: "<sys/uio.h>".}

   * writev
          proc writev*(a1: cint; a2: ptr IOVec; a3: cint): int {.importc, header: "<sys/uio.h>".}

   * CMSG_DATA
          proc CMSG_DATA*(cmsg: ptr Tcmsghdr): cstring {.importc, header: "<sys/socket.h>".}

   * CMSG_NXTHDR header: "<sys/socket.h>".}
          proc CMSG_NXTHDR*(mhdr: ptr Tmsghdr; cmsg: ptr Tcmsghdr): ptr Tcmsghdr {.importc,
              header: "<sys/socket.h>".}

   * CMSG_FIRSTHDR header: "<sys/socket.h>".}
          proc CMSG_FIRSTHDR*(mhdr: ptr Tmsghdr): ptr Tcmsghdr {.importc,
              header: "<sys/socket.h>".}

   * '=='
          proc `==`*(x, y: SocketHandle): bool {.borrow.}

   * accept header: "<sys/socket.h>".}
          proc accept*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): SocketHandle {.importc,
              header: "<sys/socket.h>".}

   * bindSocket importc: "bind", header: "<sys/socket.h>".}
          proc bindSocket*(a1: SocketHandle; a2: ptr SockAddr; a3: Socklen): cint {.
              importc: "bind", header: "<sys/socket.h>".}

     is Posix's 'bind', because 'bind' is a reserved word

   * connect header: "<sys/socket.h>".}
          proc connect*(a1: SocketHandle; a2: ptr SockAddr; a3: Socklen): cint {.importc,
              header: "<sys/socket.h>".}

   * getpeername header: "<sys/socket.h>".}
          proc getpeername*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): cint {.importc,
              header: "<sys/socket.h>".}

   * getsockname header: "<sys/socket.h>".}
          proc getsockname*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): cint {.importc,
              header: "<sys/socket.h>".}

   * getsockopt importc, header: "<sys/socket.h>".}
          proc getsockopt*(a1: SocketHandle; a2, a3: cint; a4: pointer; a5: ptr Socklen): cint {.
              importc, header: "<sys/socket.h>".}

   * listen
          proc listen*(a1: SocketHandle; a2: cint): cint {.importc, header: "<sys/socket.h>".}

   * recv header: "<sys/socket.h>".}
          proc recv*(a1: SocketHandle; a2: pointer; a3: int; a4: cint): int {.importc,
              header: "<sys/socket.h>".}

   * recvfrom a6: ptr Socklen): int {.importc, header:
     "<sys/socket.h>".}
          proc recvfrom*(a1: SocketHandle; a2: pointer; a3: int; a4: cint; a5: ptr SockAddr;
                        a6: ptr Socklen): int {.importc, header: "<sys/socket.h>".}

   * recvmsg header: "<sys/socket.h>".}
          proc recvmsg*(a1: SocketHandle; a2: ptr Tmsghdr; a3: cint): int {.importc,
              header: "<sys/socket.h>".}

   * send header: "<sys/socket.h>".}
          proc send*(a1: SocketHandle; a2: pointer; a3: int; a4: cint): int {.importc,
              header: "<sys/socket.h>".}

   * sendmsg header: "<sys/socket.h>".}
          proc sendmsg*(a1: SocketHandle; a2: ptr Tmsghdr; a3: cint): int {.importc,
              header: "<sys/socket.h>".}

   * sendto importc, header: "<sys/socket.h>".}
          proc sendto*(a1: SocketHandle; a2: pointer; a3: int; a4: cint; a5: ptr SockAddr; a6: Socklen): int {.
              importc, header: "<sys/socket.h>".}

   * setsockopt header: "<sys/socket.h>".}
          proc setsockopt*(a1: SocketHandle; a2, a3: cint; a4: pointer; a5: Socklen): cint {.importc,
              header: "<sys/socket.h>".}

   * shutdown
          proc shutdown*(a1: SocketHandle; a2: cint): cint {.importc, header: "<sys/socket.h>".}

   * socket
          proc socket*(a1, a2, a3: cint): SocketHandle {.importc, header: "<sys/socket.h>".}

   * sockatmark
          proc sockatmark*(a1: cint): cint {.importc, header: "<sys/socket.h>".}

   * socketpair header: "<sys/socket.h>".}
          proc socketpair*(a1, a2, a3: cint; a4: var array[0 .. 1, cint]): cint {.importc,
              header: "<sys/socket.h>".}

   * if_nametoindex
          proc if_nametoindex*(a1: cstring): cint {.importc, header: "<net/if.h>".}

   * if_indextoname
          proc if_indextoname*(a1: cint; a2: cstring): cstring {.importc, header: "<net/if.h>".}

   * if_nameindex
          proc if_nameindex*(): ptr Tif_nameindex {.importc, header: "<net/if.h>".}

   * if_freenameindex
          proc if_freenameindex*(a1: ptr Tif_nameindex) {.importc, header: "<net/if.h>".}

   * IN6_IS_ADDR_UNSPECIFIED header: "<netinet/in.h>".}
          proc IN6_IS_ADDR_UNSPECIFIED*(a1: ptr In6Addr): cint {.importc,
              header: "<netinet/in.h>".}

     Unspecified address.

   * IN6_IS_ADDR_LOOPBACK
          proc IN6_IS_ADDR_LOOPBACK*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}

     Loopback address.

   * IN6_IS_ADDR_MULTICAST
          proc IN6_IS_ADDR_MULTICAST*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}

     Multicast address.

   * IN6_IS_ADDR_LINKLOCAL
          proc IN6_IS_ADDR_LINKLOCAL*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}

     Unicast link-local address.

   * IN6_IS_ADDR_SITELOCAL
          proc IN6_IS_ADDR_SITELOCAL*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}

     Unicast site-local address.

   * IN6_IS_ADDR_V4MAPPED
          proc IN6_IS_ADDR_V4MAPPED*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}

     IPv4 mapped address.

   * IN6_IS_ADDR_V4COMPAT
          proc IN6_IS_ADDR_V4COMPAT*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}

     IPv4-compatible address.

   * IN6_IS_ADDR_MC_NODELOCAL header: "<netinet/in.h>".}
          proc IN6_IS_ADDR_MC_NODELOCAL*(a1: ptr In6Addr): cint {.importc,
              header: "<netinet/in.h>".}

     Multicast node-local address.

   * IN6_IS_ADDR_MC_LINKLOCAL header: "<netinet/in.h>".}
          proc IN6_IS_ADDR_MC_LINKLOCAL*(a1: ptr In6Addr): cint {.importc,
              header: "<netinet/in.h>".}

     Multicast link-local address.

   * IN6_IS_ADDR_MC_SITELOCAL header: "<netinet/in.h>".}
          proc IN6_IS_ADDR_MC_SITELOCAL*(a1: ptr In6Addr): cint {.importc,
              header: "<netinet/in.h>".}

     Multicast site-local address.

   * IN6_IS_ADDR_MC_ORGLOCAL header: "<netinet/in.h>".}
          proc IN6_IS_ADDR_MC_ORGLOCAL*(a1: ptr In6Addr): cint {.importc,
              header: "<netinet/in.h>".}

     Multicast organization-local address.

   * IN6_IS_ADDR_MC_GLOBAL
          proc IN6_IS_ADDR_MC_GLOBAL*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}

     Multicast global address.

   * endhostent
          proc endhostent*() {.importc, header: "<netdb.h>".}

   * endnetent
          proc endnetent*() {.importc, header: "<netdb.h>".}

   * endprotoent
          proc endprotoent*() {.importc, header: "<netdb.h>".}

   * endservent
          proc endservent*() {.importc, header: "<netdb.h>".}

   * freeaddrinfo
          proc freeaddrinfo*(a1: ptr AddrInfo) {.importc, header: "<netdb.h>".}

   * gai_strerror
          proc gai_strerror*(a1: cint): cstring {.importc: "(char *)$1", header: "<netdb.h>".}

   * getaddrinfo header: "<netdb.h>".}
          proc getaddrinfo*(a1, a2: cstring; a3: ptr AddrInfo; a4: var ptr AddrInfo): cint {.importc,
              header: "<netdb.h>".}

   * gethostbyaddr header: "<netdb.h>".}
          proc gethostbyaddr*(a1: pointer; a2: Socklen; a3: cint): ptr Hostent {.importc,
              header: "<netdb.h>".}

   * gethostbyname
          proc gethostbyname*(a1: cstring): ptr Hostent {.importc, header: "<netdb.h>".}

   * gethostent
          proc gethostent*(): ptr Hostent {.importc, header: "<netdb.h>".}

   * getnameinfo a6: Socklen; a7: cint): cint {.importc, header:
     "<netdb.h>".}
          proc getnameinfo*(a1: ptr SockAddr; a2: Socklen; a3: cstring; a4: Socklen; a5: cstring;
                           a6: Socklen; a7: cint): cint {.importc, header: "<netdb.h>".}

   * getnetbyaddr
          proc getnetbyaddr*(a1: int32; a2: cint): ptr Tnetent {.importc, header: "<netdb.h>".}

   * getnetbyname
          proc getnetbyname*(a1: cstring): ptr Tnetent {.importc, header: "<netdb.h>".}

   * getnetent
          proc getnetent*(): ptr Tnetent {.importc, header: "<netdb.h>".}

   * getprotobyname
          proc getprotobyname*(a1: cstring): ptr Protoent {.importc, header: "<netdb.h>".}

   * getprotobynumber
          proc getprotobynumber*(a1: cint): ptr Protoent {.importc, header: "<netdb.h>".}

   * getprotoent
          proc getprotoent*(): ptr Protoent {.importc, header: "<netdb.h>".}

   * getservbyname
          proc getservbyname*(a1, a2: cstring): ptr Servent {.importc, header: "<netdb.h>".}

   * getservbyport
          proc getservbyport*(a1: cint; a2: cstring): ptr Servent {.importc, header: "<netdb.h>".}

   * getservent
          proc getservent*(): ptr Servent {.importc, header: "<netdb.h>".}

   * sethostent
          proc sethostent*(a1: cint) {.importc, header: "<netdb.h>".}

   * setnetent
          proc setnetent*(a1: cint) {.importc, header: "<netdb.h>".}

   * setprotoent
          proc setprotoent*(a1: cint) {.importc, header: "<netdb.h>".}

   * setservent
          proc setservent*(a1: cint) {.importc, header: "<netdb.h>".}

   * poll
          proc poll*(a1: ptr TPollfd; a2: Tnfds; a3: int): cint {.importc, header: "<poll.h>".}

   * realpath header: "<stdlib.h>".}
          proc realpath*(name, resolved: cstring): cstring {.importc: "realpath",
              header: "<stdlib.h>".}

   * utimes header: "<sys/time.h>".}
          proc utimes*(path: cstring; times: ptr array[2, Timeval]): int {.importc: "utimes",
              header: "<sys/time.h>".}

     Sets file access and modification times.

     Pass the filename and an array of times to set the access and
     modification times respectively.  If you pass nil as the array both
     attributes will be set to the current time.

     Returns zero on success.

     For more information read
     http://www.unix.com/man-page/posix/3/utimes/
     (http://www.unix.com/man-page/posix/3/utimes/).


File: nim-ref-0.13.0.info,  Node: /posix/termios,  Next: /posix/epoll,  Prev: /posix/posix,  Up: Top

349 Constant variables
**********************

   * NCCS
          NCCS* = 32

   * VEOL2
          VEOL2* = 16

   * IUTF8
          IUTF8* = 40000

   * XTABS
          XTABS* = 14000

   * CRTSCTS
          CRTSCTS* = 0o000000000000020000000000'i64

   * EXTPROC
          EXTPROC* = 0o000000200000

   * TCION
          TCION* = 3

   * TCIOFLUSH
          TCIOFLUSH* = 2

   * TCSAFLUSH
          TCSAFLUSH* = 2

350 Types
*********

   * Cflag
          Cflag* = cuint

   * Termios c_iflag*: Cflag c_oflag*: Cflag c_cflag*: Cflag c_lflag*:
     Cflag c_cc*: array[NCCS, cuchar]

          Termios* {.importc: "struct termios", header: "<termios.h>".} = object
            c_iflag*: Cflag
            c_oflag*: Cflag
            c_cflag*: Cflag
            c_lflag*: Cflag
            c_cc*: array[NCCS, cuchar]


351 Procedures
**************

   * cfGetOspeed header: "<termios.h>".}
          proc cfGetOspeed*(termios: ptr Termios): Speed {.importc: "cfgetospeed",
              header: "<termios.h>".}

   * cfGetIspeed header: "<termios.h>".}
          proc cfGetIspeed*(termios: ptr Termios): Speed {.importc: "cfgetispeed",
              header: "<termios.h>".}

   * cfSetOspeed header: "<termios.h>".}
          proc cfSetOspeed*(termios: ptr Termios; speed: Speed): cint {.importc: "cfsetospeed",
              header: "<termios.h>".}

   * cfSetIspeed header: "<termios.h>".}
          proc cfSetIspeed*(termios: ptr Termios; speed: Speed): cint {.importc: "cfsetispeed",
              header: "<termios.h>".}

   * cfSetSpeed header: "<termios.h>".}
          proc cfSetSpeed*(termios: ptr Termios; speed: Speed): cint {.importc: "cfsetspeed",
              header: "<termios.h>".}

   * tcGetAttr header: "<termios.h>".}
          proc tcGetAttr*(fd: cint; termios: ptr Termios): cint {.importc: "tcgetattr",
              header: "<termios.h>".}

   * tcSetAttr importc: "tcsetattr", header: "<termios.h>".}
          proc tcSetAttr*(fd: cint; optional_actions: cint; termios: ptr Termios): cint {.
              importc: "tcsetattr", header: "<termios.h>".}

   * cfMakeRaw
          proc cfMakeRaw*(termios: ptr Termios) {.importc: "cfmakeraw", header: "<termios.h>".}

   * tcSendBreak header: "<termios.h>".}
          proc tcSendBreak*(fd: cint; duration: cint): cint {.importc: "tcsendbreak",
              header: "<termios.h>".}

   * tcDrain
          proc tcDrain*(fd: cint): cint {.importc: "tcdrain", header: "<termios.h>".}

   * tcFlush header: "<termios.h>".}
          proc tcFlush*(fd: cint; queue_selector: cint): cint {.importc: "tcflush",
              header: "<termios.h>".}

   * tcFlow
          proc tcFlow*(fd: cint; action: cint): cint {.importc: "tcflow", header: "<termios.h>".}

   * tcGetSid
          proc tcGetSid*(fd: cint): Pid {.importc: "tcgetsid", header: "<termios.h>".}

352 Templates
*************

   * cceq
          template cceq*(val, c: expr): expr


File: nim-ref-0.13.0.info,  Node: /posix/epoll,  Next: /posix/kqueue,  Prev: /posix/termios,  Up: Top

353 Constant variables
**********************

   * EPOLLET
          EPOLLET* = 1 shl 31

   * EPOLL_CTL_MOD
          EPOLL_CTL_MOD* = 3

354 Types
*********

   * epoll_event events*: uint32 data*: epoll_data

          epoll_event* {.importc: "struct epoll_event", header: "<sys/epoll.h>", pure, final.} = object
            events*: uint32
            data*: epoll_data


355 Procedures
**************

   * epoll_create header: "<sys/epoll.h>".}
          proc epoll_create*(size: cint): cint {.importc: "epoll_create",
                                             header: "<sys/epoll.h>".}

     Creates an epoll instance. Returns an fd for the new instance.

          The "size" parameter is a hint specifying the number of file
          descriptors to be associated with the new instance.  The fd
          returned by epoll_create() should be closed with close().

   * epoll_create1 header: "<sys/epoll.h>".}
          proc epoll_create1*(flags: cint): cint {.importc: "epoll_create1",
                                               header: "<sys/epoll.h>".}

     Same as epoll_create but with an FLAGS parameter. The unused SIZE

          parameter has been dropped.

   * epoll_ctl importc: "epoll_ctl", header: "<sys/epoll.h>".}
          proc epoll_ctl*(epfd: cint; op: cint; fd: cint | SocketHandle; event: ptr epoll_event): cint {.
              importc: "epoll_ctl", header: "<sys/epoll.h>".}

     Manipulate an epoll instance "epfd". Returns 0 in case of success,

          -1 in case of error ( the "errno" variable will contain the

          specific error code ) The "op" parameter is one of the
          EPOLL_CTL_* constants defined above.  The "fd" parameter is
          the target of the operation.  The "event" parameter describes
          which events the caller is interested in and any associated
          user data.

   * epoll_wait importc: "epoll_wait", header: "<sys/epoll.h>".}
          proc epoll_wait*(epfd: cint; events: ptr epoll_event; maxevents: cint; timeout: cint): cint {.
              importc: "epoll_wait", header: "<sys/epoll.h>".}

     Wait for events on an epoll instance "epfd". Returns the number of

          triggered events returned in "events" buffer.  Or -1 in case
          of error with the "errno" variable set to the specific error
          code.  The "events" parameter is a buffer that will contain
          triggered events.  The "maxevents" is the maximum number of
          events to be returned ( usually size of "events" ).  The
          "timeout" parameter specifies the maximum wait time in
          milliseconds (-1 == infinite).

          This function is a cancellation point and therefore not marked
          with __THROW.


File: nim-ref-0.13.0.info,  Node: /posix/kqueue,  Next: /core/macros,  Prev: /posix/epoll,  Up: Top

356 Constant variables
**********************

   * EVFILT_VM
          EVFILT_VM* = - 12

   * EV_DISABLE
          EV_DISABLE* = 0x00000008

     Disable event (not reported).

   * EV_DISPATCH
          EV_DISPATCH* = 0x00000080

     Disable event after reporting.

   * EV_ERROR
          EV_ERROR* = 0x00004000

     Error, data contains errno

357 Types
*********

   * KEvent ident*: cuint filter*: cshort ## filter for event flags*:
     cushort ## general flags fflags*: cuint ## filter-specific flags
     data*: cuint ## filter-specific data (intptr_t)

          KEvent* {.importc: "struct kevent", header: "<sys/event.h>", pure, final.} = object
            ident*: cuint
            filter*: cshort              ## filter for event
            flags*: cushort              ## general flags
            fflags*: cuint               ## filter-specific flags
            data*: cuint                 ## filter-specific data  (intptr_t)


     identifier for this event (uintptr_t)

358 Procedures
**************

   * kqueue
          proc kqueue*(): cint {.importc: "kqueue", header: "<sys/event.h>".}

     Creates new queue and returns its descriptor.

   * kevent nevents: cint; timeout: ptr Timespec): cint {.importc:
     "kevent", header: "<sys/event.h>".}
          proc kevent*(kqFD: cint; changelist: ptr KEvent; nchanges: cint; eventlist: ptr KEvent;
                      nevents: cint; timeout: ptr Timespec): cint {.importc: "kevent",
              header: "<sys/event.h>".}

     Manipulates queue for given 'kqFD' descriptor.

   * EV_SET fflags: cuint; data: cuint; udata: ptr void) {.importc:
     "EV_SET", header: "<sys/event.h>".}
          proc EV_SET*(event: ptr KEvent; ident: cuint; filter: cshort; flags: cushort;
                      fflags: cuint; data: cuint; udata: ptr void) {.importc: "EV_SET",
              header: "<sys/event.h>".}

     Fills event with given data.


File: nim-ref-0.13.0.info,  Node: /core/macros,  Next: /core/typeinfo,  Prev: /posix/kqueue,  Up: Top

359 Constant variables
**********************

   * nnkCallKinds
          nnkCallKinds* = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit}

   * CallNodes nnkHiddenCallConv}
          CallNodes* = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit,
                      nnkHiddenCallConv}

360 Types
*********

   * TNimSymKinds
          TNimSymKinds* {.deprecated.} = set[NimSymKind]

   * NimSym
          NimSym* = ref NimSymObj

     represents a Nim _symbol_ in the compiler; a _symbol_ is a
     looked-up _ident_.

   * BindSymRule brClosed, ## only the symbols in current scope are
     bound brOpen, ## open wrt overloaded symbols, but may be a single
     ## symbol if not ambiguous (the rules match that of ## binding in
     generics) brForceOpen ## same as brOpen, but it will always be open
     even ## if not ambiguous (this cannot be achieved with ## any other
     means in the language currently)
          BindSymRule* = enum
            brClosed,                   ## only the symbols in current scope are bound
            brOpen,                     ## open wrt overloaded symbols, but may be a single
                   ## symbol if not ambiguous (the rules match that of
                   ## binding in generics)
            brForceOpen                 ## same as brOpen, but it will always be open even
                       ## if not ambiguous (this cannot be achieved with
                       ## any other means in the language currently)

     specifies how 'bindSym' behaves

361 Procedures
**************

   * '[]'
          proc `[]`*(n: NimNode; i: int): NimNode {.magic: "NChild", noSideEffect.}

     get n's i'th child.

   * '[]='
          proc `[]=`*(n: NimNode; i: int; child: NimNode) {.magic: "NSetChild", noSideEffect.}

     set n's i'th child to child.

   * '!'
          proc `!`*(s: string): NimIdent {.magic: "StrToIdent", noSideEffect.}

     constructs an identifier from the string s

   * '$'
          proc `$`*(i: NimIdent): string {.magic: "IdentToStr", noSideEffect.}

     converts a Nim identifier to a string

   * '$'
          proc `$`*(s: NimSym): string {.magic: "IdentToStr", noSideEffect.}

     converts a Nim symbol to a string

   * '=='
          proc `==`*(a, b: NimIdent): bool {.magic: "EqIdent", noSideEffect.}

     compares two Nim identifiers

   * '=='
          proc `==`*(a, b: NimNode): bool {.magic: "EqNimrodNode", noSideEffect.}

     compares two Nim nodes

   * sameType
          proc sameType*(a, b: NimNode): bool {.magic: "SameNodeType", noSideEffect.}

     compares two Nim nodes' types.  Return true if the types are the
     same, eg.  true when comparing alias with original type.

   * len
          proc len*(n: NimNode): int {.magic: "NLen", noSideEffect.}

     returns the number of children of n.

   * add locks: 0.}
          proc add*(father, child: NimNode): NimNode {.magic: "NAdd", discardable, noSideEffect,
                                                  locks: 0.}

     Adds the child to the father node.  Returns the father node so that
     calls can be nested.

   * add magic: "NAddMultiple", discardable, noSideEffect, locks: 0.}
          proc add*(father: NimNode; children: varargs[NimNode]): NimNode {.
              magic: "NAddMultiple", discardable, noSideEffect, locks: 0.}

     Adds each child of children to the father node.  Returns the father
     node so that calls can be nested.

   * del
          proc del*(father: NimNode; idx = 0; n = 1) {.magic: "NDel", noSideEffect.}

     deletes n children of father starting at index idx.

   * kind
          proc kind*(n: NimNode): NimNodeKind {.magic: "NKind", noSideEffect.}

     returns the kind of the node n.

   * intVal
          proc intVal*(n: NimNode): BiggestInt {.magic: "NIntVal", noSideEffect.}

   * floatVal
          proc floatVal*(n: NimNode): BiggestFloat {.magic: "NFloatVal", noSideEffect.}

   * symbol
          proc symbol*(n: NimNode): NimSym {.magic: "NSymbol", noSideEffect.}

   * ident
          proc ident*(n: NimNode): NimIdent {.magic: "NIdent", noSideEffect.}

   * getType
          proc getType*(n: NimNode): NimNode {.magic: "NGetType", noSideEffect.}

     with 'getType' you can access the node's type.  A Nim type is
     mapped to a Nim AST too, so it's slightly confusing but it means
     the same API can be used to traverse types.  Recursive types are
     flattened for you so there is no danger of infinite recursions
     during traversal.  To resolve recursive types, you have to call
     'getType' again.  To see what kind of type it is, call typeKind on
     getType's result.

   * getType
          proc getType*(n: typedesc): NimNode {.magic: "NGetType", noSideEffect.}

     Returns the Nim type node for given type.  This can be used to turn
     macro typedesc parameter into proper NimNode representing type,
     since typedesc are an exception in macro calls - they are not
     mapped implicitly to NimNode like any other arguments.

   * typeKind
          proc typeKind*(n: NimNode): NimTypeKind {.magic: "NGetType", noSideEffect.}

     Returns the type kind of the node 'n' that should represent a type,
     that means the node should have been obtained via getType.

   * strVal
          proc strVal*(n: NimNode): string {.magic: "NStrVal", noSideEffect.}

   * 'intVal='
          proc `intVal =`*(n: NimNode; val: BiggestInt) {.magic: "NSetIntVal", noSideEffect.}

   * 'floatVal='
          proc `floatVal =`*(n: NimNode; val: BiggestFloat) {.magic: "NSetFloatVal", noSideEffect.}

   * 'symbol='
          proc `symbol =`*(n: NimNode; val: NimSym) {.magic: "NSetSymbol", noSideEffect.}

   * 'ident='
          proc `ident =`*(n: NimNode; val: NimIdent) {.magic: "NSetIdent", noSideEffect.}

   * 'strVal='
          proc `strVal =`*(n: NimNode; val: string) {.magic: "NSetStrVal", noSideEffect.}

   * newNimNode noSideEffect.}
          proc newNimNode*(kind: NimNodeKind; n: NimNode = nil): NimNode {.magic: "NNewNimNode",
              noSideEffect.}

   * copyNimNode
          proc copyNimNode*(n: NimNode): NimNode {.magic: "NCopyNimNode", noSideEffect.}

   * copyNimTree
          proc copyNimTree*(n: NimNode): NimNode {.magic: "NCopyNimTree", noSideEffect.}

   * getImpl
          proc getImpl*(s: NimSym): NimNode {.magic: "GetImpl", noSideEffect.}

     retrieve the implementation of a symbol s.  s can be a routine or a
     const.

   * error
          proc error*(msg: string) {.magic: "NError", benign.}

     writes an error message at compile time

   * warning
          proc warning*(msg: string) {.magic: "NWarning", benign.}

     writes a warning message at compile time

   * hint
          proc hint*(msg: string) {.magic: "NHint", benign.}

     writes a hint message at compile time

   * newStrLitNode
          proc newStrLitNode*(s: string): NimNode {.compileTime, noSideEffect.}

     creates a string literal node from s

   * newIntLitNode
          proc newIntLitNode*(i: BiggestInt): NimNode {.compileTime.}

     creates a int literal node from i

   * newFloatLitNode
          proc newFloatLitNode*(f: BiggestFloat): NimNode {.compileTime.}

     creates a float literal node from f

   * newIdentNode
          proc newIdentNode*(i: NimIdent): NimNode {.compileTime.}

     creates an identifier node from i

   * newIdentNode
          proc newIdentNode*(i: string): NimNode {.compileTime.}

     creates an identifier node from i

   * bindSym noSideEffect.}
          proc bindSym*(ident: string; rule: BindSymRule = brClosed): NimNode {.magic: "NBindSym",
              noSideEffect.}

     creates a node that binds ident to a symbol node.  The bound symbol
     may be an overloaded symbol.  If 'rule == brClosed' either an
     'nkClosedSymChoice' tree is returned or 'nkSym' if the symbol is
     not ambiguous.  If 'rule == brOpen' either an 'nkOpenSymChoice'
     tree is returned or 'nkSym' if the symbol is not ambiguous.  If
     'rule == brForceOpen' always an 'nkOpenSymChoice' tree is returned
     even if the symbol is not ambiguous.

   * genSym noSideEffect.}
          proc genSym*(kind: NimSymKind = nskLet; ident = ""): NimNode {.magic: "NGenSym",
              noSideEffect.}

     generates a fresh symbol that is guaranteed to be unique.  The
     symbol needs to occur in a declaration context.

   * callsite
          proc callsite*(): NimNode {.magic: "NCallSite", benign.}

     returns the AST of the invocation expression that invoked this
     macro.

   * toStrLit
          proc toStrLit*(n: NimNode): NimNode {.compileTime.}

     converts the AST n to the concrete Nim code and wraps that in a
     string literal node

   * lineinfo
          proc lineinfo*(n: NimNode): string {.magic: "NLineInfo", noSideEffect.}

     returns the position the node appears in the original source file
     in the form filename(line, col)

   * internalErrorFlag
          proc internalErrorFlag*(): string {.magic: "NError", noSideEffect.}

     Some builtins set an error flag.  This is then turned into a proper
     exception.  *Note*: Ordinary application code should not call this.

   * parseExpr
          proc parseExpr*(s: string): NimNode {.noSideEffect, compileTime.}

     Compiles the passed string to its AST representation.  Expects a
     single expression.  Raises 'ValueError' for parsing errors.

   * parseStmt
          proc parseStmt*(s: string): NimNode {.noSideEffect, compileTime.}

     Compiles the passed string to its AST representation.  Expects one
     or more statements.  Raises 'ValueError' for parsing errors.

   * getAst
          proc getAst*(macroOrTemplate: expr): NimNode {.magic: "ExpandToAst", noSideEffect.}

     Obtains the AST nodes returned from a macro or template invocation.
     Example:
     macro FooMacro() =
       var ast = getAst(BarTemplate())

   * quote
          proc quote*(bl: stmt; op = "``"): NimNode {.magic: "QuoteAst", noSideEffect.}

     Quasi-quoting operator.  Accepts an expression or a block and
     returns the AST that represents it.  Within the quoted AST, you are
     able to interpolate NimNode expressions from the surrounding scope.
     If no operator is given, quoting is done using backticks.
     Otherwise, the given operator must be used as a prefix operator for
     any interpolated expression.  The original meaning of the
     interpolation operator may be obtained by escaping it (by prefixing
     it with itself): e.g.  @ is escaped as @@, @@ is escaped as @@@ and
     so on.

     Example:
     macro check(ex: expr): stmt =
       # this is a simplified version of the check macro from the
       # unittest module.

       # If there is a failed check, we want to make it easy for
       # the user to jump to the faulty line in the code, so we
       # get the line info here:
       var info = ex.lineinfo

       # We will also display the code string of the failed check:
       var expString = ex.toStrLit

       # Finally we compose the code to implement the check:
       result = quote do:
         if not `ex`:
           echo `info` & ": Check failed: " & `expString`

   * expectKind
          proc expectKind*(n: NimNode; k: NimNodeKind) {.compileTime.}

     checks that n is of kind k.  If this is not the case, compilation
     aborts with an error message.  This is useful for writing macros
     that check the AST that is passed to them.

   * expectMinLen
          proc expectMinLen*(n: NimNode; min: int) {.compileTime.}

     checks that n has at least min children.  If this is not the case,
     compilation aborts with an error message.  This is useful for
     writing macros that check its number of arguments.

   * expectLen
          proc expectLen*(n: NimNode; len: int) {.compileTime.}

     checks that n has exactly len children.  If this is not the case,
     compilation aborts with an error message.  This is useful for
     writing macros that check its number of arguments.

   * newTree
          proc newTree*(kind: NimNodeKind; children: varargs[NimNode]): NimNode {.compileTime.}

     produces a new node with children.

   * newCall
          proc newCall*(theProc: NimNode; args: varargs[NimNode]): NimNode {.compileTime.}

     produces a new call node.  theProc is the proc that is called with
     the arguments 'args[0..]'.

   * newCall
          proc newCall*(theProc: NimIdent; args: varargs[NimNode]): NimNode {.compileTime.}

     produces a new call node.  theProc is the proc that is called with
     the arguments 'args[0..]'.

   * newCall
          proc newCall*(theProc: string; args: varargs[NimNode]): NimNode {.compileTime.}

     produces a new call node.  theProc is the proc that is called with
     the arguments 'args[0..]'.

   * newLit
          proc newLit*(c: char): NimNode {.compileTime.}

     produces a new character literal node.

   * newLit
          proc newLit*(i: BiggestInt): NimNode {.compileTime.}

     produces a new integer literal node.

   * newLit
          proc newLit*(b: bool): NimNode {.compileTime.}

     produces a new boolean literal node.

   * newLit
          proc newLit*(f: BiggestFloat): NimNode {.compileTime.}

     produces a new float literal node.

   * newLit
          proc newLit*(s: string): NimNode {.compileTime.}

     produces a new string literal node.

   * nestList
          proc nestList*(theProc: NimIdent; x: NimNode): NimNode {.compileTime.}

     nests the list x into a tree of call expressions: '[a, b, c]' is
     transformed into 'theProc(a, theProc(c, d))'.

   * treeRepr
          proc treeRepr*(n: NimNode): string {.compileTime, benign.}

     Convert the AST n to a human-readable tree-like string.

     See also repr and lispRepr.

   * lispRepr
          proc lispRepr*(n: NimNode): string {.compileTime, benign.}

     Convert the AST n to a human-readable lisp-like string,

     See also repr and treeRepr.

   * newEmptyNode
          proc newEmptyNode*(): NimNode {.compileTime, noSideEffect.}

     Create a new empty node

   * newStmtList
          proc newStmtList*(stmts: varargs[NimNode]): NimNode {.compileTime.}

     Create a new statement list

   * newPar
          proc newPar*(exprs: varargs[NimNode]): NimNode {.compileTime.}

     Create a new parentheses-enclosed expression

   * newBlockStmt
          proc newBlockStmt*(label, body: NimNode): NimNode {.compileTime.}

     Create a new block statement with label

   * newBlockStmt
          proc newBlockStmt*(body: NimNode): NimNode {.compiletime.}

     Create a new block: stmt

   * newVarStmt
          proc newVarStmt*(name, value: NimNode): NimNode {.compiletime.}

     Create a new var stmt

   * newLetStmt
          proc newLetStmt*(name, value: NimNode): NimNode {.compiletime.}

     Create a new let stmt

   * newConstStmt
          proc newConstStmt*(name, value: NimNode): NimNode {.compileTime.}

     Create a new const stmt

   * newAssignment
          proc newAssignment*(lhs, rhs: NimNode): NimNode {.compileTime.}

   * newDotExpr
          proc newDotExpr*(a, b: NimNode): NimNode {.compileTime.}

     Create new dot expression a.dot(b) -> a.b

   * newColonExpr
          proc newColonExpr*(a, b: NimNode): NimNode {.compileTime.}

     Create new colon expression newColonExpr(a, b) -> a: b

   * newIdentDefs
          proc newIdentDefs*(name, kind: NimNode; default = newEmptyNode()): NimNode {.compileTime.}

     Creates a new 'nnkIdentDefs' node of a specific kind and value.

     'nnkIdentDefs' need to have at least three children, but they can
     have more: first comes a list of identifiers followed by a type and
     value nodes.  This helper proc creates a three node subtree, the
     first subnode being a single identifier name.  Both the 'kind' node
     and 'default' (value) nodes may be empty depending on where the
     'nnkIdentDefs' appears: tuple or object definitions will have an
     empty 'default' node, 'let' or 'var' blocks may have an empty
     'kind' node if the identifier is being assigned a value.  Example:
     var varSection = newNimNode(nnkVarSection).add(
       newIdentDefs(ident("a"), ident("string")),
       newIdentDefs(ident("b"), newEmptyNode(), newLit(3)))
     # --> var
     #       a: string
     #       b = 3

     If you need to create multiple identifiers you need to use the
     lower level 'newNimNode':
     result = newNimNode(nnkIdentDefs).add(
       ident("a"), ident("b"), ident("c"), ident("string"),
         newStrLitNode("Hello"))

   * newNilLit
          proc newNilLit*(): NimNode {.compileTime.}

     New nil literal shortcut

   * last
          proc last*(node: NimNode): NimNode {.compileTime.}

     Return the last item in nodes children.  Same as node[^1]

   * expectKind
          proc expectKind*(n: NimNode; k: set[NimNodeKind]) {.compileTime.}

   * newProc body: NimNode = newStmtList(); procType = nnkProcDef):
     NimNode {.  compileTime.}
          proc newProc*(name = newEmptyNode(); params: openArray[NimNode] = [newEmptyNode()];
                       body: NimNode = newStmtList(); procType = nnkProcDef): NimNode {.
              compileTime.}

     shortcut for creating a new proc

     The 'params' array must start with the return type of the proc,
     followed by a list of IdentDefs which specify the params.

   * newIfStmt
          proc newIfStmt*(branches: varargs[tuple[cond, body: NimNode]]): NimNode {.compiletime.}

     Constructor for 'if' statements.
     newIfStmt(
       (Ident, StmtList),
       ...
     )

   * copyChildrenTo
          proc copyChildrenTo*(src, dest: NimNode) {.compileTime.}

     Copy all children from src to dest

   * name
          proc name*(someProc: NimNode): NimNode {.compileTime.}

   * 'name='
          proc `name =`*(someProc: NimNode; val: NimNode) {.compileTime.}

   * params
          proc params*(someProc: NimNode): NimNode {.compileTime.}

   * 'params='
          proc `params =`*(someProc: NimNode; params: NimNode) {.compileTime.}

   * pragma
          proc pragma*(someProc: NimNode): NimNode {.compileTime.}

     Get the pragma of a proc type These will be expanded

   * 'pragma='
          proc `pragma =`*(someProc: NimNode; val: NimNode) {.compileTime.}

     Set the pragma of a proc type

   * body
          proc body*(someProc: NimNode): NimNode {.compileTime.}

   * 'body='
          proc `body =`*(someProc: NimNode; val: NimNode) {.compileTime.}

   * basename
          proc basename*(a: NimNode): NimNode {.compiletime, benign.}

   * '$'
          proc `$`*(node: NimNode): string {.compileTime.}

     Get the string of an identifier node

   * ident
          proc ident*(name: string): NimNode {.compileTime, inline.}

     Create a new ident node from a string

   * insert
          proc insert*(a: NimNode; pos: int; b: NimNode) {.compileTime.}

     Insert node B into A at pos

   * basename
          proc basename*(a: NimNode): NimNode

     Pull an identifier from prefix/postfix expressions

   * 'basename='
          proc `basename =`*(a: NimNode; val: string) {.compileTime.}

   * postfix
          proc postfix*(node: NimNode; op: string): NimNode {.compileTime.}

   * prefix
          proc prefix*(node: NimNode; op: string): NimNode {.compileTime.}

   * infix
          proc infix*(a: NimNode; op: string; b: NimNode): NimNode {.compileTime.}

   * unpackPostfix
          proc unpackPostfix*(node: NimNode): tuple[node: NimNode, op: string] {.compileTime.}

   * unpackPrefix
          proc unpackPrefix*(node: NimNode): tuple[node: NimNode, op: string] {.compileTime.}

   * unpackInfix compileTime.}
          proc unpackInfix*(node: NimNode): tuple[left: NimNode, op: string, right: NimNode] {.
              compileTime.}

   * copy
          proc copy*(node: NimNode): NimNode {.compileTime.}

     An alias for copyNimTree().

   * eqIdent
          proc eqIdent*(a, b: string): bool

     Check if two idents are identical.

   * hasArgOfName
          proc hasArgOfName*(params: NimNode; name: string): bool {.compiletime.}

     Search nnkFormalParams for an argument.

   * addIdentIfAbsent
          proc addIdentIfAbsent*(dest: NimNode; ident: string) {.compiletime.}

     Add ident to dest if it is not present.  This is intended for use
     with pragmas.

   * boolVal
          proc boolVal*(n: NimNode): bool {.compileTime, noSideEffect.}

362 Templates
*************

   * findChild
          template findChild*(n: NimNode; cond: expr): NimNode {.immediate, dirty.}

     Find the first child node matching condition (or nil).
     var res = findChild(n, it.kind == nnkPostfix and
                            it.basename.ident == !"foo")

   * emit
          template emit*(e: static[string]): stmt

     accepts a single string argument and treats it as nim code that
     should be inserted verbatim in the program Example:
     emit("echo " & '"' & "hello world".toUpper & '"')

363 Macros
**********

   * dumpTree
          macro dumpTree*(s: stmt): stmt {.immediate.}

     Accepts a block of nim code and prints the parsed abstract syntax
     tree using the toTree function.  Printing is done _at compile
     time_.

     You can use this as a tool to explore the Nim's abstract syntax
     tree and to discover what kind of nodes must be created to
     represent a certain expression/statement.

   * dumpLisp
          macro dumpLisp*(s: stmt): stmt {.immediate.}

     Accepts a block of nim code and prints the parsed abstract syntax
     tree using the toLisp function.  Printing is done _at compile
     time_.

     See dumpTree.

   * dumpTreeImm
          macro dumpTreeImm*(s: stmt): stmt {.immediate, deprecated.}

     The 'immediate' version of dumpTree.

   * dumpLispImm
          macro dumpLispImm*(s: stmt): stmt {.immediate, deprecated.}

     The 'immediate' version of dumpLisp.

364 Iterators
*************

   * items
          iterator items*(n: NimNode): NimNode {.inline.}

     Iterates over the children of the NimNode 'n'.

   * children
          iterator children*(n: NimNode): NimNode {.inline.}

     Iterates over the children of the NimNode 'n'.


File: nim-ref-0.13.0.info,  Node: /core/typeinfo,  Next: /core/locks,  Prev: /core/macros,  Up: Top

365 Procedures
**************

   * toAny
          proc toAny*(x: VarSlot): Any {.inline.}

     constructs a 'Any' object from a variable slot 'x'.  This captures
     x's address, so x can be modified with its 'Any' wrapper!  The
     client needs to ensure that the wrapper *does not* live longer than
     x!  This is provided for easier reflection capabilities of a
     debugger.

   * toAny
          proc toAny*[T](x: var T): Any {.inline.}

     constructs a 'Any' object from x.  This captures x's address, so x
     can be modified with its 'Any' wrapper!  The client needs to ensure
     that the wrapper *does not* live longer than x!

   * kind
          proc kind*(x: Any): AnyKind {.inline.}

     get the type kind

   * size
          proc size*(x: Any): int {.inline.}

     returns the size of x's type.

   * baseTypeKind
          proc baseTypeKind*(x: Any): AnyKind {.inline.}

     get the base type's kind; 'akNone' is returned if x has no base
     type.

   * baseTypeSize
          proc baseTypeSize*(x: Any): int {.inline.}

     returns the size of x's basetype.

   * invokeNew
          proc invokeNew*(x: Any)

     performs 'new(x)'.  x needs to represent a 'ref'.

   * invokeNewSeq
          proc invokeNewSeq*(x: Any; len: int)

     performs 'newSeq(x, len)'.  x needs to represent a 'seq'.

   * extendSeq
          proc extendSeq*(x: Any)

     performs 'setLen(x, x.len+1)'.  x needs to represent a 'seq'.

   * setObjectRuntimeType
          proc setObjectRuntimeType*(x: Any)

     this needs to be called to set x's runtime object type field.

   * '[]'
          proc `[]`*(x: Any; i: int): Any

     accessor for an any x that represents an array or a sequence.

   * '[]='
          proc `[]=`*(x: Any; i: int; y: Any)

     accessor for an any x that represents an array or a sequence.

   * len
          proc len*(x: Any): int

     len for an any x that represents an array or a sequence.

   * base
          proc base*(x: Any): Any

     returns base Any (useful for inherited object types).

   * isNil
          proc isNil*(x: Any): bool

     isNil for an any x that represents a sequence, string, cstring,
     proc or some pointer type.

   * getPointer
          proc getPointer*(x: Any): pointer

     retrieve the pointer value out of x.  'x' needs to be of kind
     'akString', 'akCString', 'akProc', 'akRef', 'akPtr', 'akPointer',
     'akSequence'.

   * setPointer
          proc setPointer*(x: Any; y: pointer)

     sets the pointer value of x.  'x' needs to be of kind 'akString',
     'akCString', 'akProc', 'akRef', 'akPtr', 'akPointer', 'akSequence'.

   * '[]='
          proc `[]=`*(x: Any; fieldName: string; value: Any)

     sets a field of x; x represents an object or a tuple.

   * '[]'
          proc `[]`*(x: Any; fieldName: string): Any

     gets a field of x; x represents an object or a tuple.

   * '[]'
          proc `[]`*(x: Any): Any

     dereference operation for the any x that represents a ptr or a ref.

   * '[]='
          proc `[]=`*(x, y: Any)

     dereference operation for the any x that represents a ptr or a ref.

   * getInt
          proc getInt*(x: Any): int

     retrieve the int value out of x.  x needs to represent an int.

   * getInt8
          proc getInt8*(x: Any): int8

     retrieve the int8 value out of x.  x needs to represent an int8.

   * getInt16
          proc getInt16*(x: Any): int16

     retrieve the int16 value out of x.  x needs to represent an int16.

   * getInt32
          proc getInt32*(x: Any): int32

     retrieve the int32 value out of x.  x needs to represent an int32.

   * getInt64
          proc getInt64*(x: Any): int64

     retrieve the int64 value out of x.  x needs to represent an int64.

   * getBiggestInt
          proc getBiggestInt*(x: Any): BiggestInt

     retrieve the integer value out of x.  x needs to represent some
     integer, a bool, a char, an enum or a small enough bit set.  The
     value might be sign-extended to 'BiggestInt'.

   * setBiggestInt
          proc setBiggestInt*(x: Any; y: BiggestInt)

     sets the integer value of x.  x needs to represent some integer, a
     bool, a char, an enum or a small enough bit set.

   * getUInt
          proc getUInt*(x: Any): uint

     retrieve the uint value out of x, x needs to represent an uint.

   * getUInt8
          proc getUInt8*(x: Any): uint8

     retrieve the uint8 value out of x, x needs to represent an uint8.

   * getUInt16
          proc getUInt16*(x: Any): uint16

     retrieve the uint16 value out of x, x needs to represent an uint16.

   * getUInt32
          proc getUInt32*(x: Any): uint32

     retrieve the uint32 value out of x, x needs to represent an uint32.

   * getUInt64
          proc getUInt64*(x: Any): uint64

     retrieve the uint64 value out of x, x needs to represent an uint64.

   * getBiggestUint
          proc getBiggestUint*(x: Any): uint64

     retrieve the unsigned integer value out of x.  x needs to represent
     an unsigned integer.

   * setBiggestUint
          proc setBiggestUint*(x: Any; y: uint64)

     sets the unsigned integer value of c.  c needs to represent an
     unsigned integer.

   * getChar
          proc getChar*(x: Any): char

     retrieve the char value out of x.  x needs to represent a char.

   * getBool
          proc getBool*(x: Any): bool

     retrieve the bool value out of x.  x needs to represent a bool.

   * skipRange
          proc skipRange*(x: Any): Any

     skips the range information of x.

   * getEnumOrdinal
          proc getEnumOrdinal*(x: Any; name: string): int

     gets the enum field ordinal from name.  x needs to represent an
     enum but is only used to access the type information.  In case of
     an error 'low(int)' is returned.

   * getEnumField
          proc getEnumField*(x: Any; ordinalValue: int): string

     gets the enum field name as a string.  x needs to represent an enum
     but is only used to access the type information.  The field name of
     ordinalValue is returned.

   * getEnumField
          proc getEnumField*(x: Any): string

     gets the enum field name as a string.  x needs to represent an
     enum.

   * getFloat
          proc getFloat*(x: Any): float

     retrieve the float value out of x.  x needs to represent an float.

   * getFloat32
          proc getFloat32*(x: Any): float32

     retrieve the float32 value out of x.  x needs to represent an
     float32.

   * getFloat64
          proc getFloat64*(x: Any): float64

     retrieve the float64 value out of x.  x needs to represent an
     float64.

   * getBiggestFloat
          proc getBiggestFloat*(x: Any): BiggestFloat

     retrieve the float value out of x.  x needs to represent some
     float.  The value is extended to 'BiggestFloat'.

   * setBiggestFloat
          proc setBiggestFloat*(x: Any; y: BiggestFloat)

     sets the float value of x.  x needs to represent some float.

   * getString
          proc getString*(x: Any): string

     retrieve the string value out of x.  x needs to represent a string.

   * setString
          proc setString*(x: Any; y: string)

     sets the string value of x.  x needs to represent a string.

   * getCString
          proc getCString*(x: Any): cstring

     retrieve the cstring value out of x.  x needs to represent a
     cstring.

   * assign
          proc assign*(x, y: Any)

     copies the value of y to x.  The assignment operator for 'Any' does
     NOT do this; it performs a shallow copy instead!

   * inclSetElement
          proc inclSetElement*(x: Any; elem: int)

     includes an element elem in x.  x needs to represent a Nim bitset.

366 Iterators
*************

   * fields
          iterator fields*(x: Any): tuple[name: string, any: Any]

     iterates over every active field of the any x that represents an
     object or a tuple.

   * elements
          iterator elements*(x: Any): int

     iterates over every element of x that represents a Nim bitset.


File: nim-ref-0.13.0.info,  Node: /core/locks,  Next: /system/avltree,  Prev: /core/typeinfo,  Up: Top

367 Types
*********

   * Cond
          Cond* = SysCond

     Nim condition variable

368 Procedures
**************

   * initLock
          proc initLock*(lock: var Lock) {.inline.}

     Initializes the given lock.

   * deinitLock
          proc deinitLock*(lock: var Lock) {.inline.}

     Frees the resources associated with the lock.

   * tryAcquire
          proc tryAcquire*(lock: var Lock): bool

     Tries to acquire the given lock.  Returns true on success.

   * acquire
          proc acquire*(lock: var Lock)

     Acquires the given lock.

   * release
          proc release*(lock: var Lock)

     Releases the given lock.

   * initCond
          proc initCond*(cond: var Cond) {.inline.}

     Initializes the given condition variable.

   * deinitCond
          proc deinitCond*(cond: var Cond) {.inline.}

     Frees the resources associated with the lock.

   * wait
          proc wait*(cond: var Cond; lock: var Lock) {.inline.}

     waits on the condition variable cond.

   * signal
          proc signal*(cond: var Cond) {.inline.}

     sends a signal to the condition variable cond.


File: nim-ref-0.13.0.info,  Node: /system/avltree,  Next: /system/excpt,  Prev: /core/locks,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/excpt,  Next: /system/gc_common,  Prev: /system/avltree,  Up: Top

369 Variables
*************

   * errorMessageWriter
          errorMessageWriter*: (proc (msg: string) {.tags: [WriteIOEffect], benign.})

     Function that will be called instead of stdmsg.write when printing
     stacktrace.  Unstable API.

370 Procedures
**************

   * getFrame
          proc getFrame*(): PFrame {.compilerRtl, inl.}

   * setFrame
          proc setFrame*(s: PFrame) {.compilerRtl, inl.}

   * stackTraceAvailable
          proc stackTraceAvailable*(): bool


File: nim-ref-0.13.0.info,  Node: /system/gc_common,  Next: /system/sysspawn,  Prev: /system/excpt,  Up: Top

371 Procedures
**************

   * GC_addStack
          proc GC_addStack*(starts: pointer) {.cdecl, exportc.}

   * GC_removeStack
          proc GC_removeStack*(starts: pointer) {.cdecl, exportc.}

   * GC_setCurrentStack
          proc GC_setCurrentStack*(starts, pos: pointer) {.cdecl, exportc.}

   * setupForeignThreadGc
          proc setupForeignThreadGc*()

     call this if you registered a callback that will be run from a
     thread not under your control.  This has a cheap thread-local
     guard, so the GC for this thread will only be initialized once per
     thread, no matter how often it is called.


File: nim-ref-0.13.0.info,  Node: /system/assign,  Next: /system/sysspawn,  Prev: /system/gc_common,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/sysspawn,  Next: /system/gc_ms,  Prev: /system/gc_common,  Up: Top

372 Types
*********

   * Barrier counter: int cv: CondVar

          Barrier* {.compilerProc.} = object
            counter: int
            cv: CondVar


373 Procedures
**************

   * barrierEnter
          proc barrierEnter*(b: ptr Barrier) {.compilerProc.}

   * barrierLeave
          proc barrierLeave*(b: ptr Barrier) {.compilerProc.}

   * openBarrier
          proc openBarrier*(b: ptr Barrier) {.compilerProc.}

   * closeBarrier
          proc closeBarrier*(b: ptr Barrier) {.compilerProc.}

   * preferSpawn
          proc preferSpawn*(): bool

     Use this proc to determine quickly if a 'spawn' or a direct call is
     preferable.  If it returns 'true' a 'spawn' may make sense.  In
     general it is not necessary to call this directly; use 'spawnX'
     instead.

   * spawn
          proc spawn*(call: stmt) {.magic: "Spawn".}

     always spawns a new task, so that the 'call' is never executed on
     the calling thread.  'call' has to be proc call 'p(...)'  where 'p'
     is gcsafe and has 'void' as the return type.

   * sync
          proc sync*()

     a simple barrier to wait for all spawn'ed tasks.  If you need more
     elaborate waiting, you have to use an explicit barrier.

374 Templates
*************

   * spawnX
          template spawnX*(call: stmt)

     spawns a new task if a CPU core is ready, otherwise executes the
     call in the calling thread.  Usually it is advised to use 'spawn'
     in order to not block the producer for an unknown amount of time.
     'call' has to be proc call 'p(...)'  where 'p' is gcsafe and has
     'void' as the return type.


File: nim-ref-0.13.0.info,  Node: /system/gc_ms,  Next: /system/gc,  Prev: /system/sysspawn,  Up: Top

375 Procedures
**************

   * getCellId
          proc getCellId*[T](x: ref T): int


File: nim-ref-0.13.0.info,  Node: /system/cgprocs,  Next: /system/inclrtl,  Prev: /system/gc_ms,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/inclrtl,  Next: /system/repr,  Prev: /system/cgprocs,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/repr,  Next: /system/gc,  Prev: /system/inclrtl,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/gc,  Next: /system/atomics,  Prev: /system/gc_ms,  Up: Top

376 Procedures
**************

   * GC_addCycleRoot
          proc GC_addCycleRoot*[T](p: ref T) {.inline.}

     adds 'p' to the cycle candidate set for the cycle collector.  It is
     necessary if you used the 'acyclic' pragma for optimization
     purposes and need to break cycles manually.

   * gcInvariant
          proc gcInvariant*()

   * GC_setMaxPause
          proc GC_setMaxPause*(MaxPauseInUs: int)

   * GC_step
          proc GC_step*(us: int; strongAdvice = false)


File: nim-ref-0.13.0.info,  Node: /system/dyncalls,  Next: /system/syslocks,  Prev: /system/gc,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/syslocks,  Next: /system/atomics,  Prev: /system/dyncalls,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/atomics,  Next: /system/sysio,  Prev: /system/gc,  Up: Top

377 Variables
*************

   * ATOMIC_RELAXED
          ATOMIC_RELAXED* {.importc: "__ATOMIC_RELAXED", nodecl.}: AtomMemModel

     No barriers or synchronization.

   * ATOMIC_CONSUME
          ATOMIC_CONSUME* {.importc: "__ATOMIC_CONSUME", nodecl.}: AtomMemModel

     Data dependency only for both barrier and synchronization with
     another thread.

   * ATOMIC_ACQUIRE
          ATOMIC_ACQUIRE* {.importc: "__ATOMIC_ACQUIRE", nodecl.}: AtomMemModel

     Barrier to hoisting of code and synchronizes with release (or
     stronger) semantic stores from another thread.

   * ATOMIC_RELEASE
          ATOMIC_RELEASE* {.importc: "__ATOMIC_RELEASE", nodecl.}: AtomMemModel

     Barrier to sinking of code and synchronizes with acquire (or
     stronger) semantic loads from another thread.

   * ATOMIC_ACQ_REL
          ATOMIC_ACQ_REL* {.importc: "__ATOMIC_ACQ_REL", nodecl.}: AtomMemModel

     Full barrier in both directions and synchronizes with acquire loads
     and release stores in another thread.

   * ATOMIC_SEQ_CST
          ATOMIC_SEQ_CST* {.importc: "__ATOMIC_SEQ_CST", nodecl.}: AtomMemModel

     Full barrier in both directions and synchronizes with acquire loads
     and release stores in all threads.

378 Types
*********

   * AtomMemModel
          AtomMemModel* = distinct cint

   * AtomType
          AtomType* = SomeNumber | pointer | ptr | char | bool

     Type Class representing valid types for use with atomic procs

379 Procedures
**************

   * atomicLoadN importc: "__atomic_load_n", nodecl.}
          proc atomicLoadN*[T: AtomType](p: ptr T; mem: AtomMemModel): T {.
              importc: "__atomic_load_n", nodecl.}

     This proc implements an atomic load operation.  It returns the
     contents at p.  ATOMIC_RELAXED, ATOMIC_SEQ_CST, ATOMIC_ACQUIRE,
     ATOMIC_CONSUME.

   * atomicLoad importc: "__atomic_load", nodecl.}
          proc atomicLoad*[T: AtomType](p, ret: ptr T; mem: AtomMemModel) {.
              importc: "__atomic_load", nodecl.}

     This is the generic version of an atomic load.  It returns the
     contents at p in ret.

   * atomicStoreN importc: "__atomic_store_n", nodecl.}
          proc atomicStoreN*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel) {.
              importc: "__atomic_store_n", nodecl.}

     This proc implements an atomic store operation.  It writes val at
     p.  ATOMIC_RELAXED, ATOMIC_SEQ_CST, and ATOMIC_RELEASE.

   * atomicStore importc: "__atomic_store", nodecl.}
          proc atomicStore*[T: AtomType](p, val: ptr T; mem: AtomMemModel) {.
              importc: "__atomic_store", nodecl.}

     This is the generic version of an atomic store.  It stores the
     value of val at p

   * atomicExchangeN importc: "__atomic_exchange_n", nodecl.}
          proc atomicExchangeN*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_exchange_n", nodecl.}

     This proc implements an atomic exchange operation.  It writes val
     at p, and returns the previous contents at p.  ATOMIC_RELAXED,
     ATOMIC_SEQ_CST, ATOMIC_ACQUIRE, ATOMIC_RELEASE, ATOMIC_ACQ_REL

   * atomicExchange importc: "__atomic_exchange", nodecl.}
          proc atomicExchange*[T: AtomType](p, val, ret: ptr T; mem: AtomMemModel) {.
              importc: "__atomic_exchange", nodecl.}

     This is the generic version of an atomic exchange.  It stores the
     contents at val at p.  The original value at p is copied into ret.

   * atomicCompareExchangeN success_memmodel: AtomMemModel;
     failure_memmodel: AtomMemModel): bool {.  importc:
     "__atomic_compare_exchange_n ", nodecl.}
          proc atomicCompareExchangeN*[T: AtomType](p, expected: ptr T; desired: T; weak: bool;
                                                  success_memmodel: AtomMemModel;
                                                  failure_memmodel: AtomMemModel): bool {.
              importc: "__atomic_compare_exchange_n ", nodecl.}

     This proc implements an atomic compare and exchange operation.
     This compares the contents at p with the contents at expected and
     if equal, writes desired at p.  If they are not equal, the current
     contents at p is written into expected.  Weak is true for weak
     compare_exchange, and false for the strong variation.  Many targets
     only offer the strong variation and ignore the parameter.  When in
     doubt, use the strong variation.  True is returned if desired is
     written at p and the execution is considered to conform to the
     memory model specified by success_memmodel.  There are no
     restrictions on what memory model can be used here.  False is
     returned otherwise, and the execution is considered to conform to
     failure_memmodel.  This memory model cannot be __ATOMIC_RELEASE nor
     __ATOMIC_ACQ_REL. It also cannot be a stronger model than that
     specified by success_memmodel.

   * atomicCompareExchange success_memmodel: AtomMemModel;
     failure_memmodel: AtomMemModel): bool {.  importc:
     "__atomic_compare_exchange", nodecl.}
          proc atomicCompareExchange*[T: AtomType](p, expected, desired: ptr T; weak: bool;
                                                 success_memmodel: AtomMemModel;
                                                 failure_memmodel: AtomMemModel): bool {.
              importc: "__atomic_compare_exchange", nodecl.}

     This proc implements the generic version of
     atomic_compare_exchange.  The proc is virtually identical to
     atomic_compare_exchange_n, except the desired value is also a
     pointer.

   * atomicAddFetch importc: "__atomic_add_fetch", nodecl.}
          proc atomicAddFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_add_fetch", nodecl.}

   * atomicSubFetch importc: "__atomic_sub_fetch", nodecl.}
          proc atomicSubFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_sub_fetch", nodecl.}

   * atomicOrFetch importc: "__atomic_or_fetch ", nodecl.}
          proc atomicOrFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_or_fetch ", nodecl.}

   * atomicAndFetch importc: "__atomic_and_fetch", nodecl.}
          proc atomicAndFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_and_fetch", nodecl.}

   * atomicXorFetch importc: "__atomic_xor_fetch", nodecl.}
          proc atomicXorFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_xor_fetch", nodecl.}

   * atomicNandFetch importc: "__atomic_nand_fetch ", nodecl.}
          proc atomicNandFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_nand_fetch ", nodecl.}

   * atomicFetchAdd importc: "__atomic_fetch_add", nodecl.}
          proc atomicFetchAdd*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_fetch_add", nodecl.}

   * atomicFetchSub importc: "__atomic_fetch_sub", nodecl.}
          proc atomicFetchSub*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_fetch_sub", nodecl.}

   * atomicFetchOr importc: "__atomic_fetch_or", nodecl.}
          proc atomicFetchOr*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_fetch_or", nodecl.}

   * atomicFetchAnd importc: "__atomic_fetch_and", nodecl.}
          proc atomicFetchAnd*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_fetch_and", nodecl.}

   * atomicFetchXor importc: "__atomic_fetch_xor", nodecl.}
          proc atomicFetchXor*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_fetch_xor", nodecl.}

   * atomicFetchNand importc: "__atomic_fetch_nand", nodecl.}
          proc atomicFetchNand*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.
              importc: "__atomic_fetch_nand", nodecl.}

   * atomicTestAndSet importc: "__atomic_test_and_set", nodecl.}
          proc atomicTestAndSet*(p: pointer; mem: AtomMemModel): bool {.
              importc: "__atomic_test_and_set", nodecl.}

     This built-in function performs an atomic test-and-set operation on
     the byte at p.  The byte is set to some implementation defined
     nonzero “set” value and the return value is true if and only if
     the previous contents were “set”.  All memory models are valid.

   * atomicClear
          proc atomicClear*(p: pointer; mem: AtomMemModel) {.importc: "__atomic_clear", nodecl.}

     This built-in function performs an atomic clear operation at p.
     After the operation, at p contains 0.  ATOMIC_RELAXED,
     ATOMIC_SEQ_CST, ATOMIC_RELEASE

   * atomicThreadFence
          proc atomicThreadFence*(mem: AtomMemModel) {.importc: "__atomic_thread_fence", nodecl.}

     This built-in function acts as a synchronization fence between
     threads based on the specified memory model.  All memory orders are
     valid.

   * atomicSignalFence
          proc atomicSignalFence*(mem: AtomMemModel) {.importc: "__atomic_signal_fence", nodecl.}

     This built-in function acts as a synchronization fence between a
     thread and signal handlers based in the same thread.  All memory
     orders are valid.

   * atomicAlwaysLockFree importc: "__atomic_always_lock_free", nodecl.}
          proc atomicAlwaysLockFree*(size: int; p: pointer): bool {.
              importc: "__atomic_always_lock_free", nodecl.}

     This built-in function returns true if objects of size bytes always
     generate lock free atomic instructions for the target architecture.
     size must resolve to a compile-time constant and the result also
     resolves to a compile-time constant.  ptr is an optional pointer to
     the object that may be used to determine alignment.  A value of 0
     indicates typical alignment should be used.  The compiler may also
     ignore this parameter.

   * atomicIsLockFree importc: "__atomic_is_lock_free", nodecl.}
          proc atomicIsLockFree*(size: int; p: pointer): bool {.
              importc: "__atomic_is_lock_free", nodecl.}

     This built-in function returns true if objects of size bytes always
     generate lock free atomic instructions for the target architecture.
     If it is not known to be lock free a call is made to a runtime
     routine named __atomic_is_lock_free.  ptr is an optional pointer to
     the object that may be used to determine alignment.  A value of 0
     indicates typical alignment should be used.  The compiler may also
     ignore this parameter.

   * atomicInc
          proc atomicInc*(memLoc: var int; x: int = 1): int

   * atomicDec
          proc atomicDec*(memLoc: var int; x: int = 1): int

   * cas
          proc cas*[T: bool | int | ptr](p: ptr T; oldValue, newValue: T): bool

   * cpuRelax
          proc cpuRelax*() {.inline.}

   * fence
          proc fence*() {.inline.}

380 Templates
*************

   * fence
          template fence*()


File: nim-ref-0.13.0.info,  Node: /system/sysio,  Next: /system/gc2,  Prev: /system/atomics,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/gc2,  Next: /system/jssys,  Prev: /system/sysio,  Up: Top

381 Procedures
**************

   * GC_addCycleRoot
          proc GC_addCycleRoot*[T](p: ref T) {.inline.}

     adds 'p' to the cycle candidate set for the cycle collector.  It is
     necessary if you used the 'acyclic' pragma for optimization
     purposes and need to break cycles manually.

   * gcInvariant
          proc gcInvariant*()

   * GC_setMaxPause
          proc GC_setMaxPause*(MaxPauseInUs: int)

   * GC_step
          proc GC_step*(us: int; strongAdvice = false)


File: nim-ref-0.13.0.info,  Node: /system/jssys,  Next: /system/profiler,  Prev: /system/gc2,  Up: Top

382 Procedures
**************

   * alert
          proc alert*(s: cstring) {.importc: "console.log", nodecl.}

   * log
          proc log*(s: cstring) {.importc: "console.log", varargs, nodecl.}

   * getCurrentExceptionMsg
          proc getCurrentExceptionMsg*(): string

   * ze
          proc ze*(a: int): int {.compilerproc.}

   * ze64
          proc ze64*(a: int64): int64 {.compilerproc.}

   * toU8
          proc toU8*(a: int): int8 {.asmNoStackFrame, compilerproc.}

   * toU16
          proc toU16*(a: int): int16 {.asmNoStackFrame, compilerproc.}

   * toU32
          proc toU32*(a: int64): int32 {.asmNoStackFrame, compilerproc.}


File: nim-ref-0.13.0.info,  Node: /system/reprjs,  Next: /system/profiler,  Prev: /system/jssys,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/profiler,  Next: /system/nimscript,  Prev: /system/jssys,  Up: Top

383 Variables
*************

   * profilingRequestedHook
          profilingRequestedHook*: proc (): bool {.nimcall, benign.}

     set this variable to provide a procedure that implements a profiler
     in user space.  See the nimprof module for a reference
     implementation.

   * profilerHook
          profilerHook*: MemProfilerHook

     set this variable to provide a procedure that implements a profiler
     in user space.  See the nimprof module for a reference
     implementation.

384 Types
*********

   * ProfilerHook
          ProfilerHook* = proc (st: StackTrace) {.nimcall.}

   * MemProfilerHook
          MemProfilerHook* = proc (st: StackTrace; requestedSize: int) {.nimcall, benign.}


File: nim-ref-0.13.0.info,  Node: /system/nimscript,  Next: /system/sysstr,  Prev: /system/profiler,  Up: Top

385 Variables
*************

   * mode
          mode*: ScriptMode

     Set this to influence how mkDir, rmDir, rmFile etc.  behave

   * requiresData
          requiresData*: seq[string] = @ []

     Exposes the list of requirements for read and write accesses.

386 Types
*********

   * ScriptMode Silent, ## Be silent.  Verbose, ## Be verbose.  Whatif
     ## Do not run commands, instead just echo what ## would have been
     done.
          ScriptMode* {.pure.} = enum
            Silent,                     ## Be silent.
            Verbose,                    ## Be verbose.
            Whatif                      ## Do not run commands, instead just echo what
                  ## would have been done.

     Controls the behaviour of the script.

387 Procedures
**************

   * listDirs
          proc listDirs*(dir: string): seq[string]

     Lists all the subdirectories (non-recursively) in the directory
     dir.

   * listFiles
          proc listFiles*(dir: string): seq[string]

     Lists all the files (non-recursively) in the directory dir.

   * paramStr
          proc paramStr*(i: int): string

     Retrieves the 'i''th command line parameter.

   * paramCount
          proc paramCount*(): int

     Retrieves the number of command line parameters.

   * switch
          proc switch*(key: string; val = "")

     Sets a Nim compiler command line switch, for example
     'switch("checks", "on")'.

   * getCommand
          proc getCommand*(): string

     Gets the Nim command that the compiler has been invoked with, for
     example "c", "js", "build", "help".

   * setCommand
          proc setCommand*(cmd: string; project = "")

     Sets the Nim command that should be continued with after this
     Nimscript has finished.

   * cmpic
          proc cmpic*(a, b: string): int

     Compares a and b ignoring case.

   * getEnv
          proc getEnv*(key: string): string {.tags: [ReadIOEffect].}

     Retrieves the environment variable of name key.

   * existsEnv
          proc existsEnv*(key: string): bool {.tags: [ReadIOEffect].}

     Checks for the existance of an environment variable named key.

   * fileExists
          proc fileExists*(filename: string): bool {.tags: [ReadIOEffect].}

     Checks if the file exists.

   * dirExists
          proc dirExists*(dir: string): bool {.tags: [ReadIOEffect].}

     Checks if the directory dir exists.

   * existsFile
          proc existsFile*(filename: string): bool

     An alias for 'fileExists'.

   * existsDir
          proc existsDir*(dir: string): bool

     An alias for 'dirExists'.

   * toExe
          proc toExe*(filename: string): string

     On Windows adds ".exe" to filename, else returns filename
     unmodified.

   * toDll
          proc toDll*(filename: string): string

     On Windows adds ".dll" to filename, on Posix produces
     "lib$filename.so".

   * rmDir
          proc rmDir*(dir: string) {.raises: [OSError].}

     Removes the directory dir.

   * rmFile
          proc rmFile*(file: string) {.raises: [OSError].}

     Removes the file.

   * mkDir
          proc mkDir*(dir: string) {.raises: [OSError].}

     Creates the directory dir including all necessary subdirectories.
     If the directory already exists, no error is raised.

   * mvFile
          proc mvFile*(`from`, to: string) {.raises: [OSError].}

     Moves the file from to to.

   * cpFile
          proc cpFile*(`from`, to: string) {.raises: [OSError].}

     Copies the file from to to.

   * exec
          proc exec*(command: string)

     Executes an external process.

   * exec tags: [ExecIOEffect].}
          proc exec*(command: string; input: string; cache = "") {.raises: [OSError],
              tags: [ExecIOEffect].}

     Executes an external process.

   * put
          proc put*(key, value: string)

     Sets a configuration 'key' like 'gcc.options.always' to its value.

   * get
          proc get*(key: string): string

     Retrieves a configuration 'key' like 'gcc.options.always'.

   * exists
          proc exists*(key: string): bool

     Checks for the existance of a configuration 'key' like
     'gcc.options.always'.

   * nimcacheDir
          proc nimcacheDir*(): string

     Retrieves the location of 'nimcache'.

   * thisDir
          proc thisDir*(): string

     Retrieves the location of the current 'nims' script file.

   * cd
          proc cd*(dir: string) {.raises: [OSError].}

     Changes the current directory.

     The change is permanent for the rest of the execution, since this
     is just a shortcut for os.setCurrentDir()
     (http://nim-lang.org/os.html#setCurrentDir,string) .  Use the
     withDir() (#withDir) template if you want to perform a temporary
     change only.

   * requires
          proc requires*(deps: varargs[string])

     Nimble support: Call this to set the list of requirements of your
     Nimble package.

388 Templates
*************

   * '-'
          template `--`*(key, val: untyped)

     A shortcut for 'switch(astToStr(key), astToStr(val))'.

   * '-'
          template `--`*(key: untyped)

     A shortcut for 'switch(astToStr(key)'.

   * withDir
          template withDir*(dir: string; body: untyped): untyped

     Changes the current directory temporarily.

     If you need a permanent change, use the cd() (#cd) proc.  Usage
     example:
     withDir "foo":
       # inside foo
     #back to last dir

   * task
          template task*(name: untyped; description: string; body: untyped): untyped

     Defines a task.  Hidden tasks are supported via an empty
     description.  Example:
     task build, "default build is via the C backend":
       setCommand "c"


File: nim-ref-0.13.0.info,  Node: /system/sysstr,  Next: /system/timers,  Prev: /system/nimscript,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/timers,  Next: /system/deepcopy,  Prev: /system/sysstr,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/deepcopy,  Next: /system/embedded,  Prev: /system/timers,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/embedded,  Next: /system/cellsets,  Prev: /system/deepcopy,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/cellsets,  Next: /system/arithm,  Prev: /system/embedded,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/arithm,  Next: /system/debugger,  Prev: /system/cellsets,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/debugger,  Next: /system/widestrs,  Prev: /system/arithm,  Up: Top

389 Variables
*************

   * dbgWatchpointHook
          dbgWatchpointHook*: proc (watchpointName: cstring) {.nimcall.}

390 Types
*********

   * Breakpoint low*, high*: int ## range from low to high; if disabled
     ## both low and high are set to their negative values filename*:
     cstring ## the filename of the breakpoint

          Breakpoint* = object
            low*, high*: int              ## range from low to high; if disabled
                          ## both low and high are set to their negative values
            filename*: cstring           ## the filename of the breakpoint


     represents a break point

391 Procedures
**************

   * getLocal
          proc getLocal*(frame: PFrame; slot: int): VarSlot {.inline.}

     retrieves the meta data for the local variable at slot.  CAUTION:
     An invalid slot value causes a corruption!

   * getGlobalLen
          proc getGlobalLen*(): int {.inline.}

     gets the number of registered globals.

   * getGlobal
          proc getGlobal*(slot: int): VarSlot {.inline.}

     retrieves the meta data for the global variable at slot.  CAUTION:
     An invalid slot value causes a corruption!

   * addBreakpoint
          proc addBreakpoint*(filename: cstring; lo, hi: int): bool

   * canonFilename
          proc canonFilename*(filename: cstring): cstring

     returns 'nil' if the filename cannot be found.

   * isActive
          proc isActive*(b: ptr Breakpoint): bool

   * flip
          proc flip*(b: ptr Breakpoint)

     enables or disables 'b' depending on its current state.

   * checkBreakpoints
          proc checkBreakpoints*(filename: cstring; line: int): ptr Breakpoint

     in which breakpoint (if any) we are.

   * dbgUnregisterWatchpoints
          proc dbgUnregisterWatchpoints*()

392 Iterators
*************

   * listBreakpoints
          iterator listBreakpoints*(): ptr Breakpoint

     lists all breakpoints.


File: nim-ref-0.13.0.info,  Node: /system/widestrs,  Next: /system/sets,  Prev: /system/debugger,  Up: Top

393 Types
*********

   * WideCString
          WideCString* = ref array[0 .. 1000000, Utf16Char]

394 Procedures
**************

   * len
          proc len*(w: WideCString): int

     returns the length of a widestring.  This traverses the whole
     string to find the binary zero end marker!

   * newWideCString
          proc newWideCString*(source: cstring; L: int): WideCString

   * newWideCString
          proc newWideCString*(s: cstring): WideCString

   * newWideCString
          proc newWideCString*(s: string): WideCString

   * '$'
          proc `$`*(w: WideCString; estimate: int; replacement: int = 0x0000FFFD): string

   * '$'
          proc `$`*(s: WideCString): string


File: nim-ref-0.13.0.info,  Node: /system/sets,  Next: /system/endb,  Prev: /system/widestrs,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/endb,  Next: /system/hti,  Prev: /system/sets,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/hti,  Next: /system/mmdisp,  Prev: /system/endb,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/mmdisp,  Next: /system/channels,  Prev: /system/hti,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/channels,  Next: /system/platforms,  Prev: /system/mmdisp,  Up: Top

395 Types
*********

   * Channel
          Channel* {.gcsafe.}[TMsg] = RawChannel

     a channel for thread communication

396 Procedures
**************

   * send
          proc send*[TMsg](c: var Channel[TMsg]; msg: TMsg)

     sends a message to a thread.  msg is deeply copied.

   * recv
          proc recv*[TMsg](c: var Channel[TMsg]): TMsg

     receives a message from the channel c.  This blocks until a message
     has arrived!  You may use 'peek' to avoid the blocking.

   * tryRecv
          proc tryRecv*[TMsg](c: var Channel[TMsg]): tuple[dataAvailable: bool, msg: TMsg]

     try to receives a message from the channel c if available.
     Otherwise it returns '(false, default(msg))'.

   * peek
          proc peek*[TMsg](c: var Channel[TMsg]): int

     returns the current number of messages in the channel c.  Returns
     -1 if the channel has been closed.  *Note*: This is dangerous to
     use as it encourages races.  It's much better to use 'tryRecv'
     instead.

   * open
          proc open*[TMsg](c: var Channel[TMsg])

     opens a channel c for inter thread communication.

   * close
          proc close*[TMsg](c: var Channel[TMsg])

     closes a channel c and frees its associated resources.

   * ready
          proc ready*[TMsg](c: var Channel[TMsg]): bool

     returns true iff some thread is waiting on the channel c for new
     messages.


File: nim-ref-0.13.0.info,  Node: /system/platforms,  Next: /system/chcks,  Prev: /system/channels,  Up: Top

397 Constant variables
**********************

   * targetCPU elif defined(m68k): CpuPlatform.m68k elif defined(alpha):
     CpuPlatform.alpha elif defined(powerpc): CpuPlatform.powerpc elif
     defined(powerpc64): CpuPlatform.powerpc64 elif
     defined(powerpc64el): CpuPlatform.powerpc64el elif defined(sparc):
     CpuPlatform.sparc elif defined(ia64): CpuPlatform.ia64 elif
     defined(amd64): CpuPlatform.amd64 elif defined(mips):
     CpuPlatform.mips elif defined(mipsel): CpuPlatform.mipsel elif
     defined(arm): CpuPlatform.arm elif defined(arm64):
     CpuPlatform.arm64 elif defined(vm): CpuPlatform.vm elif
     defined(avr): CpuPlatform.avr elif defined(msp430):
     CpuPlatform.msp430 else: CpuPlatform.none
          targetCPU* = when defined(i386): CpuPlatform.i386
           elif defined(m68k): CpuPlatform.m68k
           elif defined(alpha): CpuPlatform.alpha
           elif defined(powerpc): CpuPlatform.powerpc
           elif defined(powerpc64): CpuPlatform.powerpc64
           elif defined(powerpc64el): CpuPlatform.powerpc64el
           elif defined(sparc): CpuPlatform.sparc
           elif defined(ia64): CpuPlatform.ia64
           elif defined(amd64): CpuPlatform.amd64
           elif defined(mips): CpuPlatform.mips
           elif defined(mipsel): CpuPlatform.mipsel
           elif defined(arm): CpuPlatform.arm
           elif defined(arm64): CpuPlatform.arm64
           elif defined(vm): CpuPlatform.vm
           elif defined(avr): CpuPlatform.avr
           elif defined(msp430): CpuPlatform.msp430
           else: CpuPlatform.none

     the CPU this program will run on.

398 Types
*********

   * OsPlatform none, dos, windows, os2, linux, morphos, skyos, solaris,
     irix, netbsd, freebsd, openbsd, aix, palmos, qnx, amiga, atari,
     netware, macos, macosx, haiku, js, nimVM, standalone
          OsPlatform* {.pure.} = enum
            none, dos, windows, os2, linux, morphos, skyos, solaris, irix, netbsd, freebsd, openbsd,
            aix, palmos, qnx, amiga, atari, netware, macos, macosx, haiku, js, nimVM, standalone

     the OS this program will run on.


File: nim-ref-0.13.0.info,  Node: /system/chcks,  Next: /system/threads,  Prev: /system/platforms,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/threads,  Next: /system/ansi_c,  Prev: /system/chcks,  Up: Top

399 Types
*********

   * ThreadId
          ThreadId*[TArg] = ptr Thread[TArg]

     the current implementation uses a pointer as a thread ID.

400 Procedures
**************

   * running
          proc running*[TArg](t: Thread[TArg]): bool {.inline.}

     returns true if t is running.

   * joinThread
          proc joinThread*[TArg](t: Thread[TArg]) {.inline.}

     waits for the thread t to finish.

   * joinThreads
          proc joinThreads*[TArg](t: varargs[Thread[TArg]])

     waits for every thread in t to finish.

   * createThread param: TArg)
          proc createThread*[TArg](t: var Thread[TArg]; tp: proc (arg: TArg) {.thread.};
                                  param: TArg)

     creates a new thread t and starts its execution.  Entry point is
     the proc tp.  param is passed to tp.  TArg can be 'void' if you
     don't need to pass any data to the thread.

   * pinToCpu
          proc pinToCpu*[Arg](t: var Thread[Arg]; cpu: Natural)

     pins a thread to a CPU. In other words sets a thread's affinity.
     If you don't know what this means, you shouldn't use this proc.

   * createThread
          proc createThread*(t: var Thread[void]; tp: proc () {.thread.})

   * threadId
          proc threadId*[TArg](t: var Thread[TArg]): ThreadId[TArg] {.inline.}

     returns the thread ID of t.


File: nim-ref-0.13.0.info,  Node: /system/ansi_c,  Next: /system/alloc,  Prev: /system/threads,  Up: Top


File: nim-ref-0.13.0.info,  Node: /system/alloc,  Next: Command and Function Index,  Prev: /system/ansi_c,  Up: Top

401 Procedures
**************

   * iterToProc compileTime.}
          proc iterToProc*(iter: typed; envType: typedesc; procName: untyped) {.magic: "Plugin",
              compileTime.}


File: nim-ref-0.13.0.info,  Node: Command and Function Index,  Next: Variable Index,  Prev: /system/alloc,  Up: Top

Command and function index
**************************

 [index ]
* Menu:

* converter getSocket*(s: AsyncSocket): Socket: /deprecated/pure/asyncio.
                                                             (line  235)
* iterator allValues*[A, B](t: Table[A, B]; key: A): B: /pure/collections/tables.
                                                             (line  556)
* iterator children*(n: NimNode): NimNode {.inline.}: /core/macros.
                                                             (line  681)
* iterator countdown*[T](a, b: T; step = 1): T {.inline.}: /system.
                                                             (line 2835)
* iterator countup*[S, T](a: S; b: T; step = 1): T {.inline.}: /system.
                                                             (line 2843)
* iterator decodeData*(allowedMethods: set[RequestMethod] = {methodNone, methodPost,: /pure/cgi.
                                                             (line  279)
* iterator decodeData*(data: string): tuple[key, value: TaintedString]: /pure/cgi.
                                                             (line  273)
* iterator elements*(x: Any): int:       /core/typeinfo.     (line  296)
* iterator envPairs*(): tuple[key, value: TaintedString] {.tags: [ReadEnvEffect].}: /pure/os.
                                                             (line  591)
* iterator fastRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.: /impure/db_postgres.
                                                             (line  168)
* iterator fastRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {. <1>: /impure/db_mysql.
                                                             (line  113)
* iterator fastRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {. <2>: /impure/db_sqlite.
                                                             (line  115)
* iterator fastRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.: /impure/db_postgres.
                                                             (line  177)
* iterator fastRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.: /impure/db_odbc.
                                                             (line  119)
* iterator fieldPairs*[S: tuple |:       /system.            (line 3026)
* iterator fieldPairs*[T: tuple |:       /system.            (line 2991)
* iterator fields*(x: Any): tuple[name: string, any: Any]: /core/typeinfo.
                                                             (line  290)
* iterator fields*[S: tuple |:           /system.            (line 2980)
* iterator fields*[T: tuple |:           /system.            (line 2972)
* iterator filter*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): T: /pure/collections/sequtils.
                                                             (line  421)
* iterator findAll*(s: string; pattern: Peg; start = 0): string: /pure/pegs.
                                                             (line  415)
* iterator findAll*(s: string; pattern: Regex; start = 0): string: /impure/re.
                                                             (line  198)
* iterator findIter*(str: string; pattern: Regex; start = 0; endpos = int.high): RegexMatch: /impure/nre.
                                                             (line  162)
* iterator getopt*(): GetoptResult:      /pure/parseopt2.    (line   59)
* iterator getopt*(): tuple[kind: CmdLineKind, key, val: TaintedString]: /pure/parseopt.
                                                             (line   47)
* iterator instantRows*(db: DbConn; columns: var DbColumns; query: SqlQuery;: /impure/db_mysql.
                                                             (line  133)
* iterator instantRows*(db: DbConn; columns: var DbColumns; query: SqlQuery; <1>: /impure/db_sqlite.
                                                             (line  136)
* iterator instantRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.: /impure/db_postgres.
                                                             (line  183)
* iterator instantRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {. <1>: /impure/db_mysql.
                                                             (line  125)
* iterator instantRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {. <2>: /impure/db_sqlite.
                                                             (line  128)
* iterator instantRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): InstantRow {.: /impure/db_postgres.
                                                             (line  191)
* iterator instantRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): InstantRow {.: /impure/db_odbc.
                                                             (line  133)
* iterator interpolatedFragments*(s: string): tuple[kind: InterpolatedKind,: /pure/parseutils.
                                                             (line  173)
* iterator items*(a: cstring): char {.inline.}: /system.     (line 2895)
* iterator items*(a: string): char {.inline.}: /system.      (line 3077)
* iterator items*(E: typedesc[enum]): E: /system.            (line 2906)
* iterator items*(n: NimNode): NimNode {.inline.}: /core/macros.
                                                             (line  676)
* iterator items*(n: XmlNode): XmlNode {.inline.}: /pure/xmltree.
                                                             (line  240)
* iterator items*(node: JsonNode): JsonNode: /pure/json.     (line  338)
* iterator items*(p: Poly): float:       /pure/poly.         (line  166)
* iterator items*(pattern: CaptureBounds; default = none(Slice[int])): Option[Slice[int]]: /impure/nre.
                                                             (line  156)
* iterator items*(pattern: Captures; default: string = nil): string: /impure/nre.
                                                             (line  159)
* iterator items*(r: Rope): char:        /pure/ropes.        (line  114)
* iterator items*(s: IntSet): int {.inline.}: /pure/collections/intsets.
                                                             (line   69)
* iterator items*(s: SharedString): char: /pure/collections/sharedstrings.
                                                             (line   66)
* iterator items*[A](s: HashSet[A]): A:  /pure/collections/sets.
                                                             (line  509)
* iterator items*[A](s: OrderedSet[A]): A: /pure/collections/sets.
                                                             (line  529)
* iterator items*[A](x: var SharedList[A]): A: /pure/collections/sharedlist.
                                                             (line   33)
* iterator items*[IX, T](a: array[IX, T]): T {.inline.}: /system.
                                                             (line 2877)
* iterator items*[T](a: openArray[T]): T {.inline.}: /system.
                                                             (line 2866)
* iterator items*[T](a: seq[T]): T {.inline.}: /system.      (line 3066)
* iterator items*[T](a: set[T]): T {.inline.}: /system.      (line 2888)
* iterator items*[T](c: CritBitTree[T]): string: /pure/collections/critbits.
                                                             (line  114)
* iterator items*[T](L: DoublyLinkedList[T]): T: /pure/collections/lists.
                                                             (line  198)
* iterator items*[T](L: DoublyLinkedRing[T]): T: /pure/collections/lists.
                                                             (line  213)
* iterator items*[T](L: SinglyLinkedList[T]): T: /pure/collections/lists.
                                                             (line  203)
* iterator items*[T](L: SinglyLinkedRing[T]): T: /pure/collections/lists.
                                                             (line  208)
* iterator items*[T](q: Queue[T]): T:    /pure/collections/queues.
                                                             (line   51)
* iterator items*[T](s: Slice[T]): T:    /system.            (line 2911)
* iterator itemsWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): string: /pure/collections/critbits.
                                                             (line  130)
* iterator keys*(t: StringTableRef): string: /pure/strtabs.  (line  109)
* iterator keys*[A, B](t: OrderedTableRef[A, B]): A: /pure/collections/tables.
                                                             (line  656)
* iterator keys*[A, B](t: OrderedTable[A, B]): A: /pure/collections/tables.
                                                             (line  628)
* iterator keys*[A, B](t: TableRef[A, B]): A: /pure/collections/tables.
                                                             (line  600)
* iterator keys*[A, B](t: Table[A, B]): A: /pure/collections/tables.
                                                             (line  573)
* iterator keys*[A](t: CountTableRef[A]): A: /pure/collections/tables.
                                                             (line  710)
* iterator keys*[A](t: CountTable[A]): A: /pure/collections/tables.
                                                             (line  683)
* iterator keys*[T](c: CritBitTree[T]): string: /pure/collections/critbits.
                                                             (line   97)
* iterator keysWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): string: /pure/collections/critbits.
                                                             (line  137)
* iterator leaves*(r: Rope): string:     /pure/ropes.        (line  109)
* iterator lines*(f: File): TaintedString {.tags: [ReadIOEffect].}: /system.
                                                             (line 3052)
* iterator lines*(filename: string): TaintedString {.tags: [ReadIOEffect].}: /system.
                                                             (line 3037)
* iterator lines*(mfile: MemFile; buf: var TaintedString; delim = '\x0A'; eat = '\x0D'): TaintedString {.: /pure/memfiles.
                                                             (line  121)
* iterator lines*(mfile: MemFile; delim = '\x0A'; eat = '\x0D'): TaintedString {.inline.}: /pure/memfiles.
                                                             (line  133)
* iterator listBreakpoints*(): ptr Breakpoint: /system/debugger.
                                                             (line   71)
* iterator memSlices*(mfile: MemFile; delim = '\x0A'; eat = '\x0D'): MemSlice {.inline.}: /pure/memfiles.
                                                             (line   89)
* iterator mitems*(a: var cstring): var char {.inline.}: /system.
                                                             (line 2900)
* iterator mitems*(a: var string): var char {.inline.}: /system.
                                                             (line 3082)
* iterator mitems*(n: var XmlNode): var XmlNode {.inline.}: /pure/xmltree.
                                                             (line  245)
* iterator mitems*(node: var JsonNode): var JsonNode: /pure/json.
                                                             (line  343)
* iterator mitems*[IX, T](a: var array[IX, T]): var T {.inline.}: /system.
                                                             (line 2882)
* iterator mitems*[T](a: var openArray[T]): var T {.inline.}: /system.
                                                             (line 2871)
* iterator mitems*[T](a: var seq[T]): var T {.inline.}: /system.
                                                             (line 3071)
* iterator mitems*[T](L: var DoublyLinkedList[T]): var T: /pure/collections/lists.
                                                             (line  218)
* iterator mitems*[T](L: var DoublyLinkedRing[T]): var T: /pure/collections/lists.
                                                             (line  233)
* iterator mitems*[T](L: var SinglyLinkedList[T]): var T: /pure/collections/lists.
                                                             (line  223)
* iterator mitems*[T](L: var SinglyLinkedRing[T]): var T: /pure/collections/lists.
                                                             (line  228)
* iterator mitems*[T](q: var Queue[T]): var T: /pure/collections/queues.
                                                             (line   56)
* iterator mpairs*(a: var cstring): tuple[key: int, val: var char] {.inline.}: /system.
                                                             (line 2966)
* iterator mpairs*(a: var string): tuple[key: int, val: var char] {.inline.}: /system.
                                                             (line 2955)
* iterator mpairs*(node: var JsonNode): var tuple[key: string, val: JsonNode]: /pure/json.
                                                             (line  354)
* iterator mpairs*[A, B](t: OrderedTableRef[A, B]): (A, var B): /pure/collections/tables.
                                                             (line  650)
* iterator mpairs*[A, B](t: TableRef[A, B]): (A, var B): /pure/collections/tables.
                                                             (line  594)
* iterator mpairs*[A, B](t: var OrderedTable[A, B]): (A, var B): /pure/collections/tables.
                                                             (line  622)
* iterator mpairs*[A, B](t: var Table[A, B]): (A, var B): /pure/collections/tables.
                                                             (line  567)
* iterator mpairs*[A](t: CountTableRef[A]): (A, var int): /pure/collections/tables.
                                                             (line  704)
* iterator mpairs*[A](t: var CountTable[A]): (A, var int): /pure/collections/tables.
                                                             (line  677)
* iterator mpairs*[IX, T](a: var array[IX, T]): tuple[key: IX, val: var T] {.inline.}: /system.
                                                             (line 2933)
* iterator mpairs*[T](a: var openArray[T]): tuple[key: int, val: var T] {.inline.}: /system.
                                                             (line 2922)
* iterator mpairs*[T](a: var seq[T]): tuple[key: int, val: var T] {.inline.}: /system.
                                                             (line 2944)
* iterator mpairs*[T](c: var CritBitTree[T]): tuple[key: string, val: var T]: /pure/collections/critbits.
                                                             (line  124)
* iterator mpairsWithPrefix*[T](c: var CritBitTree[T]; prefix: string;: /pure/collections/critbits.
                                                             (line  161)
* iterator mvalues*[A, B](t: OrderedTableRef[A, B]): var B: /pure/collections/tables.
                                                             (line  666)
* iterator mvalues*[A, B](t: TableRef[A, B]): var B: /pure/collections/tables.
                                                             (line  610)
* iterator mvalues*[A, B](t: var OrderedTable[A, B]): var B: /pure/collections/tables.
                                                             (line  638)
* iterator mvalues*[A, B](t: var Table[A, B]): var B: /pure/collections/tables.
                                                             (line  583)
* iterator mvalues*[A](t: CountTableRef[A]): var int: /pure/collections/tables.
                                                             (line  720)
* iterator mvalues*[A](t: CountTable[A]): var int: /pure/collections/tables.
                                                             (line  693)
* iterator mvalues*[T](c: var CritBitTree[T]): var T: /pure/collections/critbits.
                                                             (line  108)
* iterator mvaluesWithPrefix*[T](c: var CritBitTree[T]; prefix: string;: /pure/collections/critbits.
                                                             (line  148)
* iterator nodes*[T](L: DoublyLinkedList[T]): DoublyLinkedNode[T]: /pure/collections/lists.
                                                             (line  244)
* iterator nodes*[T](L: DoublyLinkedRing[T]): DoublyLinkedNode[T]: /pure/collections/lists.
                                                             (line  256)
* iterator nodes*[T](L: SinglyLinkedList[T]): SinglyLinkedNode[T]: /pure/collections/lists.
                                                             (line  238)
* iterator nodes*[T](L: SinglyLinkedRing[T]): SinglyLinkedNode[T]: /pure/collections/lists.
                                                             (line  250)
* iterator pairs*(a: cstring): tuple[key: int, val: char] {.inline.}: /system.
                                                             (line 2961)
* iterator pairs*(a: string): tuple[key: int, val: char] {.inline.}: /system.
                                                             (line 2950)
* iterator pairs*(node: JsonNode): tuple[key: string, val: JsonNode]: /pure/json.
                                                             (line  349)
* iterator pairs*(t: StringTableRef): tuple[key, value: string]: /pure/strtabs.
                                                             (line  104)
* iterator pairs*[A, B](t: OrderedTableRef[A, B]): (A, B): /pure/collections/tables.
                                                             (line  644)
* iterator pairs*[A, B](t: OrderedTable[A, B]): (A, B): /pure/collections/tables.
                                                             (line  616)
* iterator pairs*[A, B](t: TableRef[A, B]): (A, B): /pure/collections/tables.
                                                             (line  589)
* iterator pairs*[A, B](t: Table[A, B]): (A, B): /pure/collections/tables.
                                                             (line  562)
* iterator pairs*[A](t: CountTableRef[A]): (A, int): /pure/collections/tables.
                                                             (line  699)
* iterator pairs*[A](t: CountTable[A]): (A, int): /pure/collections/tables.
                                                             (line  672)
* iterator pairs*[IX, T](a: array[IX, T]): tuple[key: IX, val: T] {.inline.}: /system.
                                                             (line 2928)
* iterator pairs*[T](a: openArray[T]): tuple[key: int, val: T] {.inline.}: /system.
                                                             (line 2917)
* iterator pairs*[T](a: seq[T]): tuple[key: int, val: T] {.inline.}: /system.
                                                             (line 2939)
* iterator pairs*[T](c: CritBitTree[T]): tuple[key: string, val: T]: /pure/collections/critbits.
                                                             (line  119)
* iterator pairs*[T](tbl: PGenTable[T]): tuple[key: string, value: T]: /pure/gentabs.
                                                             (line   44)
* iterator pairsWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): tuple[: /pure/collections/critbits.
                                                             (line  155)
* iterator parentDirs*(path: string; fromRoot = false; inclusive = true): string: /pure/ospaths.
                                                             (line  237)
* iterator rows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.: /impure/db_postgres.
                                                             (line  199)
* iterator rows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {. <1>: /impure/db_mysql.
                                                             (line  141)
* iterator rows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {. <2>: /impure/db_sqlite.
                                                             (line  145)
* iterator rows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.: /impure/db_postgres.
                                                             (line  205)
* iterator rows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.: /impure/db_odbc.
                                                             (line  141)
* iterator runes*(s: string): Rune:      /pure/unicode.      (line  158)
* iterator split*(s: string; sep: char): string: /pure/strutils.
                                                             (line  867)
* iterator split*(s: string; sep: Peg): string: /pure/pegs.  (line  420)
* iterator split*(s: string; sep: Regex): string: /impure/re.
                                                             (line  206)
* iterator split*(s: string; sep: string): string: /pure/strutils.
                                                             (line  891)
* iterator split*(s: string; seps: set[char] = Whitespace): string: /pure/strutils.
                                                             (line  831)
* iterator splitLines*(s: string): string: /pure/strutils.   (line  898)
* iterator tokenize*(s: string; seps: set[char] = Whitespace): tuple[token: string,: /pure/strutils.
                                                             (line  920)
* iterator values*(t: StringTableRef): string: /pure/strtabs.
                                                             (line  114)
* iterator values*[A, B](t: OrderedTableRef[A, B]): B: /pure/collections/tables.
                                                             (line  661)
* iterator values*[A, B](t: OrderedTable[A, B]): B: /pure/collections/tables.
                                                             (line  633)
* iterator values*[A, B](t: TableRef[A, B]): B: /pure/collections/tables.
                                                             (line  605)
* iterator values*[A, B](t: Table[A, B]): B: /pure/collections/tables.
                                                             (line  578)
* iterator values*[A](t: CountTableRef[A]): int: /pure/collections/tables.
                                                             (line  715)
* iterator values*[A](t: CountTable[A]): int: /pure/collections/tables.
                                                             (line  688)
* iterator values*[T](c: CritBitTree[T]): T: /pure/collections/critbits.
                                                             (line  102)
* iterator valuesWithPrefix*[T](c: CritBitTree[T]; prefix: string; longestMatch = false): T: /pure/collections/critbits.
                                                             (line  142)
* iterator walkDir*(dir: string; relative = false): tuple[kind: PathComponent,: /pure/os.
                                                             (line  607)
* iterator walkDir*(dir: string; relative = false): tuple[kind: PathComponent, <1>: /pure/oswalkdir.
                                                             (line   21)
* iterator walkDirRec*(dir: string; filter = {pcFile, pcDir}): string: /pure/oswalkdir.
                                                             (line   25)
* iterator walkDirRec*(dir: string; filter = {pcFile, pcDir}): string {.: /pure/os.
                                                             (line  631)
* iterator walkFiles*(pattern: string): string {.tags: [ReadDirEffect].}: /pure/os.
                                                             (line  598)
* iterator `..`*[S, T](a: S; b: T): T {.inline.}: /system.   (line 2851)
* iterator `||`*[S, T](a: S; b: T; annotation = ""): T {.inline, magic: "OmpParFor", sideEffect.}: /system.
                                                             (line 2856)
* macro a*(e: expr): expr {.immediate.}: /pure/htmlgen.      (line   21)
* macro acronym*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line   26)
* macro address*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line   31)
* macro area*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line   36)
* macro async*(prc: stmt): stmt {.immediate.}: /pure/asyncdispatch.
                                                             (line  289)
* macro b*(e: expr): expr {.immediate.}: /pure/htmlgen.      (line   41)
* macro base*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line   46)
* macro big*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line   51)
* macro blockquote*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line   56)
* macro body*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line   61)
* macro br*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line   66)
* macro button*(e: expr): expr {.immediate.}: /pure/htmlgen. (line   71)
* macro caption*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line   76)
* macro check*(conditions: stmt): stmt {.immediate.}: /pure/unittest.
                                                             (line   95)
* macro cite*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line   81)
* macro code*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line   86)
* macro col*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line   91)
* macro colgroup*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line   96)
* macro dd*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  101)
* macro del*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  106)
* macro dfn*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  111)
* macro dl*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  121)
* macro dt*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  126)
* macro dumpLisp*(s: stmt): stmt {.immediate.}: /core/macros.
                                                             (line  654)
* macro dumpLispImm*(s: stmt): stmt {.immediate, deprecated.}: /core/macros.
                                                             (line  668)
* macro dumpTree*(s: stmt): stmt {.immediate.}: /core/macros.
                                                             (line  643)
* macro dumpTreeImm*(s: stmt): stmt {.immediate, deprecated.}: /core/macros.
                                                             (line  663)
* macro em*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  131)
* macro expect*(exceptions: varargs[expr]; body: stmt): stmt {.immediate.}: /pure/unittest.
                                                             (line  111)
* macro fieldset*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line  136)
* macro form*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line  141)
* macro h1*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  146)
* macro h2*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  151)
* macro h3*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  156)
* macro h4*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  161)
* macro h5*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  166)
* macro h6*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  171)
* macro head*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line  176)
* macro hr*(): expr {.immediate.}:       /pure/htmlgen.      (line  186)
* macro html*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line  181)
* macro i*(e: expr): expr {.immediate.}: /pure/htmlgen.      (line  191)
* macro img*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  196)
* macro input*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  201)
* macro ins*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  206)
* macro kbd*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  211)
* macro label*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  216)
* macro legend*(e: expr): expr {.immediate.}: /pure/htmlgen. (line  221)
* macro li*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  226)
* macro link*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line  231)
* macro map*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  236)
* macro meta*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line  241)
* macro noscript*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line  246)
* macro ol*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  256)
* macro optgroup*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line  261)
* macro option*(e: expr): expr {.immediate.}: /pure/htmlgen. (line  266)
* macro p*(e: expr): expr {.immediate.}: /pure/htmlgen.      (line  271)
* macro param*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  276)
* macro pre*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  281)
* macro q*(e: expr): expr {.immediate.}: /pure/htmlgen.      (line  286)
* macro samp*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line  291)
* macro script*(e: expr): expr {.immediate.}: /pure/htmlgen. (line  296)
* macro select*(e: expr): expr {.immediate.}: /pure/htmlgen. (line  301)
* macro small*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  306)
* macro span*(e: expr): expr {.immediate.}: /pure/htmlgen.   (line  311)
* macro strong*(e: expr): expr {.immediate.}: /pure/htmlgen. (line  316)
* macro style*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  321)
* macro styledWriteLine*(f: File; m: varargs[expr]): stmt: /pure/terminal.
                                                             (line  181)
* macro sub*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  326)
* macro sup*(e: expr): expr {.immediate.}: /pure/htmlgen.    (line  331)
* macro table*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  336)
* macro tbody*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  341)
* macro td*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  346)
* macro textarea*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line  351)
* macro tfoot*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  356)
* macro th*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  361)
* macro thead*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  366)
* macro title*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  371)
* macro tr*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  376)
* macro tt*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  381)
* macro ul*(e: expr): expr {.immediate.}: /pure/htmlgen.     (line  386)
* macro `%*`*(x: expr): expr:            /pure/json.         (line  329)
* macro `->`*(p, b: expr): expr {.immediate.}: /pure/future. (line   21)
* macro `<>`*(x: expr): expr {.immediate.}: /pure/xmltree.   (line  228)
* macro `=>`*(p, b: expr): expr {.immediate.}: /pure/future. (line   12)
* macro `div`*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  116)
* macro `object`*(e: expr): expr {.immediate.}: /pure/htmlgen.
                                                             (line  251)
* macro `var`*(e: expr): expr {.immediate.}: /pure/htmlgen.  (line  391)
* macro `[]`*(lc: ListComprehension; comp, typ: expr): expr: /pure/future.
                                                             (line   33)
* method log*(logger: ConsoleLogger; level: Level; args: varargs[string, `$`]): /pure/logging.
                                                             (line  147)
* method log*(logger: FileLogger; level: Level; args: varargs[string, `$`]): /pure/logging.
                                                             (line  152)
* method log*(logger: Logger; level: Level; args: varargs[string, `$`]) {.: /pure/logging.
                                                             (line  139)
* method log*(logger: RollingFileLogger; level: Level; args: varargs[string, `$`]): /pure/logging.
                                                             (line  157)
* proc abbrev*(s: string; possibilities: openArray[string]): int: /pure/strutils.
                                                             (line  458)
* proc abs*(x: float): float {.magic: "AbsF64", noSideEffect.}: /system.
                                                             (line 1826)
* proc abs*(x: int): int {.magic: "AbsI", noSideEffect.}: /system.
                                                             (line 2068)
* proc abs*(x: int16): int16 {.magic: "AbsI", noSideEffect.}: /system.
                                                             (line 2074)
* proc abs*(x: int32): int32 {.magic: "AbsI", noSideEffect.}: /system.
                                                             (line 2077)
* proc abs*(x: int64): int64 {.magic: "AbsI", noSideEffect.}: /system.
                                                             (line 2080)
* proc abs*(x: int8): int8 {.magic: "AbsI", noSideEffect.}: /system.
                                                             (line 2071)
* proc abs*(z: Complex): float:          /pure/complex.      (line  134)
* proc abs*[T](x: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line  193)
* proc accept*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): SocketHandle {.importc,: /posix/posix.
                                                             (line 1573)
* proc accept*(s: SocketHandle; a: ptr SockAddr; addrlen: ptr SockLen): SocketHandle {.: /windows/winlean.
                                                             (line  376)
* proc accept*(server: AsyncSocket): AsyncSocket {.deprecated.}: /deprecated/pure/asyncio.
                                                             (line   98)
* proc accept*(server: AsyncSocket; client: var AsyncSocket): /deprecated/pure/asyncio.
                                                             (line   85)
* proc accept*(server: PStream; client: PStream): cint {.importc: "uv_accept",: /wrappers/libuv.
                                                             (line   62)
* proc accept*(server: Socket): Socket {.deprecated, tags: [ReadIOEffect].}: /deprecated/pure/sockets.
                                                             (line  210)
* proc accept*(server: Socket; client: var Socket) {.tags: [ReadIOEffect].}: /deprecated/pure/sockets.
                                                             (line  193)
* proc accept*(server: Socket; client: var Socket; flags = {SocketFlag.SafeDisconn}) {.: /pure/net.
                                                             (line  199)
* proc accept*(socket: AsyncFD; flags = {SocketFlag.SafeDisconn}): Future[AsyncFD]: /pure/asyncdispatch.
                                                             (line  249)
* proc accept*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[: /pure/asyncnet.
                                                             (line   80)
* proc acceptAddr*(server: AsyncSocket): tuple[sock: AsyncSocket, address: string] {.: /deprecated/pure/asyncio.
                                                             (line   90)
* proc acceptAddr*(server: AsyncSocket; client: var AsyncSocket; address: var string): /deprecated/pure/asyncio.
                                                             (line   77)
* proc acceptAddr*(server: Socket): tuple[client: Socket, address: string] {.deprecated,: /deprecated/pure/sockets.
                                                             (line  202)
* proc acceptAddr*(server: Socket; client: var Socket; address: var string) {.: /deprecated/pure/sockets.
                                                             (line  147)
* proc acceptAddr*(server: Socket; client: var Socket; address: var string;: /pure/net.
                                                             (line  177)
* proc acceptAddr*(socket: AsyncFD; flags = {SocketFlag.SafeDisconn}): Future[: /pure/asyncdispatch.
                                                             (line  201)
* proc acceptAddr*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[: /pure/asyncnet.
                                                             (line   71)
* proc acceptAddrSSL*(server: Socket; client: var Socket; address: var string): SSLAcceptResult {.: /deprecated/pure/sockets.
                                                             (line  173)
* proc access*(a1: cstring; a2: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  777)
* proc acquire*(lock: var Lock):         /core/locks.        (line   29)
* proc add*(a: var Rope; b: Rope) {.rtl, extern: "nro$1Rope".}: /pure/ropes.
                                                             (line   58)
* proc add*(a: var Rope; b: string) {.rtl, extern: "nro$1Str".}: /pure/ropes.
                                                             (line   63)
* proc add*(c: ClassList; class: cstring): /js/dom.          (line  259)
* proc add*(father, child: JsonNode):    /pure/json.         (line  243)
* proc add*(father, child: NimNode): NimNode {.magic: "NAdd", discardable, noSideEffect,: /core/macros.
                                                             (line   91)
* proc add*(father, n: SqlNode):         /pure/parsesql.     (line   52)
* proc add*(father, son: PRstNode):      /packages/docutils/rstast.
                                                             (line   36)
* proc add*(father, son: XmlNode) {.inline.}: /pure/xmltree. (line   80)
* proc add*(father: NimNode; children: varargs[NimNode]): NimNode {.: /core/macros.
                                                             (line   98)
* proc add*(monitor: FSMonitor; target: string; filters = {MonitorAll}): cint {.discardable.}: /pure/fsmonitor.
                                                             (line   44)
* proc add*(obj: JsonNode; key: string; val: JsonNode): /pure/json.
                                                             (line  248)
* proc add*(p: var MultipartData; name, content: string; filename: string = nil;: /pure/httpclient.
                                                             (line   81)
* proc add*(p: var MultipartData; xs: MultipartEntries): MultipartData {.discardable.}: /pure/httpclient.
                                                             (line   88)
* proc add*(result: var string; n: XmlNode; indent = 0; indWidth = 2): /pure/xmltree.
                                                             (line  168)
* proc add*(s: var SharedString; t: cstring; len: Natural): /pure/collections/sharedstrings.
                                                             (line   39)
* proc add*(s: var SharedString; t: SharedString): /pure/collections/sharedstrings.
                                                             (line   48)
* proc add*(s: var SharedString; t: string): /pure/collections/sharedstrings.
                                                             (line   42)
* proc add*(url: var Url; a: Url) {.deprecated.}: /pure/uri. (line   30)
* proc add*(x: var cstring; y: cstring) {.magic: "AppendStrStr".}: /system.
                                                             (line 2032)
* proc add*(x: var string; y: char) {.magic: "AppendStrCh", noSideEffect.}: /system.
                                                             (line 1308)
* proc add*(x: var string; y: cstring) {.asmNoStackFrame.}: /system.
                                                             (line 2029)
* proc add*(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect.}: /system.
                                                             (line 1317)
* proc add*[A, B](t: OrderedTableRef[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line  337)
* proc add*[A, B](t: TableRef[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line  169)
* proc add*[A, B](t: var OrderedTable[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line  244)
* proc add*[A, B](t: var SharedTable[A, B]; key: A; val: B): /pure/collections/sharedtables.
                                                             (line   44)
* proc add*[A, B](t: var Table[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line   87)
* proc add*[A](x: var SharedList[A]; y: A): /pure/collections/sharedlist.
                                                             (line   18)
* proc add*[T](q: var Queue[T]; item: T): /pure/collections/queues.
                                                             (line   28)
* proc add*[T](x: var seq[T]; y: openArray[T]) {.noSideEffect.}: /system.
                                                             (line 1369)
* proc add*[T](x: var seq[T]; y: T) {.magic: "AppendSeqElem", noSideEffect.}: /system.
                                                             (line 1366)
* proc addBreakpoint*(filename: cstring; lo, hi: int): bool: /system/debugger.
                                                             (line   44)
* proc addch*(a2: cunsignedlong): cint {.extdecl, importc: "addch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  105)
* proc addchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "addchnstr",: /wrappers/pdcurses.
                                                             (line  108)
* proc addchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "addchstr",: /wrappers/pdcurses.
                                                             (line  112)
* proc addCompletion*(a2: ptr Completions; a3: cstring) {.: /wrappers/linenoise/linenoise.
                                                             (line   16)
* proc addEscaped*(result: var string; s: string): /pure/xmltree.
                                                             (line  149)
* proc addEventListener*(et: EventTarget; ev: cstring; cb: proc (ev: Event);: /js/dom.
                                                             (line   21)
* proc addf*(c: var Rope; frmt: string; args: openArray[Rope]) {.rtl, extern: "nro$1".}: /pure/ropes.
                                                             (line   90)
* proc addf*(s: var string; formatstr: string; a: varargs[string, `$`]) {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  717)
* proc addf*(s: var string; formatstr: Subex; a: varargs[string, `$`]) {.noSideEffect, rtl,: /pure/subexes.
                                                             (line   25)
* proc addFile*(s: PccState; filename: cstring): cint {.cdecl, importc: "tcc_add_file".}: /wrappers/tinyc.
                                                             (line   71)
* proc addFileExt*(filename, ext: string): string {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line  147)
* proc addFiles*(p: var MultipartData; xs: openarray[tuple[name, file: string]]): MultipartData {.: /pure/httpclient.
                                                             (line  102)
* proc addHandler*(handler: Logger):     /pure/logging.      (line   83)
* proc addHandler*(handler: var EventHandler; fn: proc (e: EventArgs) {.closure.}): /pure/events.
                                                             (line   22)
* proc addIdentIfAbsent*(dest: NimNode; ident: string) {.compiletime.}: /core/macros.
                                                             (line  614)
* proc addIfNotNil*(father, son: PRstNode): /packages/docutils/rstast.
                                                             (line   39)
* proc addIncludePath*(s: PccState; pathname: cstring) {.cdecl,: /wrappers/tinyc.
                                                             (line   47)
* proc addLibrary*(s: PCCState; libraryname: cstring): cint {.cdecl,: /wrappers/tinyc.
                                                             (line   95)
* proc addLibraryPath*(s: PccState; pathname: cstring): cint {.cdecl,: /wrappers/tinyc.
                                                             (line   89)
* proc addNodes*(n: PRstNode): string:   /packages/docutils/rst.
                                                             (line   18)
* proc addnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "addnstr",: /wrappers/pdcurses.
                                                             (line  116)
* proc addnwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "addnwstr",: /wrappers/pdcurses.
                                                             (line 1070)
* proc addQuitProc*(QuitProc: proc () {.noconv.}) {.importc: "atexit",: /system.
                                                             (line 1454)
* proc addrawch*(a2: cunsignedlong): cint {.extdecl, importc: "addrawch",: /wrappers/pdcurses.
                                                             (line 1580)
* proc addref*(a2: PLoop) {.importc: "uv_ref", header: "uv.h".}: /wrappers/libuv.
                                                             (line   24)
* proc addSep*(dest: var string; sep = ", "; startLen: Natural = 0) {.noSideEffect, inline.}: /pure/strutils.
                                                             (line  434)
* proc addstr*(a2: cstring): cint {.extdecl, importc: "addstr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  120)
* proc addSymbol*(s: PccState; name: cstring; val: pointer): cint {.cdecl,: /wrappers/tinyc.
                                                             (line  101)
* proc addSysincludePath*(s: PccState; pathname: cstring) {.cdecl,: /wrappers/tinyc.
                                                             (line   53)
* proc addwstr*(a2: cstring): cint {.extdecl, importc: "addwstr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1074)
* proc add_slave*(MySQL: PMySQL; host: cstring; port: cuint; user: cstring; passwd: cstring): cint {.: /wrappers/mysql.
                                                             (line  490)
* proc add_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: "add_wch",: /wrappers/pdcurses.
                                                             (line 1077)
* proc add_wchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1081)
* proc add_wchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "add_wchstr",: /wrappers/pdcurses.
                                                             (line 1085)
* proc advice*(s: var ThreadPoolState): ThreadPoolAdvice: /pure/concurrency/cpuload.
                                                             (line   21)
* proc affected_rows*(MySQL: PMySQL): my_ulonglong {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  343)
* proc aggregate_context*(para1: Pcontext; nBytes: int32): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  349)
* proc aggregate_count*(para1: Pcontext): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  301)
* proc aio_cancel*(a1: cint; a2: ptr Taiocb): cint {.importc, header: "<aio.h>".}: /posix/posix.
                                                             (line  146)
* proc aio_error*(a1: ptr Taiocb): cint {.importc, header: "<aio.h>".}: /posix/posix.
                                                             (line  149)
* proc aio_fsync*(a1: cint; a2: ptr Taiocb): cint {.importc, header: "<aio.h>".}: /posix/posix.
                                                             (line  152)
* proc aio_read*(a1: ptr Taiocb): cint {.importc, header: "<aio.h>".}: /posix/posix.
                                                             (line  155)
* proc aio_return*(a1: ptr Taiocb): int {.importc, header: "<aio.h>".}: /posix/posix.
                                                             (line  158)
* proc aio_suspend*(a1: ptr ptr Taiocb; a2: cint; a3: ptr Timespec): cint {.importc,: /posix/posix.
                                                             (line  161)
* proc aio_write*(a1: ptr Taiocb): cint {.importc, header: "<aio.h>".}: /posix/posix.
                                                             (line  165)
* proc alarm*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  780)
* proc alarm*(title, msg, b1, b2, b3: cstring): cint {.importc: "IupAlarm", dynlib: dllname,: /wrappers/iup.
                                                             (line   61)
* proc alert*(s: cstring) {.importc: "console.log", nodecl.}: /system/jssys.
                                                             (line    6)
* proc alert*(w: Window; msg: cstring):  /js/dom.            (line   25)
* proc align*(s: string; count: Natural; padding = ' '): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  374)
* proc alive*(c: proc ()): bool:         /pure/coro.         (line   25)
* proc all*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): bool: /pure/collections/sequtils.
                                                             (line  219)
* proc allCharsInSet*(s: string; theSet: set[char]): bool: /pure/strutils.
                                                             (line  453)
* proc alloc*(size: Natural): pointer {.noconv, rtl, tags: [], benign.}: /system.
                                                             (line 1530)
* proc alloc0*(size: Natural): pointer {.noconv, rtl, tags: [], benign.}: /system.
                                                             (line 1549)
* proc allocCStringArray*(a: openArray[string]): cstringArray: /system.
                                                             (line 2310)
* proc allocShared*(size: Natural): pointer {.noconv, rtl, benign.}: /system.
                                                             (line 1599)
* proc allocShared0*(size: Natural): pointer {.noconv, rtl, benign.}: /system.
                                                             (line 1616)
* proc angle*(a, b: Point2d): float:     /pure/basic2d.      (line  378)
* proc angle*(v: Vector2d): float:       /pure/basic2d.      (line  205)
* proc angleCCW*(v1, v2: Vector2d): float: /pure/basic2d.    (line  340)
* proc angleCW*(v1, v2: Vector2d): float: /pure/basic2d.     (line  346)
* proc angleTo*(v1, v2: Vector2d): float: /pure/basic2d.     (line  334)
* proc angleTo*(v1, v2: Vector3d): float: /pure/basic3d.     (line  332)
* proc any*(): Peg {.inline.}:           /pure/pegs.         (line  104)
* proc any*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): bool: /pure/collections/sequtils.
                                                             (line  230)
* proc anyRune*(): Peg {.inline.}:       /pure/pegs.         (line  109)
* proc append*(ih, child: PIhandle): PIhandle {.importc: "IupAppend", cdecl,: /wrappers/iup.
                                                             (line  166)
* proc append*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T]): /pure/collections/lists.
                                                             (line  125)
* proc append*[T](L: var DoublyLinkedList[T]; value: T): /pure/collections/lists.
                                                             (line  130)
* proc append*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T]): /pure/collections/lists.
                                                             (line  170)
* proc append*[T](L: var DoublyLinkedRing[T]; value: T): /pure/collections/lists.
                                                             (line  175)
* proc append*[T](L: var SinglyLinkedRing[T]; n: SinglyLinkedNode[T]): /pure/collections/lists.
                                                             (line  150)
* proc append*[T](L: var SinglyLinkedRing[T]; value: T): /pure/collections/lists.
                                                             (line  155)
* proc appendChild*(n, child: Node):     /js/dom.            (line  112)
* proc appendChild*(n: PNode; newChild: PNode): /pure/xmldom.
                                                             (line  172)
* proc appendData*(n: Node; data: cstring): /js/dom.         (line  115)
* proc apply*(m: Matrix2d; x, y: var float; translate = false): /pure/basic2d.
                                                             (line  169)
* proc apply*(m: Matrix3d; x, y, z: var float; translate = false): /pure/basic3d.
                                                             (line  199)
* proc apply*[T](data: var seq[T]; op: proc (x: T): T {.closure.}) {.inline.}: /pure/collections/sequtils.
                                                             (line  152)
* proc apply*[T](data: var seq[T]; op: proc (x: var T) {.closure.}) {.inline.}: /pure/collections/sequtils.
                                                             (line  137)
* proc arbitraryAxis*(norm: Vector3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  338)
* proc arccos*(x: float): float {.importc: "acos", header: "<math.h>".}: /pure/math.
                                                             (line  140)
* proc arccos*(z: Complex): Complex:     /pure/complex.      (line  189)
* proc arccosh*(z: Complex): Complex:    /pure/complex.      (line  249)
* proc arccot*(z: Complex): Complex:     /pure/complex.      (line  209)
* proc arccoth*(z: Complex): Complex:    /pure/complex.      (line  289)
* proc arccsc*(z: Complex): Complex:     /pure/complex.      (line  229)
* proc arccsch*(z: Complex): Complex:    /pure/complex.      (line  279)
* proc arcsec*(z: Complex): Complex:     /pure/complex.      (line  219)
* proc arcsech*(z: Complex): Complex:    /pure/complex.      (line  269)
* proc arcsin*(x: float): float {.importc: "asin", header: "<math.h>".}: /pure/math.
                                                             (line  145)
* proc arcsin*(z: Complex): Complex:     /pure/complex.      (line  179)
* proc arcsinh*(z: Complex): Complex:    /pure/complex.      (line  239)
* proc arctan*(x: float): float {.importc: "atan", header: "<math.h>".}: /pure/math.
                                                             (line  150)
* proc arctan*(z: Complex): Complex:     /pure/complex.      (line  199)
* proc arctan2*(y, x: float): float {.importc: "atan2", header: "<math.h>".}: /pure/math.
                                                             (line  155)
* proc arctanh*(z: Complex): Complex:    /pure/complex.      (line  259)
* proc area*(a, b, c: Point2d): float:   /pure/basic2d.      (line  493)
* proc area*(a, b, c: Point3d): float {.inline.}: /pure/basic3d.
                                                             (line  465)
* proc ares_destroy*(a2: PLoop; channel: PAresChannel) {.importc: "uv_ares_destroy",: /wrappers/libuv.
                                                             (line  249)
* proc ares_init_options*(a2: PLoop; channel: PAresChannel; options: PAresOptions;: /wrappers/libuv.
                                                             (line  243)
* proc arity*(t: typedesc): int {.magic: "TypeTrait".}: /pure/typetraits.
                                                             (line   26)
* proc asctime*(a1: var Tm): cstring {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1203)
* proc asctime_r*(a1: var Tm; a2: cstring): cstring {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1206)
* proc assign*(dest: var IntSet; src: IntSet): /pure/collections/intsets.
                                                             (line   48)
* proc assign*(x, y: Any):               /core/typeinfo.     (line  276)
* proc assign_jit_stack*(extra: ptr ExtraData; callback: JitCallback; data: pointer): /wrappers/pcre.
                                                             (line  205)
* proc assume_default_colors*(a2: cint; a3: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1530)
* proc astToStr*[T](x: T): string {.magic: "AstToStr", noSideEffect.}: /system.
                                                             (line 2564)
* proc asyncCheck*[T](future: Future[T]): /pure/asyncdispatch.
                                                             (line  121)
* proc asyncFTPClient*(address: string; port = Port(21); user, pass = ""; handleEvent: proc (: /deprecated/pure/ftpclient.
                                                             (line  123)
* proc asyncHTTPServer*(handleRequest: proc (server: PAsyncHTTPServer; client: Socket;: /pure/httpserver.
                                                             (line   38)
* proc asyncSocket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM;: /deprecated/pure/asyncio.
                                                             (line   19)
* proc async_init*(a2: PLoop; async: PAsync; async_cb: AsyncProc): cint {.: /wrappers/libuv.
                                                             (line  214)
* proc async_send*(async: PAsync): cint {.importc: "uv_async_send", header: "uv.h".}: /wrappers/libuv.
                                                             (line  218)
* proc atEnd*(s, unused: Stream): bool {.deprecated.}: /pure/streams.
                                                             (line   73)
* proc atEnd*(s: Stream): bool:          /pure/streams.      (line   67)
* proc atomicAddFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  135)
* proc atomicAlwaysLockFree*(size: int; p: pointer): bool {.: /system/atomics.
                                                             (line  213)
* proc atomicAndFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  147)
* proc atomicClear*(p: pointer; mem: AtomMemModel) {.importc: "__atomic_clear", nodecl.}: /system/atomics.
                                                             (line  192)
* proc atomicCompareExchange*[T: AtomType](p, expected, desired: ptr T; weak: bool;: /system/atomics.
                                                             (line  122)
* proc atomicCompareExchangeN*[T: AtomType](p, expected: ptr T; desired: T; weak: bool;: /system/atomics.
                                                             (line   99)
* proc atomicDec*(memLoc: var int; x: int = 1): int: /system/atomics.
                                                             (line  240)
* proc atomicDec*(memLoc: var int; x: int = 1): int {.inline, discardable, benign.}: /system.
                                                             (line 2326)
* proc atomicExchange*[T: AtomType](p, val, ret: ptr T; mem: AtomMemModel) {.: /system/atomics.
                                                             (line   92)
* proc atomicExchangeN*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line   84)
* proc atomicFetchAdd*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  159)
* proc atomicFetchAnd*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  171)
* proc atomicFetchNand*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  179)
* proc atomicFetchOr*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  167)
* proc atomicFetchSub*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  163)
* proc atomicFetchXor*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  175)
* proc atomicInc*(memLoc: var int; x: int = 1): int: /system/atomics.
                                                             (line  237)
* proc atomicInc*(memLoc: var int; x: int = 1): int {.inline, discardable, benign.}: /system.
                                                             (line 2321)
* proc atomicIsLockFree*(size: int; p: pointer): bool {.: /system/atomics.
                                                             (line  225)
* proc atomicLoad*[T: AtomType](p, ret: ptr T; mem: AtomMemModel) {.: /system/atomics.
                                                             (line   63)
* proc atomicLoadN*[T: AtomType](p: ptr T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line   55)
* proc atomicNandFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  155)
* proc atomicOrFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  143)
* proc atomicSignalFence*(mem: AtomMemModel) {.importc: "__atomic_signal_fence", nodecl.}: /system/atomics.
                                                             (line  206)
* proc atomicStore*[T: AtomType](p, val: ptr T; mem: AtomMemModel) {.: /system/atomics.
                                                             (line   77)
* proc atomicStoreN*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel) {.: /system/atomics.
                                                             (line   70)
* proc atomicSubFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  139)
* proc atomicTestAndSet*(p: pointer; mem: AtomMemModel): bool {.: /system/atomics.
                                                             (line  183)
* proc atomicThreadFence*(mem: AtomMemModel) {.importc: "__atomic_thread_fence", nodecl.}: /system/atomics.
                                                             (line  199)
* proc atomicXorFetch*[T: AtomType](p: ptr T; val: T; mem: AtomMemModel): T {.: /system/atomics.
                                                             (line  151)
* proc attr*(n: XmlNode; name: string): string: /pure/xmltree.
                                                             (line  192)
* proc attroff*(a2: cunsignedlong): cint {.extdecl, importc: "attroff",: /wrappers/pdcurses.
                                                             (line  123)
* proc attron*(a2: cunsignedlong): cint {.extdecl, importc: "attron", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  127)
* proc attrs*(n: XmlNode): XmlAttributes {.inline.}: /pure/xmltree.
                                                             (line  121)
* proc attrset*(a2: cunsignedlong): cint {.extdecl, importc: "attrset",: /wrappers/pdcurses.
                                                             (line  130)
* proc attrsLen*(n: XmlNode): int {.inline.}: /pure/xmltree. (line  132)
* proc attr_get*(a2: ptr cunsignedlong; a3: ptr cshort; a4: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  134)
* proc attr_off*(a2: cunsignedlong; a3: pointer): cint {.extdecl, importc: "attr_off",: /wrappers/pdcurses.
                                                             (line  138)
* proc attr_on*(a2: cunsignedlong; a3: pointer): cint {.extdecl, importc: "attr_on",: /wrappers/pdcurses.
                                                             (line  142)
* proc attr_set*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  146)
* proc auth*(smtp: AsyncSmtp; username, password: string) {.async.}: /pure/smtp.
                                                             (line   73)
* proc auth*(smtp: var Smtp; username, password: string): /pure/smtp.
                                                             (line   27)
* proc autocommit*(MySQL: PMySQL; auto_mode: my_bool): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  760)
* proc await*(fv: FlowVarBase):          /pure/concurrency/threadpool.
                                                             (line   20)
* proc awaitAndThen*[T](fv: FlowVar[T]; action: proc (x: T) {.closure.}): /pure/concurrency/threadpool.
                                                             (line   26)
* proc awaitAny*(flowVars: openArray[FlowVarBase]): int: /pure/concurrency/threadpool.
                                                             (line   49)
* proc back*(h: History):                /js/dom.            (line  247)
* proc back*(w: Window):                 /js/dom.            (line   28)
* proc backref*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  162)
* proc backrefIgnoreCase*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  169)
* proc backrefIgnoreStyle*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  176)
* proc barrierEnter*(b: ptr Barrier) {.compilerProc.}: /system/sysspawn.
                                                             (line   16)
* proc barrierLeave*(b: ptr Barrier) {.compilerProc.}: /system/sysspawn.
                                                             (line   19)
* proc base*(x: Any): Any:               /core/typeinfo.     (line   78)
* proc basename*(a1: cstring): cstring {.importc, header: "<libgen.h>".}: /posix/posix.
                                                             (line  315)
* proc basename*(a: NimNode): NimNode:   /core/macros.       (line  572)
* proc basename*(a: NimNode): NimNode {.compiletime, benign.}: /core/macros.
                                                             (line  554)
* proc baseTypeKind*(x: Any): AnyKind {.inline.}: /core/typeinfo.
                                                             (line   32)
* proc baseTypeSize*(x: Any): int {.inline.}: /core/typeinfo.
                                                             (line   38)
* proc baudrate*(): cint {.extdecl, importc: "baudrate", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  150)
* proc beep*(): cint {.extdecl, importc: "beep", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  153)
* proc bigEndian16*(outp, inp: pointer) {.inline.}: /pure/endians.
                                                             (line   39)
* proc bigEndian32*(outp, inp: pointer) {.inline.}: /pure/endians.
                                                             (line   36)
* proc bigEndian64*(outp, inp: pointer) {.inline.}: /pure/endians.
                                                             (line   33)
* proc binarySearch*[T](a: openArray[T]; key: T): int: /pure/algorithm.
                                                             (line   52)
* proc bindAddr*(sock: AsyncSocket; port = Port(0); address = ""): /deprecated/pure/asyncio.
                                                             (line   67)
* proc bindAddr*(socket: AsyncSocket; port = Port(0); address = "") {.tags: [ReadIOEffect].}: /pure/asyncnet.
                                                             (line  141)
* proc bindAddr*(socket: Socket; port = Port(0); address = "") {.tags: [ReadIOEffect].}: /pure/net.
                                                             (line  170)
* proc bindAddr*(socket: Socket; port = Port(0); address = "") {.tags: [ReadIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  136)
* proc bindAddr*(socket: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint: /pure/nativesockets.
                                                             (line   76)
* proc bindSocket*(a1: SocketHandle; a2: ptr SockAddr; a3: Socklen): cint {.: /posix/posix.
                                                             (line 1577)
* proc bindSocket*(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.stdcall,: /windows/winlean.
                                                             (line  380)
* proc bindSym*(ident: string; rule: BindSymRule = brClosed): NimNode {.magic: "NBindSym",: /core/macros.
                                                             (line  226)
* proc bind_blob*(para1: Pstmt; para2: int32; para3: pointer; n: int32;: /wrappers/sqlite3.
                                                             (line  148)
* proc bind_blob*(para1: Pstmt; para2: int32; para3: pointer; n: int32; para5: int32): int32 {.: /wrappers/sqlite3.
                                                             (line  182)
* proc bind_double*(para1: Pstmt; para2: int32; para3: float64): int32 {.cdecl,: /wrappers/sqlite3.
                                                             (line  154)
* proc bind_int*(para1: Pstmt; para2: int32; para3: int32): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  158)
* proc bind_int64*(para1: Pstmt; para2: int32; para3: int64): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  162)
* proc bind_null*(para1: Pstmt; para2: int32): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  166)
* proc bind_parameter_count*(para1: Pstmt): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  194)
* proc bind_parameter_index*(para1: Pstmt; zName: cstring): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  202)
* proc bind_parameter_name*(para1: Pstmt; para2: int32): cstring {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  198)
* proc bind_text*(para1: Pstmt; para2: int32; para3: cstring; n: int32;: /wrappers/sqlite3.
                                                             (line  170)
* proc bind_text*(para1: Pstmt; para2: int32; para3: cstring; n: int32; para5: int32): int32 {.: /wrappers/sqlite3.
                                                             (line  186)
* proc bind_text16*(para1: Pstmt; para2: int32; para3: pointer; para4: int32;: /wrappers/sqlite3.
                                                             (line  176)
* proc bind_text16*(para1: Pstmt; para2: int32; para3: pointer; para4: int32; para5: int32): int32 {.: /wrappers/sqlite3.
                                                             (line  190)
* proc binom*(n, k: int): int {.noSideEffect.}: /pure/math.  (line   26)
* proc bioCtrlPending*(b: BIO): cInt {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  245)
* proc bioFreeAll*(b: BIO) {.cdecl, dynlib: DLLUtilName, importc: "BIO_free_all".}: /wrappers/openssl.
                                                             (line  239)
* proc bioNew*(b: PBIO_METHOD): BIO {.cdecl, dynlib: DLLUtilName, importc: "BIO_new".}: /wrappers/openssl.
                                                             (line  236)
* proc bioRead*(b: BIO; Buf: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  249)
* proc bioSMem*(): PBIO_METHOD {.cdecl, dynlib: DLLUtilName, importc: "BIO_s_mem".}: /wrappers/openssl.
                                                             (line  242)
* proc bioWrite*(b: BIO; Buf: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  253)
* proc BIO_ctrl*(bio: BIO; cmd: cint; larg: int; arg: cstring): int {.cdecl,: /wrappers/openssl.
                                                             (line  137)
* proc BIO_do_connect*(bio: BIO): int:   /wrappers/openssl.  (line  150)
* proc BIO_do_handshake*(bio: BIO): int: /wrappers/openssl.  (line  147)
* proc BIO_free*(b: BIO): cInt {.cdecl, dynlib: DLLUtilName, importc.}: /wrappers/openssl.
                                                             (line  161)
* proc BIO_get_ssl*(bio: BIO; ssl: ptr SslPtr): int: /wrappers/openssl.
                                                             (line  141)
* proc BIO_new_ssl_connect*(ctx: SslCtx): BIO {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  134)
* proc BIO_read*(b: BIO; data: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  153)
* proc BIO_set_conn_hostname*(bio: BIO; name: cstring): int: /wrappers/openssl.
                                                             (line  144)
* proc BIO_write*(b: BIO; data: cstring; length: cInt): cInt {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  157)
* proc bisect*(v1, v2: Vector2d): Vector2d {.noInit.}: /pure/basic2d.
                                                             (line  357)
* proc bisect*(v1, v2: Vector3d): Vector3d {.noInit.}: /pure/basic3d.
                                                             (line  346)
* proc bkgd*(a2: cunsignedlong): cint {.extdecl, importc: "bkgd", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  156)
* proc bkgdset*(a2: cunsignedlong) {.extdecl, importc: "bkgdset", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  159)
* proc blur*(e: Element):                /js/dom.            (line  208)
* proc blur*(w: Window):                 /js/dom.            (line   31)
* proc body*(someProc: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  548)
* proc boolVal*(n: NimNode): bool {.compileTime, noSideEffect.}: /core/macros.
                                                             (line  620)
* proc border*(a2: cunsignedlong; a3: cunsignedlong; a4: cunsignedlong;: /wrappers/pdcurses.
                                                             (line  162)
* proc border_set*(a2: ptr cunsignedlong; a3: ptr cunsignedlong; a4: ptr cunsignedlong;: /wrappers/pdcurses.
                                                             (line 1089)
* proc bottom_panel*(pan: ptr PANEL): cint {.extdecl, importc: "bottom_panel",: /wrappers/pdcurses.
                                                             (line 1704)
* proc bounds*(c: Captures; i: range[0 .. MaxSubpatterns - 1]): tuple[first, last: int]: /pure/pegs.
                                                             (line  199)
* proc box*(a2: ptr WINDOW; a3: cunsignedlong; a4: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  170)
* proc box_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong): cint {.: /wrappers/pdcurses.
                                                             (line 1097)
* proc brent*(xmin, xmax: float; function: OneVarFunction; tol: float; maxiter = 1000): tuple[: /pure/numeric.
                                                             (line   12)
* proc bsd_signal*(a1: cint; a2: proc (x: pointer) {.noconv.}) {.importc,: /posix/posix.
                                                             (line 1301)
* proc buf_init*(base: cstring; len: csize): Buf {.importc: "uv_buf_init", header: "uv.h".}: /wrappers/libuv.
                                                             (line   55)
* proc busy_handler*(para1: PSqlite3;:   /wrappers/sqlite3.  (line   51)
* proc busy_timeout*(para1: PSqlite3; ms: int32): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line   59)
* proc button*(title, action: cstring): PIhandle {.importc: "IupButton", cdecl,: /wrappers/iup.
                                                             (line  480)
* proc callsite*(): NimNode {.magic: "NCallSite", benign.}: /core/macros.
                                                             (line  245)
* proc canonFilename*(filename: cstring): cstring: /system/debugger.
                                                             (line   47)
* proc canvas*(action: cstring): PIhandle {.importc: "IupCanvas", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  487)
* proc can_change_color*(): cunsignedchar {.extdecl, importc: "can_change_color",: /wrappers/pdcurses.
                                                             (line  174)
* proc capitalize*(s: string): string {.noSideEffect, procvar, rtl,: /pure/strutils.
                                                             (line  166)
* proc capture*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsCapture".}: /pure/pegs.
                                                             (line  157)
* proc captureBetween*(s: string; first: char; second = '\0'; start = 0): string: /pure/parseutils.
                                                             (line  131)
* proc captureBounds*(pattern: RegexMatch): CaptureBounds: /impure/nre.
                                                             (line   23)
* proc captureCount*(pattern: Regex): int: /impure/nre.      (line   17)
* proc captureEvents*(d: Document; eventMask: int) {.deprecated.}: /js/dom.
                                                             (line  163)
* proc captureEvents*(w: Window; eventMask: int) {.deprecated.}: /js/dom.
                                                             (line   34)
* proc captureNameId*(pattern: Regex): Table[string, int]: /impure/nre.
                                                             (line   20)
* proc captures*(pattern: RegexMatch): Captures: /impure/nre.
                                                             (line   26)
* proc card*[A](s: HashSet[A]): int:     /pure/collections/sets.
                                                             (line   60)
* proc card*[A](s: OrderedSet[A]): int {.inline.}: /pure/collections/sets.
                                                             (line  389)
* proc card*[T](x: set[T]): int {.magic: "Card", noSideEffect.}: /system.
                                                             (line  605)
* proc cas*[T: bool | int | ptr](p: ptr T; oldValue, newValue: T): bool: /system/atomics.
                                                             (line  243)
* proc catclose*(a1: Nl_catd): cint {.importc, header: "<nl_types.h>".}: /posix/posix.
                                                             (line 1384)
* proc catgets*(a1: Nl_catd; a2, a3: cint; a4: cstring): cstring {.importc,: /posix/posix.
                                                             (line 1387)
* proc catopen*(a1: cstring; a2: cint): Nl_catd {.importc, header: "<nl_types.h>".}: /posix/posix.
                                                             (line 1391)
* proc cbox*(child: PIhandle): PIhandle {.importc: "IupCbox", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  435)
* proc cboxv*(children: ptr PIhandle): PIhandle {.importc: "IupCboxv", cdecl,: /wrappers/iup.
                                                             (line  439)
* proc cbreak*(): cint {.extdecl, importc: "cbreak", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  178)
* proc cbrt*(x: float): float {.importc: "cbrt", header: "<math.h>".}: /pure/math.
                                                             (line  102)
* proc cd*(dir: string) {.raises: [OSError].}: /system/nimscript.
                                                             (line  182)
* proc cd*(ftp: AsyncFtpClient; dir: string) {.async.}: /pure/asyncftpclient.
                                                             (line   31)
* proc cd*[T](ftp: FtpBase[T]; dir: string): /deprecated/pure/ftpclient.
                                                             (line   35)
* proc cdup*(ftp: AsyncFtpClient) {.async.}: /pure/asyncftpclient.
                                                             (line   36)
* proc cdup*[T](ftp: FtpBase[T]):        /deprecated/pure/ftpclient.
                                                             (line   40)
* proc ceil*(x: float): float {.importc: "ceil", header: "<math.h>".}: /pure/math.
                                                             (line  236)
* proc cells*(): PIhandle {.cdecl, importc: "IupCells", dynlib: dllname.}: /wrappers/iup.
                                                             (line  673)
* proc cfGetIspeed*(termios: ptr Termios): Speed {.importc: "cfgetispeed",: /posix/termios.
                                                             (line   57)
* proc cfGetOspeed*(termios: ptr Termios): Speed {.importc: "cfgetospeed",: /posix/termios.
                                                             (line   53)
* proc cfMakeRaw*(termios: ptr Termios) {.importc: "cfmakeraw", header: "<termios.h>".}: /posix/termios.
                                                             (line   81)
* proc cfSetIspeed*(termios: ptr Termios; speed: Speed): cint {.importc: "cfsetispeed",: /posix/termios.
                                                             (line   65)
* proc cfSetOspeed*(termios: ptr Termios; speed: Speed): cint {.importc: "cfsetospeed",: /posix/termios.
                                                             (line   61)
* proc cfSetSpeed*(termios: ptr Termios; speed: Speed): cint {.importc: "cfsetspeed",: /posix/termios.
                                                             (line   69)
* proc cgiError*(msg: string) {.noreturn.}: /pure/cgi.       (line   46)
* proc changeFileExt*(filename, ext: string): string {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line  137)
* proc changes*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_changes".}: /wrappers/sqlite3.
                                                             (line   34)
* proc change_user*(MySQL: PMySQL; user: cstring; passwd: cstring; db: cstring): my_bool {.: /wrappers/mysql.
                                                             (line  388)
* proc character_set_name*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  371)
* proc charSet*(s: set[char]): Peg {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line   54)
* proc chdir*(a1: cstring): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  783)
* proc checkBreakpoints*(filename: cstring; line: int): ptr Breakpoint: /system/debugger.
                                                             (line   60)
* proc checkedSymAddr*(lib: LibHandle; name: cstring): pointer: /pure/dynlib.
                                                             (line   42)
* proc checkpoint*(msg: string):         /pure/unittest.     (line   19)
* proc check_init*(a2: PLoop; check: PCheck): cint {.importc: "uv_check_init",: /wrappers/libuv.
                                                             (line  193)
* proc check_parameter*(prob: ptr Problem; param: ptr Parameter): cstring {.cdecl,: /wrappers/libsvm.
                                                             (line  123)
* proc check_probability_model*(model: ptr Model): cint {.cdecl,: /wrappers/libsvm.
                                                             (line  127)
* proc check_scramble*(reply: cstring; message: cstring; hash_stage2: pointer): my_bool {.: /wrappers/mysql.
                                                             (line  228)
* proc check_scramble_323*(para1: cstring; message: cstring; salt: int): my_bool {.cdecl,: /wrappers/mysql.
                                                             (line  203)
* proc check_start*(check: PCheck; cb: CheckProc): cint {.importc: "uv_check_start",: /wrappers/libuv.
                                                             (line  197)
* proc check_stop*(check: PCheck): cint {.importc: "uv_check_stop", header: "uv.h".}: /wrappers/libuv.
                                                             (line  201)
* proc chgat*(a2: cint; a3: cunsignedlong; a4: cshort; a5: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  181)
* proc child*(n: XmlNode; name: string): XmlNode: /pure/xmltree.
                                                             (line  186)
* proc chmod*(a1: cstring; a2: Mode): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1074)
* proc chmod*(ftp: AsyncFtpClient; path: string; permissions: set[FilePermission]) {.: /pure/asyncftpclient.
                                                             (line   63)
* proc chmod*(loop: PLoop; req: PFS; path: cstring; mode: cint; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  341)
* proc chmod*[T](ftp: FtpBase[T]; path: string; permissions: set[FilePermission]): /deprecated/pure/ftpclient.
                                                             (line   80)
* proc chown*(a1: cstring; a2: Uid; a3: Gid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  786)
* proc chown*(loop: PLoop; req: PFS; path: cstring; uid: cint; gid: cint; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  374)
* proc chr*(u: range[0 .. 255]): char {.magic: "Chr", noSideEffect.}: /system.
                                                             (line  619)
* proc clamp*[T](x, a, b: T): T:         /system.            (line 1835)
* proc classify*(x: float): FloatClass:  /pure/math.         (line   36)
* proc clean*(p: var Poly; zerotol = 0.0'f64): /pure/poly.   (line   41)
* proc clean*[T](future: FutureVar[T]):  /pure/asyncdispatch.
                                                             (line   38)
* proc clear*(): cint {.extdecl, importc: "clear", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  189)
* proc clear*(r: var RunningRegress):    /pure/stats.        (line  152)
* proc clear*(s: StringTableRef; mode: StringTableMode): /pure/strtabs.
                                                             (line   67)
* proc clear*(s: var RunningStat):       /pure/stats.        (line   23)
* proc clear*[A](t: var SharedList[A]):  /pure/collections/sharedlist.
                                                             (line   24)
* proc clearclipboard*(): cint {.extdecl, importc: "PDC_clearclipboard",: /wrappers/pdcurses.
                                                             (line 1668)
* proc clearHandlers*(handler: var EventHandler): /pure/events.
                                                             (line   37)
* proc clearInterval*(w: Window; interval: ref TInterval): /js/dom.
                                                             (line   37)
* proc clearok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "clearok",: /wrappers/pdcurses.
                                                             (line  185)
* proc clearScreen*() {.importc: "linenoiseClearScreen".}: /wrappers/linenoise/linenoise.
                                                             (line   35)
* proc clearTimeout*(w: Window; timeout: ref TTimeOut): /js/dom.
                                                             (line   40)
* proc click*(e: Element):               /js/dom.            (line  211)
* proc clientData*(n: XmlNode): int {.inline.}: /pure/xmltree.
                                                             (line  137)
* proc clock*(): Clock {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1209)
* proc clock_getcpuclockid*(a1: Pid; a2: var ClockId): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1212)
* proc clock_getres*(a1: ClockId; a2: var Timespec): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1215)
* proc clock_gettime*(a1: ClockId; a2: var Timespec): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1218)
* proc clock_nanosleep*(a1: ClockId; a2: cint; a3: var Timespec; a4: var Timespec): cint {.: /posix/posix.
                                                             (line 1221)
* proc clock_settime*(a1: ClockId; a2: var Timespec): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1225)
* proc clone*(fn: pointer; child_stack: pointer; flags: cint; arg: pointer; ptid: ptr Pid;: /posix/linux.
                                                             (line   12)
* proc cloneNode*(n: Node; copyContent: bool): Node: /js/dom.
                                                             (line  118)
* proc cloneNode*(n: PNode; deep: bool): PNode: /pure/xmldom.
                                                             (line  178)
* proc close*() {.importc: "IupClose", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line   95)
* proc close*(a1: cint | SocketHandle): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  789)
* proc close*(c: EncodingConverter):     /pure/encodings.    (line   31)
* proc close*(c: var CfgParser) {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   26)
* proc close*(client: AsyncHttpClient):  /pure/httpclient.   (line  251)
* proc close*(db: DbConn) {.tags: [DbEffect].}: /impure/db_postgres.
                                                             (line  134)
* proc close*(db: DbConn) {.tags: [DbEffect].} <1>: /impure/db_mysql.
                                                             (line   93)
* proc close*(db: DbConn) {.tags: [DbEffect].} <2>: /impure/db_sqlite.
                                                             (line   90)
* proc close*(db: var DbConn) {.tags: [WriteDbEffect], raises: [].}: /impure/db_odbc.
                                                             (line   90)
* proc close*(f: AsyncFile):             /pure/asyncfile.    (line   62)
* proc close*(f: File) {.importc: "fclose", header: "<stdio.h>", tags: [].}: /system.
                                                             (line 2122)
* proc close*(f: var MemFile):           /pure/memfiles.     (line   75)
* proc close*(h: PAsyncHTTPServer):      /pure/httpserver.   (line   51)
* proc close*(handle: PHandle; close_cb: CloseProc) {.importc: "uv_close", header: "uv.h".}: /wrappers/libuv.
                                                             (line   52)
* proc close*(L: var BaseLexer):         /pure/lexbase.      (line   42)
* proc close*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.importc: "uv_fs_close",: /wrappers/libuv.
                                                             (line  279)
* proc close*(my: var CsvParser) {.inline.}: /pure/parsecsv. (line   45)
* proc close*(my: var JsonParser) {.inline.}: /pure/json.    (line   34)
* proc close*(my: var XmlParser) {.inline.}: /pure/parsexml. (line   34)
* proc close*(p: Process) {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  106)
* proc close*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_close".}: /wrappers/sqlite3.
                                                             (line   22)
* proc close*(s, unused: Stream) {.deprecated.}: /pure/streams.
                                                             (line   62)
* proc close*(s: AsyncScgiState):        /pure/scgi.         (line   70)
* proc close*(s: Selector):              /pure/selectors.    (line   44)
* proc close*(s: Server):                /pure/httpserver.   (line   27)
* proc close*(s: Stream):                /pure/streams.      (line   57)
* proc close*(s: var ScgiState):         /pure/scgi.         (line   27)
* proc close*(server: AsyncHttpServer):  /pure/asynchttpserver.
                                                             (line   47)
* proc close*(smtp: AsyncSmtp) {.async.}: /pure/smtp.        (line   87)
* proc close*(smtp: Smtp):               /pure/smtp.         (line   39)
* proc close*(sock: AsyncSocket):        /deprecated/pure/asyncio.
                                                             (line   62)
* proc close*(sock: AsyncSocket) {.gcsafe.}: /deprecated/pure/asyncio.
                                                             (line   54)
* proc close*(sock: PMySQL) {.stdcall, dynlib: lib, importc: "mysql_close".}: /wrappers/mysql.
                                                             (line  772)
* proc close*(sock: SecureSocket):       /impure/ssl.        (line   34)
* proc close*(socket: AsyncSocket):      /pure/asyncnet.     (line  148)
* proc close*(socket: Socket):           /pure/net.          (line  214)
* proc close*(socket: Socket) <1>:       /deprecated/pure/sockets.
                                                             (line  215)
* proc close*(socket: SocketHandle):     /pure/nativesockets.
                                                             (line   71)
* proc close*(w: Window):                /js/dom.            (line   43)
* proc close*[TMsg](c: var Channel[TMsg]): /system/channels. (line   44)
* proc close*[T](ftp: FtpBase[T]):       /deprecated/pure/ftpclient.
                                                             (line  118)
* proc closeBarrier*(b: ptr Barrier) {.compilerProc.}: /system/sysspawn.
                                                             (line   25)
* proc closeCCState*(s: PccState) {.importc: "tcc_delete", cdecl.}: /wrappers/tinyc.
                                                             (line   25)
* proc closedir*(a1: ptr DIR): cint {.importc, header: "<dirent.h>".}: /posix/posix.
                                                             (line  204)
* proc closeHandle*(hObject: Handle): WINBOOL {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  120)
* proc closesocket*(s: SocketHandle): cint {.stdcall, importc: "closesocket",: /windows/winlean.
                                                             (line  372)
* proc closeSocket*(socket: AsyncFD):    /pure/asyncdispatch.
                                                             (line  233)
* proc closestPoint*(p: Point2d; pts: varargs[Point2d]): Point2d: /pure/basic2d.
                                                             (line  498)
* proc clrtobot*(): cint {.extdecl, importc: "clrtobot", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  192)
* proc clrtoeol*(): cint {.extdecl, importc: "clrtoeol", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  195)
* proc cmdLineRest*(p: OptParser): TaintedString {.rtl, extern: "npo$1".}: /pure/parseopt.
                                                             (line   38)
* proc cmdLineRest*(p: OptParser): TaintedString {.rtl, extern: "npo2$1", deprecated.}: /pure/parseopt2.
                                                             (line   50)
* proc cmp*(x, y: Rational): int {.procvar.}: /pure/rationals.
                                                             (line  179)
* proc cmp*(x, y: string): int {.noSideEffect, procvar.}: /system.
                                                             (line 1235)
* proc cmp*[T](x, y: T): int {.procvar.}: /system.           (line 1225)
* proc cmpic*(a, b: string): int:        /system/nimscript.  (line   72)
* proc cmpIgnoreCase*(a, b: string): int {.noSideEffect, rtl, extern: "nsuCmpIgnoreCase",: /pure/strutils.
                                                             (line  182)
* proc cmpIgnoreStyle*(a, b: string): int {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  192)
* proc cmpPaths*(pathA, pathB: string): int {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line  157)
* proc cmpRunesIgnoreCase*(a, b: string): int {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line  114)
* proc CMSG_DATA*(cmsg: ptr Tcmsghdr): cstring {.importc, header: "<sys/socket.h>".}: /posix/posix.
                                                             (line 1559)
* proc CMSG_FIRSTHDR*(mhdr: ptr Tmsghdr): ptr Tcmsghdr {.importc,: /posix/posix.
                                                             (line 1566)
* proc CMSG_NXTHDR*(mhdr: ptr Tmsghdr; cmsg: ptr Tcmsghdr): ptr Tcmsghdr {.importc,: /posix/posix.
                                                             (line 1562)
* proc collation_needed*(para1: PSqlite3; para2: pointer; para3: Collation_needed_func): int32 {.: /wrappers/sqlite3.
                                                             (line  431)
* proc collation_needed16*(para1: PSqlite3; para2: pointer;: /wrappers/sqlite3.
                                                             (line  436)
* proc colorbar*(): PIhandle {.cdecl, importc: "IupColorbar", dynlib: dllname.}: /wrappers/iup.
                                                             (line  670)
* proc colorBrowser*(): PIhandle {.cdecl, importc: "IupColorBrowser", dynlib: dllname.}: /wrappers/iup.
                                                             (line  676)
* proc colorDlg*(): PIhandle {.importc: "IupColorDlg", dynlib: dllname, cdecl.}: /wrappers/iup.
                                                             (line   45)
* proc color_content*(a2: cshort; a3: ptr cshort; a4: ptr cshort; a5: ptr cshort): cint {.: /wrappers/pdcurses.
                                                             (line  198)
* proc color_set*(a2: cshort; a3: pointer): cint {.extdecl, importc: "color_set",: /wrappers/pdcurses.
                                                             (line  203)
* proc column_blob*(para1: Pstmt; iCol: int32): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  237)
* proc column_bytes*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  241)
* proc column_bytes16*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  245)
* proc column_count*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  206)
* proc column_decltype*(para1: Pstmt; i: int32): cstring {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  222)
* proc column_decltype16*(para1: Pstmt; para2: int32): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  226)
* proc column_double*(para1: Pstmt; iCol: int32): float64 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  249)
* proc column_int*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  253)
* proc column_int64*(para1: Pstmt; iCol: int32): int64 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  257)
* proc column_name*(para1: Pstmt; para2: int32): cstring {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  210)
* proc column_name16*(para1: Pstmt; para2: int32): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  218)
* proc column_table_name*(para1: Pstmt; para2: int32): cstring {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  214)
* proc column_text*(para1: Pstmt; iCol: int32): cstring {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  261)
* proc column_text16*(para1: Pstmt; iCol: int32): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  265)
* proc column_type*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  269)
* proc combine*(base: Uri; reference: Uri): Uri: /pure/uri.  (line   52)
* proc combine*(uris: varargs[Uri]): Uri: /pure/uri.         (line   75)
* proc commandLineParams*(): seq[TaintedString]: /pure/os.   (line  491)
* proc commit*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, importc: "mysql_commit".}: /wrappers/mysql.
                                                             (line  753)
* proc commit_hook*(para1: PSqlite3; para2: proc (para1: pointer): int32 {.cdecl.};: /wrappers/sqlite3.
                                                             (line  106)
* proc compile*(pattern: cstring; options: cint; errptr: ptr cstring; erroffset: ptr cint;: /wrappers/pcre.
                                                             (line  111)
* proc compile2*(pattern: cstring; options: cint; errorcodeptr: ptr cint;: /wrappers/pcre.
                                                             (line  115)
* proc compileOption*(option, arg: string): bool {.magic: "CompileOptionArg",: /system.
                                                             (line 1333)
* proc compileOption*(option: string): bool {.magic: "CompileOption", noSideEffect.}: /system.
                                                             (line 1326)
* proc compiles*(x: expr): bool {.magic: "Compiles", noSideEffect, compileTime.}: /system.
                                                             (line 2627)
* proc compileString*(s: PccState; buf: cstring): cint {.cdecl,: /wrappers/tinyc.
                                                             (line   77)
* proc complete*(future: Future[void]):  /pure/asyncdispatch.
                                                             (line   48)
* proc complete*(sql: cstring): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_complete".}: /wrappers/sqlite3.
                                                             (line   44)
* proc complete*[T](future: FutureVar[T]): /pure/asyncdispatch.
                                                             (line   53)
* proc complete*[T](future: Future[T]; val: T): /pure/asyncdispatch.
                                                             (line   43)
* proc complete16*(sql: pointer): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line   47)
* proc concat*[T](seqs: varargs[seq[T]]): seq[T]: /pure/collections/sequtils.
                                                             (line    6)
* proc config*(what: cint; where: pointer): cint: /wrappers/pcre.
                                                             (line  120)
* proc confirm*(w: Window; msg: cstring): bool: /js/dom.     (line   46)
* proc confstr*(a1: cint; a2: cstring; a3: int): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  792)
* proc conjugate*(z: Complex): Complex:  /pure/complex.      (line  139)
* proc connect*(a1: SocketHandle; a2: ptr SockAddr; a3: Socklen): cint {.importc,: /posix/posix.
                                                             (line 1583)
* proc connect*(address: string; port = Port(25); ssl = false; debug = false;: /pure/smtp.
                                                             (line   20)
* proc connect*(ftp: AsyncFtpClient) {.async.}: /pure/asyncftpclient.
                                                             (line   21)
* proc connect*(MySQL: PMySQL; host: cstring; user: cstring; passwd: cstring): PMySQL {.: /wrappers/mysql.
                                                             (line  778)
* proc connect*(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.stdcall,: /windows/winlean.
                                                             (line  384)
* proc connect*(smtp: AsyncSmtp) {.async.}: /pure/smtp.      (line   67)
* proc connect*(sock: AsyncSocket; name: string; port = Port(0); af: Domain = AF_INET): /deprecated/pure/asyncio.
                                                             (line   57)
* proc connect*(sock: var SecureSocket; address: string; port: int): int: /impure/ssl.
                                                             (line   16)
* proc connect*(socket: AsyncFD; address: string; port: Port;: /pure/asyncdispatch.
                                                             (line  164)
* proc connect*(socket: AsyncSocket; address: string; port: Port) {.async.}: /pure/asyncnet.
                                                             (line   38)
* proc connect*(socket: Socket; address: string; port = Port(0)) {.tags: [ReadIOEffect].}: /pure/net.
                                                             (line  250)
* proc connect*(socket: Socket; address: string; port = Port(0); af: Domain = AF_INET) {.: /deprecated/pure/sockets.
                                                             (line  273)
* proc connect*(socket: Socket; address: string; port = Port(0); timeout: int) {.: /pure/net.
                                                             (line  410)
* proc connect*(socket: Socket; address: string; port = Port(0); timeout: int;: /deprecated/pure/sockets.
                                                             (line  599)
* proc connect*[T](ftp: FtpBase[T]):     /deprecated/pure/ftpclient.
                                                             (line   25)
* proc connectAsync*(socket: Socket; name: string; port = Port(0); af: Domain = AF_INET) {.: /deprecated/pure/sockets.
                                                             (line  285)
* proc contains*(c: ClassList; class: cstring): bool: /js/dom.
                                                             (line  265)
* proc contains*(s, sub: string): bool {.noSideEffect.}: /pure/strutils.
                                                             (line  551)
* proc contains*(s: IntSet; key: int): bool: /pure/collections/intsets.
                                                             (line   19)
* proc contains*(s: Selector; fd: SocketHandle): bool: /pure/selectors.
                                                             (line   62)
* proc contains*(s: Selector; key: SelectorKey): bool: /pure/selectors.
                                                             (line   72)
* proc contains*(s: string; c: char): bool {.noSideEffect.}: /pure/strutils.
                                                             (line  546)
* proc contains*(s: string; chars: set[char]): bool {.noSideEffect.}: /pure/strutils.
                                                             (line  556)
* proc contains*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {.: /pure/pegs.
                                                             (line  281)
* proc contains*(s: string; pattern: Peg; start = 0): bool {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  275)
* proc contains*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool: /impure/re.
                                                             (line  112)
* proc contains*(s: string; pattern: Regex; start = 0): bool: /impure/re.
                                                             (line  107)
* proc contains*[A, B](t: OrderedTableRef[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line  327)
* proc contains*[A, B](t: OrderedTable[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line  234)
* proc contains*[A, B](t: TableRef[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line  159)
* proc contains*[A, B](t: Table[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line   61)
* proc contains*[A](s: HashSet[A]; key: A): bool: /pure/collections/sets.
                                                             (line   94)
* proc contains*[A](s: OrderedSet[A]; key: A): bool: /pure/collections/sets.
                                                             (line  397)
* proc contains*[A](t: CountTableRef[A]; key: A): bool: /pure/collections/tables.
                                                             (line  484)
* proc contains*[A](t: CountTable[A]; key: A): bool: /pure/collections/tables.
                                                             (line  404)
* proc contains*[T](a: openArray[T]; item: T): bool {.inline.}: /system.
                                                             (line 1908)
* proc contains*[T](c: CritBitTree[T]; key: string): bool {.inline.}: /pure/collections/critbits.
                                                             (line   24)
* proc contains*[T](L: DoublyLinkedList[T]; value: T): bool {.inline.}: /pure/collections/lists.
                                                             (line   97)
* proc contains*[T](L: DoublyLinkedRing[T]; value: T): bool {.inline.}: /pure/collections/lists.
                                                             (line  109)
* proc contains*[T](L: SinglyLinkedList[T]; value: T): bool {.inline.}: /pure/collections/lists.
                                                             (line   91)
* proc contains*[T](L: SinglyLinkedRing[T]; value: T): bool {.inline.}: /pure/collections/lists.
                                                             (line  103)
* proc contains*[T](s: Slice[T]; value: T): bool {.noSideEffect, inline.}: /system.
                                                             (line 1196)
* proc contains*[T](x: set[T]; y: T): bool {.magic: "InSet", noSideEffect.}: /system.
                                                             (line 1178)
* proc containsHandler*(handler: var EventHandler; fn: proc (e: EventArgs) {.closure.}): bool: /pure/events.
                                                             (line   32)
* proc containsOrIncl*(c: var CritBitTree[void]; key: string): bool: /pure/collections/critbits.
                                                             (line   40)
* proc containsOrIncl*(s: var IntSet; key: int): bool: /pure/collections/intsets.
                                                             (line   34)
* proc containsOrIncl*[A](s: var HashSet[A]; key: A): bool: /pure/collections/sets.
                                                             (line  154)
* proc containsOrIncl*[A](s: var OrderedSet[A]; key: A): bool: /pure/collections/sets.
                                                             (line  431)
* proc containsOrIncl*[T](c: var CritBitTree[T]; key: string; val: T): bool: /pure/collections/critbits.
                                                             (line   34)
* proc continuesWith*(s, substr: string; start: Natural): bool {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  426)
* proc controlsClose*() {.cdecl, importc: "IupControlsClose", dynlib: dllname.}: /wrappers/iup.
                                                             (line  661)
* proc controlsOpen*(): cint {.cdecl, importc: "IupControlsOpen", dynlib: dllname.}: /wrappers/iup.
                                                             (line  658)
* proc convert*(c: EncodingConverter; s: string): string: /pure/encodings.
                                                             (line   36)
* proc convert*(s: string; destEncoding = "UTF-8"; srcEncoding = "CP1252"): string: /pure/encodings.
                                                             (line   42)
* proc convertXYToPos*(ih: PIhandle; x, y: cint): cint {.importc: "IupConvertXYToPos",: /wrappers/iup.
                                                             (line  550)
* proc copy*(node: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  599)
* proc copy*(p: JsonNode): JsonNode:     /pure/json.         (line  279)
* proc copy*(s: string; first = 0): string {.magic: "CopyStr", importc: "copyStr",: /system.
                                                             (line 1466)
* proc copy*(s: string; first, last: int): string {.magic: "CopyStrLast",: /system.
                                                             (line 1470)
* proc copyChildrenTo*(src, dest: NimNode) {.compileTime.}: /core/macros.
                                                             (line  521)
* proc copyDir*(source, dest: string) {.rtl, extern: "nos$1",: /pure/os.
                                                             (line  318)
* proc copyDirWithPermissions*(source, dest: string; ignorePermissionErrors = true) {.: /pure/os.
                                                             (line  404)
* proc copyFile*(source, dest: string) {.rtl, extern: "nos$1",: /pure/os.
                                                             (line  236)
* proc copyFileW*(lpExistingFileName, lpNewFileName: WideCString; bFailIfExists: cint): cint {.: /windows/winlean.
                                                             (line  298)
* proc copyFileWithPermissions*(source, dest: string; ignorePermissionErrors = true): /pure/os.
                                                             (line  387)
* proc copyMem*(dest, source: pointer; size: Natural) {.importc: "memcpy",: /system.
                                                             (line 1502)
* proc copyNimNode*(n: NimNode): NimNode {.magic: "NCopyNimNode", noSideEffect.}: /core/macros.
                                                             (line  174)
* proc copyNimTree*(n: NimNode): NimNode {.magic: "NCopyNimTree", noSideEffect.}: /core/macros.
                                                             (line  177)
* proc copywin*(a2: ptr WINDOW; a3: ptr WINDOW; a4: cint; a5: cint; a6: cint; a7: cint; a8: cint;: /wrappers/pdcurses.
                                                             (line  207)
* proc copy_named_substring*(code: ptr Pcre; subject: cstring; ovector: ptr cint;: /wrappers/pcre.
                                                             (line  123)
* proc copy_substring*(subject: cstring; ovector: ptr cint; stringcount: cint;: /wrappers/pcre.
                                                             (line  129)
* proc correlation*(r: RunningRegress): float: /pure/stats.  (line  185)
* proc cos*(x: float): float {.importc: "cos", header: "<math.h>".}: /pure/math.
                                                             (line  162)
* proc cos*(z: Complex): Complex:        /pure/complex.      (line  184)
* proc cosh*(x: float): float {.importc: "cosh", header: "<math.h>".}: /pure/math.
                                                             (line  167)
* proc cosh*(z: Complex): Complex:       /pure/complex.      (line  244)
* proc cot*(z: Complex): Complex:        /pure/complex.      (line  204)
* proc coth*(z: Complex): Complex:       /pure/complex.      (line  284)
* proc count*(s: string; sub: char): int {.noSideEffect, rtl, extern: "nsuCountChar".}: /pure/strutils.
                                                             (line  525)
* proc count*(s: string; sub: string; overlapping: bool = false): int {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  517)
* proc count*(s: string; subs: set[char]): int {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  530)
* proc countBits32*(n: int32): int {.noSideEffect.}: /pure/math.
                                                             (line   54)
* proc countDays*(yearSpan: int): int:   /pure/times.        (line  418)
* proc countLeapYears*(yearSpan: int): int: /pure/times.     (line  407)
* proc countLines*(s: string): int {.noSideEffect, rtl, extern: "nsuCountLines".}: /pure/strutils.
                                                             (line  226)
* proc countProcessors*(): int {.rtl, extern: "ncpi$1".}: /pure/concurrency/cpuinfo.
                                                             (line    6)
* proc countProcessors*(): int {.rtl, extern: "nosp$1".}: /pure/osproc.
                                                             (line  209)
* proc countYears*(daySpan: int): int:   /pure/times.        (line  423)
* proc countYearsAndDays*(daySpan: int): tuple[years: int, days: int]: /pure/times.
                                                             (line  428)
* proc cpFile*(`from`, to: string) {.raises: [OSError].}: /system/nimscript.
                                                             (line  140)
* proc cpuRelax*() {.inline.}:           /system/atomics.    (line  246)
* proc cpuTime*(): float {.rtl, extern: "nt$1", tags: [TimeEffect].}: /pure/times.
                                                             (line  200)
* proc creat*(a1: cstring; a2: Mode): cint {.importc, header: "<fcntl.h>".}: /posix/posix.
                                                             (line  238)
* proc create*(classname: cstring): PIhandle {.importc: "IupCreate", cdecl,: /wrappers/iup.
                                                             (line  385)
* proc create*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}: /system.
                                                             (line 1559)
* proc createActorPool*[In, Out](a: var ActorPool[In, Out]; poolSize = 4): /deprecated/pure/actors.
                                                             (line   83)
* proc createAttribute*(d: Document; identifier: cstring): Node: /js/dom.
                                                             (line  166)
* proc createAttribute*(doc: PDocument; name: string): PAttr: /pure/xmldom.
                                                             (line   45)
* proc createAttributeNS*(doc: PDocument; namespaceURI: string; qualifiedName: string): PAttr: /pure/xmldom.
                                                             (line   53)
* proc createCDATASection*(doc: PDocument; data: string): PCDataSection: /pure/xmldom.
                                                             (line   58)
* proc createComment*(doc: PDocument; data: string): PComment: /pure/xmldom.
                                                             (line   63)
* proc createDir*(dir: string) {.rtl, extern: "nos$1", tags: [WriteDirEffect].}: /pure/os.
                                                             (line  308)
* proc createDir*(ftp: AsyncFtpClient; dir: string; recursive = false) {.async.}: /pure/asyncftpclient.
                                                             (line   55)
* proc createDir*[T](ftp: FtpBase[T]; dir: string; recursive: bool = false): /deprecated/pure/ftpclient.
                                                             (line   72)
* proc createDirectoryW*(pathName: WideCString; security: pointer = nil): int32 {.: /windows/winlean.
                                                             (line  236)
* proc createDocument*(dom: PDOMImplementation; n: PElement): PDocument: /pure/xmldom.
                                                             (line   27)
* proc createDocument*(dom: PDOMImplementation; namespaceURI: string;: /pure/xmldom.
                                                             (line   20)
* proc createDocumentFragment*(doc: PDocument): PDocumentFragment: /pure/xmldom.
                                                             (line   68)
* proc createElement*(d: Document; identifier: cstring): Element: /js/dom.
                                                             (line  169)
* proc createElement*(doc: PDocument; tagName: string): PElement: /pure/xmldom.
                                                             (line   73)
* proc createElementNS*(doc: PDocument; namespaceURI: string; qualifiedName: string): PElement: /pure/xmldom.
                                                             (line   78)
* proc createFileMappingA*(hFile: THANDLE; lpFileMappingAttributes: pointer;: /windows/winlean.
                                                             (line  541)
* proc createFileMappingW*(hFile: Handle; lpFileMappingAttributes: pointer;: /windows/winlean.
                                                             (line  533)
* proc createFileW*(lpFileName: WideCString; dwDesiredAccess, dwShareMode: DWORD;: /windows/winlean.
                                                             (line  497)
* proc createHardlink*(src, dest: string): /pure/os.         (line  340)
* proc createHardLinkW*(lpFileName, lpExistingFileName: WideCString;: /windows/winlean.
                                                             (line  262)
* proc createIoCompletionPort*(FileHandle: Handle; ExistingCompletionPort: Handle;: /windows/winlean.
                                                             (line  553)
* proc createMessage*(mSubject, mBody: string; mTo, mCc: seq[string] = @ []): Message: /pure/smtp.
                                                             (line   51)
* proc createMessage*(mSubject, mBody: string; mTo, mCc: seq[string];: /pure/smtp.
                                                             (line   44)
* proc createNamedPipe*(lpName: WideCString; dwOpenMode, dwPipeMode, nMaxInstances,: /windows/winlean.
                                                             (line  144)
* proc createp*(classname: cstring; first: pointer): PIhandle {.importc: "IupCreatep",: /wrappers/iup.
                                                             (line  393)
* proc createPipe*(hReadPipe, hWritePipe: var Handle;: /windows/winlean.
                                                             (line  137)
* proc createProcessingInstruction*(doc: PDocument; target: string; data: string): PProcessingInstruction: /pure/xmldom.
                                                             (line   83)
* proc createProcessW*(lpApplicationName, lpCommandLine: WideCString;: /windows/winlean.
                                                             (line  163)
* proc createShared*(T: typedesc; size = 1.Positive): ptr T {.inline.}: /system.
                                                             (line 1624)
* proc createSharedU*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}: /system.
                                                             (line 1607)
* proc createSymbolicLinkW*(lpSymlinkFileName, lpTargetFileName: WideCString;: /windows/winlean.
                                                             (line  256)
* proc createSymlink*(src, dest: string): /pure/os.          (line  331)
* proc createTextNode*(d: Document; identifier: cstring): Node: /js/dom.
                                                             (line  172)
* proc createTextNode*(doc: PDocument; data: string): PText: /pure/xmldom.
                                                             (line   89)
* proc createThread*(t: var Thread[void]; tp: proc () {.thread.}): /system/threads.
                                                             (line   43)
* proc createThread*[TArg](t: var Thread[TArg]; tp: proc (arg: TArg) {.thread.};: /system/threads.
                                                             (line   29)
* proc createU*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}: /system.
                                                             (line 1539)
* proc createv*(classname: cstring; params: pointer): PIhandle {.importc: "IupCreatev",: /wrappers/iup.
                                                             (line  389)
* proc create_collation*(para1: PSqlite3; zName: cstring; eTextRep: int32;: /wrappers/sqlite3.
                                                             (line  418)
* proc create_collation16*(para1: PSqlite3; zName: cstring; eTextRep: int32;: /wrappers/sqlite3.
                                                             (line  424)
* proc create_db*(MySQL: PMySQL; DB: cstring): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  782)
* proc create_function*(para1: PSqlite3; zFunctionName: cstring; nArg: int32;: /wrappers/sqlite3.
                                                             (line  279)
* proc create_function16*(para1: PSqlite3; zFunctionName: pointer; nArg: int32;: /wrappers/sqlite3.
                                                             (line  290)
* proc create_random_string*(fto: cstring; len: cuint; rand_st: Prand_struct) {.cdecl,: /wrappers/mysql.
                                                             (line  186)
* proc crmode*(): cint {.extdecl, importc: "crmode", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1479)
* proc cross*(v1, v2: Vector2d): float:  /pure/basic2d.      (line  316)
* proc cross*(v1, v2: Vector3d): Vector3d {.inline.}: /pure/basic3d.
                                                             (line  313)
* proc cross_validation*(prob: ptr Problem; param: ptr Parameter; nr_fold: cint;: /wrappers/libsvm.
                                                             (line   64)
* proc crypt*(a1, a2: cstring): cstring {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  795)
* proc CRYPTO_malloc_init*():            /wrappers/openssl.  (line  185)
* proc csc*(z: Complex): Complex:        /pure/complex.      (line  224)
* proc csch*(z: Complex): Complex:       /pure/complex.      (line  274)
* proc cstringArrayToSeq*(a: cstringArray): seq[string]: /system.
                                                             (line 2304)
* proc cstringArrayToSeq*(a: cstringArray; len: Natural): seq[string]: /system.
                                                             (line 2298)
* proc ctermid*(a1: cstring): cstring {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  798)
* proc ctime*(a1: var Time): cstring {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1228)
* proc ctime_r*(a1: var Time; a2: cstring): cstring {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1231)
* proc curses_version*(): cstring {.extdecl, importc: "curses_version",: /wrappers/pdcurses.
                                                             (line 1535)
* proc cursorBackward*(f: File; count = 1): /pure/terminal.  (line   78)
* proc cursorDown*(f: File; count = 1):  /pure/terminal.     (line   68)
* proc cursorForward*(f: File; count = 1): /pure/terminal.   (line   73)
* proc cursorUp*(f: File; count = 1):    /pure/terminal.     (line   63)
* proc curs_set*(a2: cint): cint {.extdecl, importc: "curs_set", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  213)
* proc cycle*[T](s: seq[T]; n: Natural): seq[T]: /pure/collections/sequtils.
                                                             (line   20)
* proc data_count*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  233)
* proc data_seek*(result: PRES; offset: my_ulonglong) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  562)
* proc days*(d: int): TimeInterval {.inline.}: /pure/times.  (line  271)
* proc dbError*(db: DbConn) {.noreturn.}: /impure/db_postgres.
                                                             (line   14)
* proc dbError*(db: DbConn) {.noreturn.} <1>: /impure/db_mysql.
                                                             (line   18)
* proc dbError*(db: DbConn) {.noreturn.} <2>: /impure/db_sqlite.
                                                             (line   14)
* proc dbError*(db: var DbConn) {.tags: [ReadDbEffect, WriteDbEffect], raises: [DbError].}: /impure/db_odbc.
                                                             (line   14)
* proc dbError*(msg: string) {.noreturn, noinline.}: /pure/db_common.
                                                             (line   12)
* proc dbgUnregisterWatchpoints*():      /system/debugger.   (line   65)
* proc dbQuote*(s: string): string:      /impure/db_postgres.
                                                             (line   19)
* proc dbQuote*(s: string): string <1>:  /impure/db_mysql.   (line   23)
* proc dbQuote*(s: string): string <2>:  /impure/db_sqlite.  (line   19)
* proc dbQuote*(s: string): string {.noSideEffect.}: /impure/db_odbc.
                                                             (line   19)
* proc dealloc*(ai: ptr AddrInfo):       /pure/nativesockets.
                                                             (line   93)
* proc dealloc*(p: pointer) {.noconv, rtl, tags: [], benign.}: /system.
                                                             (line 1589)
* proc deallocCStringArray*(a: cstringArray): /system.       (line 2316)
* proc deallocShared*(p: pointer) {.noconv, rtl, benign.}: /system.
                                                             (line 1651)
* proc debug*(a2: cstring) {.varargs, extdecl, importc: "PDC_debug", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1651)
* proc debug*(debug: cstring) {.stdcall, dynlib: lib, importc: "mysql_debug".}: /wrappers/mysql.
                                                             (line  602)
* proc debugEcho*(x: varargs[typed, `$`]) {.magic: "Echo", noSideEffect, tags: [],: /system.
                                                             (line 2053)
* proc dec*[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: "Dec", noSideEffect.}: /system.
                                                             (line  521)
* proc decimalToRoman*(number: range[1 .. 3999]): string: /pure/romans.
                                                             (line   19)
* proc declared*(x: expr): bool {.magic: "Defined", noSideEffect, compileTime.}: /system.
                                                             (line  206)
* proc declaredInScope*(x: expr): bool {.magic: "DefinedInScope", noSideEffect,: /system.
                                                             (line  222)
* proc decode*(s: string): string:       /pure/base64.       (line   23)
* proc decodeURI*(uri: cstring): cstring {.importc, nodecl.}: /js/dom.
                                                             (line  280)
* proc decodeURIComponent*(uri: cstring): cstring {.importc, nodecl.}: /js/dom.
                                                             (line  292)
* proc decodeUrl*(s: string): string:    /pure/cgi.          (line   27)
* proc deduplicate*[T](seq1: seq[T]): seq[T]: /pure/collections/sequtils.
                                                             (line   46)
* proc deepCopy*[T](x: var T; y: T) {.noSideEffect, magic: "DeepCopy".}: /system.
                                                             (line 2677)
* proc defaultConfig*(): StringTableRef: /packages/docutils/rstgen.
                                                             (line  174)
* proc defaultFilename*(): string:       /pure/logging.      (line   52)
* proc defaultFindFile*(filename: string): string {.procvar.}: /packages/docutils/rst.
                                                             (line   36)
* proc defaultMsgHandler*(filename: string; line, col: int; msgkind: MsgKind; arg: string) {.: /packages/docutils/rst.
                                                             (line   32)
* proc defaultOnProgressChanged*(total, progress: BiggestInt; speed: float): Future[void] {.: /pure/asyncftpclient.
                                                             (line   80)
* proc default_loop*(): PLoop {.importc: "uv_default_loop", header: "uv.h".}: /wrappers/libuv.
                                                             (line   18)
* proc defined*(x: expr): bool {.magic: "Defined", noSideEffect, compileTime.}: /system.
                                                             (line  196)
* proc definedInScope*(x: expr): bool {.magic: "DefinedInScope", noSideEffect,: /system.
                                                             (line  216)
* proc defineSymbol*(s: PccState; sym, value: cstring) {.cdecl,: /wrappers/tinyc.
                                                             (line   59)
* proc def_prog_mode*(): cint {.extdecl, importc: "def_prog_mode", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  216)
* proc def_shell_mode*(): cint {.extdecl, importc: "def_shell_mode", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  219)
* proc degree*(p: Poly): int:            /pure/poly.         (line   15)
* proc degToRad*(deg: float): float {.inline.}: /pure/basic2d.
                                                             (line  510)
* proc degToRad*[T: float32 | float64](d: T): T {.inline.}: /pure/math.
                                                             (line  249)
* proc deinitCond*(cond: var Cond) {.inline.}: /core/locks.  (line   44)
* proc deinitGeneralTokenizer*(g: var GeneralTokenizer): /packages/docutils/highlite.
                                                             (line   23)
* proc deinitLock*(lock: var Lock) {.inline.}: /core/locks.  (line   19)
* proc deinitSharedList*[A](t: var SharedList[A]): /pure/collections/sharedlist.
                                                             (line   27)
* proc deinitSharedTable*[A, B](t: var SharedTable[A, B]): /pure/collections/sharedtables.
                                                             (line   65)
* proc del*(father: NimNode; idx = 0; n = 1) {.magic: "NDel", noSideEffect.}: /core/macros.
                                                             (line  105)
* proc del*(monitor: FSMonitor; wd: cint): /pure/fsmonitor.  (line   51)
* proc del*[A, B](t: TableRef[A, B]; key: A): /pure/collections/tables.
                                                             (line  175)
* proc del*[A, B](t: var SharedTable[A, B]; key: A): /pure/collections/sharedtables.
                                                             (line   50)
* proc del*[A, B](t: var Table[A, B]; key: A): /pure/collections/tables.
                                                             (line   66)
* proc del*[T](x: var seq[T]; i: Natural) {.noSideEffect.}: /system.
                                                             (line 1389)
* proc delay_output*(a2: cint): cint {.extdecl, importc: "delay_output",: /wrappers/pdcurses.
                                                             (line  222)
* proc delch*(): cint {.extdecl, importc: "delch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  226)
* proc delete*(n: XmlNode; i: Natural) {.noSideEffect.}: /pure/xmltree.
                                                             (line  105)
* proc delete*(obj: JsonNode; key: string): /pure/json.      (line  273)
* proc delete*(s: var string; first, last: int) {.noSideEffect, rtl, extern: "nsuDelete".}: /pure/strutils.
                                                             (line  586)
* proc delete*[T](s: var seq[T]; first, last: Natural): /pure/collections/sequtils.
                                                             (line  193)
* proc delete*[T](x: var seq[T]; i: Natural) {.noSideEffect.}: /system.
                                                             (line 1397)
* proc deleteData*(n: Node; start, len: int): /js/dom.       (line  121)
* proc deleteFileW*(pathName: WideCString): int32 {.importc: "DeleteFileW",: /windows/winlean.
                                                             (line  506)
* proc deleteln*(): cint {.extdecl, importc: "deleteln", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  229)
* proc delHandleWrite*(s: AsyncSocket):  /deprecated/pure/asyncio.
                                                             (line  166)
* proc delscreen*(a2: ptr SCREEN) {.extdecl, importc: "delscreen", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  232)
* proc delwin*(a2: ptr WINDOW): cint {.extdecl, importc: "delwin", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  235)
* proc del_panel*(pan: ptr PANEL): cint {.extdecl, importc: "del_panel",: /wrappers/pdcurses.
                                                             (line 1708)
* proc dequeue*[T](q: var Queue[T]): T:  /pure/collections/queues.
                                                             (line   38)
* proc derivative*(p: Poly): Poly:       /pure/poly.         (line   54)
* proc derwin*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr WINDOW {.extdecl,: /wrappers/pdcurses.
                                                             (line  238)
* proc destroy*(ih: PIhandle) {.importc: "IupDestroy", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  160)
* proc destroy_param*(param: ptr Parameter) {.cdecl, importc: "svm_destroy_param",: /wrappers/libsvm.
                                                             (line  119)
* proc detach*(child: PIhandle) {.importc: "IupDetach", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  163)
* proc determinant*(m: Matrix3d): float: /pure/basic3d.      (line  151)
* proc determinant*(t: Matrix2d): float: /pure/basic2d.      (line  133)
* proc dfa_exec*(code: ptr Pcre; extra: ptr ExtraData; subject: cstring; length: cint;: /wrappers/pcre.
                                                             (line  134)
* proc dial*(theType: cstring): PIhandle {.cdecl, importc: "IupDial", dynlib: dllname.}: /wrappers/iup.
                                                             (line  682)
* proc dialog*(child: PIhandle): PIhandle {.importc: "IupDialog", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  490)
* proc diff*(p: Poly; x: float): float:  /pure/poly.         (line   59)
* proc difference*[A](s1, s2: HashSet[A]): HashSet[A]: /pure/collections/sets.
                                                             (line  251)
* proc difftime*(a1, a2: Time): cdouble {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1234)
* proc dirExists*(dir: string): bool {.inline.}: /pure/os.   (line  155)
* proc dirExists*(dir: string): bool {.tags: [ReadIOEffect].}: /system/nimscript.
                                                             (line   92)
* proc dirname*(a1: cstring): cstring {.importc, header: "<libgen.h>".}: /posix/posix.
                                                             (line  318)
* proc disableCache*() {.rtl, extern: "nro$1".}: /pure/ropes.
                                                             (line   32)
* proc disableExternalCapture*(w: Window): /js/dom.          (line   49)
* proc disableProfiling*():              /pure/nimprof.      (line   13)
* proc disable_reads_from_master*(MySQL: PMySQL) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  466)
* proc disable_rpl_parse*(MySQL: PMySQL) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  453)
* proc disjoint*[A](s1, s2: HashSet[A]): bool: /pure/collections/sets.
                                                             (line  299)
* proc dist*(a, b: Point2d): float {.inline.}: /pure/basic2d.
                                                             (line  373)
* proc dist*(a, b: Point3d): float {.inline.}: /pure/basic3d.
                                                             (line  362)
* proc distribute*[T](s: seq[T]; num: Positive; spread = true): seq[seq[T]]: /pure/collections/sequtils.
                                                             (line   78)
* proc divMod*(p, d: Poly; q, r: var Poly): /pure/poly.      (line   84)
* proc dlclose*(a1: pointer): cint {.importc, header: "<dlfcn.h>".}: /posix/posix.
                                                             (line  226)
* proc dlerror*(): cstring {.importc, header: "<dlfcn.h>".}: /posix/posix.
                                                             (line  229)
* proc dlopen*(a1: cstring; a2: cint): pointer {.importc, header: "<dlfcn.h>".}: /posix/posix.
                                                             (line  232)
* proc dlsym*(a1: pointer; a2: cstring): pointer {.importc, header: "<dlfcn.h>".}: /posix/posix.
                                                             (line  235)
* proc documentElement*(doc: PDocument): PElement: /pure/xmldom.
                                                             (line   42)
* proc dot*(v1, v2: Vector2d): float:    /pure/basic2d.      (line  310)
* proc dot*(v1, v2: Vector3d): float {.inline.}: /pure/basic3d.
                                                             (line  307)
* proc doupdate*(): cint {.extdecl, importc: "doupdate", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  242)
* proc downloadFile*(url: string; outputFilename: string;: /pure/httpclient.
                                                             (line  224)
* proc draino*(a2: cint): cint {.extdecl, importc: "draino", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1485)
* proc drop_db*(MySQL: PMySQL; DB: cstring): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  786)
* proc dump_debug_info*(MySQL: PMySQL): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  498)
* proc dup*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  801)
* proc dup2*(a1, a2: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  804)
* proc duplicateHandle*(hSourceProcessHandle: HANDLE; hSourceHandle: HANDLE;: /windows/winlean.
                                                             (line  483)
* proc dupwin*(a2: ptr WINDOW): ptr WINDOW {.extdecl, importc: "dupwin",: /wrappers/pdcurses.
                                                             (line  245)
* proc echo*(): cint {.extdecl, importc: "echo", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  253)
* proc echo*(x: varargs[typed, `$`]) {.magic: "Echo", tags: [WriteIOEffect], benign,: /system.
                                                             (line 2035)
* proc echochar*(a2: cunsignedlong): cint {.extdecl, importc: "echochar",: /wrappers/pdcurses.
                                                             (line  249)
* proc echo_wchar*(a2: ptr cunsignedlong): cint {.extdecl, importc: "echo_wchar",: /wrappers/pdcurses.
                                                             (line 1101)
* proc editDistance*(a, b: string): int {.noSideEffect, rtl, extern: "nsuEditDistance".}: /pure/strutils.
                                                             (line  671)
* proc embedded*(): my_bool {.stdcall, dynlib: lib, importc: "mysql_embedded".}: /wrappers/mysql.
                                                             (line  612)
* proc emit*(emitter: var EventEmitter; event: string; args: EventArgs): /pure/events.
                                                             (line   53)
* proc emit*(emitter: var EventEmitter; eventhandler: var EventHandler; args: EventArgs): /pure/events.
                                                             (line   48)
* proc empty*(s: IntSet): bool {.inline, deprecated.}: /pure/collections/intsets.
                                                             (line   59)
* proc enableCache*() {.rtl, extern: "nro$1".}: /pure/ropes. (line   26)
* proc enableDebug*(s: PccState) {.importc: "tcc_enable_debug", cdecl.}: /wrappers/tinyc.
                                                             (line   30)
* proc enableExternalCapture*(w: Window): /js/dom.           (line   52)
* proc enableProfiling*():               /pure/nimprof.      (line   16)
* proc enable_reads_from_master*(MySQL: PMySQL) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  461)
* proc enable_rpl_parse*(MySQL: PMySQL) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  449)
* proc encode*(s: string; lineLen = 75; newLine = "\x0D\x0A"): string: /pure/base64.
                                                             (line   15)
* proc encode*[T: SomeInteger | char](s: openarray[T]; lineLen = 75; newLine = "\x0D\x0A"): string: /pure/base64.
                                                             (line    6)
* proc encodeURI*(uri: cstring): cstring {.importc, nodecl.}: /js/dom.
                                                             (line  283)
* proc encodeURIComponent*(uri: cstring): cstring {.importc, nodecl.}: /js/dom.
                                                             (line  295)
* proc encodeUrl*(s: string): string:    /pure/cgi.          (line   19)
* proc encrypt*(a1: array[0 .. 63, char]; a2: cint) {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  807)
* proc endAnchor*(): Peg {.inline.}:     /pure/pegs.         (line  152)
* proc endgrent*() {.importc, header: "<grp.h>".}: /posix/posix.
                                                             (line  296)
* proc endhostent*() {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1721)
* proc endnetent*() {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1724)
* proc endOfFile*(f: File): bool {.tags: [], benign.}: /system.
                                                             (line 2127)
* proc endprotoent*() {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1727)
* proc endpwent*() {.importc, header: "<pwd.h>".}: /posix/posix.
                                                             (line  378)
* proc endservent*() {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1730)
* proc endsWith*(s, suffix: string): bool {.noSideEffect, rtl, extern: "nsuEndsWith".}: /pure/strutils.
                                                             (line  419)
* proc endsWith*(s: string; suffix: Peg; start = 0): bool {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  293)
* proc endsWith*(s: string; suffix: Regex): bool: /impure/re.
                                                             (line  122)
* proc endwin*(): cint {.extdecl, importc: "endwin", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  256)
* proc enqueue*[T](q: var Queue[T]; item: T): /pure/collections/queues.
                                                             (line   33)
* proc entityToUtf8*(entity: string): string: /pure/htmlparser.
                                                             (line  223)
* proc eof*(res: PRES): my_bool {.stdcall, dynlib: lib, importc: "mysql_eof".}: /wrappers/mysql.
                                                             (line  321)
* proc epochTime*(): float {.rtl, extern: "nt$1", tags: [TimeEffect].}: /pure/times.
                                                             (line  193)
* proc epoll_create*(size: cint): cint {.importc: "epoll_create",: /posix/epoll.
                                                             (line   25)
* proc epoll_create1*(flags: cint): cint {.importc: "epoll_create1",: /posix/epoll.
                                                             (line   35)
* proc epoll_ctl*(epfd: cint; op: cint; fd: cint | SocketHandle; event: ptr epoll_event): cint {.: /posix/epoll.
                                                             (line   43)
* proc epoll_wait*(epfd: cint; events: ptr epoll_event; maxevents: cint; timeout: cint): cint {.: /posix/epoll.
                                                             (line   57)
* proc eqIdent*(a, b: string): bool:     /core/macros.       (line  604)
* proc equalMem*(a, b: pointer; size: Natural): bool {.importc: "equalMem", noDecl,: /system.
                                                             (line 1521)
* proc equals*(m1: Matrix2d; m2: Matrix2d; tol = 1e-06'f64): bool: /pure/basic2d.
                                                             (line  151)
* proc equals*(m1: Matrix3d; m2: Matrix3d; tol = 1e-06'f64): bool: /pure/basic3d.
                                                             (line  162)
* proc equals*(v1, v2: Vector2d; tol = 1e-06'f64): bool: /pure/basic2d.
                                                             (line  323)
* proc equals*(v1, v2: Vector3d; tol = 1e-06'f64): bool: /pure/basic3d.
                                                             (line  321)
* proc equalsFile*(r: Rope; f: File): bool {.rtl, extern: "nro$1File".}: /pure/ropes.
                                                             (line   95)
* proc equalsFile*(r: Rope; filename: string): bool {.rtl, extern: "nro$1Str".}: /pure/ropes.
                                                             (line  100)
* proc erase*(): cint {.extdecl, importc: "erase", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  262)
* proc erasechar*(): char {.extdecl, importc: "erasechar", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  259)
* proc eraseLine*(f: File):              /pure/terminal.     (line   83)
* proc eraseScreen*(f: File):            /pure/terminal.     (line   88)
* proc erasewchar*(a2: cstring): cint {.extdecl, importc: "erasewchar",: /wrappers/pdcurses.
                                                             (line 1105)
* proc erf*(x: float): float {.importc: "erf", header: "<math.h>".}: /pure/math.
                                                             (line  203)
* proc erfc*(x: float): float {.importc: "erfc", header: "<math.h>".}: /pure/math.
                                                             (line  208)
* proc ErrClearError*() {.cdecl, dynlib: DLLUtilName, importc: "ERR_clear_error".}: /wrappers/openssl.
                                                             (line  285)
* proc errcode*(db: PSqlite3): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_errcode".}: /wrappers/sqlite3.
                                                             (line  120)
* proc ErrFreeStrings*() {.cdecl, dynlib: DLLUtilName, importc: "ERR_free_strings".}: /wrappers/openssl.
                                                             (line  288)
* proc errmsg*(para1: PSqlite3): cstring {.cdecl, dynlib: Lib, importc: "sqlite3_errmsg".}: /wrappers/sqlite3.
                                                             (line  123)
* proc errmsg16*(para1: PSqlite3): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  126)
* proc errno*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib, importc: "mysql_errno".}: /wrappers/mysql.
                                                             (line  351)
* proc errno_to_sqlstate*(errno: cuint): cstring {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  245)
* proc error*(msg: string) {.magic: "NError", benign.}: /core/macros.
                                                             (line  186)
* proc error*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: "mysql_error".}: /wrappers/mysql.
                                                             (line  354)
* proc errorHandle*(p: Process): FileHandle {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  201)
* proc errorMsg*(my: JsonParser): string: /pure/json.        (line   75)
* proc errorMsg*(my: XmlParser): string: /pure/parsexml.     (line   71)
* proc errorMsg*(my: XmlParser; msg: string): string: /pure/parsexml.
                                                             (line   82)
* proc errorMsgExpected*(my: JsonParser; e: string): string: /pure/json.
                                                             (line   80)
* proc errorMsgExpected*(my: XmlParser; tag: string): string: /pure/parsexml.
                                                             (line   76)
* proc errorStr*(c: CfgParser; msg: string): string {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   46)
* proc errorStream*(p: Process): Stream {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  177)
* proc ErrRemoveState*(pid: cInt) {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  291)
* proc ERR_error_string*(e: cInt; buf: cstring): cstring {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  167)
* proc ERR_get_error*(): cInt {.cdecl, dynlib: DLLUtilName, importc.}: /wrappers/openssl.
                                                             (line  171)
* proc ERR_load_BIO_strings*() {.cdecl, dynlib: DLLUtilName, importc.}: /wrappers/openssl.
                                                             (line   36)
* proc err_name*(err: Err): cstring {.importc: "uv_err_name", header: "uv.h".}: /wrappers/libuv.
                                                             (line   42)
* proc ERR_peek_last_error*(): cInt {.cdecl, dynlib: DLLUtilName, importc.}: /wrappers/openssl.
                                                             (line  174)
* proc ERR_print_errors_fp*(fp: File) {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  164)
* proc esc*(target: OutputTarget; s: string; splitAfter = - 1): string: /packages/docutils/rstgen.
                                                             (line   82)
* proc escape*(s: string): string:       /pure/xmltree.      (line  154)
* proc escape*(s: string; prefix = "\""; suffix = "\""): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  630)
* proc escape*(uri: cstring): cstring {.importc, nodecl.}: /js/dom.
                                                             (line  286)
* proc escapeJson*(s: string): string:   /pure/json.         (line  284)
* proc escapePeg*(s: string): string:    /pure/pegs.         (line  352)
* proc escapeRe*(s: string): string:     /impure/re.         (line  169)
* proc escapeRe*(str: string): string:   /impure/nre.        (line  147)
* proc escape_string*(fto: cstring; `from`: cstring; from_length: int): int {.stdcall,: /wrappers/mysql.
                                                             (line  589)
* proc escChar*(target: OutputTarget; dest: var string; c: char) {.inline.}: /packages/docutils/rstgen.
                                                             (line   76)
* proc eval*(p: Poly; x: float): float:  /pure/poly.         (line   21)
* proc event_init*(loop: PLoop; handle: PFSEvent; filename: cstring; cb: FsEventProc): cint {.: /wrappers/libuv.
                                                             (line  382)
* proc EV_SET*(event: ptr KEvent; ident: cuint; filter: cshort; flags: cushort;: /posix/kqueue.
                                                             (line   57)
* proc excl*(s: var IntSet; key: int):   /pure/collections/intsets.
                                                             (line   29)
* proc excl*[A](s: var HashSet[A]; key: A): /pure/collections/sets.
                                                             (line  130)
* proc excl*[A](s: var HashSet[A]; other: HashSet[A]): /pure/collections/sets.
                                                             (line  141)
* proc excl*[T](c: var CritBitTree[T]; key: string): /pure/collections/critbits.
                                                             (line   81)
* proc excl*[T](x: var set[T]; y: T) {.magic: "Excl", noSideEffect.}: /system.
                                                             (line  597)
* proc exclFilePermissions*(filename: string; permissions: set[FilePermission]) {.rtl,: /pure/os.
                                                             (line  431)
* proc exec*(code: ptr Pcre; extra: ptr ExtraData; subject: cstring; length: cint;: /wrappers/pcre.
                                                             (line  140)
* proc exec*(command: string):           /system/nimscript.  (line  145)
* proc exec*(command: string; input: string; cache = "") {.raises: [OSError],: /system/nimscript.
                                                             (line  150)
* proc exec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {.: /impure/db_postgres.
                                                             (line   38)
* proc exec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {. <1>: /impure/db_mysql.
                                                             (line   35)
* proc exec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]) {. <2>: /impure/db_sqlite.
                                                             (line   31)
* proc exec*(db: DbConn; stmtName: SqlPrepared; args: varargs[string]) {.: /impure/db_postgres.
                                                             (line   44)
* proc exec*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]) {.: /impure/db_odbc.
                                                             (line   31)
* proc exec*(para1: PSqlite3; sql: cstring; para3: Callback; para4: pointer;: /wrappers/sqlite3.
                                                             (line   25)
* proc execAffectedRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_postgres.
                                                             (line  120)
* proc execAffectedRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {. <1>: /impure/db_mysql.
                                                             (line   86)
* proc execAffectedRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {. <2>: /impure/db_sqlite.
                                                             (line   83)
* proc execAffectedRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): int64 {.: /impure/db_postgres.
                                                             (line  127)
* proc execAffectedRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_odbc.
                                                             (line   82)
* proc execCmd*(command: string): int {.rtl, extern: "nosp$1", tags: [ExecIOEffect].}: /pure/osproc.
                                                             (line   57)
* proc execCmdEx*(command: string;:      /pure/osproc.       (line  244)
* proc execl*(a1, a2: cstring): cint {.varargs, importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  810)
* proc execle*(a1, a2: cstring): cint {.varargs, importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  813)
* proc execlp*(a1, a2: cstring): cint {.varargs, importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  816)
* proc execProcess*(command: string; args: openArray[string] = [];: /pure/osproc.
                                                             (line   41)
* proc execProcesses*(cmds: openArray[string];: /pure/osproc.
                                                             (line  215)
* proc execShellCmd*(command: string): int {.rtl, extern: "nos$1", tags: [ExecIOEffect].}: /pure/os.
                                                             (line  266)
* proc execv*(a1: cstring; a2: cstringArray): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  819)
* proc execve*(a1: cstring; a2, a3: cstringArray): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  822)
* proc execvp*(a1: cstring; a2: cstringArray): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  825)
* proc execvpe*(a1: cstring; a2: cstringArray; a3: cstringArray): cint {.importc,: /posix/posix.
                                                             (line  828)
* proc exepath*(buffer: cstring; size: var csize): cint {.importc: "uv_exepath",: /wrappers/libuv.
                                                             (line  402)
* proc exists*(key: string): bool:       /system/nimscript.  (line  166)
* proc existsCookie*(name: string): bool: /pure/cgi.         (line  265)
* proc existsDir*(dir: string): bool:    /system/nimscript.  (line  102)
* proc existsDir*(dir: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}: /pure/os.
                                                             (line  138)
* proc existsEnv*(key: string): bool {.tags: [ReadEnvEffect].}: /pure/os.
                                                             (line  286)
* proc existsEnv*(key: string): bool {.tags: [ReadIOEffect].}: /system/nimscript.
                                                             (line   82)
* proc existsFile*(filename: string): bool: /system/nimscript.
                                                             (line   97)
* proc existsFile*(filename: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}: /pure/os.
                                                             (line  133)
* proc existsFile*(ftp: AsyncFtpClient; file: string): Future[bool] {.async.}: /pure/asyncftpclient.
                                                             (line   50)
* proc existsFile*(ftp: FtpClient; file: string): bool: /deprecated/pure/ftpclient.
                                                             (line   64)
* proc existsKey*(node: JsonNode; key: string): bool {.deprecated.}: /pure/json.
                                                             (line  238)
* proc exitLoop*() {.importc: "IupExitLoop", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  114)
* proc exitnow*(code: int): void {.importc: "_exit", header: "<unistd.h>".}: /posix/posix.
                                                             (line  774)
* proc exp*(x: float): float {.importc: "exp", header: "<math.h>".}: /pure/math.
                                                             (line  122)
* proc exp*(z: Complex): Complex:        /pure/complex.      (line  149)
* proc expandFilename*(filename: string): string {.rtl, extern: "nos$1",: /pure/os.
                                                             (line  196)
* proc expandSymlink*(symlinkPath: string): string: /pure/os.
                                                             (line  439)
* proc expandTilde*(path: string): string {.tags: [ReadEnvEffect, ReadIOEffect].}: /pure/ospaths.
                                                             (line  210)
* proc expectKind*(n: NimNode; k: NimNodeKind) {.compileTime.}: /core/macros.
                                                             (line  320)
* proc expectKind*(n: NimNode; k: set[NimNodeKind]) {.compileTime.}: /core/macros.
                                                             (line  498)
* proc expectLen*(n: NimNode; len: int) {.compileTime.}: /core/macros.
                                                             (line  334)
* proc expectMinLen*(n: NimNode; min: int) {.compileTime.}: /core/macros.
                                                             (line  327)
* proc extendSeq*(x: Any):               /core/typeinfo.     (line   53)
* proc extractFilename*(path: string): string {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line  131)
* proc extractRGB*(a: Color): tuple[r, g, b: range[0 .. 255]]: /pure/colors.
                                                             (line   31)
* proc fac*(n: int): int {.noSideEffect.}: /pure/math.       (line   31)
* proc fail*[T](future: Future[T]; error: ref Exception): /pure/asyncdispatch.
                                                             (line   58)
* proc failed*(future: FutureBase): bool: /pure/asyncdispatch.
                                                             (line  116)
* proc failedAssertImpl*(msg: string) {.raises: [], tags: [].}: /system.
                                                             (line 2605)
* proc fchdir*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  835)
* proc fchmod*(a1: cint; a2: Mode): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1077)
* proc fchmod*(loop: PLoop; req: PFS; file: File; mode: cint; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  370)
* proc fchown*(a1: cint; a2: Uid; a3: Gid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  832)
* proc fchown*(loop: PLoop; req: PFS; file: File; uid: cint; gid: cint; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  378)
* proc fcntl*(a1: cint | SocketHandle; a2: cint): cint {.varargs, importc,: /posix/posix.
                                                             (line  241)
* proc fdatasync*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  838)
* proc fdatasync*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  327)
* proc FD_CLR*(a1: cint; a2: var TFdSet) {.importc, header: "<sys/select.h>".}: /posix/posix.
                                                             (line 1426)
* proc FD_ISSET*(a1: cint | SocketHandle; a2: var TFdSet): cint {.importc,: /posix/posix.
                                                             (line 1429)
* proc FD_ISSET*(socket: SocketHandle; set: var TFdSet): cint: /windows/winlean.
                                                             (line  446)
* proc FD_SET*(a1: cint | SocketHandle; a2: var TFdSet) {.importc: "FD_SET",: /posix/posix.
                                                             (line 1433)
* proc FD_SET*(socket: SocketHandle; s: var TFdSet): /windows/winlean.
                                                             (line  449)
* proc FD_ZERO*(a1: var TFdSet) {.importc, header: "<sys/select.h>".}: /posix/posix.
                                                             (line 1437)
* proc FD_ZERO*(s: var TFdSet):          /windows/winlean.   (line  452)
* proc feclearexcept*(excepts: cint): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   32)
* proc fegetenv*(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   72)
* proc fegetexceptflag*(flagp: ptr Tfexcept; excepts: cint): cint {.importc,: /pure/fenv.
                                                             (line   37)
* proc fegetround*(): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   62)
* proc feholdexcept*(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   78)
* proc fence*() {.inline.}:              /system/atomics.    (line  249)
* proc feraiseexcept*(excepts: cint): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   44)
* proc fesetenv*(a1: ptr Tfenv): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   85)
* proc fesetexceptflag*(flagp: ptr Tfexcept; excepts: cint): cint {.importc,: /pure/fenv.
                                                             (line   49)
* proc fesetround*(roundingDirection: cint): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   67)
* proc fetch_field*(result: PRES): PFIELD {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  581)
* proc fetch_fields*(res: PRES): PFIELD {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  328)
* proc fetch_field_direct*(res: PRES; fieldnr: cuint): PFIELD {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  324)
* proc fetch_lengths*(result: PRES): ptr int {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  577)
* proc fetch_row*(result: PRES): ROW {.stdcall, dynlib: lib, importc: "mysql_fetch_row".}: /wrappers/mysql.
                                                             (line  574)
* proc fetestexcept*(excepts: cint): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   56)
* proc feupdateenv*(envp: ptr Tfenv): cint {.importc, header: "<fenv.h>".}: /pure/fenv.
                                                             (line   91)
* proc fget*[K, V](self: Table[K, V]; key: K): V: /impure/nre/private/util.
                                                             (line    6)
* proc field_count*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  339)
* proc field_seek*(result: PRES; offset: FIELD_OFFSET): FIELD_OFFSET {.stdcall,: /wrappers/mysql.
                                                             (line  570)
* proc field_tell*(res: PRES): FIELD_OFFSET {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  335)
* proc fileDlg*(): PIhandle {.importc: "IupFileDlg", dynlib: dllname, cdecl.}: /wrappers/iup.
                                                             (line   39)
* proc fileExists*(filename: string): bool {.inline.}: /pure/os.
                                                             (line  150)
* proc fileExists*(filename: string): bool {.tags: [ReadIOEffect].}: /system/nimscript.
                                                             (line   87)
* proc fileExists*(ftp: FtpClient; file: string): bool {.deprecated.}: /deprecated/pure/ftpclient.
                                                             (line   54)
* proc fileNewer*(a, b: string): bool {.rtl, extern: "nos$1".}: /pure/os.
                                                             (line  179)
* proc fill*(): PIhandle {.importc: "IupFill", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  397)
* proc fill*[T](a: var openArray[T]; first, last: Natural; value: T): /pure/algorithm.
                                                             (line   22)
* proc fill*[T](a: var openArray[T]; value: T): /pure/algorithm.
                                                             (line   27)
* proc filter*() {.extdecl, importc: "filter", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  265)
* proc filter*[T](self: Option[T]; callback: proc (input: T): bool): Option[T]: /pure/options.
                                                             (line   57)
* proc filter*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): seq[T] {.inline.}: /pure/collections/sequtils.
                                                             (line  167)
* proc finalize*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_finalize".}: /wrappers/sqlite3.
                                                             (line  273)
* proc find*(s, sub: string; start: Natural = 0): int {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  478)
* proc find*(s: string; chars: set[char]; start: Natural = 0): int {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  494)
* proc find*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {.: /pure/pegs.
                                                             (line  245)
* proc find*(s: string; pattern: Peg; start = 0): int {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line  262)
* proc find*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int: /impure/re.
                                                             (line   88)
* proc find*(s: string; pattern: Regex; start = 0): int: /impure/re.
                                                             (line   95)
* proc find*(s: string; sub: char; start: Natural = 0): int {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  486)
* proc find*(str: string; pattern: Regex; start = 0; endpos = int.high): Option[RegexMatch]: /impure/nre.
                                                             (line   80)
* proc find*(w: Window; text: cstring; caseSensitive = false; backwards = false): /js/dom.
                                                             (line   55)
* proc find*[T, S](a: T; item: S): int {.inline.}: /system.  (line 1902)
* proc find*[T](L: DoublyLinkedList[T]; value: T): DoublyLinkedNode[T]: /pure/collections/lists.
                                                             (line   73)
* proc find*[T](L: DoublyLinkedRing[T]; value: T): DoublyLinkedNode[T]: /pure/collections/lists.
                                                             (line   85)
* proc find*[T](L: SinglyLinkedList[T]; value: T): SinglyLinkedNode[T]: /pure/collections/lists.
                                                             (line   67)
* proc find*[T](L: SinglyLinkedRing[T]; value: T): SinglyLinkedNode[T]: /pure/collections/lists.
                                                             (line   79)
* proc findAll*(n: XmlNode; tag: string): seq[XmlNode]: /pure/xmltree.
                                                             (line  215)
* proc findAll*(n: XmlNode; tag: string; result: var seq[XmlNode]): /pure/xmltree.
                                                             (line  198)
* proc findAll*(s: string; pattern: Peg; start = 0): seq[string] {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  268)
* proc findAll*(s: string; pattern: Regex; start = 0): seq[string]: /impure/re.
                                                             (line  101)
* proc findAll*(str: string; pattern: Regex; start = 0; endpos = int.high): seq[string]: /impure/nre.
                                                             (line   95)
* proc findBounds*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): tuple[: /pure/pegs.
                                                             (line  253)
* proc findBounds*(s: string; pattern: Regex;: /impure/re.   (line   46)
* proc findBounds*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): tuple[: /impure/re.
                                                             (line   38)
* proc findBounds*(s: string; pattern: Regex; start = 0): tuple[first, last: int]: /impure/re.
                                                             (line   56)
* proc findClose*(hFindFile: Handle) {.stdcall, dynlib: "kernel32", importc: "FindClose".}: /windows/winlean.
                                                             (line  278)
* proc findExe*(exe: string): string {.tags: [ReadDirEffect, ReadEnvEffect, ReadIOEffect].}: /pure/ospaths.
                                                             (line  226)
* proc findFirstFileW*(lpFileName: WideCString; lpFindFileData: var WIN32_FIND_DATA): Handle {.: /windows/winlean.
                                                             (line  268)
* proc findNextFileW*(hFindFile: Handle; lpFindFileData: var WIN32_FIND_DATA): int32 {.: /windows/winlean.
                                                             (line  273)
* proc finished*[T: proc](x: T): bool {.noSideEffect, inline.}: /system.
                                                             (line 2421)
* proc finished*[T](future: Future[T]): bool: /pure/asyncdispatch.
                                                             (line  108)
* proc firstChild*(n: PNode): PNode:     /pure/xmldom.       (line  114)
* proc fixterm*(): cint {.extdecl, importc: "fixterm", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1491)
* proc flash*(): cint {.extdecl, importc: "flash", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  268)
* proc flip*(b: ptr Breakpoint):         /system/debugger.   (line   55)
* proc floatVal*(n: NimNode): BiggestFloat {.magic: "NFloatVal", noSideEffect.}: /core/macros.
                                                             (line  118)
* proc floor*(x: float): float {.importc: "floor", header: "<math.h>".}: /pure/math.
                                                             (line  229)
* proc flush*() {.importc: "IupFlush", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  111)
* proc flush*(s: Stream):                /pure/streams.      (line   52)
* proc flushFile*(f: File) {.importc: "fflush", header: "<stdio.h>",: /system.
                                                             (line 2138)
* proc flushFileBuffers*(hFile: Handle): WINBOOL {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  208)
* proc flushinp*(): cint {.extdecl, importc: "flushinp", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  271)
* proc fmod*(x, y: float): float {.importc: "fmod", header: "<math.h>".}: /pure/math.
                                                             (line  243)
* proc fmtmsg*(a1: int; a2: cstring; a3: cint; a4, a5, a6: cstring): cint {.importc,: /posix/posix.
                                                             (line  254)
* proc fnmatch*(a1, a2: cstring; a3: cint): cint {.importc, header: "<fnmatch.h>".}: /posix/posix.
                                                             (line  258)
* proc focus*(e: Element):               /js/dom.            (line  214)
* proc focus*(w: Window):                /js/dom.            (line   58)
* proc fontDlg*(): PIhandle {.importc: "IupFontDlg", dynlib: dllname, cdecl.}: /wrappers/iup.
                                                             (line   48)
* proc fork*(): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  841)
* proc format*(formatstr: string; a: varargs[string, `$`]): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  764)
* proc format*(formatstr: Subex; a: varargs[string, `$`]): string {.noSideEffect, rtl,: /pure/subexes.
                                                             (line   45)
* proc format*(info: TimeInfo; f: string): string: /pure/times.
                                                             (line  317)
* proc formatBiggestFloat*(f: BiggestFloat; format: FloatFormatMode = ffDefault;: /pure/strutils.
                                                             (line  679)
* proc formatFloat*(f: float; format: FloatFormatMode = ffDefault;: /pure/strutils.
                                                             (line  696)
* proc formatMessageW*(dwFlags: int32; lpSource: pointer;: /windows/winlean.
                                                             (line  215)
* proc formatNamedVars*(frmt: string; varnames: openArray[string];: /packages/docutils/rstgen.
                                                             (line  170)
* proc formatSize*(bytes: BiggestInt; decimalSep = '.'): string: /pure/strutils.
                                                             (line  710)
* proc forward*(h: History):             /js/dom.            (line  250)
* proc forward*(w: Window):              /js/dom.            (line   61)
* proc fpathconf*(a1, a2: cint): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  844)
* proc frame*(child: PIhandle): PIhandle {.importc: "IupFrame", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  446)
* proc free*(s: cstring) {.importc: "free", header: "<stdlib.h>".}: /wrappers/linenoise/linenoise.
                                                             (line   44)
* proc free*(z: cstring) {.cdecl, dynlib: Lib, importc: "sqlite3_free".}: /wrappers/sqlite3.
                                                             (line   77)
* proc freeaddrinfo*(a1: ptr AddrInfo) {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1733)
* proc freeaddrinfo*(ai: ptr AddrInfo) {.importc: "uv_freeaddrinfo", header: "uv.h".}: /wrappers/libuv.
                                                             (line  259)
* proc freeaddrinfo*(ai: ptr AddrInfo) {.stdcall, importc: "freeaddrinfo", dynlib: ws2dll.}: /windows/winlean.
                                                             (line  465)
* proc freeclipboard*(a2: cstring): cint {.extdecl, importc: "PDC_freeclipboard",: /wrappers/pdcurses.
                                                             (line 1672)
* proc freeEnvironmentStringsW*(para1: WideCString): int32 {.stdcall,: /windows/winlean.
                                                             (line  310)
* proc freeShared*[T](p: ptr T) {.inline, benign.}: /system. (line 1660)
* proc free_and_destroy_model*(model_ptr_ptr: ptr ptr Model) {.cdecl,: /wrappers/libsvm.
                                                             (line  114)
* proc free_model_content*(model_ptr: ptr Model) {.cdecl,: /wrappers/libsvm.
                                                             (line  109)
* proc free_result*(result: PRES) {.stdcall, dynlib: lib, importc: "mysql_free_result".}: /wrappers/mysql.
                                                             (line  559)
* proc free_study*(extra: ptr ExtraData): /wrappers/pcre.    (line  190)
* proc free_substring*(stringptr: cstring): /wrappers/pcre.  (line  151)
* proc free_substring_list*(stringptr: cstringArray): /wrappers/pcre.
                                                             (line  154)
* proc free_table*(result: cstringArray) {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line   69)
* proc frexp*(x: float; exponent: var int): float {.importc: "frexp", header: "<math.h>".}: /pure/math.
                                                             (line  127)
* proc fromSeconds*(since1970: float): Time {.tags: [], raises: [], benign.}: /pure/times.
                                                             (line   60)
* proc fromSeconds*(since1970: int64): Time {.tags: [], raises: [], benign.}: /pure/times.
                                                             (line   66)
* proc fstat*(a1: cint; a2: var Stat): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1080)
* proc fstat*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.importc: "uv_fs_fstat",: /wrappers/libuv.
                                                             (line  315)
* proc fstatvfs*(a1: cint; a2: var Statvfs): cint {.importc, header: "<sys/statvfs.h>".}: /posix/posix.
                                                             (line 1071)
* proc fsync*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  847)
* proc fsync*(loop: PLoop; req: PFS; file: File; cb: FsProc): cint {.importc: "uv_fs_fsync",: /wrappers/libuv.
                                                             (line  323)
* proc ftok*(a1: cstring; a2: cint): Key {.importc, header: "<sys/ipc.h>".}: /posix/posix.
                                                             (line 1065)
* proc ftpClient*(address: string; port = Port(21); user, pass = ""): FtpClient: /deprecated/pure/ftpclient.
                                                             (line   12)
* proc ftruncate*(a1: cint; a2: Off): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  850)
* proc ftruncate*(loop: PLoop; req: PFS; file: File; offset: coff; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  331)
* proc ftw*(a1: cstring;:                /posix/posix.       (line  261)
* proc fullinfo*(code: ptr Pcre; extra: ptr ExtraData; what: cint; where: pointer): cint: /wrappers/pcre.
                                                             (line  157)
* proc futime*(loop: PLoop; req: PFS; file: File; atime: cdouble; mtime: cdouble; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  349)
* proc gai_strerror*(a1: cint): cstring {.importc: "(char *)$1", header: "<netdb.h>".}: /posix/posix.
                                                             (line 1736)
* proc gauge*(): PIhandle {.cdecl, importc: "IupGauge", dynlib: dllname.}: /wrappers/iup.
                                                             (line  679)
* proc gcd*[T](x, y: T): T:              /pure/math.         (line  283)
* proc gcInvariant*():                   /system/gc.         (line   13)
* proc gcInvariant*() <1>:               /system/gc2.        (line   13)
* proc GC_addCycleRoot*[T](p: ref T) {.inline.}: /system/gc. (line    6)
* proc GC_addCycleRoot*[T](p: ref T) {.inline.} <1>: /system/gc2.
                                                             (line    6)
* proc GC_addStack*(starts: pointer) {.cdecl, exportc.}: /system/gc_common.
                                                             (line    6)
* proc GC_disable*() {.rtl, inl, benign.}: /system.          (line 1962)
* proc GC_disableMarkAndSweep*() {.rtl, benign.}: /system.   (line 1989)
* proc GC_enable*() {.rtl, inl, benign.}: /system.           (line 1969)
* proc GC_enableMarkAndSweep*() {.rtl, benign.}: /system.    (line 1986)
* proc GC_fullCollect*() {.rtl, benign.}: /system.           (line 1974)
* proc GC_getStatistics*(): string {.rtl, benign.}: /system. (line 1999)
* proc GC_ref*(x: string) {.magic: "GCref", benign.}: /system.
                                                             (line 2011)
* proc GC_ref*[T](x: ref T) {.magic: "GCref", benign.}: /system.
                                                             (line 2005)
* proc GC_ref*[T](x: seq[T]) {.magic: "GCref", benign.}: /system.
                                                             (line 2008)
* proc GC_removeStack*(starts: pointer) {.cdecl, exportc.}: /system/gc_common.
                                                             (line    9)
* proc GC_setCurrentStack*(starts, pos: pointer) {.cdecl, exportc.}: /system/gc_common.
                                                             (line   12)
* proc GC_setMaxPause*(MaxPauseInUs: int): /system/gc.       (line   16)
* proc GC_setMaxPause*(MaxPauseInUs: int) <1>: /system/gc2.  (line   16)
* proc GC_setStrategy*(strategy: GC_Strategy) {.rtl, deprecated, benign.}: /system.
                                                             (line 1980)
* proc GC_step*(us: int; strongAdvice = false): /system/gc.  (line   19)
* proc GC_step*(us: int; strongAdvice = false) <1>: /system/gc2.
                                                             (line   19)
* proc GC_unref*(x: string) {.magic: "GCunref", benign.}: /system.
                                                             (line 2024)
* proc GC_unref*[T](x: ref T) {.magic: "GCunref", benign.}: /system.
                                                             (line 2018)
* proc GC_unref*[T](x: seq[T]) {.magic: "GCunref", benign.}: /system.
                                                             (line 2021)
* proc generatedTime*(oid: Oid): Time:   /pure/oids.         (line   43)
* proc genOid*(): Oid:                   /pure/oids.         (line   38)
* proc genSym*(kind: NimSymKind = nskLet; ident = ""): NimNode {.magic: "NGenSym",: /core/macros.
                                                             (line  238)
* proc get*(client: AsyncHttpClient; url: string): Future[Response] {.async.}: /pure/httpclient.
                                                             (line  282)
* proc get*(key: string): string:        /system/nimscript.  (line  161)
* proc get*(url: string; extraHeaders = ""; maxRedirects = 5;: /pure/httpclient.
                                                             (line  158)
* proc get*[T](self: Option[T]): T:      /pure/options.      (line   33)
* proc get*[T](self: Option[T]; otherwise: T): T: /pure/options.
                                                             (line   39)
* proc getActionName*(): cstring {.importc: "IupGetActionName", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  331)
* proc getaddrinfo*(a1, a2: cstring; a3: ptr AddrInfo; a4: var ptr AddrInfo): cint {.importc,: /posix/posix.
                                                             (line 1739)
* proc getaddrinfo*(a2: PLoop; handle: PGetAddrInfo; getaddrinfo_cb: GetAddrInfoProc;: /wrappers/libuv.
                                                             (line  253)
* proc getAddrInfo*(address: string; port: Port; domain: Domain = AF_INET;: /pure/nativesockets.
                                                             (line   85)
* proc getaddrinfo*(nodename, servname: cstring; hints: ptr AddrInfo;: /windows/winlean.
                                                             (line  459)
* proc getAddrString*(sockAddr: ptr SockAddr): string: /pure/nativesockets.
                                                             (line  147)
* proc getAllAttributes*(ih: PIhandle; names: cstringArray; n: cint): cint {.: /wrappers/iup.
                                                             (line  273)
* proc getAllDialogs*(names: cstringArray; n: cint): cint {.importc: "IupGetAllDialogs",: /wrappers/iup.
                                                             (line  346)
* proc getAllNames*(names: cstringArray; n: cint): cint {.importc: "IupGetAllNames",: /wrappers/iup.
                                                             (line  342)
* proc getAllRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {.: /impure/db_postgres.
                                                             (line   75)
* proc getAllRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {. <1>: /impure/db_mysql.
                                                             (line   58)
* proc getAllRows*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {. <2>: /impure/db_sqlite.
                                                             (line   54)
* proc getAllRows*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): seq[Row] {.: /impure/db_postgres.
                                                             (line   81)
* proc getAllRows*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): seq[Row] {.: /impure/db_odbc.
                                                             (line   54)
* proc getAppDir*(): string {.rtl, extern: "nos$1", tags: [ReadIOEffect].}: /pure/os.
                                                             (line  530)
* proc getAppFilename*(): string {.rtl, extern: "nos$1", tags: [ReadIOEffect].}: /pure/os.
                                                             (line  509)
* proc getApplicationDir*(): string {.rtl, extern: "nos$1", deprecated.}: /pure/os.
                                                             (line  524)
* proc getApplicationFilename*(): string {.rtl, extern: "nos$1", deprecated.}: /pure/os.
                                                             (line  518)
* proc getArgument*(n: PRstNode): string: /packages/docutils/rst.
                                                             (line   24)
* proc getAst*(macroOrTemplate: expr): NimNode {.magic: "ExpandToAst", noSideEffect.}: /core/macros.
                                                             (line  281)
* proc getAttribute*(el: PElement; name: string): string: /pure/xmldom.
                                                             (line  309)
* proc getAttribute*(ih: PIhandle; name: cstring): cstring {.importc: "IupGetAttribute",: /wrappers/iup.
                                                             (line  244)
* proc getAttribute*(n: Node; attr: cstring): cstring: /js/dom.
                                                             (line  124)
* proc getAttribute*(s: Style; attr: cstring; caseSensitive = false): cstring: /js/dom.
                                                             (line  271)
* proc getAttributeHandle*(ih: PIhandle; name: cstring): PIhandle {.: /wrappers/iup.
                                                             (line  358)
* proc getAttributeNode*(el: PElement; name: string): PAttr: /pure/xmldom.
                                                             (line  319)
* proc getAttributeNode*(n: Node; attr: cstring): Node: /js/dom.
                                                             (line  127)
* proc getAttributeNodeNS*(el: PElement; namespaceURI: string; localName: string): PAttr: /pure/xmldom.
                                                             (line  326)
* proc getAttributeNS*(el: PElement; namespaceURI: string; localName: string): string: /pure/xmldom.
                                                             (line  314)
* proc getAttributes*(ih: PIhandle): cstring {.importc: "IupGetAttributes", cdecl,: /wrappers/iup.
                                                             (line  248)
* proc getattrs*(a2: ptr WINDOW): cunsignedlong {.extdecl, importc: "getattrs",: /wrappers/pdcurses.
                                                             (line 1441)
* proc getbegx*(a2: ptr WINDOW): cint {.extdecl, importc: "getbegx", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1445)
* proc getbegy*(a2: ptr WINDOW): cint {.extdecl, importc: "getbegy", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1448)
* proc getBiggestFloat*(x: Any): BiggestFloat: /core/typeinfo.
                                                             (line  249)
* proc getBiggestInt*(x: Any): BiggestInt: /core/typeinfo.   (line  147)
* proc getBiggestUint*(x: Any): uint64:  /core/typeinfo.     (line  185)
* proc getbkgd*(a2: ptr WINDOW): cunsignedlong {.extdecl, importc: "getbkgd",: /wrappers/pdcurses.
                                                             (line  274)
* proc getbkgrnd*(a2: ptr cunsignedlong): cint {.extdecl, importc: "getbkgrnd",: /wrappers/pdcurses.
                                                             (line 1109)
* proc getbmap*(): cunsignedlong {.extdecl, importc: "getbmap", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1527)
* proc getBool*(x: Any): bool:           /core/typeinfo.     (line  202)
* proc getBrother*(ih: PIhandle): PIhandle {.importc: "IupGetBrother", cdecl,: /wrappers/iup.
                                                             (line  190)
* proc getBVal*(n: JsonNode; default: bool = false): bool: /pure/json.
                                                             (line  153)
* proc getCallback*(ih: PIhandle; name: cstring): Icallback {.importc: "IupGetCallback",: /wrappers/iup.
                                                             (line  308)
* proc getcchar*(a2: ptr cunsignedlong; a3: cstring; a4: ptr cunsignedlong; a5: ptr cshort;: /wrappers/pdcurses.
                                                             (line 1113)
* proc getCellId*[T](x: ref T): int:     /system/gc_ms.      (line    6)
* proc getch*(): char:                   /pure/terminal.     (line  124)
* proc getChar*(x: Any): char:           /core/typeinfo.     (line  197)
* proc getChild*(ih: PIhandle; pos: cint): PIhandle {.importc: "IupGetChild", cdecl,: /wrappers/iup.
                                                             (line  174)
* proc getChildCount*(ih: PIhandle): cint {.importc: "IupGetChildCount", cdecl,: /wrappers/iup.
                                                             (line  182)
* proc getChildPos*(ih, child: PIhandle): cint {.importc: "IupGetChildPos", cdecl,: /wrappers/iup.
                                                             (line  178)
* proc getClassAttributes*(classname: cstring; names: cstringArray; n: cint): cint {.: /wrappers/iup.
                                                             (line  371)
* proc getClassName*(ih: PIhandle): cstring {.importc: "IupGetClassName", cdecl,: /wrappers/iup.
                                                             (line  363)
* proc getClassType*(ih: PIhandle): cstring {.importc: "IupGetClassType", cdecl,: /wrappers/iup.
                                                             (line  367)
* proc getclipboard*(a2: cstringArray; a3: ptr clong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1676)
* proc getClockStr*(): string {.rtl, extern: "nt$1", tags: [TimeEffect].}: /pure/times.
                                                             (line  228)
* proc getColNumber*(L: BaseLexer; pos: int): int: /pure/lexbase.
                                                             (line   72)
* proc getColor*(x, y: cint; r, g, b: var byte): cint {.importc: "IupGetColor",: /wrappers/iup.
                                                             (line   77)
* proc getColumn*(c: CfgParser): int {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   31)
* proc getColumn*(my: JsonParser): int {.inline.}: /pure/json.
                                                             (line   60)
* proc getColumn*(my: XmlParser): int {.inline.}: /pure/parsexml.
                                                             (line   56)
* proc getCommand*(): string:            /system/nimscript.  (line   60)
* proc getCommandLineW*(): WideCString {.importc: "GetCommandLineW", stdcall,: /windows/winlean.
                                                             (line  315)
* proc getConfigDir*(): string {.rtl, extern: "nos$1",: /pure/ospaths.
                                                             (line  198)
* proc getContent*(url: string; extraHeaders = ""; maxRedirects = 5;: /pure/httpclient.
                                                             (line  173)
* proc getContentLength*(): string:      /pure/cgi.          (line   63)
* proc getContentType*(): string:        /pure/cgi.          (line   68)
* proc getcontext*(a1: var Ucontext): cint {.importc, header: "<ucontext.h>".}: /posix/posix.
                                                             (line 1540)
* proc getCookie*(name: string): TaintedString: /pure/cgi.   (line  260)
* proc getCreationTime*(file: string): Time {.rtl, extern: "nos$1".}: /pure/os.
                                                             (line  170)
* proc getCString*(x: Any): cstring:     /core/typeinfo.     (line  270)
* proc getCurrentDir*(): string {.rtl, extern: "nos$1", tags: [].}: /pure/os.
                                                             (line  185)
* proc getCurrentDirectoryW*(nBufferLength: int32; lpBuffer: WideCString): int32 {.: /windows/winlean.
                                                             (line  226)
* proc getCurrentEncoding*(): string:    /pure/encodings.    (line   19)
* proc getCurrentException*(): ref Exception {.compilerRtl, inl, benign.}: /system.
                                                             (line 2354)
* proc getCurrentExceptionMsg*(): string: /system/jssys.     (line   12)
* proc getCurrentExceptionMsg*(): string {.inline, benign.}: /system.
                                                             (line 2359)
* proc getCurrentLine*(L: BaseLexer; marker: bool = true): string: /pure/lexbase.
                                                             (line   77)
* proc getCurrentProcess*(): HANDLE {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  493)
* proc getcurx*(a2: ptr WINDOW): cint {.extdecl, importc: "getcurx", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1463)
* proc getcury*(a2: ptr WINDOW): cint {.extdecl, importc: "getcury", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1466)
* proc getcwd*(a1: cstring; a2: int): cstring {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  853)
* proc getdate*(a1: cstring): ptr Tm {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1237)
* proc getDateStr*(): string {.rtl, extern: "nt$1", tags: [TimeEffect].}: /pure/times.
                                                             (line  223)
* proc getDayOfWeek*(day, month, year: int): WeekDay: /pure/times.
                                                             (line  434)
* proc getDayOfWeekJulian*(day, month, year: int): WeekDay: /pure/times.
                                                             (line  439)
* proc getDaysInMonth*(month: Month; year: int): int: /pure/times.
                                                             (line  155)
* proc getDaysInYear*(year: int): int:   /pure/times.        (line  160)
* proc getDialog*(ih: PIhandle): PIhandle {.importc: "IupGetDialog", cdecl,: /wrappers/iup.
                                                             (line  198)
* proc getDialogChild*(ih: PIhandle; name: cstring): PIhandle {.: /wrappers/iup.
                                                             (line  202)
* proc getDocumentRoot*(): string:       /pure/cgi.          (line   73)
* proc getDOM*(): PDOMImplementation:    /pure/xmldom.       (line   15)
* proc getegid*(): Gid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  856)
* proc getElementById*(d: Document; id: cstring): Element: /js/dom.
                                                             (line  175)
* proc getElementsByClassName*(d: Document; name: cstring): seq[Element]: /js/dom.
                                                             (line  184)
* proc getElementsByClassName*(e: Element; name: cstring): seq[Element]: /js/dom.
                                                             (line  226)
* proc getElementsByName*(d: Document; name: cstring): seq[Element]: /js/dom.
                                                             (line  178)
* proc getElementsByTagName*(d: Document; name: cstring): seq[Element]: /js/dom.
                                                             (line  181)
* proc getElementsByTagName*(doc: PDocument; tagName: string): seq[PNode]: /pure/xmldom.
                                                             (line   94)
* proc getElementsByTagName*(e: Element; name: cstring): seq[Element]: /js/dom.
                                                             (line  223)
* proc getElementsByTagName*(el: PElement; name: string): seq[PNode]: /pure/xmldom.
                                                             (line  331)
* proc getElementsByTagNameNS*(doc: PDocument; namespaceURI: string; localName: string): seq[: /pure/xmldom.
                                                             (line  101)
* proc getElementsByTagNameNS*(el: PElement; namespaceURI: string; localName: string): seq[: /pure/xmldom.
                                                             (line  339)
* proc getElems*(n: JsonNode; default: seq[JsonNode] = @ []): seq[JsonNode]: /pure/json.
                                                             (line  168)
* proc getEnumField*(x: Any): string:    /core/typeinfo.     (line  226)
* proc getEnumField*(x: Any; ordinalValue: int): string: /core/typeinfo.
                                                             (line  219)
* proc getEnumOrdinal*(x: Any; name: string): int: /core/typeinfo.
                                                             (line  212)
* proc getEnv*(key: string): string {.tags: [ReadIOEffect].}: /system/nimscript.
                                                             (line   77)
* proc getEnv*(key: string): TaintedString {.tags: [ReadEnvEffect].}: /pure/os.
                                                             (line  277)
* proc getEnvironmentStringsW*(): WideCString {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  306)
* proc geteuid*(): Uid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  859)
* proc getExitCodeProcess*(hProcess: Handle; lpExitCode: var int32): WINBOOL {.stdcall,: /windows/winlean.
                                                             (line  195)
* proc getExt*(mimedb: MimeDB; mimetype: string; default = "txt"): string: /pure/mimetypes.
                                                             (line  503)
* proc getFd*(socket: AsyncSocket): SocketHandle: /pure/asyncnet.
                                                             (line  192)
* proc getFd*(socket: Socket): SocketHandle: /pure/net.      (line  425)
* proc getFD*(socket: Socket): SocketHandle: /deprecated/pure/sockets.
                                                             (line  615)
* proc getFields*(n: JsonNode; default: seq[tuple[key: string, val: JsonNode]] = @ []): seq[: /pure/json.
                                                             (line  160)
* proc getFieldValue*(n: PRstNode): string: /packages/docutils/rst.
                                                             (line   39)
* proc getFieldValue*(n: PRstNode; fieldname: string): string: /packages/docutils/rst.
                                                             (line   21)
* proc getFile*(arq: cstring): cint {.importc: "IupGetFile", dynlib: dllname, cdecl.}: /wrappers/iup.
                                                             (line   51)
* proc getFileAttributesW*(lpFileName: WideCString): int32 {.stdcall,: /windows/winlean.
                                                             (line  288)
* proc getFileHandle*(f: File): FileHandle {.importc: "fileno", header: "<stdio.h>".}: /system.
                                                             (line 2292)
* proc getFileInfo*(file: File): FileInfo: /pure/os.         (line  556)
* proc getFileInfo*(handle: FileHandle): FileInfo: /pure/os. (line  547)
* proc getFileInfo*(path: string; followSymlink = true): FileInfo: /pure/os.
                                                             (line  559)
* proc getFileInformationByHandle*(hFile: Handle; lpFileInformation: ptr BY_HANDLE_FILE_INFORMATION): WINBOOL {.: /windows/winlean.
                                                             (line  341)
* proc getFilename*(c: CfgParser): string {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   41)
* proc getFilename*(my: JsonParser): string {.inline.}: /pure/json.
                                                             (line   70)
* proc getFilename*(my: XmlParser): string {.inline.}: /pure/parsexml.
                                                             (line   66)
* proc getFilePermissions*(filename: string): set[FilePermission] {.rtl,: /pure/os.
                                                             (line  220)
* proc getFilePos*(f: AsyncFile): int64: /pure/asyncfile.    (line   36)
* proc getFilePos*(f: File): int64 {.benign.}: /system.      (line 2286)
* proc getFileSize*(f: File): int64 {.tags: [ReadIOEffect], benign.}: /system.
                                                             (line 2227)
* proc getFileSize*(file: string): BiggestInt {.rtl, extern: "nos$1",: /pure/os.
                                                             (line  541)
* proc getFileSize*(hFile: Handle; lpFileSizeHigh: ptr DWORD): DWORD {.stdcall,: /windows/winlean.
                                                             (line  521)
* proc getFloat*(ih: PIhandle; name: cstring): cfloat {.importc: "IupGetFloat", cdecl,: /wrappers/iup.
                                                             (line  264)
* proc getFloat*(my: JsonParser): float {.inline.}: /pure/json.
                                                             (line   50)
* proc getFloat*(x: Any): float:         /core/typeinfo.     (line  232)
* proc getFloat32*(x: Any): float32:     /core/typeinfo.     (line  237)
* proc getFloat64*(x: Any): float64:     /core/typeinfo.     (line  243)
* proc getFNum*(n: JsonNode; default: float = 0.0'f64): float: /pure/json.
                                                             (line  145)
* proc getFocus*(): PIhandle {.importc: "IupGetFocus", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  297)
* proc getFrame*(): PFrame {.compilerRtl, inl.}: /system/excpt.
                                                             (line   15)
* proc getFreeMem*(): int {.rtl.}:       /system.            (line 1751)
* proc getFreeSharedMem*(): int {.rtl.}: /system.            (line 1769)
* proc getFullPathNameW*(lpFileName: WideCString; nBufferLength: int32;: /windows/winlean.
                                                             (line  281)
* proc getFunction*(name: cstring): Icallback {.importc: "IupGetFunction", cdecl,: /wrappers/iup.
                                                             (line  322)
* proc getGatewayInterface*(): string:   /pure/cgi.          (line   78)
* proc getgid*(): Gid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  862)
* proc getGlobal*(name: cstring): cstring {.importc: "IupGetGlobal", cdecl,: /wrappers/iup.
                                                             (line  290)
* proc getGlobal*(slot: int): VarSlot {.inline.}: /system/debugger.
                                                             (line   38)
* proc getGlobalDispatcher*(): PDispatcher: /pure/asyncdispatch.
                                                             (line  149)
* proc getGlobalLen*(): int {.inline.}:  /system/debugger.   (line   33)
* proc getGMTime*(t: Time): TimeInfo {.tags: [TimeEffect], raises: [], benign.}: /pure/times.
                                                             (line   46)
* proc getgrent*(): ptr Group {.importc, header: "<grp.h>".}: /posix/posix.
                                                             (line  293)
* proc getgrgid*(a1: Gid): ptr Group {.importc, header: "<grp.h>".}: /posix/posix.
                                                             (line  279)
* proc getgrgid_r*(a1: Gid; a2: ptr Group; a3: cstring; a4: int; a5: ptr ptr Group): cint {.: /posix/posix.
                                                             (line  285)
* proc getgrnam*(a1: cstring): ptr Group {.importc, header: "<grp.h>".}: /posix/posix.
                                                             (line  282)
* proc getgrnam_r*(a1: cstring; a2: ptr Group; a3: cstring; a4: int; a5: ptr ptr Group): cint {.: /posix/posix.
                                                             (line  289)
* proc getgroups*(a1: cint; a2: ptr array[0 .. 255, Gid]): cint {.importc,: /posix/posix.
                                                             (line  865)
* proc getHandle*(name: cstring): PIhandle {.importc: "IupGetHandle", cdecl,: /wrappers/iup.
                                                             (line  334)
* proc getHandlers*(): seq[Logger]:      /pure/logging.      (line   88)
* proc getHomeDir*(): string {.rtl, extern: "nos$1", tags: [ReadEnvEffect, ReadIOEffect].}: /pure/ospaths.
                                                             (line  190)
* proc gethostbyaddr*(a1: pointer; a2: Socklen; a3: cint): ptr Hostent {.importc,: /posix/posix.
                                                             (line 1743)
* proc gethostbyaddr*(ip: ptr InAddr; len: cuint; theType: cint): ptr Hostent {.stdcall,: /windows/winlean.
                                                             (line  360)
* proc getHostByAddr*(ip: string): Hostent {.tags: [ReadIOEffect].}: /pure/nativesockets.
                                                             (line  132)
* proc getHostByAddr*(ip: string): Hostent {.tags: [ReadIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  240)
* proc gethostbyname*(a1: cstring): ptr Hostent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1747)
* proc gethostbyname*(name: cstring): ptr Hostent {.stdcall, importc: "gethostbyname",: /windows/winlean.
                                                             (line  364)
* proc getHostByName*(name: string): Hostent {.tags: [ReadIOEffect].}: /pure/nativesockets.
                                                             (line  137)
* proc getHostByName*(name: string): Hostent {.tags: [ReadIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  245)
* proc gethostent*(): ptr Hostent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1750)
* proc gethostid*(): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  869)
* proc gethostname*(a1: cstring; a2: int): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  872)
* proc getHttpAccept*(): string:         /pure/cgi.          (line   83)
* proc getHttpAcceptCharset*(): string:  /pure/cgi.          (line   88)
* proc getHttpAcceptEncoding*(): string: /pure/cgi.          (line   93)
* proc getHttpAcceptLanguage*(): string: /pure/cgi.          (line   98)
* proc getHttpConnection*(): string:     /pure/cgi.          (line  103)
* proc getHttpCookie*(): string:         /pure/cgi.          (line  108)
* proc getHttpHost*(): string:           /pure/cgi.          (line  113)
* proc getHttpReferer*(): string:        /pure/cgi.          (line  118)
* proc getHttpUserAgent*(): string:      /pure/cgi.          (line  123)
* proc getImpl*(s: NimSym): NimNode {.magic: "GetImpl", noSideEffect.}: /core/macros.
                                                             (line  180)
* proc getInt*(ih: PIhandle; name: cstring): cint {.importc: "IupGetInt", cdecl,: /wrappers/iup.
                                                             (line  252)
* proc getInt*(my: JsonParser): BiggestInt {.inline.}: /pure/json.
                                                             (line   45)
* proc getInt*(x: Any): int:             /core/typeinfo.     (line  122)
* proc getInt16*(x: Any): int16:         /core/typeinfo.     (line  132)
* proc getInt2*(ih: PIhandle; name: cstring): cint {.importc: "IupGetInt2", cdecl,: /wrappers/iup.
                                                             (line  256)
* proc getInt32*(x: Any): int32:         /core/typeinfo.     (line  137)
* proc getInt64*(x: Any): int64:         /core/typeinfo.     (line  142)
* proc getInt8*(x: Any): int8:           /core/typeinfo.     (line  127)
* proc getIntInt*(ih: PIhandle; name: cstring; i1, i2: var cint): cint {.: /wrappers/iup.
                                                             (line  260)
* proc getLanguage*(): cstring {.importc: "IupGetLanguage", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  157)
* proc getLastAccessTime*(file: string): Time {.rtl, extern: "nos$1".}: /pure/os.
                                                             (line  165)
* proc getLastError*(): int32 {.importc: "GetLastError", stdcall, dynlib: "kernel32".}: /windows/winlean.
                                                             (line  212)
* proc getLastModificationTime*(file: string): Time {.rtl, extern: "nos$1".}: /pure/os.
                                                             (line  160)
* proc getLine*(c: CfgParser): int {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   36)
* proc getLine*(my: JsonParser): int {.inline.}: /pure/json. (line   65)
* proc getLine*(my: XmlParser): int {.inline.}: /pure/parsexml.
                                                             (line   61)
* proc getLocal*(frame: PFrame; slot: int): VarSlot {.inline.}: /system/debugger.
                                                             (line   27)
* proc getLocalAddr*(socket: Socket): (string, Port): /pure/net.
                                                             (line  230)
* proc getLocalAddr*(socket: SocketHandle; domain: Domain): (string, Port): /pure/nativesockets.
                                                             (line  157)
* proc getLocalTime*(t: Time): TimeInfo {.tags: [TimeEffect], raises: [], benign.}: /pure/times.
                                                             (line   40)
* proc getLogFilter*(): Level:           /pure/logging.      (line   98)
* proc getlogin*(): cstring {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  875)
* proc getlogin_r*(a1: cstring; a2: int): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  878)
* proc getmaxx*(a2: ptr WINDOW): cint {.extdecl, importc: "getmaxx", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1451)
* proc getmaxy*(a2: ptr WINDOW): cint {.extdecl, importc: "getmaxy", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1454)
* proc getMD5*(s: string): string:       /pure/md5.          (line   43)
* proc getMimetype*(mimedb: MimeDB; ext: string; default = "text/plain"): string: /pure/mimetypes.
                                                             (line  497)
* proc getModuleFileNameW*(handle: Handle; buf: WideCString; size: int32): int32 {.: /windows/winlean.
                                                             (line  251)
* proc getmouse*(): cunsignedlong {.extdecl, importc: "getmouse", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1524)
* proc getName*(ih: PIhandle): cstring {.importc: "IupGetName", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  350)
* proc getNamedItem*(nList: seq[PAttr]; name: string): PAttr: /pure/xmldom.
                                                             (line  231)
* proc getNamedItem*(nList: seq[PNode]; name: string): PNode: /pure/xmldom.
                                                             (line  225)
* proc getNamedItemNS*(nList: seq[PAttr]; namespaceURI: string; localName: string): PAttr: /pure/xmldom.
                                                             (line  243)
* proc getNamedItemNS*(nList: seq[PNode]; namespaceURI: string; localName: string): PNode: /pure/xmldom.
                                                             (line  237)
* proc getnameinfo*(a1: ptr SockAddr; a2: SockLen; a3: cstring; a4: SockLen; a5: cstring;: /windows/winlean.
                                                             (line  437)
* proc getnameinfo*(a1: ptr SockAddr; a2: Socklen; a3: cstring; a4: Socklen; a5: cstring;: /posix/posix.
                                                             (line 1753)
* proc getnetbyaddr*(a1: int32; a2: cint): ptr Tnetent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1758)
* proc getnetbyname*(a1: cstring): ptr Tnetent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1761)
* proc getnetent*(): ptr Tnetent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1764)
* proc getNextChild*(ih, child: PIhandle): PIhandle {.importc: "IupGetNextChild", cdecl,: /wrappers/iup.
                                                             (line  186)
* proc getNextToken*(g: var GeneralTokenizer; lang: SourceLanguage): /packages/docutils/highlite.
                                                             (line   26)
* proc getnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "getnstr",: /wrappers/pdcurses.
                                                             (line  278)
* proc getNum*(m: var MersenneTwister): int: /pure/mersenne. (line   19)
* proc getNum*(n: JsonNode; default: BiggestInt = 0): BiggestInt: /pure/json.
                                                             (line  138)
* proc getn_wstr*(a2: ptr cint; a3: cint): cint {.extdecl, importc: "getn_wstr",: /wrappers/pdcurses.
                                                             (line 1118)
* proc getOccupiedMem*(): int {.rtl.}:   /system.            (line 1745)
* proc getOccupiedSharedMem*(): int {.rtl.}: /system.        (line 1762)
* proc getopt*(a1: cint; a2: cstringArray; a3: cstring): cint {.importc,: /posix/posix.
                                                             (line  881)
* proc getOrDefault*(t: StringTableRef; key: string): string: /pure/strtabs.
                                                             (line   49)
* proc getOrDefault*[A, B](t: OrderedTableRef[A, B]; key: A): B: /pure/collections/tables.
                                                             (line  308)
* proc getOrDefault*[A, B](t: OrderedTable[A, B]; key: A): B: /pure/collections/tables.
                                                             (line  226)
* proc getOrDefault*[A, B](t: TableRef[A, B]; key: A): B: /pure/collections/tables.
                                                             (line  145)
* proc getOrDefault*[A, B](t: Table[A, B]; key: A): B: /pure/collections/tables.
                                                             (line   53)
* proc getOrDefault*[A](t: CountTableRef[A]; key: A): int: /pure/collections/tables.
                                                             (line  476)
* proc getOrDefault*[A](t: CountTable[A]; key: A): int: /pure/collections/tables.
                                                             (line  396)
* proc getOverlappedResult*(hFile: Handle; lpOverlapped: OVERLAPPED;: /windows/winlean.
                                                             (line  570)
* proc getParam*(title: cstring; action: Iparamcb; userData: pointer; format: cstring): cint {.: /wrappers/iup.
                                                             (line   81)
* proc getParamv*(title: cstring; action: Iparamcb; userData: pointer; format: cstring;: /wrappers/iup.
                                                             (line   85)
* proc getParent*(ih: PIhandle): PIhandle {.importc: "IupGetParent", cdecl,: /wrappers/iup.
                                                             (line  194)
* proc getparx*(a2: ptr WINDOW): cint {.extdecl, importc: "getparx", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1457)
* proc getpary*(a2: ptr WINDOW): cint {.extdecl, importc: "getpary", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1460)
* proc getPathInfo*(): string:           /pure/cgi.          (line  128)
* proc getPathTranslated*(): string:     /pure/cgi.          (line  133)
* proc getPeerAddr*(socket: Socket): (string, Port): /pure/net.
                                                             (line  237)
* proc getPeerAddr*(socket: SocketHandle; domain: Domain): (string, Port): /pure/nativesockets.
                                                             (line  164)
* proc getpeername*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): cint {.importc,: /posix/posix.
                                                             (line 1587)
* proc getpeername*(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {.: /windows/winlean.
                                                             (line  392)
* proc getpgid*(a1: Pid): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  885)
* proc getpgrp*(): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  888)
* proc getpid*(): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  891)
* proc getPointer*(x: Any): pointer:     /core/typeinfo.     (line   89)
* proc getPosition*(s, unused: Stream): int {.deprecated.}: /pure/streams.
                                                             (line   94)
* proc getPosition*(s: Stream): int:     /pure/streams.      (line   89)
* proc getppid*(): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  894)
* proc getProcessTimes*(hProcess: Handle; lpCreationTime, lpExitTime, lpKernelTime,: /windows/winlean.
                                                             (line  612)
* proc getprotobyname*(a1: cstring): ptr Protoent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1767)
* proc getprotobynumber*(a1: cint): ptr Protoent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1770)
* proc getprotoent*(): ptr Protoent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1773)
* proc getpwent*(): ptr Passwd {.importc, header: "<pwd.h>".}: /posix/posix.
                                                             (line  381)
* proc getpwnam*(a1: cstring): ptr Passwd {.importc, header: "<pwd.h>".}: /posix/posix.
                                                             (line  364)
* proc getpwnam_r*(a1: cstring; a2: ptr Passwd; a3: cstring; a4: int; a5: ptr ptr Passwd): cint {.: /posix/posix.
                                                             (line  370)
* proc getpwuid*(a1: Uid): ptr Passwd {.importc, header: "<pwd.h>".}: /posix/posix.
                                                             (line  367)
* proc getpwuid_r*(a1: Uid; a2: ptr Passwd; a3: cstring; a4: int; a5: ptr ptr Passwd): cint {.: /posix/posix.
                                                             (line  374)
* proc getQueryString*(): string:        /pure/cgi.          (line  138)
* proc getQueuedCompletionStatus*(CompletionPort: Handle;: /windows/winlean.
                                                             (line  560)
* proc getRawData*[T](x: var RtArray[T]): ptr UncheckedArray[T]: /pure/collections/rtarrays.
                                                             (line   15)
* proc getRefcount*(x: string): int {.importc: "getRefcount", noSideEffect.}: /system.
                                                             (line 1736)
* proc getRefcount*[T](x: ref T): int {.importc: "getRefcount", noSideEffect.}: /system.
                                                             (line 1733)
* proc getRefcount*[T](x: seq[T]): int {.importc: "getRefcount", noSideEffect.}: /system.
                                                             (line 1739)
* proc getRemoteAddr*(): string:         /pure/cgi.          (line  143)
* proc getRemoteHost*(): string:         /pure/cgi.          (line  148)
* proc getRemoteIdent*(): string:        /pure/cgi.          (line  153)
* proc getRemotePort*(): string:         /pure/cgi.          (line  158)
* proc getRemoteUser*(): string:         /pure/cgi.          (line  163)
* proc getRequestMethod*(): string:      /pure/cgi.          (line  168)
* proc getRequestURI*(): string:         /pure/cgi.          (line  173)
* proc getRow*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.: /impure/db_postgres.
                                                             (line   64)
* proc getRow*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {. <1>: /impure/db_mysql.
                                                             (line   51)
* proc getRow*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {. <2>: /impure/db_sqlite.
                                                             (line   47)
* proc getRow*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): Row {.: /impure/db_postgres.
                                                             (line   71)
* proc getRow*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): Row {.: /impure/db_odbc.
                                                             (line   47)
* proc getScriptFilename*(): string:     /pure/cgi.          (line  178)
* proc getScriptName*(): string:         /pure/cgi.          (line  183)
* proc getSelection*(d: Document): cstring: /js/dom.         (line  187)
* proc getservbyname*(a1, a2: cstring): ptr Servent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1776)
* proc getservbyname*(name, proto: cstring): ptr Servent {.stdcall,: /windows/winlean.
                                                             (line  352)
* proc getServByName*(name, proto: string): Servent {.tags: [ReadIOEffect].}: /pure/nativesockets.
                                                             (line  112)
* proc getServByName*(name, proto: string): Servent {.tags: [ReadIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  220)
* proc getservbyport*(a1: cint; a2: cstring): ptr Servent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1779)
* proc getservbyport*(port: cint; proto: cstring): ptr Servent {.stdcall,: /windows/winlean.
                                                             (line  356)
* proc getServByPort*(port: Port; proto: string): Servent {.tags: [ReadIOEffect].}: /pure/nativesockets.
                                                             (line  122)
* proc getServByPort*(port: Port; proto: string): Servent {.tags: [ReadIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  230)
* proc getservent*(): ptr Servent {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1782)
* proc getServerAddr*(): string:         /pure/cgi.          (line  188)
* proc getServerAdmin*(): string:        /pure/cgi.          (line  193)
* proc getServerName*(): string:         /pure/cgi.          (line  198)
* proc getServerPort*(): string:         /pure/cgi.          (line  203)
* proc getServerProtocol*(): string:     /pure/cgi.          (line  208)
* proc getServerSignature*(): string:    /pure/cgi.          (line  213)
* proc getServerSoftware*(): string:     /pure/cgi.          (line  218)
* proc getsid*(a1: Pid): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  897)
* proc getSockDomain*(socket: SocketHandle): Domain: /pure/nativesockets.
                                                             (line  142)
* proc getSocketError*(socket: Socket): OSErrorCode: /pure/net.
                                                             (line  144)
* proc getsockname*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): cint {.importc,: /posix/posix.
                                                             (line 1591)
* proc getsockname*(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {.: /windows/winlean.
                                                             (line  388)
* proc getSockName*(socket: Socket): Port: /deprecated/pure/sockets.
                                                             (line  142)
* proc getSockName*(socket: SocketHandle): Port: /pure/nativesockets.
                                                             (line  152)
* proc getsockopt*(a1: SocketHandle; a2, a3: cint; a4: pointer; a5: ptr Socklen): cint {.: /posix/posix.
                                                             (line 1595)
* proc getsockopt*(s: SocketHandle; level, optname: cint; optval: pointer;: /windows/winlean.
                                                             (line  396)
* proc getSockOpt*(socket: AsyncSocket; opt: SOBool; level = SOL_SOCKET): bool {.: /pure/asyncnet.
                                                             (line  175)
* proc getSockOpt*(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {.: /pure/net.
                                                             (line  224)
* proc getSockOpt*(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {. <1>: /deprecated/pure/sockets.
                                                             (line  261)
* proc getSockOptInt*(socket: Socket; level, optname: int): int {.tags: [ReadIOEffect].}: /deprecated/pure/sockets.
                                                             (line  250)
* proc getSockOptInt*(socket: SocketHandle; level, optname: int): int {.: /pure/nativesockets.
                                                             (line  171)
* proc getSourceLanguage*(name: string): SourceLanguage: /packages/docutils/highlite.
                                                             (line   14)
* proc getStackTrace*(): string:         /system.            (line 2343)
* proc getStackTrace*(e: ref Exception): string: /system.    (line 2348)
* proc getStartMilsecs*(): int {.deprecated, tags: [TimeEffect], benign.}: /pure/times.
                                                             (line  121)
* proc getStdHandle*(nStdHandle: int32): Handle {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  200)
* proc getstr*(a2: cstring): cint {.extdecl, importc: "getstr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  282)
* proc getStr*(n: JsonNode; default: string = ""): string: /pure/json.
                                                             (line  131)
* proc getString*(x: Any): string:       /core/typeinfo.     (line  260)
* proc getSymbol*(s: PccState; name: cstring): pointer {.cdecl, importc: "tcc_get_symbol".}: /wrappers/tinyc.
                                                             (line  127)
* proc getSystemTimeAsFileTime*(lpSystemTimeAsFileTime: var FILETIME) {.: /windows/winlean.
                                                             (line  325)
* proc getSystemTimes*(lpIdleTime, lpKernelTime, lpUserTime: var FILETIME): WINBOOL {.: /windows/winlean.
                                                             (line  607)
* proc getTempDir*(): string {.rtl, extern: "nos$1", tags: [ReadEnvEffect, ReadIOEffect].}: /pure/ospaths.
                                                             (line  204)
* proc getText*(title, text: cstring): cint {.importc: "IupGetText", dynlib: dllname, cdecl.}: /wrappers/iup.
                                                             (line   74)
* proc getTime*(): Time {.tags: [TimeEffect], benign.}: /pure/times.
                                                             (line   33)
* proc getTimezone*(): int {.tags: [TimeEffect], raises: [], benign.}: /pure/times.
                                                             (line  115)
* proc getTotalMem*(): int {.rtl.}:      /system.            (line 1757)
* proc getTotalSharedMem*(): int {.rtl.}: /system.           (line 1776)
* proc getType*(n: NimNode): NimNode {.magic: "NGetType", noSideEffect.}: /core/macros.
                                                             (line  127)
* proc getType*(n: typedesc): NimNode {.magic: "NGetType", noSideEffect.}: /core/macros.
                                                             (line  138)
* proc getTypeInfo*[T](x: T): pointer {.magic: "GetTypeInfo", benign.}: /system.
                                                             (line 2062)
* proc getTzname*(): tuple[nonDST, DST: string] {.tags: [TimeEffect], raises: [], benign.}: /pure/times.
                                                             (line  109)
* proc getuid*(): Uid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  900)
* proc getUInt*(x: Any): uint:           /core/typeinfo.     (line  160)
* proc getUInt16*(x: Any): uint16:       /core/typeinfo.     (line  170)
* proc getUInt32*(x: Any): uint32:       /core/typeinfo.     (line  175)
* proc getUInt64*(x: Any): uint64:       /core/typeinfo.     (line  180)
* proc getUInt8*(x: Any): uint8:         /core/typeinfo.     (line  165)
* proc getValue*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.: /impure/db_postgres.
                                                             (line   87)
* proc getValue*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {. <1>: /impure/db_mysql.
                                                             (line   64)
* proc getValue*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): string {. <2>: /impure/db_sqlite.
                                                             (line   60)
* proc getValue*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): string {.: /impure/db_postgres.
                                                             (line   95)
* proc getValue*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): string {.: /impure/db_odbc.
                                                             (line   60)
* proc getwd*(a1: cstring): cstring {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  903)
* proc getwin*(a2: File): ptr WINDOW {.extdecl, importc: "getwin", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  285)
* proc getXAxis*(m: Matrix3d): Vector3d {.noInit.}: /pure/basic3d.
                                                             (line  179)
* proc getYAxis*(m: Matrix3d): Vector3d {.noInit.}: /pure/basic3d.
                                                             (line  184)
* proc getZAxis*(m: Matrix3d): Vector3d {.noInit.}: /pure/basic3d.
                                                             (line  189)
* proc get_auxdata*(para1: Pcontext; para2: int32): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  357)
* proc get_buffer_rows*(): cint {.extdecl, importc: "PDC_get_buffer_rows",: /wrappers/pdcurses.
                                                             (line 1793)
* proc get_character_set_info*(MySQL: PMySQL; charset: PMY_CHARSET_INFO) {.stdcall,: /wrappers/mysql.
                                                             (line  439)
* proc get_client_info*(): cstring {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  523)
* proc get_client_version*(): int {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  527)
* proc get_free_memory*(): cdouble {.importc: "uv_get_free_memory", header: "uv.h".}: /wrappers/libuv.
                                                             (line  412)
* proc get_host_info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  531)
* proc get_input_fd*(): cunsignedlong {.extdecl, importc: "PDC_get_input_fd",: /wrappers/pdcurses.
                                                             (line 1684)
* proc get_key_modifiers*(): cunsignedlong {.extdecl,: /wrappers/pdcurses.
                                                             (line 1688)
* proc get_labels*(model: ptr Model; label: ptr cint) {.cdecl, importc: "svm_get_labels",: /wrappers/libsvm.
                                                             (line   86)
* proc get_named_substring*(code: ptr Pcre; subject: cstring; ovector: ptr cint;: /wrappers/pcre.
                                                             (line  160)
* proc get_nr_class*(model: ptr Model): cint {.cdecl, importc: "svm_get_nr_class",: /wrappers/libsvm.
                                                             (line   82)
* proc get_osfhandle*(fd: FileHandle): Handle {.importc: "_get_osfhandle",: /windows/winlean.
                                                             (line  603)
* proc get_parameters*(): PPARAMETERS {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  304)
* proc get_proto_info*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  539)
* proc get_salt_from_password*(res: pointer; password: cstring) {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  232)
* proc get_salt_from_password_323*(res: ptr int; password: cstring) {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  207)
* proc get_server_info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  519)
* proc get_server_version*(MySQL: PMySQL): int {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  535)
* proc get_stringnumber*(code: ptr Pcre; name: cstring): cint: /wrappers/pcre.
                                                             (line  166)
* proc get_stringtable_entries*(code: ptr Pcre; name: cstring; first: cstringArray;: /wrappers/pcre.
                                                             (line  169)
* proc get_substring*(subject: cstring; ovector: ptr cint; stringcount: cint;: /wrappers/pcre.
                                                             (line  173)
* proc get_substring_list*(subject: cstring; ovector: ptr cint; stringcount: cint;: /wrappers/pcre.
                                                             (line  177)
* proc get_svm_type*(model: ptr Model): cint {.cdecl, importc: "svm_get_svm_type",: /wrappers/libsvm.
                                                             (line   78)
* proc get_svr_probability*(model: ptr Model): cdouble {.cdecl,: /wrappers/libsvm.
                                                             (line   90)
* proc get_table*(para1: PSqlite3; sql: cstring; resultp: var cstringArray;: /wrappers/sqlite3.
                                                             (line   63)
* proc get_total_memory*(): cdouble {.importc: "uv_get_total_memory", header: "uv.h".}: /wrappers/libuv.
                                                             (line  415)
* proc get_tty_password*(opt_message: cstring): cstring {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  241)
* proc get_wch*(a2: ptr cint): cint {.extdecl, importc: "get_wch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1122)
* proc get_wstr*(a2: ptr cint): cint {.extdecl, importc: "get_wstr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1125)
* proc glob*(a1: cstring; a2: cint; a3: proc (x1: cstring; x2: cint): cint {.noconv.};: /posix/posix.
                                                             (line  272)
* proc globfree*(a1: ptr Glob) {.importc, header: "<glob.h>".}: /posix/posix.
                                                             (line  276)
* proc gmtime*(a1: var Time): ptr Tm {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1240)
* proc gmtime_r*(a1: var Time; a2: var Tm): ptr Tm {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1243)
* proc go*(h: History; pagesToJump: int): /js/dom.           (line  253)
* proc gorge*(command: string; input = ""; cache = ""): string {.magic: "StaticExec".}: /system.
                                                             (line 2495)
* proc gotHandshake*(socket: Socket): bool: /pure/net.       (line  273)
* proc gotHandshake*(socket: Socket): bool <1>: /deprecated/pure/sockets.
                                                             (line  311)
* proc graphemeLen*(s: string; i: Natural): Natural: /pure/unicode.
                                                             (line  133)
* proc guess_handle*(file: File): HandleType {.importc: "uv_guess_handle",: /wrappers/libuv.
                                                             (line  162)
* proc halfdelay*(a2: cint): cint {.extdecl, importc: "halfdelay", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  288)
* proc handleCR*(L: var BaseLexer; pos: int): int: /pure/lexbase.
                                                             (line   47)
* proc handleEvent*(d: Document; event: Event): /js/dom.     (line  190)
* proc handleEvent*(e: Element; event: Event): /js/dom.      (line  217)
* proc handleEvent*(w: Window; e: Event): /js/dom.           (line   64)
* proc handleLF*(L: var BaseLexer; pos: int): int: /pure/lexbase.
                                                             (line   54)
* proc handleRefillChar*(L: var BaseLexer; pos: int): int: /pure/lexbase.
                                                             (line   61)
* proc handshake*(socket: Socket): bool {.tags: [ReadIOEffect, WriteIOEffect].}: /pure/net.
                                                             (line  261)
* proc handshake*(socket: Socket): bool {.tags: [ReadIOEffect, WriteIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  299)
* proc hasArgOfName*(params: NimNode; name: string): bool {.compiletime.}: /core/macros.
                                                             (line  609)
* proc hasAttribute*(el: PElement; name: string): bool: /pure/xmldom.
                                                             (line  347)
* proc hasAttributeNS*(el: PElement; namespaceURI: string; localName: string): bool: /pure/xmldom.
                                                             (line  353)
* proc hasAttributes*(n: PNode): bool:   /pure/xmldom.       (line  184)
* proc hasChildNodes*(n: Node): bool:    /js/dom.            (line  130)
* proc hasChildNodes*(n: PNode): bool:   /pure/xmldom.       (line  189)
* proc hasData*(p: Process): bool:       /pure/osproc.       (line  241)
* proc hasDataBuffered*(s: Socket): bool: /pure/net.         (line  281)
* proc hasDataBuffered*(s: Socket): bool <1>: /deprecated/pure/sockets.
                                                             (line  319)
* proc hasFeature*(dom: PDOMImplementation; feature: string; version: string = ""): bool: /pure/xmldom.
                                                             (line   33)
* proc hash*(n: JsonNode): Hash:         /pure/json.         (line  210)
* proc hash*(s: SharedString): THash:    /pure/collections/sharedstrings.
                                                             (line   60)
* proc hash*(sBuf: string; sPos, ePos: int): Hash: /pure/hashes.
                                                             (line   69)
* proc hash*(x: char): Hash {.inline.}:  /pure/hashes.       (line   54)
* proc hash*(x: float): Hash {.inline.}: /pure/hashes.       (line  105)
* proc hash*(x: int): Hash {.inline.}:   /pure/hashes.       (line   44)
* proc hash*(x: int64): Hash {.inline.}: /pure/hashes.       (line   49)
* proc hash*(x: pointer): Hash {.inline.}: /pure/hashes.     (line   34)
* proc hash*(x: SocketHandle): Hash {.borrow.}: /pure/selectors.
                                                             (line   20)
* proc hash*(x: string): Hash:           /pure/hashes.       (line   64)
* proc hash*[A](aBuf: openArray[A]; sPos, ePos: int): Hash: /pure/hashes.
                                                             (line  126)
* proc hash*[A](x: openArray[A]): Hash:  /pure/hashes.       (line  110)
* proc hash*[A](x: openArray[A]): Hash <1>: /pure/hashes.    (line  121)
* proc hash*[A](x: set[A]): Hash:        /pure/hashes.       (line  113)
* proc hash*[A](x: set[A]): Hash <1>:    /pure/hashes.       (line  133)
* proc hash*[T: Ordinal](x: T): Hash {.inline.}: /pure/hashes.
                                                             (line   59)
* proc hash*[T: proc](x: T): Hash {.inline.}: /pure/hashes.  (line   39)
* proc hash*[T: tuple](x: T): Hash:      /pure/hashes.       (line  116)
* proc hash*[T](x: Rational[T]): Hash:   /pure/rationals.    (line  196)
* proc hashData*(data: pointer; size: int): Hash: /pure/hashes.
                                                             (line   29)
* proc hashIgnoreCase*(sBuf: string; sPos, ePos: int): Hash: /pure/hashes.
                                                             (line   96)
* proc hashIgnoreCase*(x: string): Hash: /pure/hashes.       (line   91)
* proc hashIgnoreStyle*(sBuf: string; sPos, ePos: int): Hash: /pure/hashes.
                                                             (line   82)
* proc hashIgnoreStyle*(x: string): Hash: /pure/hashes.      (line   77)
* proc hash_password*(fto: int; password: cstring; password_len: cuint) {.cdecl,: /wrappers/mysql.
                                                             (line  190)
* proc hasKey*(node: JsonNode; key: string): bool: /pure/json.
                                                             (line  233)
* proc hasKey*(t: StringTableRef; key: string): bool {.rtl, extern: "nst$1".}: /pure/strtabs.
                                                             (line   52)
* proc hasKey*[A, B](t: OrderedTableRef[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line  322)
* proc hasKey*[A, B](t: OrderedTable[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line  229)
* proc hasKey*[A, B](t: TableRef[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line  118)
* proc hasKey*[A, B](t: Table[A, B]; key: A): bool: /pure/collections/tables.
                                                             (line   56)
* proc hasKey*[A](t: CountTableRef[A]; key: A): bool: /pure/collections/tables.
                                                             (line  479)
* proc hasKey*[A](t: CountTable[A]; key: A): bool: /pure/collections/tables.
                                                             (line  399)
* proc hasKey*[T](c: CritBitTree[T]; key: string): bool {.inline.}: /pure/collections/critbits.
                                                             (line   29)
* proc hasKey*[T](tbl: PGenTable[T]; key: string): bool: /pure/gentabs.
                                                             (line   24)
* proc hasKeyOrPut*[A, B](t: var OrderedTableRef[A, B]; key: A; val: B): bool: /pure/collections/tables.
                                                             (line  317)
* proc hasKeyOrPut*[A, B](t: var OrderedTable[A, B]; key: A; val: B): bool: /pure/collections/tables.
                                                             (line  256)
* proc hasKeyOrPut*[A, B](t: var SharedTable[A, B]; key: A; val: B): bool: /pure/collections/sharedtables.
                                                             (line   34)
* proc hasKeyOrPut*[A, B](t: var TableRef[A, B]; key: A; val: B): bool: /pure/collections/tables.
                                                             (line  154)
* proc hasKeyOrPut*[A, B](t: var Table[A, B]; key: A; val: B): bool: /pure/collections/tables.
                                                             (line   77)
* proc has_colors*(): cunsignedchar {.extdecl, importc: "has_colors",: /wrappers/pdcurses.
                                                             (line  291)
* proc has_ic*(): cunsignedchar {.extdecl, importc: "has_ic", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  295)
* proc has_il*(): cunsignedchar {.extdecl, importc: "has_il", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  298)
* proc has_key*(a2: cint): cunsignedchar {.extdecl, importc: "has_key",: /wrappers/pdcurses.
                                                             (line 1539)
* proc hbox*(child: PIhandle): PIhandle {.importc: "IupHbox", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  419)
* proc hboxv*(children: ptr PIhandle): PIhandle {.importc: "IupHboxv", cdecl,: /wrappers/iup.
                                                             (line  423)
* proc help*(url: cstring): cint {.importc: "IupHelp", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  139)
* proc hexbyte*(hex: char): int:         /pure/oids.         (line   24)
* proc hex_string*(fto: cstring; `from`: cstring; from_length: int): int {.stdcall,: /wrappers/mysql.
                                                             (line  593)
* proc hide*(ih: PIhandle): cint {.importc: "IupHide", cdecl, dynlib: dllname, discardable.}: /wrappers/iup.
                                                             (line  222)
* proc hide_panel*(pan: ptr PANEL): cint {.extdecl, importc: "hide_panel",: /wrappers/pdcurses.
                                                             (line 1712)
* proc high*[T](x: T): T {.magic: "High", noSideEffect.}: /system.
                                                             (line  313)
* proc hint*(msg: string) {.magic: "NHint", benign.}: /core/macros.
                                                             (line  196)
* proc historyAdd*(line: cstring): cint {.importc: "linenoiseHistoryAdd", discardable.}: /wrappers/linenoise/linenoise.
                                                             (line   23)
* proc historyLoad*(filename: cstring): cint {.importc: "linenoiseHistoryLoad".}: /wrappers/linenoise/linenoise.
                                                             (line   32)
* proc historySave*(filename: cstring): cint {.importc: "linenoiseHistorySave".}: /wrappers/linenoise/linenoise.
                                                             (line   29)
* proc historySetMaxLen*(len: cint): cint {.importc: "linenoiseHistorySetMaxLen".}: /wrappers/linenoise/linenoise.
                                                             (line   26)
* proc hline*(a2: cunsignedlong; a3: cint): cint {.extdecl, importc: "hline",: /wrappers/pdcurses.
                                                             (line  301)
* proc hline_set*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "hline_set",: /wrappers/pdcurses.
                                                             (line 1128)
* proc home*(w: Window):                 /js/dom.            (line   67)
* proc hours*(h: int): TimeInterval {.inline.}: /pure/times. (line  264)
* proc hrtime*(): uint64 {.importc: "uv_hrtime", header: "uv.h".}: /wrappers/libuv.
                                                             (line  406)
* proc hstrerror*(herrnum: cint): cstring {.importc: "(char *)$1", header: "<netdb.h>".}: /posix/posix.
                                                             (line 1423)
* proc htmlTag*(n: XmlNode): HtmlTag:    /pure/htmlparser.   (line  212)
* proc htmlTag*(s: string): HtmlTag:     /pure/htmlparser.   (line  217)
* proc htonl*(a1: int32): int32 {.importc, header: "<arpa/inet.h>".}: /posix/posix.
                                                             (line  172)
* proc htonl*(x: int32): int32:          /deprecated/pure/sockets.
                                                             (line   59)
* proc htons*(a1: int16): int16 {.importc, header: "<arpa/inet.h>".}: /posix/posix.
                                                             (line  175)
* proc htons*(x: int16): int16:          /deprecated/pure/sockets.
                                                             (line   67)
* proc http_errno_description*(err: HttpErrNo): cstring {.: /wrappers/joyent_http_parser.
                                                             (line   53)
* proc http_errno_name*(err: HttpErrNo): cstring {.importc: "http_errno_name",: /wrappers/joyent_http_parser.
                                                             (line   49)
* proc http_method_str*(m: HttpMethod): cstring {.importc: "http_method_str",: /wrappers/joyent_http_parser.
                                                             (line   45)
* proc http_parser_execute*(parser: var HttpParser; settings: var HttpParserSettings;: /wrappers/joyent_http_parser.
                                                             (line   34)
* proc http_parser_init*(parser: var HttpParser; typ: HttpParserType) {.: /wrappers/joyent_http_parser.
                                                             (line   29)
* proc http_should_keep_alive*(parser: var HttpParser): cint {.: /wrappers/joyent_http_parser.
                                                             (line   40)
* proc hypot*(x, y: float): float {.importc: "hypot", header: "<math.h>".}: /pure/math.
                                                             (line  172)
* proc iconv*(a1: Iconv; a2: var cstring; a3: var int; a4: var cstring; a5: var int): int {.: /posix/posix.
                                                             (line  305)
* proc iconv_close*(a1: Iconv): cint {.importc, header: "<iconv.h>".}: /posix/posix.
                                                             (line  309)
* proc iconv_open*(a1, a2: cstring): Iconv {.importc, header: "<iconv.h>".}: /posix/posix.
                                                             (line  302)
* proc idcok*(a2: ptr WINDOW; a3: cunsignedchar) {.extdecl, importc: "idcok",: /wrappers/pdcurses.
                                                             (line  305)
* proc ident*(n: NimNode): NimIdent {.magic: "NIdent", noSideEffect.}: /core/macros.
                                                             (line  124)
* proc ident*(name: string): NimNode {.compileTime, inline.}: /core/macros.
                                                             (line  562)
* proc idle_init*(a2: PLoop; idle: PIdle): cint {.importc: "uv_idle_init", header: "uv.h".}: /wrappers/libuv.
                                                             (line  204)
* proc idle_start*(idle: PIdle; cb: IdleProc): cint {.importc: "uv_idle_start",: /wrappers/libuv.
                                                             (line  207)
* proc idle_stop*(idle: PIdle): cint {.importc: "uv_idle_stop", header: "uv.h".}: /wrappers/libuv.
                                                             (line  211)
* proc idlok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "idlok",: /wrappers/pdcurses.
                                                             (line  309)
* proc if_freenameindex*(a1: ptr Tif_nameindex) {.importc, header: "<net/if.h>".}: /posix/posix.
                                                             (line 1653)
* proc if_indextoname*(a1: cint; a2: cstring): cstring {.importc, header: "<net/if.h>".}: /posix/posix.
                                                             (line 1647)
* proc if_nameindex*(): ptr Tif_nameindex {.importc, header: "<net/if.h>".}: /posix/posix.
                                                             (line 1650)
* proc if_nametoindex*(a1: cstring): cint {.importc, header: "<net/if.h>".}: /posix/posix.
                                                             (line 1644)
* proc ignoreMsg*(c: CfgParser; e: CfgEvent): string {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   58)
* proc image*(width, height: cint; pixmap: pointer): PIhandle {.importc: "IupImage", cdecl,: /wrappers/iup.
                                                             (line  449)
* proc imageLibOpen*() {.importc: "IupImageLibOpen", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line   98)
* proc imageRGB*(width, height: cint; pixmap: pointer): PIhandle {.: /wrappers/iup.
                                                             (line  453)
* proc imageRGBA*(width, height: cint; pixmap: pointer): PIhandle {.: /wrappers/iup.
                                                             (line  457)
* proc immedok*(a2: ptr WINDOW; a3: cunsignedchar) {.extdecl, importc: "immedok",: /wrappers/pdcurses.
                                                             (line  313)
* proc implementation*(doc: PDocument): PDOMImplementation: /pure/xmldom.
                                                             (line   39)
* proc importNode*(doc: PDocument; importedNode: PNode; deep: bool): PNode: /pure/xmldom.
                                                             (line  109)
* proc IN6ADDR_ANY_INIT*(): In6Addr {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line  198)
* proc IN6ADDR_LOOPBACK_INIT*(): In6Addr {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line  201)
* proc IN6_IS_ADDR_LINKLOCAL*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line 1672)
* proc IN6_IS_ADDR_LOOPBACK*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line 1662)
* proc IN6_IS_ADDR_MC_GLOBAL*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line 1716)
* proc IN6_IS_ADDR_MC_LINKLOCAL*(a1: ptr In6Addr): cint {.importc,: /posix/posix.
                                                             (line 1698)
* proc IN6_IS_ADDR_MC_NODELOCAL*(a1: ptr In6Addr): cint {.importc,: /posix/posix.
                                                             (line 1692)
* proc IN6_IS_ADDR_MC_ORGLOCAL*(a1: ptr In6Addr): cint {.importc,: /posix/posix.
                                                             (line 1710)
* proc IN6_IS_ADDR_MC_SITELOCAL*(a1: ptr In6Addr): cint {.importc,: /posix/posix.
                                                             (line 1704)
* proc IN6_IS_ADDR_MULTICAST*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line 1667)
* proc IN6_IS_ADDR_SITELOCAL*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line 1677)
* proc IN6_IS_ADDR_UNSPECIFIED*(a1: ptr In6Addr): cint {.importc,: /posix/posix.
                                                             (line 1656)
* proc IN6_IS_ADDR_V4COMPAT*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line 1687)
* proc IN6_IS_ADDR_V4MAPPED*(a1: ptr In6Addr): cint {.importc, header: "<netinet/in.h>".}: /posix/posix.
                                                             (line 1682)
* proc inbox*[In, Out](self: PActor[In, Out]): ptr Channel[In]: /deprecated/pure/actors.
                                                             (line   33)
* proc inc*(c: var CritBitTree[int]; key: string): /pure/collections/critbits.
                                                             (line   46)
* proc inc*[A](t: CountTableRef[A]; key: A; val = 1): /pure/collections/tables.
                                                             (line  515)
* proc inc*[A](t: var CountTable[A]; key: A; val = 1): /pure/collections/tables.
                                                             (line  435)
* proc inc*[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: "Inc", noSideEffect.}: /system.
                                                             (line  511)
* proc inch*(): cunsignedlong {.extdecl, importc: "inch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  325)
* proc inchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "inchnstr",: /wrappers/pdcurses.
                                                             (line  317)
* proc inchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "inchstr",: /wrappers/pdcurses.
                                                             (line  321)
* proc incl*(c: var CritBitTree[void]; key: string): /pure/collections/critbits.
                                                             (line   51)
* proc incl*(s: var IntSet; key: int):   /pure/collections/intsets.
                                                             (line   24)
* proc incl*[A](s: var HashSet[A]; key: A): /pure/collections/sets.
                                                             (line  107)
* proc incl*[A](s: var HashSet[A]; other: HashSet[A]): /pure/collections/sets.
                                                             (line  118)
* proc incl*[A](s: var HashSet[A]; other: OrderedSet[A]): /pure/collections/sets.
                                                             (line  419)
* proc incl*[A](s: var OrderedSet[A]; key: A): /pure/collections/sets.
                                                             (line  408)
* proc incl*[T](x: var set[T]; y: T) {.magic: "Incl", noSideEffect.}: /system.
                                                             (line  588)
* proc inclFilePermissions*(filename: string; permissions: set[FilePermission]) {.rtl,: /pure/os.
                                                             (line  423)
* proc inclSetElement*(x: Any; elem: int): /core/typeinfo.   (line  282)
* proc indent*(s: string; count: Natural; padding: string = " "): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  397)
* proc indexBy*[A, B, C](collection: A; index: proc (x: B): C): Table[C, B]: /pure/collections/tables.
                                                             (line  126)
* proc inet_addr*(a1: cstring): InAddrT {.importc, header: "<arpa/inet.h>".}: /posix/posix.
                                                             (line  184)
* proc inet_addr*(cp: cstring): int32 {.stdcall, importc: "inet_addr", dynlib: ws2dll.}: /windows/winlean.
                                                             (line  443)
* proc inet_ntoa*(a1: InAddr): cstring {.importc, header: "<arpa/inet.h>".}: /posix/posix.
                                                             (line  187)
* proc inet_ntoa*(i: InAddr): cstring {.stdcall, importc, dynlib: ws2dll.}: /windows/winlean.
                                                             (line  468)
* proc inet_ntop*(a1: cint; a2: pointer; a3: cstring; a4: int32): cstring {.: /posix/posix.
                                                             (line  190)
* proc inet_ntop*(family: cint; paddr: pointer; pStringBuffer: cstring;: /windows/winlean.
                                                             (line  471)
* proc inet_pton*(a1: cint; a2: cstring; a3: pointer): cint {.importc,: /posix/posix.
                                                             (line  194)
* proc infix*(a: NimNode; op: string; b: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  586)
* proc info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: "mysql_info".}: /wrappers/mysql.
                                                             (line  365)
* proc init*(MySQL: PMySQL): PMySQL {.stdcall, dynlib: lib, importc: "mysql_init".}: /wrappers/mysql.
                                                             (line  379)
* proc init*[A](s: var HashSet[A]; initialSize = 64): /pure/collections/sets.
                                                             (line  167)
* proc init*[A](s: var OrderedSet[A]; initialSize = 64): /pure/collections/sets.
                                                             (line  444)
* proc initCond*(cond: var Cond) {.inline.}: /core/locks.    (line   39)
* proc initCountTable*[A](initialSize = 64): CountTable[A]: /pure/collections/tables.
                                                             (line  414)
* proc initDoublyLinkedList*[T](): DoublyLinkedList[T]: /pure/collections/lists.
                                                             (line   22)
* proc initDoublyLinkedRing*[T](): DoublyLinkedRing[T]: /pure/collections/lists.
                                                             (line   32)
* proc initEventEmitter*(): EventEmitter: /pure/events.      (line   58)
* proc initEventHandler*(name: string): EventHandler: /pure/events.
                                                             (line   17)
* proc initGeneralTokenizer*(g: var GeneralTokenizer; buf: cstring): /packages/docutils/highlite.
                                                             (line   17)
* proc initGeneralTokenizer*(g: var GeneralTokenizer; buf: string): /packages/docutils/highlite.
                                                             (line   20)
* proc initInterval*(milliseconds, seconds, minutes, hours, days, months, years: int = 0): TimeInterval: /pure/times.
                                                             (line  127)
* proc initIntSet*(): IntSet:            /pure/collections/intsets.
                                                             (line   40)
* proc initLock*(lock: var Lock) {.inline.}: /core/locks.    (line   14)
* proc initOptParser*(): OptParser:      /pure/parseopt2.    (line   42)
* proc initOptParser*(cmdline = ""): OptParser: /pure/parseopt.
                                                             (line   26)
* proc initOptParser*(cmdline: seq[string]): OptParser {.rtl.}: /pure/parseopt2.
                                                             (line   29)
* proc initOptParser*(cmdline: string): OptParser {.rtl, deprecated.}: /pure/parseopt2.
                                                             (line   36)
* proc initOrderedSet*[A](initialSize = 64): OrderedSet[A]: /pure/collections/sets.
                                                             (line  465)
* proc initOrderedTable*[A, B](initialSize = 64): OrderedTable[A, B]: /pure/collections/tables.
                                                             (line  261)
* proc initPoly*(cofs: varargs[float]): Poly: /pure/poly.    (line   77)
* proc initQueue*[T](initialSize = 4): Queue[T]: /pure/collections/queues.
                                                             (line   18)
* proc initRational*[T: SomeInteger](num, den: T): Rational[T]: /pure/rationals.
                                                             (line   17)
* proc initRstGenerator*(g: var RstGenerator; target: OutputTarget;: /packages/docutils/rstgen.
                                                             (line   18)
* proc initRtArray*[T](len: Natural): RtArray[T]: /pure/collections/rtarrays.
                                                             (line   12)
* proc initscr*(): ptr WINDOW {.extdecl, importc: "initscr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  336)
* proc initSet*[A](initialSize = 64): HashSet[A]: /pure/collections/sets.
                                                             (line  188)
* proc initSharedList*[A](): SharedList[A]: /pure/collections/sharedlist.
                                                             (line   21)
* proc initSharedTable*[A, B](initialSize = 64): SharedTable[A, B]: /pure/collections/sharedtables.
                                                             (line   55)
* proc initSinglyLinkedList*[T](): SinglyLinkedList[T]: /pure/collections/lists.
                                                             (line   17)
* proc initSinglyLinkedRing*[T](): SinglyLinkedRing[T]: /pure/collections/lists.
                                                             (line   27)
* proc initTable*[A, B](initialSize = 64): Table[A, B]: /pure/collections/tables.
                                                             (line   98)
* proc initUri*(): Uri:                  /pure/uri.          (line   37)
* proc init_color*(a2: cshort; a3: cshort; a4: cshort; a5: cshort): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  328)
* proc init_pair*(a2: cshort; a3: cshort; a4: cshort): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  332)
* proc innerText*(n: XmlNode): string:   /pure/xmltree.      (line   63)
* proc innstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "innstr",: /wrappers/pdcurses.
                                                             (line  339)
* proc innwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "innwstr",: /wrappers/pdcurses.
                                                             (line 1132)
* proc inotify_add_watch*(fd: cint; name: cstring; mask: uint32): cint {.cdecl,: /posix/inotify.
                                                             (line   49)
* proc inotify_init*(): cint {.cdecl, importc: "inotify_init", header: "<sys/inotify.h>".}: /posix/inotify.
                                                             (line   42)
* proc inotify_init1*(flags: cint): cint {.cdecl, importc: "inotify_init1",: /posix/inotify.
                                                             (line   45)
* proc inotify_rm_watch*(fd: cint; wd: cint): cint {.cdecl, importc: "inotify_rm_watch",: /posix/inotify.
                                                             (line   54)
* proc inputHandle*(p: Process): FileHandle {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  185)
* proc inputStream*(p: Process): Stream {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  161)
* proc insch*(a2: cunsignedlong): cint {.extdecl, importc: "insch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  343)
* proc insdelln*(a2: cint): cint {.extdecl, importc: "insdelln", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  346)
* proc insert*(a: NimNode; pos: int; b: NimNode) {.compileTime.}: /core/macros.
                                                             (line  567)
* proc insert*(father, son: XmlNode; index: int) {.inline.}: /pure/xmltree.
                                                             (line   85)
* proc insert*(ih, refChild, child: PIhandle): PIhandle {.importc: "IupInsert", cdecl,: /wrappers/iup.
                                                             (line  170)
* proc insert*(x: var string; item: string; i = 0.Natural) {.noSideEffect.}: /system.
                                                             (line 2622)
* proc insert*[T](dest: var seq[T]; src: openArray[T]; pos = 0): /pure/collections/sequtils.
                                                             (line  205)
* proc insert*[T](x: var seq[T]; item: T; i = 0.Natural) {.noSideEffect.}: /system.
                                                             (line 1405)
* proc insertBefore*(n, newNode, before: Node): /js/dom.     (line  133)
* proc insertBefore*(n: PNode; newChild: PNode; refChild: PNode): PNode: /pure/xmldom.
                                                             (line  194)
* proc insertData*(n: Node; position: int; data: cstring): /js/dom.
                                                             (line  136)
* proc insertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_postgres.
                                                             (line  112)
* proc insertId*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_mysql.
                                                             (line   79)
* proc insertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {. <1>: /impure/db_sqlite.
                                                             (line   75)
* proc insertId*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_odbc.
                                                             (line   75)
* proc insertln*(): cint {.extdecl, importc: "insertln", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  349)
* proc insertSep*(s: string; sep = '_'; digits = 3): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  620)
* proc insert_id*(MySQL: PMySQL): my_ulonglong {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  347)
* proc insnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "insnstr",: /wrappers/pdcurses.
                                                             (line  352)
* proc insrawch*(a2: cunsignedlong): cint {.extdecl, importc: "insrawch",: /wrappers/pdcurses.
                                                             (line 1584)
* proc insstr*(a2: cstring): cint {.extdecl, importc: "insstr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  356)
* proc instantiationInfo*(index = - 1; fullPaths = false): tuple[filename: string, line: int] {.: /system.
                                                             (line 2570)
* proc instr*(a2: cstring): cint {.extdecl, importc: "instr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  359)
* proc ins_nwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: "ins_nwstr",: /wrappers/pdcurses.
                                                             (line 1136)
* proc ins_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: "ins_wch",: /wrappers/pdcurses.
                                                             (line 1140)
* proc ins_wstr*(a2: cstring): cint {.extdecl, importc: "ins_wstr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1144)
* proc integral*(p: Poly): Poly:         /pure/poly.         (line   65)
* proc integrate*(p: Poly; xmin, xmax: float): float: /pure/poly.
                                                             (line   71)
* proc intensity*(a: Color; f: float): Color: /pure/colors.  (line   36)
* proc intercept*(r: RunningRegress): float: /pure/stats.    (line  180)
* proc internalErrorFlag*(): string {.magic: "NError", noSideEffect.}: /core/macros.
                                                             (line  263)
* proc internalNew*[T](a: var ref T) {.magic: "New", noSideEffect.}: /system.
                                                             (line  290)
* proc INTERNAL_NUM_FIELD*(f: Pst_mysql_field): bool: /wrappers/mysql.
                                                             (line  284)
* proc interrupt*(para1: PSqlite3) {.cdecl, dynlib: Lib, importc: "sqlite3_interrupt".}: /wrappers/sqlite3.
                                                             (line   41)
* proc intersection*[A](s1, s2: HashSet[A]): HashSet[A]: /pure/collections/sets.
                                                             (line  237)
* proc intrflush*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  362)
* proc intToStr*(x: int; minchars: Positive = 1): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  276)
* proc intVal*(n: NimNode): BiggestInt {.magic: "NIntVal", noSideEffect.}: /core/macros.
                                                             (line  115)
* proc inverse*(m: Matrix2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line  144)
* proc inverse*(m: Matrix3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  156)
* proc invokeNew*(x: Any):               /core/typeinfo.     (line   43)
* proc invokeNewSeq*(x: Any; len: int):  /core/typeinfo.     (line   48)
* proc inwstr*(a2: cstring): cint {.extdecl, importc: "inwstr", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1147)
* proc in_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: "in_wch",: /wrappers/pdcurses.
                                                             (line 1150)
* proc in_wchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1154)
* proc in_wchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: "in_wchstr",: /wrappers/pdcurses.
                                                             (line 1158)
* proc ioctl*(f: FileHandle; device: uint): int {.importc: "ioctl",: /posix/posix.
                                                             (line  951)
* proc ioctlsocket*(s: SocketHandle; cmd: clong; argptr: ptr clong): cint {.stdcall,: /pure/nativesockets.
                                                             (line   28)
* proc ip4_addr*(ip: cstring; port: cint): SockAddrIn {.importc: "uv_ip4_addr",: /wrappers/libuv.
                                                             (line  386)
* proc ip4_name*(src: ptr SockAddrIn; dst: cstring; size: csize): cint {.: /wrappers/libuv.
                                                             (line  394)
* proc ip6_addr*(ip: cstring; port: cint): TSockAddrIn6 {.importc: "uv_ip6_addr",: /wrappers/libuv.
                                                             (line  390)
* proc ip6_name*(src: ptr TSockAddrIn6; dst: cstring; size: csize): cint {.: /wrappers/libuv.
                                                             (line  398)
* proc IPv4_any*(): IpAddress:           /pure/net.          (line  430)
* proc IPv4_broadcast*(): IpAddress:     /pure/net.          (line  441)
* proc IPv4_loopback*(): IpAddress:      /pure/net.          (line  436)
* proc IPv6_any*(): IpAddress:           /pure/net.          (line  446)
* proc IPv6_loopback*(): IpAddress:      /pure/net.          (line  452)
* proc isAbsolute*(path: string): bool {.rtl, noSideEffect, extern: "nos$1".}: /pure/ospaths.
                                                             (line  169)
* proc isActive*(b: ptr Breakpoint): bool: /system/debugger. (line   52)
* proc isAlpha*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsAlphaChar".}: /pure/strutils.
                                                             (line   37)
* proc isAlpha*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   88)
* proc isAlpha*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsAlphaStr".}: /pure/strutils.
                                                             (line   78)
* proc isAlphaNumeric*(c: char): bool {.noSideEffect, procvar, rtl,: /pure/strutils.
                                                             (line   44)
* proc isAlphaNumeric*(s: string): bool {.noSideEffect, procvar, rtl,: /pure/strutils.
                                                             (line   87)
* proc isAlt*(s: cstring): bool:         /wrappers/iup.      (line  613)
* proc isAltXkey*(c: cint): bool:        /wrappers/iup.      (line  637)
* proc isatty*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  906)
* proc isatty*(f: File): bool:           /pure/terminal.     (line  119)
* proc isBlocking*(socket: Socket): bool: /deprecated/pure/sockets.
                                                             (line  620)
* proc isButton1*(s: cstring): bool:     /wrappers/iup.      (line  601)
* proc isButton2*(s: cstring): bool:     /wrappers/iup.      (line  604)
* proc isbutton3*(s: cstring): bool:     /wrappers/iup.      (line  607)
* proc isButton4*(s: cstring): bool:     /wrappers/iup.      (line  619)
* proc isButton5*(s: cstring): bool:     /wrappers/iup.      (line  622)
* proc isClosed*(s: AsyncSocket): bool:  /deprecated/pure/asyncio.
                                                             (line  143)
* proc isClosed*(socket: AsyncSocket): bool: /pure/asyncnet. (line  197)
* proc isColor*(name: string): bool:     /pure/colors.       (line   54)
* proc isCombining*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line  104)
* proc isConnected*(s: AsyncSocket): bool: /deprecated/pure/asyncio.
                                                             (line  128)
* proc isConnecting*(s: AsyncSocket): bool: /deprecated/pure/asyncio.
                                                             (line  138)
* proc isControl*(s: cstring): bool:     /wrappers/iup.      (line  598)
* proc isCtrlXkey*(c: cint): bool:       /wrappers/iup.      (line  634)
* proc isDigit*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsDigitChar".}: /pure/strutils.
                                                             (line   52)
* proc isDigit*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsDigitStr".}: /pure/strutils.
                                                             (line   97)
* proc isDisconnectionError*(flags: set[SocketFlag]; lastError: OSErrorCode): bool: /pure/net.
                                                             (line   58)
* proc isDouble*(s: cstring): bool:      /wrappers/iup.      (line  610)
* proc isendwin*(): cunsignedchar {.extdecl, importc: "isendwin", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  366)
* proc isFinite*(x: BiggestFloat): bool {.importc, nodecl.}: /js/dom.
                                                             (line  298)
* proc isHidden*(path: string): bool:    /pure/os.           (line  577)
* proc isIdentity*(m: Matrix2d; tol = 1e-06'f64): bool: /pure/basic2d.
                                                             (line  163)
* proc isIpAddress*(address_str: string): bool {.tags: [].}: /pure/net.
                                                             (line   48)
* proc isLeapYear*(year: int): bool:     /pure/times.        (line  150)
* proc isListening*(s: AsyncSocket): bool: /deprecated/pure/asyncio.
                                                             (line  133)
* proc isLower*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsLowerChar".}: /pure/strutils.
                                                             (line   64)
* proc isLower*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   76)
* proc isLower*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsLowerStr".}: /pure/strutils.
                                                             (line  114)
* proc isMagicIdentSeparatorRune*(cs: cstring; i: int): bool {.inline.}: /pure/etcpriv.
                                                             (line   12)
* proc isMirroring*(m: Matrix2d): bool:  /pure/basic2d.      (line  138)
* proc isNaN*(x: BiggestFloat): bool {.importc, nodecl.}: /js/dom.
                                                             (line  301)
* proc isNil*(x: Any): bool:             /core/typeinfo.     (line   83)
* proc isNil*(x: cstring): bool {.noSideEffect, magic: "IsNil".}: /system.
                                                             (line 1857)
* proc isNil*(x: IntSet): bool {.inline.}: /pure/collections/intsets.
                                                             (line   45)
* proc isNil*(x: pointer): bool {.noSideEffect, magic: "IsNil".}: /system.
                                                             (line 1854)
* proc isNil*(x: string): bool {.noSideEffect, magic: "IsNil".}: /system.
                                                             (line 1848)
* proc isNil*[T: proc](x: T): bool {.noSideEffect, magic: "IsNil".}: /system.
                                                             (line 1860)
* proc isNil*[T](x: ptr T): bool {.noSideEffect, magic: "IsNil".}: /system.
                                                             (line 1851)
* proc isNil*[T](x: ref T): bool {.noSideEffect, magic: "IsNil".}: /system.
                                                             (line 1845)
* proc isNil*[T](x: seq[T]): bool {.noSideEffect, magic: "IsNil".}: /system.
                                                             (line 1842)
* proc isNone*[T](self: Option[T]): bool: /pure/options.     (line   25)
* proc isPowerOfTwo*(x: int): bool {.noSideEffect.}: /pure/math.
                                                             (line   42)
* proc isPrint*(c: cint): bool:          /wrappers/iup.      (line  625)
* proc isReady*(fv: FlowVarBase): bool:  /pure/concurrency/threadpool.
                                                             (line   59)
* proc isRootDir*(path: string): bool {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line  103)
* proc isSendDataBuffered*(s: AsyncSocket): bool: /deprecated/pure/asyncio.
                                                             (line  148)
* proc isShift*(s: cstring): bool:       /wrappers/iup.      (line  595)
* proc isShiftXkey*(c: cint): bool:      /wrappers/iup.      (line  631)
* proc isSome*[T](self: Option[T]): bool: /pure/options.     (line   22)
* proc isSorted*[T](a: openarray[T]; cmp: proc (x, y: T): int {.closure.};: /pure/algorithm.
                                                             (line  111)
* proc isSpace*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsSpaceChar".}: /pure/strutils.
                                                             (line   59)
* proc isSpace*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsSpaceStr".}: /pure/strutils.
                                                             (line  106)
* proc isSsl*(socket: AsyncSocket): bool: /pure/asyncnet.    (line  187)
* proc isSsl*(socket: Socket): bool:     /pure/net.          (line  420)
* proc isSSL*(socket: Socket): bool:     /deprecated/pure/sockets.
                                                             (line  610)
* proc isSupported*(n: PNode; feature: string; version: string): bool: /pure/xmldom.
                                                             (line  201)
* proc isSys*(s: cstring): bool:         /wrappers/iup.      (line  616)
* proc isSysXkey*(c: cint): bool:        /wrappers/iup.      (line  640)
* proc isTitle*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   94)
* proc isUniform*(m: Matrix3d; tol = 1e-06'f64): bool: /pure/basic3d.
                                                             (line  129)
* proc isUniform*(t: Matrix2d; tol = 1e-06'f64): bool: /pure/basic2d.
                                                             (line  125)
* proc isUpper*(c: char): bool {.noSideEffect, procvar, rtl, extern: "nsuIsUpperChar".}: /pure/strutils.
                                                             (line   71)
* proc isUpper*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   82)
* proc isUpper*(s: string): bool {.noSideEffect, procvar, rtl, extern: "nsuIsUpperStr".}: /pure/strutils.
                                                             (line  122)
* proc isValid*[A](s: HashSet[A]): bool: /pure/collections/sets.
                                                             (line   34)
* proc isValid*[A](s: OrderedSet[A]): bool: /pure/collections/sets.
                                                             (line  363)
* proc isWhiteSpace*(c: Rune): bool {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   99)
* proc isWriteable*(s: AsyncSocket): bool: /deprecated/pure/asyncio.
                                                             (line  123)
* proc isXkey*(c: cint): bool:           /wrappers/iup.      (line  628)
* proc is_active*(handle: PHandle): cint {.importc: "uv_is_active", header: "uv.h".}: /wrappers/libuv.
                                                             (line   49)
* proc IS_BLOB*(n: int32): bool:         /wrappers/mysql.    (line  278)
* proc is_linetouched*(a2: ptr WINDOW; a3: cint): cunsignedchar {.extdecl,: /wrappers/pdcurses.
                                                             (line  369)
* proc IS_NOT_NULL*(n: int32): bool:     /wrappers/mysql.    (line  275)
* proc IS_NUM*(t: Enum_field_types): bool: /wrappers/mysql.  (line  281)
* proc IS_NUM_FIELD*(f: Pst_mysql_field): bool: /wrappers/mysql.
                                                             (line  287)
* proc IS_PRI_KEY*(n: int32): bool:      /wrappers/mysql.    (line  272)
* proc is_termresized*(): cunsignedchar {.extdecl, importc: "is_termresized",: /wrappers/pdcurses.
                                                             (line 1588)
* proc is_wintouched*(a2: ptr WINDOW): cunsignedchar {.extdecl,: /wrappers/pdcurses.
                                                             (line  373)
* proc item*(nList: seq[PNode]; index: int): PNode: /pure/xmldom.
                                                             (line  249)
* proc item*(title, action: cstring): PIhandle {.importc: "IupItem", cdecl,: /wrappers/iup.
                                                             (line  461)
* proc iterToProc*(iter: typed; envType: typedesc; procName: untyped) {.magic: "Plugin",: /system/alloc.
                                                             (line    6)
* proc iUPcxCODE*(c: cint): cint:        /wrappers/iup.      (line  649)
* proc iUPmxCODE*(c: cint): cint:        /wrappers/iup.      (line  652)
* proc iUPsxCODE*(c: cint): cint:        /wrappers/iup.      (line  646)
* proc iupVersion*(): cstring {.importc: "IupVersion", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  145)
* proc iupVersionDate*(): cstring {.importc: "IupVersionDate", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  148)
* proc iupVersionNumber*(): cint {.importc: "IupVersionNumber", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  151)
* proc iUPxCODE*(c: cint): cint:         /wrappers/iup.      (line  643)
* proc iUPyxCODE*(c: cint): cint:        /wrappers/iup.      (line  655)
* proc javaEnabled*(h: Navigator): bool: /js/dom.            (line  256)
* proc jit_exec*(code: ptr Pcre; extra: ptr ExtraData; subject: cstring; length: cint;: /wrappers/pcre.
                                                             (line  145)
* proc jit_free_unused_memory*():        /wrappers/pcre.     (line  208)
* proc jit_stack_alloc*(startsize: cint; maxsize: cint): ptr JitStack: /wrappers/pcre.
                                                             (line  199)
* proc jit_stack_free*(stack: ptr JitStack): /wrappers/pcre. (line  202)
* proc join*(a: openArray[string]): string {.noSideEffect, rtl, extern: "nsuJoin".}: /pure/strutils.
                                                             (line  473)
* proc join*(a: openArray[string]; sep: string): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  467)
* proc join*[In, Out](a: PActor[In, Out]): /deprecated/pure/actors.
                                                             (line   48)
* proc join*[In, Out](a: var ActorPool[In, Out]): /deprecated/pure/actors.
                                                             (line  103)
* proc joinPath*(head, tail: string): string {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line   29)
* proc joinPath*(parts: varargs[string]): string {.noSideEffect, rtl,: /pure/ospaths.
                                                             (line   50)
* proc joinThread*[TArg](t: Thread[TArg]) {.inline.}: /system/threads.
                                                             (line   19)
* proc joinThreads*[TArg](t: varargs[Thread[TArg]]): /system/threads.
                                                             (line   24)
* proc keepIf*[T](seq1: var seq[T]; pred: proc (item: T): bool {.closure.}) {.inline.}: /pure/collections/sequtils.
                                                             (line  181)
* proc kevent*(kqFD: cint; changelist: ptr KEvent; nchanges: cint; eventlist: ptr KEvent;: /posix/kqueue.
                                                             (line   49)
* proc keyname*(a2: cint): cstring {.extdecl, importc: "keyname", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  377)
* proc keypad*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "keypad",: /wrappers/pdcurses.
                                                             (line  380)
* proc key_name*(a2: char): cstring {.extdecl, importc: "key_name", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1162)
* proc kill*(a1: Pid; a2: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1305)
* proc kill*(MySQL: PMySQL; pid: int): cint {.stdcall, dynlib: lib, importc: "mysql_kill".}: /wrappers/mysql.
                                                             (line  506)
* proc kill*(p: Process) {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  128)
* proc killchar*(): char {.extdecl, importc: "killchar", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  384)
* proc killpg*(a1: Pid; a2: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1308)
* proc killwchar*(a2: cstring): cint {.extdecl, importc: "killwchar", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1165)
* proc kind*(my: JsonParser): JsonEventKind {.inline.}: /pure/json.
                                                             (line   55)
* proc kind*(my: XmlParser): XmlEventKind {.inline.}: /pure/parsexml.
                                                             (line   39)
* proc kind*(n: NimNode): NimNodeKind {.magic: "NKind", noSideEffect.}: /core/macros.
                                                             (line  110)
* proc kind*(n: XmlNode): XmlNodeKind {.inline.}: /pure/xmltree.
                                                             (line   95)
* proc kind*(x: Any): AnyKind {.inline.}: /core/typeinfo.    (line   22)
* proc kqueue*(): cint {.importc: "kqueue", header: "<sys/event.h>".}: /posix/kqueue.
                                                             (line   44)
* proc kurtosis*(s: RunningStat): float: /pure/stats.        (line   84)
* proc kurtosis*[T](x: openArray[T]): float: /pure/stats.    (line  142)
* proc kurtosisS*(s: RunningStat): float: /pure/stats.       (line   89)
* proc kurtosisS*[T](x: openArray[T]): float: /pure/stats.   (line  147)
* proc label*(title: cstring): PIhandle {.importc: "IupLabel", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  496)
* proc largest*[A](t: CountTableRef[A]): (A, int): /pure/collections/tables.
                                                             (line  525)
* proc largest*[A](t: CountTable[A]): tuple[key: A, val: int]: /pure/collections/tables.
                                                             (line  445)
* proc last*(node: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  493)
* proc lastChild*(n: PNode): PNode:      /pure/xmldom.       (line  119)
* proc lastRune*(s: string; last: int): (Rune, int): /pure/unicode.
                                                             (line  139)
* proc lastSon*(n: PRstNode): PRstNode:  /packages/docutils/rstast.
                                                             (line   33)
* proc last_error*(a2: PLoop): Err {.importc: "uv_last_error", header: "uv.h".}: /wrappers/libuv.
                                                             (line   36)
* proc last_insert_rowid*(para1: PSqlite3): int64 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line   30)
* proc lchown*(a1: cstring; a2: Uid; a3: Gid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  909)
* proc lcm*[T](x, y: T): T:              /pure/math.         (line  291)
* proc leaveok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "leaveok",: /wrappers/pdcurses.
                                                             (line  387)
* proc len*(a: Rope): int {.rtl, extern: "nro$1".}: /pure/ropes.
                                                             (line    6)
* proc len*(disp: Dispatcher): int:      /deprecated/pure/asyncio.
                                                             (line  227)
* proc len*(n: JsonNode): int:           /pure/json.         (line  215)
* proc len*(n: NimNode): int {.magic: "NLen", noSideEffect.}: /core/macros.
                                                             (line   86)
* proc len*(n: PRstNode): int:           /packages/docutils/rstast.
                                                             (line   24)
* proc len*(n: SqlNode): int:            /pure/parsesql.     (line   49)
* proc len*(n: XmlNode): int {.inline.}: /pure/xmltree.      (line   90)
* proc len*(row: InstantRow): int {.inline.}: /impure/db_odbc.
                                                             (line   42)
* proc len*(row: InstantRow): int {.inline.} <1>: /impure/db_mysql.
                                                             (line   46)
* proc len*(row: InstantRow): int32 {.inline.}: /impure/db_postgres.
                                                             (line   59)
* proc len*(row: InstantRow): int32 {.inline.} <1>: /impure/db_sqlite.
                                                             (line   42)
* proc len*(s: SharedString): int:       /pure/collections/sharedstrings.
                                                             (line   21)
* proc len*(s: TaintedString): int {.borrow.}: /system.      (line 1341)
* proc len*(t: StringTableRef): int {.rtl, extern: "nst$1".}: /pure/strtabs.
                                                             (line   30)
* proc len*(v: Vector2d): float {.inline.}: /pure/basic2d.   (line  189)
* proc len*(v: Vector3d): float:         /pure/basic3d.      (line  208)
* proc len*(w: WideCString): int:        /system/widestrs.   (line   12)
* proc len*(x: Any): int:                /core/typeinfo.     (line   73)
* proc len*(x: cstring): int {.magic: "LengthStr", noSideEffect.}: /system.
                                                             (line  571)
* proc len*(x: string): int {.magic: "LengthStr", noSideEffect.}: /system.
                                                             (line  568)
* proc len*[A, B](t: OrderedTableRef[A, B]): int {.inline.}: /pure/collections/tables.
                                                             (line  289)
* proc len*[A, B](t: OrderedTable[A, B]): int {.inline.}: /pure/collections/tables.
                                                             (line  201)
* proc len*[A, B](t: TableRef[A, B]): int: /pure/collections/tables.
                                                             (line   93)
* proc len*[A, B](t: Table[A, B]): int:  /pure/collections/tables.
                                                             (line   28)
* proc len*[A](s: HashSet[A]): int:      /pure/collections/sets.
                                                             (line   48)
* proc len*[A](s: OrderedSet[A]): int {.inline.}: /pure/collections/sets.
                                                             (line  377)
* proc len*[A](t: CountTableRef[A]): int: /pure/collections/tables.
                                                             (line  458)
* proc len*[A](t: CountTable[A]): int:   /pure/collections/tables.
                                                             (line  371)
* proc len*[I, T](x: array[I, T]): int {.magic: "LengthArray", noSideEffect.}: /system.
                                                             (line  574)
* proc len*[TOpenArray: openArray | varargs](x: TOpenArray): int {.: /system.
                                                             (line  564)
* proc len*[T](c: CritBitTree[T]): int:  /pure/collections/critbits.
                                                             (line   19)
* proc len*[T](q: Queue[T]): int:        /pure/collections/queues.
                                                             (line   23)
* proc len*[T](tbl: PGenTable[T]): int {.inline.}: /pure/gentabs.
                                                             (line   14)
* proc len*[T](x: seq[T]): int {.magic: "LengthSeq", noSideEffect.}: /system.
                                                             (line  577)
* proc lgamma*(x: float): float {.importc: "lgamma", header: "<math.h>".}: /pure/math.
                                                             (line  213)
* proc library_end*() {.cdecl, dynlib: lib, importc: "mysql_server_end".}: /wrappers/mysql.
                                                             (line  301)
* proc library_init*(argc: cint; argv: cstringArray; groups: cstringArray): cint {.cdecl,: /wrappers/mysql.
                                                             (line  297)
* proc libversion*(): cstring {.cdecl, dynlib: Lib, importc: "sqlite3_libversion".}: /wrappers/sqlite3.
                                                             (line  442)
* proc libversion_number*(): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  448)
* proc likely*(val: bool): bool {.importc: "likely", nodecl, nosideeffect.}: /system.
                                                             (line 2381)
* proc lineinfo*(n: NimNode): string {.magic: "NLineInfo", noSideEffect.}: /core/macros.
                                                             (line  257)
* proc link*(a1, a2: cstring): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  912)
* proc link*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  357)
* proc link*(url, title: cstring): PIhandle {.importc: "IupLink", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  484)
* proc lio_listio*(a1: cint; a2: ptr ptr Taiocb; a3: cint; a4: ptr SigEvent): cint {.importc,: /posix/posix.
                                                             (line  168)
* proc lispRepr*(n: NimNode): string {.compileTime, benign.}: /core/macros.
                                                             (line  402)
* proc list*(action: cstring): PIhandle {.importc: "IupList", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  499)
* proc list*(ftp: AsyncFtpClient; dir = ""): Future[string] {.async.}: /pure/asyncftpclient.
                                                             (line   69)
* proc list*[T](ftp: FtpBase[T]; dir: string = ""; async = false): string: /deprecated/pure/ftpclient.
                                                             (line   85)
* proc listDialog*(theType: cint; title: cstring; size: cint; list: cstringArray;: /wrappers/iup.
                                                             (line   68)
* proc listDirs*(dir: string): seq[string]: /system/nimscript.
                                                             (line   33)
* proc listDirs*(ftp: AsyncFtpClient; dir = ""): Future[seq[string]] {.async.}: /pure/asyncftpclient.
                                                             (line   42)
* proc listDirs*[T](ftp: FtpBase[T]; dir: string = ""; async = false): seq[string]: /deprecated/pure/ftpclient.
                                                             (line   46)
* proc listen*(a1: SocketHandle; a2: cint): cint {.importc, header: "<sys/socket.h>".}: /posix/posix.
                                                             (line 1599)
* proc listen*(s: SocketHandle; backlog: cint): cint {.stdcall, importc: "listen",: /windows/winlean.
                                                             (line  406)
* proc listen*(sock: AsyncSocket):       /deprecated/pure/asyncio.
                                                             (line   72)
* proc listen*(socket: AsyncSocket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}: /pure/asyncnet.
                                                             (line  133)
* proc listen*(socket: Socket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}: /pure/net.
                                                             (line  162)
* proc listen*(socket: Socket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  121)
* proc listen*(socket: SocketHandle; backlog = SOMAXCONN): cint {.tags: [ReadIOEffect].}: /pure/nativesockets.
                                                             (line   79)
* proc listen*(stream: PStream; backlog: cint; cb: ConnectionProc): cint {.: /wrappers/libuv.
                                                             (line   58)
* proc listFiles*(dir: string): seq[string]: /system/nimscript.
                                                             (line   39)
* proc list_dbs*(MySQL: PMySQL; wild: cstring): PRES {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  543)
* proc list_fields*(MySQL: PMySQL; table: cstring; wild: cstring): PRES {.stdcall,: /wrappers/mysql.
                                                             (line  585)
* proc list_processes*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  551)
* proc list_tables*(MySQL: PMySQL; wild: cstring): PRES {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  547)
* proc littleEndian16*(outp, inp: pointer) {.inline.}: /pure/endians.
                                                             (line   30)
* proc littleEndian32*(outp, inp: pointer) {.inline.}: /pure/endians.
                                                             (line   27)
* proc littleEndian64*(outp, inp: pointer) {.inline.}: /pure/endians.
                                                             (line   24)
* proc ln*(x: float): float {.importc: "log", header: "<math.h>".}: /pure/math.
                                                             (line  107)
* proc ln*(z: Complex): Complex:         /pure/complex.      (line  154)
* proc load*(filename: cstring): cstring {.importc: "IupLoad", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  142)
* proc load*[T](s: Stream; data: var T): /pure/marshal.      (line    6)
* proc loadavg*(load: var array[0 .. 2, cdouble]) {.importc: "uv_loadavg", header: "uv.h".}: /wrappers/libuv.
                                                             (line  409)
* proc loadHtml*(path: string): XmlNode: /pure/htmlparser.   (line  249)
* proc loadHtml*(path: string; errors: var seq[string]): XmlNode: /pure/htmlparser.
                                                             (line  242)
* proc loadLib*(): LibHandle:            /pure/dynlib.       (line   20)
* proc loadLib*(path: string; global_symbols = false): LibHandle: /pure/dynlib.
                                                             (line   14)
* proc loadUnidecodeTable*(datafile = "unidecode.dat"): /pure/unidecode/unidecode.
                                                             (line    6)
* proc loadXml*(path: string): XmlNode:  /pure/xmlparser.    (line   36)
* proc loadXml*(path: string; errors: var seq[string]): XmlNode: /pure/xmlparser.
                                                             (line   29)
* proc loadXML*(xml: string): PDocument: /pure/xmldomparser. (line   12)
* proc loadXMLFile*(path: string): PDocument: /pure/xmldomparser.
                                                             (line   18)
* proc loadXMLStream*(stream: Stream): PDocument: /pure/xmldomparser.
                                                             (line    6)
* proc load_defaults*(conf_file: cstring; groups: cstringArray; argc: ptr cint;: /wrappers/mysql.
                                                             (line  257)
* proc load_model*(model_file_name: cstring): ptr Model {.cdecl,: /wrappers/libsvm.
                                                             (line   74)
* proc localeconv*(): ptr Lconv {.importc, header: "<locale.h>".}: /posix/posix.
                                                             (line  321)
* proc localFree*(p: pointer) {.importc: "LocalFree", stdcall, dynlib: "kernel32".}: /windows/winlean.
                                                             (line  223)
* proc localName*(n: PNode): string:     /pure/xmldom.       (line  124)
* proc locals*(): RootObj {.magic: "Plugin", noSideEffect.}: /system.
                                                             (line 2653)
* proc localtime*(a1: var Time): ptr Tm {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1246)
* proc localtime_r*(a1: var Time; a2: var Tm): ptr Tm {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1249)
* proc lockf*(a1, a2: cint; a3: Off): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  915)
* proc log*(s: cstring) {.importc: "console.log", varargs, nodecl.}: /system/jssys.
                                                             (line    9)
* proc log10*(x: float): float {.importc: "log10", header: "<math.h>".}: /pure/math.
                                                             (line  112)
* proc log10*(z: Complex): Complex:      /pure/complex.      (line  159)
* proc log2*(x: float): float:           /pure/math.         (line  117)
* proc log2*(z: Complex): Complex:       /pure/complex.      (line  164)
* proc longname*(): cstring {.extdecl, importc: "longname", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  391)
* proc loopStep*(): cint {.importc: "IupLoopStep", cdecl, dynlib: dllname, discardable.}: /wrappers/iup.
                                                             (line  104)
* proc loop_delete*(a2: PLoop) {.importc: "uv_loop_delete", header: "uv.h".}: /wrappers/libuv.
                                                             (line   15)
* proc loop_new*(): PLoop {.importc: "uv_loop_new", header: "uv.h".}: /wrappers/libuv.
                                                             (line   12)
* proc low*[T](x: T): T {.magic: "Low", noSideEffect.}: /system.
                                                             (line  324)
* proc lowerBound*[T](a: openArray[T]; key: T): int: /pure/algorithm.
                                                             (line   78)
* proc lowerBound*[T](a: openArray[T]; key: T; cmp: proc (x, y: T): int {.closure.}): int: /pure/algorithm.
                                                             (line   62)
* proc lo_close*(conn: PPGconn; fd: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  394)
* proc lo_creat*(conn: PPGconn; mode: int32): Oid {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  410)
* proc lo_export*(conn: PPGconn; lobjId: Oid; filename: cstring): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  426)
* proc lo_import*(conn: PPGconn; filename: cstring): Oid {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  422)
* proc lo_lseek*(conn: PPGconn; fd: int32; offset: int32; whence: int32): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  406)
* proc lo_open*(conn: PPGconn; lobjId: Oid; mode: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  390)
* proc lo_read*(conn: PPGconn; fd: int32; buf: cstring; length: int): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  398)
* proc lo_tell*(conn: PPGconn; fd: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  414)
* proc lo_unlink*(conn: PPGconn; lobjId: Oid): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  418)
* proc lo_write*(conn: PPGconn; fd: int32; buf: cstring; length: int): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  402)
* proc lseek*(a1: cint; a2: Off; a3: cint): Off {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  918)
* proc lstat*(a1: cstring; a2: var Stat): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1083)
* proc lstat*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  353)
* proc mainLoop*(): cint {.importc: "IupMainLoop", cdecl, dynlib: dllname, discardable.}: /wrappers/iup.
                                                             (line  101)
* proc mainLoopLevel*(): cint {.importc: "IupMainLoopLevel", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  107)
* proc makecontext*(a1: var Ucontext; a4: proc () {.noconv.}; a3: cint) {.varargs, importc,: /posix/posix.
                                                             (line 1543)
* proc maketables*(): pointer:           /wrappers/pcre.     (line  181)
* proc make_password_from_salt*(fto: cstring; hash_stage2: pointer) {.cdecl,: /wrappers/mysql.
                                                             (line  236)
* proc make_password_from_salt_323*(fto: cstring; salt: ptr int) {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  211)
* proc make_scrambled_password*(fto: cstring; password: cstring) {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  220)
* proc make_scrambled_password_323*(fto: cstring; password: cstring) {.cdecl,: /wrappers/mysql.
                                                             (line  194)
* proc manager_close*(con: PMANAGER) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  625)
* proc manager_command*(con: PMANAGER; cmd: cstring; cmd_len: cint): cint {.stdcall,: /wrappers/mysql.
                                                             (line  629)
* proc manager_connect*(con: PMANAGER; host: cstring; user: cstring; passwd: cstring;: /wrappers/mysql.
                                                             (line  619)
* proc manager_fetch_line*(con: PMANAGER; res_buf: cstring; res_buf_size: cint): cint {.: /wrappers/mysql.
                                                             (line  633)
* proc manager_init*(con: PMANAGER): PMANAGER {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  615)
* proc map*(ih: PIhandle): cint {.importc: "IupMap", cdecl, dynlib: dllname, discardable.}: /wrappers/iup.
                                                             (line  225)
* proc map*[A, B](data: HashSet[A]; op: proc (x: A): B {.closure.}): HashSet[B]: /pure/collections/sets.
                                                             (line  351)
* proc map*[T, R](self: Option[T]; callback: proc (input: T): R): Option[R]: /pure/options.
                                                             (line   50)
* proc map*[T, S](data: openArray[T]; op: proc (x: T): S {.closure.}): seq[S] {.inline.}: /pure/collections/sequtils.
                                                             (line  107)
* proc map*[T](data: var openArray[T]; op: proc (x: var T) {.closure.}) {.deprecated.}: /pure/collections/sequtils.
                                                             (line  121)
* proc map*[T](self: Option[T]; callback: proc (input: T)): /pure/options.
                                                             (line   45)
* proc mapFont*(iupfont: cstring): cstring {.importc: "IupMapFont", cdecl,: /wrappers/iup.
                                                             (line  131)
* proc mapMem*(m: var MemFile; mode: FileMode = fmRead; mappedSize = - 1; offset = 0): pointer: /pure/memfiles.
                                                             (line   44)
* proc mapViewOfFileEx*(hFileMappingObject: Handle; dwDesiredAccess: DWORD;: /windows/winlean.
                                                             (line  525)
* proc map_button*(a2: cunsignedlong): cint {.extdecl, importc: "map_button",: /wrappers/pdcurses.
                                                             (line 1516)
* proc master_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  423)
* proc master_send_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall,: /wrappers/mysql.
                                                             (line  427)
* proc match*(pattern: RegexMatch): string: /impure/nre.     (line   35)
* proc match*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {.: /pure/pegs.
                                                             (line  231)
* proc match*(s: string; pattern: Peg; start = 0): bool {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  239)
* proc match*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool: /impure/re.
                                                             (line   81)
* proc match*(s: string; pattern: Regex; start = 0): bool: /impure/re.
                                                             (line   76)
* proc match*(str: string; pattern: Regex; start = 0; endpos = int.high): Option[RegexMatch]: /impure/nre.
                                                             (line   73)
* proc matchBounds*(pattern: RegexMatch): Slice[int]: /impure/nre.
                                                             (line   38)
* proc matchLen*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {.: /pure/pegs.
                                                             (line  213)
* proc matchLen*(s: string; pattern: Peg; start = 0): int {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  222)
* proc matchLen*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int: /impure/re.
                                                             (line   62)
* proc matchLen*(s: string; pattern: Regex; start = 0): int: /impure/re.
                                                             (line   69)
* proc matGetAttribute*(ih: PIhandle; name: cstring; lin, col: cint): cstring {.cdecl,: /wrappers/iup.
                                                             (line  698)
* proc matGetFloat*(ih: PIhandle; name: cstring; lin, col: cint): cfloat {.cdecl,: /wrappers/iup.
                                                             (line  706)
* proc matGetInt*(ih: PIhandle; name: cstring; lin, col: cint): cint {.cdecl,: /wrappers/iup.
                                                             (line  702)
* proc matrix*(action: cstring): PIhandle {.cdecl, importc: "IupMatrix", dynlib: dllname.}: /wrappers/iup.
                                                             (line  685)
* proc matrix2d*(ax, ay, bx, by, tx, ty: float): Matrix2d: /pure/basic2d.
                                                             (line   49)
* proc matrix2d*(ax, ay, bx, by, tx, ty: float): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   28)
* proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float): Matrix3d: /pure/basic3d.
                                                             (line   59)
* proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float): Matrix3d {.: /pure/basic3d.
                                                             (line   28)
* proc matSetAttribute*(ih: PIhandle; name: cstring; lin, col: cint; value: cstring) {.: /wrappers/iup.
                                                             (line  688)
* proc matSetfAttribute*(ih: PIhandle; name: cstring; lin, col: cint; format: cstring) {.: /wrappers/iup.
                                                             (line  710)
* proc matStoreAttribute*(ih: PIhandle; name: cstring; lin, col: cint; value: cstring) {.: /wrappers/iup.
                                                             (line  693)
* proc max*(x, y: float): float {.magic: "MaxF64", noSideEffect.}: /system.
                                                             (line 1832)
* proc max*(x, y: int): int {.magic: "MaxI", noSideEffect.}: /system.
                                                             (line 1804)
* proc max*(x, y: int16): int16 {.magic: "MaxI", noSideEffect.}: /system.
                                                             (line 1810)
* proc max*(x, y: int32): int32 {.magic: "MaxI", noSideEffect.}: /system.
                                                             (line 1813)
* proc max*(x, y: int64): int64 {.magic: "MaxI", noSideEffect.}: /system.
                                                             (line 1816)
* proc max*(x, y: int8): int8 {.magic: "MaxI", noSideEffect.}: /system.
                                                             (line 1807)
* proc max*[T](x: varargs[T]): T:        /system.            (line 1821)
* proc md5*(d: ptr cuchar; n: csize; md: ptr cuchar): ptr cuchar {.ic.}: /wrappers/openssl.
                                                             (line  304)
* proc md5Final*(c: var MD5Context; digest: var MD5Digest): /pure/md5.
                                                             (line   28)
* proc md5Init*(c: var MD5Context):      /pure/md5.          (line   18)
* proc md5Update*(c: var MD5Context; input: cstring; len: int): /pure/md5.
                                                             (line   23)
* proc md5_File*(file: string): string {.raises: [IOError, Exception].}: /wrappers/openssl.
                                                             (line  310)
* proc md5_Final*(md: cstring; c: var MD5_CTX): cint {.ic.}: /wrappers/openssl.
                                                             (line  301)
* proc md5_Init*(c: var MD5_CTX): cint {.ic.}: /wrappers/openssl.
                                                             (line  295)
* proc md5_Str*(str: string): string {.raises: [IOError].}: /wrappers/openssl.
                                                             (line  315)
* proc md5_Transform*(c: var MD5_CTX; b: ptr cuchar) {.ic.}: /wrappers/openssl.
                                                             (line  307)
* proc md5_Update*(c: var MD5_CTX; data: pointer; len: csize): cint {.ic.}: /wrappers/openssl.
                                                             (line  298)
* proc mean*(s: RunningStat): float:     /pure/stats.        (line   49)
* proc mean*[T](x: openArray[T]): float: /pure/stats.        (line  107)
* proc menu*(child: PIhandle): PIhandle {.importc: "IupMenu", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  472)
* proc menuv*(children: ptr PIhandle): PIhandle {.importc: "IupMenuv", cdecl,: /wrappers/iup.
                                                             (line  476)
* proc merge*[A](s, t: CountTableRef[A]): /pure/collections/tables.
                                                             (line  548)
* proc merge*[A](s, t: CountTable[A]): CountTable[A]: /pure/collections/tables.
                                                             (line  543)
* proc merge*[A](s: var CountTable[A]; t: CountTable[A]): /pure/collections/tables.
                                                             (line  538)
* proc mergeIndexes*(dir: string): string: /packages/docutils/rstgen.
                                                             (line  135)
* proc message*(title, msg: cstring) {.importc: "IupMessage", dynlib: dllname, cdecl.}: /wrappers/iup.
                                                             (line   54)
* proc messageDlg*(): PIhandle {.importc: "IupMessageDlg", dynlib: dllname, cdecl.}: /wrappers/iup.
                                                             (line   42)
* proc messagef*(title, format: cstring) {.importc: "IupMessagef", dynlib: dllname, cdecl,: /wrappers/iup.
                                                             (line   57)
* proc meta*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "meta",: /wrappers/pdcurses.
                                                             (line  394)
* proc mget*(n: var XmlNode; i: int): var XmlNode {.inline, deprecated.}: /pure/xmltree.
                                                             (line  115)
* proc mget*(t: StringTableRef; key: string): var string {.deprecated.}: /pure/strtabs.
                                                             (line   43)
* proc mget*[A, B](t: OrderedTableRef[A, B]; key: A): var B {.deprecated.}: /pure/collections/tables.
                                                             (line  301)
* proc mget*[A, B](t: TableRef[A, B]; key: A): var B {.deprecated.}: /pure/collections/tables.
                                                             (line  138)
* proc mget*[A, B](t: var OrderedTable[A, B]; key: A): var B {.deprecated.}: /pure/collections/tables.
                                                             (line  219)
* proc mget*[A, B](t: var SharedTable[A, B]; key: A): var B: /pure/collections/sharedtables.
                                                             (line   20)
* proc mget*[A, B](t: var Table[A, B]; key: A): var B {.deprecated.}: /pure/collections/tables.
                                                             (line   46)
* proc mget*[A](s: var HashSet[A]; key: A): var A {.deprecated.}: /pure/collections/sets.
                                                             (line   86)
* proc mget*[A](t: CountTableRef[A]; key: A): var int {.deprecated.}: /pure/collections/tables.
                                                             (line  469)
* proc mget*[A](t: var CountTable[A]; key: A): var int {.deprecated.}: /pure/collections/tables.
                                                             (line  389)
* proc mget*[T](c: var CritBitTree[T]; key: string): var T {.inline, deprecated.}: /pure/collections/critbits.
                                                             (line   74)
* proc mget*[T](future: FutureVar[T]): var T: /pure/asyncdispatch.
                                                             (line  100)
* proc mgetOrPut*[A, B](t: OrderedTableRef[A, B]; key: A; val: B): var B: /pure/collections/tables.
                                                             (line  311)
* proc mgetOrPut*[A, B](t: TableRef[A, B]; key: A; val: B): var B: /pure/collections/tables.
                                                             (line  148)
* proc mgetOrPut*[A, B](t: var OrderedTable[A, B]; key: A; val: B): var B: /pure/collections/tables.
                                                             (line  250)
* proc mgetOrPut*[A, B](t: var SharedTable[A, B]; key: A; val: B): var B: /pure/collections/sharedtables.
                                                             (line   26)
* proc mgetOrPut*[A, B](t: var Table[A, B]; key: A; val: B): var B: /pure/collections/tables.
                                                             (line   71)
* proc miliseconds*(t: TimeInterval): int {.deprecated.}: /pure/times.
                                                             (line  182)
* proc milliseconds*(ms: int): TimeInterval {.inline.}: /pure/times.
                                                             (line  243)
* proc min*(x, y: float): float {.magic: "MinF64", noSideEffect.}: /system.
                                                             (line 1829)
* proc min*(x, y: int): int {.magic: "MinI", noSideEffect.}: /system.
                                                             (line 1782)
* proc min*(x, y: int16): int16 {.magic: "MinI", noSideEffect.}: /system.
                                                             (line 1788)
* proc min*(x, y: int32): int32 {.magic: "MinI", noSideEffect.}: /system.
                                                             (line 1791)
* proc min*(x, y: int64): int64 {.magic: "MinI", noSideEffect.}: /system.
                                                             (line 1794)
* proc min*(x, y: int8): int8 {.magic: "MinI", noSideEffect.}: /system.
                                                             (line 1785)
* proc min*[T](x: varargs[T]): T:        /system.            (line 1799)
* proc minutes*(m: int): TimeInterval {.inline.}: /pure/times.
                                                             (line  257)
* proc mirror*(org: Point2d; v: Vector2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line  107)
* proc mirror*(org: Point3d; planeperp: Vector3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  144)
* proc mirror*(planeperp: Vector3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  137)
* proc mirror*(v: var Vector2d; mirrvec: Vector2d): /pure/basic2d.
                                                             (line  300)
* proc mirror*(v: var Vector3d; planeperp: Vector3d): /pure/basic3d.
                                                             (line  296)
* proc mirror*(v: Vector2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line  101)
* proc mkdir*(a1: cstring; a2: Mode): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1086)
* proc mkDir*(dir: string) {.raises: [OSError].}: /system/nimscript.
                                                             (line  129)
* proc mkdir*(loop: PLoop; req: PFS; path: cstring; mode: cint; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  299)
* proc mkfifo*(a1: cstring; a2: Mode): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1089)
* proc mknod*(a1: cstring; a2: Mode; a3: Dev): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1092)
* proc mktime*(a1: var Tm): Time {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1252)
* proc mlock*(a1: pointer; a2: int): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1156)
* proc mlockall*(a1: cint): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1159)
* proc mmap*(a1: pointer; a2: int; a3, a4, a5: cint; a6: Off): pointer {.importc,: /posix/posix.
                                                             (line 1162)
* proc modify_defaults_file*(file_location: cstring; option: cstring;: /wrappers/mysql.
                                                             (line  249)
* proc months*(m: int): TimeInterval {.inline.}: /pure/times.
                                                             (line  278)
* proc more_results*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  764)
* proc mouseinterval*(a2: cint): cint {.extdecl, importc: "mouseinterval",: /wrappers/pdcurses.
                                                             (line 1551)
* proc mousemask*(a2: cunsignedlong; a3: ptr cunsignedlong): cunsignedlong {.extdecl,: /wrappers/pdcurses.
                                                             (line 1555)
* proc mouse_off*(a2: cunsignedlong): cint {.extdecl, importc: "mouse_off",: /wrappers/pdcurses.
                                                             (line 1508)
* proc mouse_on*(a2: cunsignedlong): cint {.extdecl, importc: "mouse_on",: /wrappers/pdcurses.
                                                             (line 1504)
* proc mouse_set*(a2: cunsignedlong): cint {.extdecl, importc: "mouse_set",: /wrappers/pdcurses.
                                                             (line 1500)
* proc mouse_trafo*(a2: ptr cint; a3: ptr cint; a4: cunsignedchar): cunsignedchar {.extdecl,: /wrappers/pdcurses.
                                                             (line 1559)
* proc move*(a2: cint; a3: cint): cint {.extdecl, importc: "move", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  398)
* proc move*(dx, dy, dz: float): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line   89)
* proc move*(dx, dy: float): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   79)
* proc move*(p: var Point2d; dx, dy: float) {.inline.}: /pure/basic2d.
                                                             (line  475)
* proc move*(p: var Point2d; v: Vector2d) {.inline.}: /pure/basic2d.
                                                             (line  480)
* proc move*(p: var Point3d; dx, dy, dz: float) {.inline.}: /pure/basic3d.
                                                             (line  455)
* proc move*(p: var Point3d; v: Vector3d) {.inline.}: /pure/basic3d.
                                                             (line  460)
* proc move*(v: Vector2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   84)
* proc move*(v: Vector3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line   94)
* proc moveBy*(w: Window; x, y: int):    /js/dom.            (line   70)
* proc moveFile*(source, dest: string) {.rtl, extern: "nos$1",: /pure/os.
                                                             (line  252)
* proc moveFileW*(lpExistingFileName, lpNewFileName: WideCString; bFailIfExists: cint): cint {.: /windows/winlean.
                                                             (line  302)
* proc moveMem*(dest, source: pointer; size: Natural) {.importc: "memmove",: /system.
                                                             (line 1511)
* proc moveTo*(w: Window; x, y: int):    /js/dom.            (line   73)
* proc move_panel*(pan: ptr PANEL; starty: cint; startx: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1716)
* proc mprintf*(para1: cstring): cstring {.cdecl, varargs, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line   73)
* proc mprotect*(a1: pointer; a2: int; a3: cint): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1166)
* proc mq_close*(a1: Mqd): cint {.importc, header: "<mqueue.h>".}: /posix/posix.
                                                             (line  331)
* proc mq_getattr*(a1: Mqd; a2: ptr MqAttr): cint {.importc, header: "<mqueue.h>".}: /posix/posix.
                                                             (line  334)
* proc mq_notify*(a1: Mqd; a2: ptr SigEvent): cint {.importc, header: "<mqueue.h>".}: /posix/posix.
                                                             (line  337)
* proc mq_open*(a1: cstring; a2: cint): Mqd {.varargs, importc, header: "<mqueue.h>".}: /posix/posix.
                                                             (line  340)
* proc mq_receive*(a1: Mqd; a2: cstring; a3: int; a4: var int): int {.importc,: /posix/posix.
                                                             (line  343)
* proc mq_send*(a1: Mqd; a2: cstring; a3: int; a4: int): cint {.importc, header: "<mqueue.h>".}: /posix/posix.
                                                             (line  347)
* proc mq_setattr*(a1: Mqd; a2, a3: ptr MqAttr): cint {.importc, header: "<mqueue.h>".}: /posix/posix.
                                                             (line  350)
* proc mq_timedreceive*(a1: Mqd; a2: cstring; a3: int; a4: int; a5: ptr Timespec): int {.: /posix/posix.
                                                             (line  353)
* proc mq_timedsend*(a1: Mqd; a2: cstring; a3: int; a4: int; a5: ptr Timespec): cint {.importc,: /posix/posix.
                                                             (line  357)
* proc mq_unlink*(a1: cstring): cint {.importc, header: "<mqueue.h>".}: /posix/posix.
                                                             (line  361)
* proc msync*(a1: pointer; a2: int; a3: cint): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1169)
* proc multiLine*(action: cstring): PIhandle {.importc: "IupMultiLine", cdecl,: /wrappers/iup.
                                                             (line  505)
* proc munlock*(a1: pointer; a2: int): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1172)
* proc munlockall*(): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1175)
* proc munmap*(a1: pointer; a2: int): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1178)
* proc mvaddch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, importc: "mvaddch",: /wrappers/pdcurses.
                                                             (line  401)
* proc mvaddchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  405)
* proc mvaddchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  409)
* proc mvaddnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  413)
* proc mvaddnwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1168)
* proc mvaddrawch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1592)
* proc mvaddstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvaddstr",: /wrappers/pdcurses.
                                                             (line  417)
* proc mvaddwstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvaddwstr",: /wrappers/pdcurses.
                                                             (line 1172)
* proc mvadd_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1176)
* proc mvadd_wchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1180)
* proc mvadd_wchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1184)
* proc mvchgat*(a2: cint; a3: cint; a4: cint; a5: cunsignedlong; a6: cshort; a7: pointer): cint {.: /wrappers/pdcurses.
                                                             (line  421)
* proc mvcur*(a2: cint; a3: cint; a4: cint; a5: cint): cint {.extdecl, importc: "mvcur",: /wrappers/pdcurses.
                                                             (line  425)
* proc mvdelch*(a2: cint; a3: cint): cint {.extdecl, importc: "mvdelch",: /wrappers/pdcurses.
                                                             (line  429)
* proc mvdeleteln*(a2: cint; a3: cint): cint {.extdecl, importc: "mvdeleteln",: /wrappers/pdcurses.
                                                             (line 1596)
* proc mvderwin*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvderwin",: /wrappers/pdcurses.
                                                             (line  433)
* proc mvFile*(`from`, to: string) {.raises: [OSError].}: /system/nimscript.
                                                             (line  135)
* proc mvgetch*(a2: cint; a3: cint): cint {.extdecl, importc: "mvgetch",: /wrappers/pdcurses.
                                                             (line  437)
* proc mvgetnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  441)
* proc mvgetn_wstr*(a2: cint; a3: cint; a4: ptr cint; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1188)
* proc mvgetstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvgetstr",: /wrappers/pdcurses.
                                                             (line  445)
* proc mvget_wch*(a2: cint; a3: cint; a4: ptr cint): cint {.extdecl, importc: "mvget_wch",: /wrappers/pdcurses.
                                                             (line 1192)
* proc mvget_wstr*(a2: cint; a3: cint; a4: ptr cint): cint {.extdecl, importc: "mvget_wstr",: /wrappers/pdcurses.
                                                             (line 1196)
* proc mvhline*(a2: cint; a3: cint; a4: cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  449)
* proc mvhline_set*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1200)
* proc mvinch*(a2: cint; a3: cint): cunsignedlong {.extdecl, importc: "mvinch",: /wrappers/pdcurses.
                                                             (line  453)
* proc mvinchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  457)
* proc mvinchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  461)
* proc mvinnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  465)
* proc mvinnwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1204)
* proc mvinsch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, importc: "mvinsch",: /wrappers/pdcurses.
                                                             (line  469)
* proc mvinsertln*(a2: cint; a3: cint): cint {.extdecl, importc: "mvinsertln",: /wrappers/pdcurses.
                                                             (line 1600)
* proc mvinsnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  473)
* proc mvinsrawch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1604)
* proc mvinsstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvinsstr",: /wrappers/pdcurses.
                                                             (line  477)
* proc mvinstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvinstr",: /wrappers/pdcurses.
                                                             (line  481)
* proc mvins_nwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1208)
* proc mvins_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1212)
* proc mvins_wstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvins_wstr",: /wrappers/pdcurses.
                                                             (line 1216)
* proc mvinwstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, importc: "mvinwstr",: /wrappers/pdcurses.
                                                             (line 1220)
* proc mvin_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1224)
* proc mvin_wchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1228)
* proc mvin_wchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1232)
* proc mvprintw*(a2: cint; a3: cint; a4: cstring): cint {.varargs, extdecl,: /wrappers/pdcurses.
                                                             (line  485)
* proc mvscanw*(a2: cint; a3: cint; a4: cstring): cint {.varargs, extdecl,: /wrappers/pdcurses.
                                                             (line  489)
* proc mvvline*(a2: cint; a3: cint; a4: cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  493)
* proc mvvline_set*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1236)
* proc mvwaddch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  506)
* proc mvwaddchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line  497)
* proc mvwaddchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.: /wrappers/pdcurses.
                                                             (line  502)
* proc mvwaddnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  510)
* proc mvwaddnwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1240)
* proc mvwaddrawch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1608)
* proc mvwaddstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  514)
* proc mvwaddwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1244)
* proc mvwadd_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1248)
* proc mvwadd_wchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line 1252)
* proc mvwadd_wchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.: /wrappers/pdcurses.
                                                             (line 1257)
* proc mvwchgat*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cunsignedlong; a7: cshort;: /wrappers/pdcurses.
                                                             (line  518)
* proc mvwdelch*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvwdelch",: /wrappers/pdcurses.
                                                             (line  523)
* proc mvwdeleteln*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1612)
* proc mvwgetch*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvwgetch",: /wrappers/pdcurses.
                                                             (line  527)
* proc mvwgetnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  531)
* proc mvwgetn_wstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cint; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line 1262)
* proc mvwgetstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  535)
* proc mvwget_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1267)
* proc mvwget_wstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1271)
* proc mvwhline*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line  539)
* proc mvwhline_set*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line 1275)
* proc mvwin*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "mvwin",: /wrappers/pdcurses.
                                                             (line  575)
* proc mvwinch*(a2: ptr WINDOW; a3: cint; a4: cint): cunsignedlong {.extdecl,: /wrappers/pdcurses.
                                                             (line  551)
* proc mvwinchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line  543)
* proc mvwinchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  547)
* proc mvwinnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  555)
* proc mvwinnwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1280)
* proc mvwinsch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  559)
* proc mvwinsertln*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1616)
* proc mvwinsnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  563)
* proc mvwinsrawch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1620)
* proc mvwinsstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  567)
* proc mvwinstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  571)
* proc mvwins_nwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line 1284)
* proc mvwins_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1289)
* proc mvwins_wstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1293)
* proc mvwinwstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1311)
* proc mvwin_wch*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1297)
* proc mvwin_wchnstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line 1301)
* proc mvwin_wchstr*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.: /wrappers/pdcurses.
                                                             (line 1306)
* proc mvwprintw*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.varargs, extdecl,: /wrappers/pdcurses.
                                                             (line  579)
* proc mvwscanw*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cstring): cint {.varargs, extdecl,: /wrappers/pdcurses.
                                                             (line  583)
* proc mvwvline*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line  587)
* proc mvwvline_set*(a2: ptr WINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; a6: cint): cint {.: /wrappers/pdcurses.
                                                             (line 1315)
* proc myodbc_remove_escape*(MySQL: PMySQL; name: cstring) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  605)
* proc my_connect*(s: my_socket; name: Psockaddr; namelen: cuint; timeout: cuint): cint {.: /wrappers/mysql.
                                                             (line  175)
* proc my_init*(): my_bool {.cdecl, dynlib: lib, importc: "my_init".}: /wrappers/mysql.
                                                             (line  263)
* proc my_net_init*(net: PNET; vio: PVio): my_bool {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  138)
* proc my_net_local_init*(net: PNET) {.cdecl, dynlib: lib, importc: "my_net_local_init".}: /wrappers/mysql.
                                                             (line  142)
* proc my_net_read*(net: PNET): int {.cdecl, dynlib: lib, importc: "my_net_read".}: /wrappers/mysql.
                                                             (line  172)
* proc my_net_write*(net: PNET; packet: cstring; length: int): my_bool {.cdecl,: /wrappers/mysql.
                                                             (line  158)
* proc my_rnd*(para1: Prand_struct): cdouble {.cdecl, dynlib: lib, importc: "my_rnd".}: /wrappers/mysql.
                                                             (line  183)
* proc my_thread_end*() {.cdecl, dynlib: lib, importc: "my_thread_end".}: /wrappers/mysql.
                                                             (line  269)
* proc my_thread_init*(): my_bool {.cdecl, dynlib: lib, importc: "my_thread_init".}: /wrappers/mysql.
                                                             (line  266)
* proc name*(a: PAttr): string:          /pure/xmldom.       (line  288)
* proc name*(someProc: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  526)
* proc name*(t: typedesc): string {.magic: "TypeTrait".}: /pure/typetraits.
                                                             (line    6)
* proc namespaceURI*(n: PNode): string:  /pure/xmldom.       (line  129)
* proc nanosleep*(a1, a2: var Timespec): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1258)
* proc napms*(a2: cint): cint {.extdecl, importc: "napms", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  591)
* proc nc_getmouse*(a2: ptr MEVENT): cint {.extdecl, importc: "nc_getmouse",: /wrappers/pdcurses.
                                                             (line 1563)
* proc nestList*(theProc: NimIdent; x: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  389)
* proc net_clear*(net: PNET) {.cdecl, dynlib: lib, importc: "net_clear".}: /wrappers/mysql.
                                                             (line  148)
* proc net_end*(net: PNET) {.cdecl, dynlib: lib, importc: "net_end".}: /wrappers/mysql.
                                                             (line  145)
* proc net_flush*(net: PNET): my_bool {.cdecl, dynlib: lib, importc: "net_flush".}: /wrappers/mysql.
                                                             (line  155)
* proc net_realloc*(net: PNET; len: int): my_bool {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  151)
* proc net_real_write*(net: PNET; packet: cstring; length: int): cint {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  168)
* proc net_safe_read*(MySQL: PMySQL): cuint {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  790)
* proc net_write_command*(net: PNET; command: char; header: cstring; head_len: int;: /wrappers/mysql.
                                                             (line  162)
* proc new*(T: typedesc): auto:          /system.            (line  281)
* proc new*[T](a: var ref T) {.magic: "New", noSideEffect.}: /system.
                                                             (line  275)
* proc new*[T](a: var ref T; finalizer: proc (x: ref T) {.nimcall.}) {.magic: "NewFinalize",: /system.
                                                             (line  295)
* proc newAssignment*(lhs, rhs: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  449)
* proc newAsyncFtpClient*(address: string; port = Port(21); user, pass = ""): AsyncFtpClient: /pure/asyncftpclient.
                                                             (line  108)
* proc newAsyncHttpClient*(userAgent = defUserAgent; maxRedirects = 5;: /pure/httpclient.
                                                             (line  237)
* proc newAsyncHttpServer*(reuseAddr = true): AsyncHttpServer: /pure/asynchttpserver.
                                                             (line   16)
* proc newAsyncNativeSocket*(domain, sockType, protocol: cint): AsyncFD: /pure/asyncdispatch.
                                                             (line  218)
* proc newAsyncNativeSocket*(domain: Domain = nativesockets.AF_INET;: /pure/asyncdispatch.
                                                             (line  224)
* proc newAsyncSmtp*(address: string; port: Port; useSsl = false;: /pure/smtp.
                                                             (line   61)
* proc newAsyncSocket*(domain, sockType, protocol: cint; buffered = true): AsyncSocket: /pure/asyncnet.
                                                             (line   30)
* proc newAsyncSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;: /pure/asyncnet.
                                                             (line   20)
* proc newAsyncSocket*(fd: AsyncFD; domain: Domain = AF_INET;: /pure/asyncnet.
                                                             (line   12)
* proc newBlockStmt*(body: NimNode): NimNode {.compiletime.}: /core/macros.
                                                             (line  429)
* proc newBlockStmt*(label, body: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  424)
* proc newCall*(theProc: NimIdent; args: varargs[NimNode]): NimNode {.compileTime.}: /core/macros.
                                                             (line  352)
* proc newCall*(theProc: NimNode; args: varargs[NimNode]): NimNode {.compileTime.}: /core/macros.
                                                             (line  346)
* proc newCall*(theProc: string; args: varargs[NimNode]): NimNode {.compileTime.}: /core/macros.
                                                             (line  358)
* proc newCData*(cdata: string): XmlNode: /pure/xmltree.     (line   29)
* proc newColonExpr*(a, b: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  457)
* proc newComment*(comment: string): XmlNode: /pure/xmltree. (line   24)
* proc newConsoleLogger*(levelThreshold = lvlAll; fmtStr = defaultFmtStr): ConsoleLogger: /pure/logging.
                                                             (line   57)
* proc newConstStmt*(name, value: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  444)
* proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";: /pure/net.
                                                             (line   98)
* proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = ""; <1>: /deprecated/pure/sockets.
                                                             (line   81)
* proc newCountTable*[A](initialSize = 64): CountTableRef[A]: /pure/collections/tables.
                                                             (line  494)
* proc newCountTable*[A](keys: openArray[A]): CountTableRef[A]: /pure/collections/tables.
                                                             (line  504)
* proc newDelegate*(): Delegate:         /deprecated/pure/asyncio.
                                                             (line   14)
* proc newDispatcher*(): Dispatcher:     /deprecated/pure/asyncio.
                                                             (line  105)
* proc newDispatcher*(): PDispatcher:    /pure/asyncdispatch.
                                                             (line  144)
* proc newDotExpr*(a, b: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  452)
* proc newDoublyLinkedNode*[T](value: T): DoublyLinkedNode[T]: /pure/collections/lists.
                                                             (line   37)
* proc newElement*(tag: string): XmlNode: /pure/xmltree.     (line   14)
* proc newEmptyNode*(): NimNode {.compileTime, noSideEffect.}: /core/macros.
                                                             (line  409)
* proc newEntity*(entity: string): XmlNode: /pure/xmltree.   (line   34)
* proc newFileLogger*(filename = defaultFilename(); mode: FileMode = fmAppend;: /pure/logging.
                                                             (line   62)
* proc newFileStream*(f: File): FileStream: /pure/streams.   (line  293)
* proc newFileStream*(filename: string; mode: FileMode = fmRead): FileStream: /pure/streams.
                                                             (line  298)
* proc newFloatLitNode*(f: BiggestFloat): NimNode {.compileTime.}: /core/macros.
                                                             (line  211)
* proc newFuture*[T](fromProc: string = "unspecified"): Future[T]: /pure/asyncdispatch.
                                                             (line   18)
* proc newFutureVar*[T](fromProc = "unspecified"): FutureVar[T]: /pure/asyncdispatch.
                                                             (line   27)
* proc newGenTable*[T](mode: GenTableMode): PGenTable[T]: /pure/gentabs.
                                                             (line   19)
* proc newIdentDefs*(name, kind: NimNode; default = newEmptyNode()): NimNode {.compileTime.}: /core/macros.
                                                             (line  462)
* proc newIdentNode*(i: NimIdent): NimNode {.compileTime.}: /core/macros.
                                                             (line  216)
* proc newIdentNode*(i: string): NimNode {.compileTime.}: /core/macros.
                                                             (line  221)
* proc newIfStmt*(branches: varargs[tuple[cond, body: NimNode]]): NimNode {.compiletime.}: /core/macros.
                                                             (line  512)
* proc newIntLitNode*(i: BiggestInt): NimNode {.compileTime.}: /core/macros.
                                                             (line  206)
* proc newJArray*(): JsonNode:           /pure/json.         (line  126)
* proc newJBool*(b: bool): JsonNode:     /pure/json.         (line  111)
* proc newJFloat*(n: float): JsonNode:   /pure/json.         (line  106)
* proc newJInt*(n: BiggestInt): JsonNode: /pure/json.        (line  101)
* proc newJNull*(): JsonNode:            /pure/json.         (line  116)
* proc newJObject*(): JsonNode:          /pure/json.         (line  121)
* proc newJString*(s: string): JsonNode: /pure/json.         (line   96)
* proc newLetStmt*(name, value: NimNode): NimNode {.compiletime.}: /core/macros.
                                                             (line  439)
* proc newLine*(): Peg {.inline.}:       /pure/pegs.         (line  114)
* proc newLit*(b: bool): NimNode {.compileTime.}: /core/macros.
                                                             (line  374)
* proc newLit*(c: char): NimNode {.compileTime.}: /core/macros.
                                                             (line  364)
* proc newLit*(f: BiggestFloat): NimNode {.compileTime.}: /core/macros.
                                                             (line  379)
* proc newLit*(i: BiggestInt): NimNode {.compileTime.}: /core/macros.
                                                             (line  369)
* proc newLit*(s: string): NimNode {.compileTime.}: /core/macros.
                                                             (line  384)
* proc newMersenneTwister*(seed: int): MersenneTwister: /pure/mersenne.
                                                             (line   16)
* proc newMimetypes*(): MimeDB:          /pure/mimetypes.    (line  491)
* proc newMonitor*(): FSMonitor:         /pure/fsmonitor.    (line   39)
* proc newMultipartData*(): MultipartData: /pure/httpclient. (line   76)
* proc newMultipartData*(xs: MultipartEntries): MultipartData: /pure/httpclient.
                                                             (line   95)
* proc newNativeSocket*(domain: cint; sockType: cint; protocol: cint): SocketHandle: /pure/nativesockets.
                                                             (line   63)
* proc newNativeSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;: /pure/nativesockets.
                                                             (line   57)
* proc newNilLit*(): NimNode {.compileTime.}: /core/macros.  (line  488)
* proc newNimNode*(kind: NimNodeKind; n: NimNode = nil): NimNode {.magic: "NNewNimNode",: /core/macros.
                                                             (line  170)
* proc newNonTerminal*(name: string; line, column: int): NonTerminal {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  188)
* proc newOrderedTable*[A, B](initialSize = 64): OrderedTableRef[A, B]: /pure/collections/tables.
                                                             (line  343)
* proc newOrderedTable*[A, B](pairs: openArray[(A, B)]): OrderedTableRef[A, B]: /pure/collections/tables.
                                                             (line  353)
* proc newpad*(a2: cint; a3: cint): ptr WINDOW {.extdecl, importc: "newpad",: /wrappers/pdcurses.
                                                             (line  594)
* proc newPar*(exprs: varargs[NimNode]): NimNode {.compileTime.}: /core/macros.
                                                             (line  419)
* proc newProc*(name = newEmptyNode(); params: openArray[NimNode] = [newEmptyNode()];: /core/macros.
                                                             (line  501)
* proc newProxy*(url: string; auth = ""): Proxy: /pure/httpclient.
                                                             (line   71)
* proc newRollingFileLogger*(filename = defaultFilename();: /pure/logging.
                                                             (line   71)
* proc newRstNode*(kind: RstNodeKind): PRstNode: /packages/docutils/rstast.
                                                             (line   27)
* proc newRstNode*(kind: RstNodeKind; s: string): PRstNode: /packages/docutils/rstast.
                                                             (line   30)
* proc newSelector*(): Selector:         /pure/selectors.    (line   57)
* proc newSeq*[T](len = 0.Natural): seq[T]: /system.         (line  549)
* proc newSeq*[T](s: var seq[T]; len: Natural) {.magic: "NewSeq", noSideEffect.}: /system.
                                                             (line  531)
* proc newSharedString*(len: Natural): SharedString: /pure/collections/sharedstrings.
                                                             (line   33)
* proc newSharedString*(s: string): SharedString: /pure/collections/sharedstrings.
                                                             (line   36)
* proc newSinglyLinkedNode*[T](value: T): SinglyLinkedNode[T]: /pure/collections/lists.
                                                             (line   42)
* proc newSocket*(domain, sockType, protocol: cint; buffered = true): Socket: /pure/net.
                                                             (line   77)
* proc newSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;: /pure/net.
                                                             (line   84)
* proc newSocket*(fd: SocketHandle; domain: Domain = AF_INET;: /pure/net.
                                                             (line   69)
* proc newStmtList*(stmts: varargs[NimNode]): NimNode {.compileTime.}: /core/macros.
                                                             (line  414)
* proc newString*(len: Natural): string {.magic: "NewString", importc: "mnewString",: /system.
                                                             (line 1266)
* proc newStringOfCap*(cap: Natural): string {.magic: "NewStringOfCap",: /system.
                                                             (line 1276)
* proc newStringStream*(s: string = ""): StringStream: /pure/streams.
                                                             (line  288)
* proc newStringTable*(keyValuePairs: varargs[string]; mode: StringTableMode): StringTableRef {.: /pure/strtabs.
                                                             (line   72)
* proc newStringTable*(keyValuePairs: varargs[tuple[key, val: string]];: /pure/strtabs.
                                                             (line   80)
* proc newStringTable*(mode: StringTableMode): StringTableRef {.rtl, extern: "nst$1".}: /pure/strtabs.
                                                             (line   62)
* proc newStrLitNode*(s: string): NimNode {.compileTime, noSideEffect.}: /core/macros.
                                                             (line  201)
* proc newTable*[A, B](initialSize = 64): TableRef[A, B]: /pure/collections/tables.
                                                             (line  180)
* proc newTable*[A, B](pairs: openArray[(A, B)]): TableRef[A, B]: /pure/collections/tables.
                                                             (line  183)
* proc newTableFrom*[A, B, C](collection: A; index: proc (x: B): C): TableRef[C, B]: /pure/collections/tables.
                                                             (line  196)
* proc newterm*(a2: cstring; a3: File; a4: File): ptr SCREEN {.extdecl, importc: "newterm",: /wrappers/pdcurses.
                                                             (line  598)
* proc newText*(text: string): XmlNode:  /pure/xmltree.      (line   19)
* proc newTree*(kind: NimNodeKind; children: varargs[NimNode]): NimNode {.compileTime.}: /core/macros.
                                                             (line  341)
* proc newVarStmt*(name, value: NimNode): NimNode {.compiletime.}: /core/macros.
                                                             (line  434)
* proc newWideCString*(s: cstring): WideCString: /system/widestrs.
                                                             (line   21)
* proc newWideCString*(s: string): WideCString: /system/widestrs.
                                                             (line   24)
* proc newWideCString*(source: cstring; L: int): WideCString: /system/widestrs.
                                                             (line   18)
* proc newwin*(a2: cint; a3: cint; a4: cint; a5: cint): ptr WINDOW {.extdecl,: /wrappers/pdcurses.
                                                             (line  602)
* proc newXmlTree*(tag: string; children: openArray[XmlNode];: /pure/xmltree.
                                                             (line  180)
* proc new_panel*(win: ptr WINDOW): ptr PANEL {.extdecl, importc: "new_panel",: /wrappers/pdcurses.
                                                             (line 1720)
* proc next*(c: var CfgParser): CfgEvent {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   64)
* proc next*(my: var JsonParser):        /pure/json.         (line   86)
* proc next*(my: var XmlParser):         /pure/parsexml.     (line   88)
* proc next*(p: var OptParser) {.rtl, extern: "npo$1".}: /pure/parseopt.
                                                             (line   32)
* proc next*(p: var OptParser) {.rtl, extern: "npo2$1".}: /pure/parseopt2.
                                                             (line   47)
* proc next*(s: var ScgiState; timeout: int = - 1): bool: /pure/scgi.
                                                             (line   32)
* proc next*(s: var Server):             /pure/httpserver.   (line   22)
* proc nextField*(ih: PIhandle): PIhandle {.importc: "IupNextField", cdecl,: /wrappers/iup.
                                                             (line  304)
* proc nextPermutation*[T](x: var openarray[T]): bool {.discardable.}: /pure/algorithm.
                                                             (line  124)
* proc nextPowerOfTwo*(x: int): int {.noSideEffect.}: /pure/math.
                                                             (line   48)
* proc nextSibling*(n: PNode): PNode:    /pure/xmldom.       (line  137)
* proc nextSplitPoint*(s: string; start: int): int: /packages/docutils/rstgen.
                                                             (line   79)
* proc next_result*(MySQL: PMySQL): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  768)
* proc nftw*(a1: cstring; a2: proc (x1: cstring; x2: ptr Stat; x3: cint; x4: ptr FTW): cint {.: /posix/posix.
                                                             (line  267)
* proc nice*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  921)
* proc nimcacheDir*(): string:           /system/nimscript.  (line  172)
* proc nl*(): cint {.extdecl, importc: "nl", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  606)
* proc nl_langinfo*(a1: Nl_item): cstring {.importc, header: "<langinfo.h>".}: /posix/posix.
                                                             (line  312)
* proc nocbreak*(): cint {.extdecl, importc: "nocbreak", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  609)
* proc nocrmode*(): cint {.extdecl, importc: "nocrmode", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1482)
* proc nodelay*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "nodelay",: /wrappers/pdcurses.
                                                             (line  612)
* proc nodeName*(n: PNode): string:      /pure/xmldom.       (line  142)
* proc nodeType*(n: PNode): int:         /pure/xmldom.       (line  147)
* proc noecho*(): cint {.extdecl, importc: "noecho", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  616)
* proc none*(T: typedesc): Option[T]:    /pure/options.      (line   17)
* proc nonl*(): cint {.extdecl, importc: "nonl", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  619)
* proc nonterminal*(n: NonTerminal): Peg {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line  183)
* proc noqiflush*() {.extdecl, importc: "noqiflush", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  622)
* proc noraw*(): cint {.extdecl, importc: "noraw", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  625)
* proc normalize*(n: PNode):             /pure/xmldom.       (line  207)
* proc normalize*(p: var Poly):          /pure/poly.         (line  136)
* proc normalize*(s: string): string {.noSideEffect, procvar, rtl, extern: "nsuNormalize".}: /pure/strutils.
                                                             (line  174)
* proc normalize*(v: var Vector2d) {.inline.}: /pure/basic2d.
                                                             (line  235)
* proc normalize*(v: var Vector3d) {.inline.}: /pure/basic3d.
                                                             (line  274)
* proc normalizer*(ihFirst: PIhandle): PIhandle {.importc: "IupNormalizer", cdecl,: /wrappers/iup.
                                                             (line  427)
* proc normalizerv*(ihList: ptr PIhandle): PIhandle {.importc: "IupNormalizerv", cdecl,: /wrappers/iup.
                                                             (line  431)
* proc normAngle*(ang: float): float:    /pure/basic2d.      (line  504)
* proc notimeout*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  628)
* proc now*(a2: PLoop): int64 {.importc: "uv_now", header: "uv.h".}: /wrappers/libuv.
                                                             (line   33)
* proc ntohl*(a1: int32): int32 {.importc, header: "<arpa/inet.h>".}: /posix/posix.
                                                             (line  178)
* proc ntohl*(x: int32): int32:          /pure/nativesockets.
                                                             (line   96)
* proc ntohl*(x: int32): int32 <1>:      /deprecated/pure/sockets.
                                                             (line   43)
* proc ntohs*(a1: int16): int16 {.importc, header: "<arpa/inet.h>".}: /posix/posix.
                                                             (line  181)
* proc ntohs*(x: int16): int16:          /pure/nativesockets.
                                                             (line  104)
* proc ntohs*(x: int16): int16 <1>:      /deprecated/pure/sockets.
                                                             (line   51)
* proc num_fields*(res: PRES): cuint {.stdcall, dynlib: lib, importc: "mysql_num_fields".}: /wrappers/mysql.
                                                             (line  318)
* proc num_rows*(res: PRES): my_ulonglong {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  314)
* proc octet2hex*(fto: cstring; str: cstring; length: cuint): cstring {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  216)
* proc oidToString*(oid: Oid; str: cstring): /pure/oids.     (line   32)
* proc oldTabsOpen*() {.cdecl, importc: "IupOldTabsOpen", dynlib: dllname.}: /wrappers/iup.
                                                             (line  667)
* proc oldValOpen*() {.cdecl, importc: "IupOldValOpen", dynlib: dllname.}: /wrappers/iup.
                                                             (line  664)
* proc on*(emitter: var EventEmitter; event: string; fn: proc (e: EventArgs) {.closure.}): /pure/events.
                                                             (line   42)
* proc onRaise*(action: proc (e: ref Exception): bool {.closure.}): /system.
                                                             (line 2365)
* proc open*(a1: cstring; a2: cint): cint {.varargs, importc, header: "<fcntl.h>".}: /posix/posix.
                                                             (line  245)
* proc open*(argc: ptr cint; argv: ptr cstringArray): cint {.importc: "IupOpen", cdecl,: /wrappers/iup.
                                                             (line   91)
* proc open*(c: var CfgParser; input: Stream; filename: string; lineOffset = 0) {.rtl,: /pure/parsecfg.
                                                             (line   18)
* proc open*(connection, user, password, database: string): DbConn {.: /impure/db_odbc.
                                                             (line   95)
* proc open*(connection, user, password, database: string): DbConn {.tags: [DbEffect].}: /impure/db_postgres.
                                                             (line  139)
* proc open*(connection, user, password, database: string): DbConn {.tags: [DbEffect].} <1>: /impure/db_mysql.
                                                             (line   98)
* proc open*(connection, user, password, database: string): DbConn {.tags: [DbEffect].} <2>: /impure/db_sqlite.
                                                             (line   95)
* proc open*(d: Document):               /js/dom.            (line  193)
* proc open*(destEncoding = "UTF-8"; srcEncoding = "CP1252"): EncodingConverter: /pure/encodings.
                                                             (line   25)
* proc open*(f: var File; filehandle: FileHandle; mode: FileMode = fmRead): bool {.tags: [],: /system.
                                                             (line 2096)
* proc open*(f: var File; filename: string; mode: FileMode = fmRead; bufSize: int = - 1): bool {.: /system.
                                                             (line 2087)
* proc open*(filename: cstring; ppDb: var PSqlite3): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  112)
* proc open*(filename: string; mode: FileMode = fmRead; bufSize: int = - 1): File: /system.
                                                             (line 2105)
* proc open*(filename: string; mode: FileMode = fmRead; mappedSize = - 1; offset = 0;: /pure/memfiles.
                                                             (line   55)
* proc open*(handleRequest: proc (client: AsyncSocket; input: string;: /pure/scgi.
                                                             (line   53)
* proc open*(L: var BaseLexer; input: Stream; bufLen: int = 8192;: /pure/lexbase.
                                                             (line   66)
* proc open*(loop: PLoop; req: PFS; path: cstring; flags: cint; mode: cint; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  283)
* proc open*(my: var CsvParser; input: Stream; filename: string; separator = ',';: /pure/parsecsv.
                                                             (line   14)
* proc open*(my: var JsonParser; input: Stream; filename: string): /pure/json.
                                                             (line   28)
* proc open*(my: var XmlParser; input: Stream; filename: string;: /pure/parsexml.
                                                             (line   23)
* proc open*(s: var ScgiState; port = Port(4000); address = "127.0.0.1"; reuseAddr = false): /pure/scgi.
                                                             (line   22)
* proc open*(s: var Server; port = Port(80); reuseAddr = false): /pure/httpserver.
                                                             (line   11)
* proc open*(w: Window; uri, windowname: cstring; properties: cstring = nil): Window: /js/dom.
                                                             (line   76)
* proc open*[TMsg](c: var Channel[TMsg]): /system/channels.  (line   39)
* proc open16*(filename: pointer; ppDb: var PSqlite3): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  116)
* proc openAsync*(filename: string; mode = fmRead): AsyncFile: /pure/asyncfile.
                                                             (line   16)
* proc openBarrier*(b: ptr Barrier) {.compilerProc.}: /system/sysspawn.
                                                             (line   22)
* proc openCCState*(): PccState {.importc: "tcc_new", cdecl.}: /wrappers/tinyc.
                                                             (line   20)
* proc openDefaultBrowser*(url: string): /pure/browsers.     (line    6)
* proc opendir*(a1: cstring): ptr DIR {.importc, header: "<dirent.h>".}: /posix/posix.
                                                             (line  207)
* proc OpenSSL_add_all_algorithms*() {.cdecl, dynlib: DLLUtilName,: /wrappers/openssl.
                                                             (line  177)
* proc OPENSSL_config*(configName: cstring) {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  182)
* proc options*(MySQL: PMySQL; option: Option; arg: cstring): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  555)
* proc ord*[T](x: T): int {.magic: "Ord", noSideEffect.}: /system.
                                                             (line  613)
* proc osErrorMsg*(): string {.rtl, extern: "nos$1", deprecated.}: /pure/os.
                                                             (line   65)
* proc osErrorMsg*(errorCode: OSErrorCode): string: /pure/os.
                                                             (line   92)
* proc osLastError*(): OSErrorCode:      /pure/os.           (line  117)
* proc outputFile*(s: PccState; filename: cstring): cint {.cdecl,: /wrappers/tinyc.
                                                             (line  107)
* proc outputHandle*(p: Process): FileHandle {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  193)
* proc outputStream*(p: Process): Stream {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  169)
* proc overlay*(a2: ptr WINDOW; a3: ptr WINDOW): cint {.extdecl, importc: "overlay",: /wrappers/pdcurses.
                                                             (line  632)
* proc overwrite*(a2: ptr WINDOW; a3: ptr WINDOW): cint {.extdecl, importc: "overwrite",: /wrappers/pdcurses.
                                                             (line  636)
* proc ownerDocument*(n: PNode): PDocument: /pure/xmldom.    (line  152)
* proc ownerElement*(a: PAttr): PElement: /pure/xmldom.      (line  299)
* proc pair_content*(a2: cshort; a3: ptr cshort; a4: ptr cshort): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  640)
* proc panel_above*(pan: ptr PANEL): ptr PANEL {.extdecl, importc: "panel_above",: /wrappers/pdcurses.
                                                             (line 1724)
* proc panel_below*(pan: ptr PANEL): ptr PANEL {.extdecl, importc: "panel_below",: /wrappers/pdcurses.
                                                             (line 1728)
* proc panel_hidden*(pan: ptr PANEL): cint {.extdecl, importc: "panel_hidden",: /wrappers/pdcurses.
                                                             (line 1732)
* proc panel_userptr*(pan: ptr PANEL): pointer {.extdecl, importc: "panel_userptr",: /wrappers/pdcurses.
                                                             (line 1736)
* proc panel_window*(pan: ptr PANEL): ptr WINDOW {.extdecl, importc: "panel_window",: /wrappers/pdcurses.
                                                             (line 1740)
* proc parallel*(body: stmt) {.magic: "Parallel".}: /pure/concurrency/threadpool.
                                                             (line  102)
* proc parallelReplace*(s: string;:      /impure/re.         (line  148)
* proc parallelReplace*(s: string; subs: varargs[tuple[pattern: Peg, repl: string]]): string {.: /pure/pegs.
                                                             (line  316)
* proc paramCount*(): int:               /system/nimscript.  (line   49)
* proc paramCount*(): int {.tags: [ReadIOEffect].}: /pure/os.
                                                             (line  447)
* proc params*(someProc: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  532)
* proc paramStr*(i: int): string:        /system/nimscript.  (line   44)
* proc paramStr*(i: int): TaintedString {.tags: [ReadIOEffect].}: /pure/os.
                                                             (line  467)
* proc parentDir*(path: string): string {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line   83)
* proc parentNode*(n: PNode): PNode:     /pure/xmldom.       (line  157)
* proc parse*(value, layout: string): TimeInfo: /pure/times. (line  362)
* proc parseBiggestFloat*(s: string; number: var BiggestFloat; start = 0): int {.: /pure/parseutils.
                                                             (line  153)
* proc parseBiggestInt*(s: string): BiggestInt {.noSideEffect, procvar, rtl,: /pure/strutils.
                                                             (line  292)
* proc parseBiggestInt*(s: string; number: var BiggestInt; start = 0): int {.rtl,: /pure/parseutils.
                                                             (line  137)
* proc parseBool*(s: string): bool:      /pure/strutils.     (line  318)
* proc parseCmdLine*(c: string): seq[string] {.noSideEffect, rtl, extern: "nos$1".}: /pure/os.
                                                             (line  349)
* proc parseColor*(name: string): Color: /pure/colors.       (line   48)
* proc parseCookies*(s: string): StringTableRef: /pure/cookies.
                                                             (line    6)
* proc parseEnum*[T: enum](s: string): T: /pure/strutils.    (line  328)
* proc parseEnum*[T: enum](s: string; default: T): T: /pure/strutils.
                                                             (line  336)
* proc parseExpr*(s: string): NimNode {.noSideEffect, compileTime.}: /core/macros.
                                                             (line  269)
* proc parseFile*(filename: string): JsonNode: /pure/json.   (line  321)
* proc parseFloat*(s: cstring): BiggestFloat {.importc, nodecl.}: /js/dom.
                                                             (line  304)
* proc parseFloat*(s: string): float {.noSideEffect, procvar, rtl,: /pure/strutils.
                                                             (line  300)
* proc parseFloat*(s: string; number: var float; start = 0): int {.rtl,: /pure/parseutils.
                                                             (line  162)
* proc parseHex*(s: string; number: var int; start = 0; maxLen = 0): int {.rtl,: /pure/parseutils.
                                                             (line   22)
* proc parseHexInt*(s: string): int {.noSideEffect, procvar, rtl,: /pure/strutils.
                                                             (line  308)
* proc parseHtml*(s: Stream): XmlNode:   /pure/htmlparser.   (line  236)
* proc parseHtml*(s: Stream; filename: string; errors: var seq[string]): XmlNode: /pure/htmlparser.
                                                             (line  230)
* proc parseIdent*(s: string; ident: var string; start = 0): int: /pure/parseutils.
                                                             (line   52)
* proc parseIdent*(s: string; start = 0): string: /pure/parseutils.
                                                             (line   58)
* proc parseInt*(s: cstring): int {.importc, nodecl.}: /js/dom.
                                                             (line  307)
* proc parseInt*(s: cstring; radix: int): int {.importc, nodecl.}: /js/dom.
                                                             (line  310)
* proc parseInt*(s: string): int {.noSideEffect, procvar, rtl, extern: "nsuParseInt".}: /pure/strutils.
                                                             (line  285)
* proc parseInt*(s: string; number: var int; start = 0): int {.rtl, extern: "npuParseInt",: /pure/parseutils.
                                                             (line  145)
* proc parseInt*(s: string; value: var int; validRange: Slice[int]) {.noSideEffect, rtl,: /pure/matchers.
                                                             (line   13)
* proc parseIp4*(s: string): BiggestInt: /deprecated/pure/sockets.
                                                             (line  127)
* proc parseIpAddress*(address_str: string): IpAddress: /pure/net.
                                                             (line   51)
* proc parseJson*(buffer: string): JsonNode: /pure/json.     (line  316)
* proc parseJson*(s: Stream; filename: string): JsonNode: /pure/json.
                                                             (line  310)
* proc parseOct*(s: string; number: var int; start = 0): int {.rtl, extern: "npuParseOct",: /pure/parseutils.
                                                             (line   45)
* proc parseOctInt*(s: string): int {.noSideEffect, rtl, extern: "nsuParseOctInt".}: /pure/strutils.
                                                             (line  593)
* proc parseOid*(str: cstring): Oid:     /pure/oids.         (line   27)
* proc parsePeg*(pattern: string; filename = "pattern"; line = 1; col = 0): Peg: /pure/pegs.
                                                             (line  338)
* proc parseSecureHash*(hash: string): SecureHash: /pure/securehash.
                                                             (line   21)
* proc parseSQL*(input: Stream; filename: string): SqlNode: /pure/parsesql.
                                                             (line   55)
* proc parseStmt*(s: string): NimNode {.noSideEffect, compileTime.}: /core/macros.
                                                             (line  275)
* proc parseToken*(s: string; token: var string; validChars: set[char]; start = 0): int {.: /pure/parseutils.
                                                             (line   64)
* proc parseUntil*(s: string; token: var string; until: char; start = 0): int {.inline.}: /pure/parseutils.
                                                             (line  116)
* proc parseUntil*(s: string; token: var string; until: set[char]; start = 0): int {.inline.}: /pure/parseutils.
                                                             (line  109)
* proc parseUri*(uri: string): Uri:      /pure/uri.          (line   47)
* proc parseUri*(uri: string; result: var Uri): /pure/uri.   (line   42)
* proc parseUrl*(url: string): Url {.deprecated.}: /deprecated/pure/parseurl.
                                                             (line   15)
* proc parseWhile*(s: string; token: var string; validChars: set[char]; start = 0): int {.: /pure/parseutils.
                                                             (line  123)
* proc parseXml*(s: Stream): XmlNode:    /pure/xmlparser.    (line   23)
* proc parseXml*(s: Stream; filename: string; errors: var seq[string]): XmlNode: /pure/xmlparser.
                                                             (line   17)
* proc pathconf*(a1: cstring; a2: cint): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  924)
* proc pattern_to_host_byte_order*(code: ptr Pcre; extra: ptr ExtraData; tables: pointer): cint: /wrappers/pcre.
                                                             (line  196)
* proc pause*(): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  927)
* proc pclose*(a: File): cint {.importc, header: "<stdio.h>".}: /posix/posix.
                                                             (line  930)
* proc pechochar*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  644)
* proc pecho_wchar*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1320)
* proc peek*[TMsg](c: var Channel[TMsg]): int: /system/channels.
                                                             (line   31)
* proc peekBool*(s: Stream): bool:       /pure/streams.      (line  175)
* proc peekChar*(s: Stream): char:       /pure/streams.      (line  164)
* proc peekData*(s: Stream; buffer: pointer; bufLen: int): int: /pure/streams.
                                                             (line  116)
* proc peekExitCode*(p: Process): int {.tags: [].}: /pure/osproc.
                                                             (line  155)
* proc peekFloat32*(s: Stream): float32: /pure/streams.      (line  226)
* proc peekFloat64*(s: Stream): float64: /pure/streams.      (line  238)
* proc peekInt16*(s: Stream): int16:     /pure/streams.      (line  195)
* proc peekInt32*(s: Stream): int32:     /pure/streams.      (line  205)
* proc peekInt64*(s: Stream): int64:     /pure/streams.      (line  215)
* proc peekInt8*(s: Stream): int8:       /pure/streams.      (line  185)
* proc peekLine*(s: Stream): TaintedString: /pure/streams.   (line  282)
* proc peekLine*(s: Stream; line: var TaintedString): bool: /pure/streams.
                                                             (line  266)
* proc peekNamedPipe*(hNamedPipe: Handle; lpBuffer: pointer = nil;: /windows/winlean.
                                                             (line  153)
* proc peekStr*(s: Stream; length: int): TaintedString: /pure/streams.
                                                             (line  250)
* proc peg*(pattern: string): Peg:       /pure/pegs.         (line  345)
* proc phase*(z: Complex): float:        /pure/complex.      (line  294)
* proc ping*(MySQL: PMySQL): cint {.stdcall, dynlib: lib, importc: "mysql_ping".}: /wrappers/mysql.
                                                             (line  513)
* proc pinnedSpawn*(id: ThreadId; call: expr): expr {.magic: "Spawn".}: /pure/concurrency/threadpool.
                                                             (line   94)
* proc pinToCpu*[Arg](t: var Thread[Arg]; cpu: Natural): /system/threads.
                                                             (line   37)
* proc pipe*(a: array[0 .. 1, cint]): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  933)
* proc pipe_bind*(handle: PPipe; name: cstring): cint {.importc: "uv_pipe_bind",: /wrappers/libuv.
                                                             (line  173)
* proc pipe_connect*(req: PConnect; handle: PPipe; name: cstring; cb: ConnectProc): cint {.: /wrappers/libuv.
                                                             (line  177)
* proc pipe_init*(a2: PLoop; handle: PPipe; ipc: int): cint {.importc: "uv_pipe_init",: /wrappers/libuv.
                                                             (line  166)
* proc pipe_open*(a2: PPipe; file: File) {.importc: "uv_pipe_open", header: "uv.h".}: /wrappers/libuv.
                                                             (line  170)
* proc play*(e: EmbedElement):           /js/dom.            (line  235)
* proc pnoutrefresh*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint; a7: cint; a8: cint): cint {.: /wrappers/pdcurses.
                                                             (line  648)
* proc point2d*(x, y: float): Point2d:   /pure/basic2d.      (line  365)
* proc point2d*(x, y: float): Point2d {.noInit, inline.}: /pure/basic2d.
                                                             (line   39)
* proc point3d*(x, y, z: float): Point3d: /pure/basic3d.     (line  354)
* proc point3d*(x, y, z: float): Point3d {.noInit, inline.}: /pure/basic3d.
                                                             (line   41)
* proc polar*(p: Point2d; ang, dist: float): Point2d {.noInit.}: /pure/basic2d.
                                                             (line  437)
* proc polar*(z: Complex): tuple[r, phi: float]: /pure/complex.
                                                             (line  299)
* proc polarVector2d*(ang: float; len: float): Vector2d {.noInit.}: /pure/basic2d.
                                                             (line  178)
* proc poll*(a1: ptr TPollfd; a2: Tnfds; a3: int): cint {.importc, header: "<poll.h>".}: /posix/posix.
                                                             (line 1797)
* proc poll*(d: Dispatcher; timeout: int = 500): bool: /deprecated/pure/asyncio.
                                                             (line  212)
* proc poll*(timeout = 500):             /pure/asyncdispatch.
                                                             (line  159)
* proc pop*[T](s: var seq[T]): T {.inline, noSideEffect.}: /system.
                                                             (line 1914)
* proc popen*(a1, a2: cstring): File {.importc, header: "<stdio.h>".}: /posix/posix.
                                                             (line  936)
* proc popup*(ih: PIhandle; x, y: cint): cint {.importc: "IupPopup", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  211)
* proc port*(s: var Server): Port:       /pure/httpserver.   (line   17)
* proc posix_fadvise*(a1: cint; a2, a3: Off; a4: cint): cint {.importc, header: "<fcntl.h>".}: /posix/posix.
                                                             (line  248)
* proc posix_fallocate*(a1: cint; a2, a3: Off): cint {.importc, header: "<fcntl.h>".}: /posix/posix.
                                                             (line  251)
* proc posix_madvise*(a1: pointer; a2: int; a3: cint): cint {.importc,: /posix/posix.
                                                             (line 1181)
* proc posix_mem_offset*(a1: pointer; a2: int; a3: var Off; a4: var int; a5: var cint): cint {.: /posix/posix.
                                                             (line 1185)
* proc posix_spawn*(a1: var Pid; a2: cstring; a3: var Tposix_spawn_file_actions;: /posix/posix.
                                                             (line 1448)
* proc posix_spawnattr_destroy*(a1: var Tposix_spawnattr): cint {.importc,: /posix/posix.
                                                             (line 1478)
* proc posix_spawnattr_getflags*(a1: var Tposix_spawnattr; a2: var cshort): cint {.: /posix/posix.
                                                             (line 1486)
* proc posix_spawnattr_getpgroup*(a1: var Tposix_spawnattr; a2: var Pid): cint {.importc,: /posix/posix.
                                                             (line 1490)
* proc posix_spawnattr_getschedparam*(a1: var Tposix_spawnattr; a2: var Sched_param): cint {.: /posix/posix.
                                                             (line 1494)
* proc posix_spawnattr_getschedpolicy*(a1: var Tposix_spawnattr; a2: var cint): cint {.: /posix/posix.
                                                             (line 1498)
* proc posix_spawnattr_getsigdefault*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.: /posix/posix.
                                                             (line 1482)
* proc posix_spawnattr_getsigmask*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.: /posix/posix.
                                                             (line 1502)
* proc posix_spawnattr_init*(a1: var Tposix_spawnattr): cint {.importc,: /posix/posix.
                                                             (line 1506)
* proc posix_spawnattr_setflags*(a1: var Tposix_spawnattr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line 1514)
* proc posix_spawnattr_setpgroup*(a1: var Tposix_spawnattr; a2: Pid): cint {.importc,: /posix/posix.
                                                             (line 1518)
* proc posix_spawnattr_setschedparam*(a1: var Tposix_spawnattr; a2: var Sched_param): cint {.: /posix/posix.
                                                             (line 1522)
* proc posix_spawnattr_setschedpolicy*(a1: var Tposix_spawnattr; a2: cint): cint {.: /posix/posix.
                                                             (line 1526)
* proc posix_spawnattr_setsigdefault*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.: /posix/posix.
                                                             (line 1510)
* proc posix_spawnattr_setsigmask*(a1: var Tposix_spawnattr; a2: var Sigset): cint {.: /posix/posix.
                                                             (line 1530)
* proc posix_spawnp*(a1: var Pid; a2: cstring; a3: var Tposix_spawn_file_actions;: /posix/posix.
                                                             (line 1534)
* proc posix_spawn_file_actions_addclose*(a1: var Tposix_spawn_file_actions; a2: cint): cint {.: /posix/posix.
                                                             (line 1454)
* proc posix_spawn_file_actions_adddup2*(a1: var Tposix_spawn_file_actions;: /posix/posix.
                                                             (line 1458)
* proc posix_spawn_file_actions_addopen*(a1: var Tposix_spawn_file_actions; a2: cint;: /posix/posix.
                                                             (line 1464)
* proc posix_spawn_file_actions_destroy*(a1: var Tposix_spawn_file_actions): cint {.: /posix/posix.
                                                             (line 1470)
* proc posix_spawn_file_actions_init*(a1: var Tposix_spawn_file_actions): cint {.: /posix/posix.
                                                             (line 1474)
* proc posix_typed_mem_get_info*(a1: cint; a2: var Posix_typed_mem_info): cint {.importc,: /posix/posix.
                                                             (line 1189)
* proc posix_typed_mem_open*(a1: cstring; a2, a3: cint): cint {.importc,: /posix/posix.
                                                             (line 1193)
* proc post*(client: AsyncHttpClient; url: string; body = "";: /pure/httpclient.
                                                             (line  291)
* proc post*(url: string; extraHeaders = ""; body = ""; maxRedirects = 5;: /pure/httpclient.
                                                             (line  188)
* proc postContent*(url: string; extraHeaders = ""; body = ""; maxRedirects = 5;: /pure/httpclient.
                                                             (line  206)
* proc postfix*(node: NimNode; op: string): NimNode {.compileTime.}: /core/macros.
                                                             (line  580)
* proc pow*(x, y: Complex): Complex:     /pure/complex.      (line  169)
* proc pow*(x, y: float): float {.importc: "pow", header: "<math.h>".}: /pure/math.
                                                             (line  198)
* proc pPlot*(): PIhandle {.cdecl, importc: "IupPPlot", dynlib: dllname.}: /wrappers/iup.
                                                             (line  718)
* proc pPlotAdd*(ih: PIhandle; x, y: cfloat) {.cdecl, importc: "IupPPlotAdd",: /wrappers/iup.
                                                             (line  725)
* proc pPlotAddStr*(ih: PIhandle; x: cstring; y: cfloat) {.cdecl,: /wrappers/iup.
                                                             (line  729)
* proc pPlotBegin*(ih: PIhandle; strXdata: cint) {.cdecl, importc: "IupPPlotBegin",: /wrappers/iup.
                                                             (line  721)
* proc pPlotEnd*(ih: PIhandle): cint {.cdecl, importc: "IupPPlotEnd", dynlib: dllname.}: /wrappers/iup.
                                                             (line  733)
* proc pPlotInsert*(ih: PIhandle; index, sampleIndex: cint; x, y: cfloat) {.cdecl,: /wrappers/iup.
                                                             (line  741)
* proc pPlotInsertStr*(ih: PIhandle; index, sampleIndex: cint; x: cstring; y: cfloat) {.: /wrappers/iup.
                                                             (line  736)
* proc pPlotOpen*() {.cdecl, importc: "IupPPlotOpen", dynlib: dllname.}: /wrappers/iup.
                                                             (line  715)
* proc pPlotPaintTo*(ih: PIhandle; cnv: pointer) {.cdecl, importc: "IupPPlotPaintTo",: /wrappers/iup.
                                                             (line  749)
* proc pPlotTransform*(ih: PIhandle; x, y: cfloat; ix, iy: var cint) {.cdecl,: /wrappers/iup.
                                                             (line  745)
* proc pqbackendPID*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  119)
* proc pqbinaryTuples*(res: PPGresult): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  288)
* proc pqclear*(res: PPGresult) {.cdecl, dynlib: dllName, importc: "PQclear".}: /wrappers/postgres.
                                                             (line  351)
* proc pqclientEncoding*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  123)
* proc pqcmdStatus*(res: PPGresult): cstring {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  324)
* proc pqcmdTuples*(res: PPGresult): cstring {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  335)
* proc pqconndefaults*(): PPQconninfoOption {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   51)
* proc pqconnectdb*(conninfo: cstring): PPGconn {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   34)
* proc pqconnectPoll*(conn: PPGconn): PostgresPollingStatusType {.cdecl,: /wrappers/postgres.
                                                             (line   30)
* proc pqconnectStart*(conninfo: cstring): PPGconn {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   26)
* proc pqconninfoFree*(connOptions: PPQconninfoOption) {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   55)
* proc pqconsumeInput*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  210)
* proc pqdb*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQdb".}: /wrappers/postgres.
                                                             (line   74)
* proc pqdisplayTuples*(res: PPGresult; fp: File; fillAlign: int32; fieldSep: cstring;: /wrappers/postgres.
                                                             (line  378)
* proc pqendcopy*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQendcopy".}: /wrappers/postgres.
                                                             (line  246)
* proc pqenv2encoding*(): int32 {.cdecl, dynlib: dllName, importc: "PQenv2encoding".}: /wrappers/postgres.
                                                             (line  434)
* proc pqerrorMessage*(conn: PPGconn): cstring {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  112)
* proc pqescapeBytea*(bintext: cstring; binlen: int; bytealen: var int): cstring {.cdecl,: /wrappers/postgres.
                                                             (line  366)
* proc pqescapeString*(till, `from`: cstring; len: int): int {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  362)
* proc pqexec*(conn: PPGconn; query: cstring): PPGresult {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  157)
* proc pqexecParams*(conn: PPGconn; command: cstring; nParams: int32; paramTypes: POid;: /wrappers/postgres.
                                                             (line  161)
* proc pqexecPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;: /wrappers/postgres.
                                                             (line  175)
* proc pqfformat*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  308)
* proc pqfinish*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: "PQfinish".}: /wrappers/postgres.
                                                             (line   48)
* proc pqflush*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQflush".}: /wrappers/postgres.
                                                             (line  257)
* proc pqfmod*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  320)
* proc pqfn*(conn: PPGconn; fnid: int32; result_buf, result_len: ptr int32;: /wrappers/postgres.
                                                             (line  260)
* proc pqfname*(res: PPGresult; field_num: int32): cstring {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  292)
* proc pqfnumber*(res: PPGresult; field_name: cstring): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  296)
* proc pqfreemem*(p: pointer) {.cdecl, dynlib: dllName, importc: "PQfreemem".}: /wrappers/postgres.
                                                             (line  354)
* proc pqfsize*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  316)
* proc pqftable*(res: PPGresult; field_num: int32): Oid {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  300)
* proc pqftablecol*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  304)
* proc pqftype*(res: PPGresult; field_num: int32): Oid {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  312)
* proc pqgetCopyData*(conn: PPGconn; buffer: cstringArray; async: int32): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  226)
* proc pqgetisnull*(res: PPGresult; tup_num: int32; field_num: int32): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  347)
* proc pqgetlength*(res: PPGresult; tup_num: int32; field_num: int32): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  343)
* proc pqgetline*(conn: PPGconn; str: cstring; len: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  230)
* proc pqgetlineAsync*(conn: PPGconn; buffer: cstring; bufsize: int32): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  238)
* proc pqgetResult*(conn: PPGconn): PPGresult {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  203)
* proc pqgetssl*(conn: PPGconn): PSSL {.cdecl, dynlib: dllName, importc: "PQgetssl".}: /wrappers/postgres.
                                                             (line  132)
* proc pqgetvalue*(res: PPGresult; tup_num: int32; field_num: int32): cstring {.cdecl,: /wrappers/postgres.
                                                             (line  339)
* proc pqhost*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQhost".}: /wrappers/postgres.
                                                             (line   83)
* proc pqisBusy*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQisBusy".}: /wrappers/postgres.
                                                             (line  207)
* proc pqisnonblocking*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  253)
* proc pqmakeEmptyPGresult*(conn: PPGconn; status: ExecStatusType): PPGresult {.cdecl,: /wrappers/postgres.
                                                             (line  357)
* proc pqmblen*(s: cstring; encoding: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  430)
* proc pqnfields*(res: PPGresult): int32 {.cdecl, dynlib: dllName, importc: "PQnfields".}: /wrappers/postgres.
                                                             (line  285)
* proc pqnotifies*(conn: PPGconn): PPGnotify {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  214)
* proc pqntuples*(res: PPGresult): int32 {.cdecl, dynlib: dllName, importc: "PQntuples".}: /wrappers/postgres.
                                                             (line  282)
* proc pqoidStatus*(res: PPGresult): cstring {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  328)
* proc pqoidValue*(res: PPGresult): Oid {.cdecl, dynlib: dllName, importc: "PQoidValue".}: /wrappers/postgres.
                                                             (line  332)
* proc pqoptions*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQoptions".}: /wrappers/postgres.
                                                             (line   92)
* proc pqparameterStatus*(conn: PPGconn; paramName: cstring): cstring {.cdecl,: /wrappers/postgres.
                                                             (line  104)
* proc pqpass*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQpass".}: /wrappers/postgres.
                                                             (line   80)
* proc pqport*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQport".}: /wrappers/postgres.
                                                             (line   86)
* proc pqprepare*(conn: PPGconn; stmtName, query: cstring; nParams: int32;: /wrappers/postgres.
                                                             (line  169)
* proc pqprint*(fout: File; res: PPGresult; ps: PPQprintOpt) {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  374)
* proc pqprintTuples*(res: PPGresult; fout: File; printAttName: int32;: /wrappers/postgres.
                                                             (line  384)
* proc pqprotocolVersion*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  108)
* proc pqputCopyData*(conn: PPGconn; buffer: cstring; nbytes: int32): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  218)
* proc pqputCopyEnd*(conn: PPGconn; errormsg: cstring): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  222)
* proc pqputline*(conn: PPGconn; str: cstring): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  234)
* proc pqputnbytes*(conn: PPGconn; buffer: cstring; nbytes: int32): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  242)
* proc pqrequestCancel*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   70)
* proc pqreset*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: "PQreset".}: /wrappers/postgres.
                                                             (line   67)
* proc pqresetPoll*(conn: PPGconn): PostgresPollingStatusType {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   63)
* proc pqresetStart*(conn: PPGconn): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   59)
* proc pqresStatus*(status: ExecStatusType): cstring {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  270)
* proc pqresultErrorField*(res: PPGresult; fieldcode: int32): cstring {.cdecl,: /wrappers/postgres.
                                                             (line  278)
* proc pqresultErrorMessage*(res: PPGresult): cstring {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  274)
* proc pqresultStatus*(res: PPGresult): ExecStatusType {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  266)
* proc pqsendQuery*(conn: PPGconn; query: cstring): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  183)
* proc pqsendQueryParams*(conn: PPGconn; command: cstring; nParams: int32;: /wrappers/postgres.
                                                             (line  187)
* proc pqsendQueryPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;: /wrappers/postgres.
                                                             (line  195)
* proc pqsetClientEncoding*(conn: PPGconn; encoding: cstring): int32 {.cdecl,: /wrappers/postgres.
                                                             (line  127)
* proc pqsetdb*(M_PGHOST, M_PGPORT, M_PGOPT, M_PGTTY, M_DBNAME: cstring): Ppgconn: /wrappers/postgres.
                                                             (line   45)
* proc pqsetdbLogin*(pghost: cstring; pgport: cstring; pgoptions: cstring;: /wrappers/postgres.
                                                             (line   38)
* proc pqsetErrorVerbosity*(conn: PPGconn; verbosity: PGVerbosity): PGVerbosity {.cdecl,: /wrappers/postgres.
                                                             (line  135)
* proc pqsetnonblocking*(conn: PPGconn; arg: int32): int32 {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  249)
* proc pqsetNoticeProcessor*(conn: PPGconn; theProc: PQnoticeProcessor; arg: pointer): PQnoticeProcessor {.: /wrappers/postgres.
                                                             (line  152)
* proc pqsetNoticeReceiver*(conn: PPGconn; theProc: PQnoticeReceiver; arg: pointer): PQnoticeReceiver {.: /wrappers/postgres.
                                                             (line  147)
* proc pqsocket*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: "PQsocket".}: /wrappers/postgres.
                                                             (line  116)
* proc pqstatus*(conn: PPGconn): ConnStatusType {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line   95)
* proc pqtrace*(conn: PPGconn; debug_port: File) {.cdecl, dynlib: dllName,: /wrappers/postgres.
                                                             (line  140)
* proc pqtransactionStatus*(conn: PPGconn): PGTransactionStatusType {.cdecl,: /wrappers/postgres.
                                                             (line   99)
* proc pqtty*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQtty".}: /wrappers/postgres.
                                                             (line   89)
* proc pqunescapeBytea*(strtext: cstring; retbuflen: var int): cstring {.cdecl,: /wrappers/postgres.
                                                             (line  370)
* proc pquntrace*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: "PQuntrace".}: /wrappers/postgres.
                                                             (line  144)
* proc pquser*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: "PQuser".}: /wrappers/postgres.
                                                             (line   77)
* proc pragma*(someProc: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  538)
* proc pread*(a1: cint; a2: pointer; a3: int; a4: Off): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  939)
* proc pred*[T](x: Ordinal[T]; y = 1): T {.magic: "Pred", noSideEffect.}: /system.
                                                             (line  504)
* proc predict*(model: ptr Model; x: ptr Node): cdouble {.cdecl, importc: "svm_predict",: /wrappers/libsvm.
                                                             (line  100)
* proc predict_probability*(model: ptr Model; x: ptr Node; prob_estimates: ptr cdouble): cdouble {.: /wrappers/libsvm.
                                                             (line  104)
* proc predict_values*(model: ptr Model; x: ptr Node; dec_values: ptr cdouble): cdouble {.: /wrappers/libsvm.
                                                             (line   95)
* proc preferSpawn*(): bool:             /pure/concurrency/threadpool.
                                                             (line   78)
* proc preferSpawn*(): bool <1>:         /system/sysspawn.   (line   28)
* proc prefix*(node: NimNode; op: string): NimNode {.compileTime.}: /core/macros.
                                                             (line  583)
* proc prefresh*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint; a7: cint; a8: cint): cint {.: /wrappers/pdcurses.
                                                             (line  653)
* proc prepare*(db: DbConn; stmtName: string; query: SqlQuery; nParams: int): SqlPrepared: /impure/db_postgres.
                                                             (line   48)
* proc prepare*(db: PSqlite3; zSql: cstring; nBytes: int32; ppStmt: var Pstmt;: /wrappers/sqlite3.
                                                             (line  130)
* proc prepare16*(db: PSqlite3; zSql: pointer; nBytes: int32; ppStmt: var Pstmt;: /wrappers/sqlite3.
                                                             (line  142)
* proc prepare_init*(a2: PLoop; prepare: PPrepare): cint {.importc: "uv_prepare_init",: /wrappers/libuv.
                                                             (line  181)
* proc prepare_start*(prepare: PPrepare; cb: PrepareProc): cint {.: /wrappers/libuv.
                                                             (line  185)
* proc prepare_stop*(prepare: PPrepare): cint {.importc: "uv_prepare_stop",: /wrappers/libuv.
                                                             (line  189)
* proc prepare_v2*(db: PSqlite3; zSql: cstring; nByte: cint; ppStmt: var Pstmt;: /wrappers/sqlite3.
                                                             (line  136)
* proc prepend*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T]): /pure/collections/lists.
                                                             (line  135)
* proc prepend*[T](L: var DoublyLinkedList[T]; value: T): /pure/collections/lists.
                                                             (line  140)
* proc prepend*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T]): /pure/collections/lists.
                                                             (line  180)
* proc prepend*[T](L: var DoublyLinkedRing[T]; value: T): /pure/collections/lists.
                                                             (line  185)
* proc prepend*[T](L: var SinglyLinkedList[T]; n: SinglyLinkedNode[T]) {.inline.}: /pure/collections/lists.
                                                             (line  115)
* proc prepend*[T](L: var SinglyLinkedList[T]; value: T) {.inline.}: /pure/collections/lists.
                                                             (line  120)
* proc prepend*[T](L: var SinglyLinkedRing[T]; n: SinglyLinkedNode[T]): /pure/collections/lists.
                                                             (line  160)
* proc prepend*[T](L: var SinglyLinkedRing[T]; value: T): /pure/collections/lists.
                                                             (line  165)
* proc pretty*(node: JsonNode; indent = 2): string: /pure/json.
                                                             (line  289)
* proc previousField*(ih: PIhandle): PIhandle {.importc: "IupPreviousField", cdecl,: /wrappers/iup.
                                                             (line  300)
* proc previousSibling*(n: PNode): PNode: /pure/xmldom.      (line  162)
* proc prevPermutation*[T](x: var openarray[T]): bool {.discardable.}: /pure/algorithm.
                                                             (line  134)
* proc print*(w: Window):                /js/dom.            (line   79)
* proc printKeyCodes*() {.importc: "linenoisePrintKeyCodes".}: /wrappers/linenoise/linenoise.
                                                             (line   41)
* proc printw*(a2: cstring): cint {.varargs, extdecl, importc: "printw",: /wrappers/pdcurses.
                                                             (line  657)
* proc procCall*(x: expr) {.magic: "ProcCall", compileTime.}: /system.
                                                             (line 2683)
* proc processedRows*(my: var CsvParser): int: /pure/parsecsv.
                                                             (line   33)
* proc processID*(p: Process): int {.rtl, extern: "nosp$1".}: /pure/osproc.
                                                             (line  141)
* proc process_kill*(a2: PProcess; signum: cint): cint {.importc: "uv_process_kill",: /wrappers/libuv.
                                                             (line  266)
* proc product*[T](x: openArray[seq[T]]): seq[seq[T]]: /pure/algorithm.
                                                             (line  118)
* proc progressBar*(): PIhandle {.importc: "IupProgressBar", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  516)
* proc progress_handler*(para1: PSqlite3; para2: int32;: /wrappers/sqlite3.
                                                             (line   99)
* proc prompt*(w: Window; text, default: cstring): cstring: /js/dom.
                                                             (line   82)
* proc pselect*(a1: cint; a2, a3, a4: ptr TFdSet; a5: ptr Timespec; a6: var Sigset): cint {.: /posix/posix.
                                                             (line 1440)
* proc pthread_atfork*(a1, a2, a3: proc () {.noconv.}): cint {.importc,: /posix/posix.
                                                             (line  390)
* proc pthread_attr_destroy*(a1: ptr PthreadAttr): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  394)
* proc pthread_attr_getdetachstate*(a1: ptr PthreadAttr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  397)
* proc pthread_attr_getguardsize*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,: /posix/posix.
                                                             (line  401)
* proc pthread_attr_getinheritsched*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,: /posix/posix.
                                                             (line  405)
* proc pthread_attr_getschedparam*(a1: ptr PthreadAttr; a2: ptr Sched_param): cint {.: /posix/posix.
                                                             (line  409)
* proc pthread_attr_getschedpolicy*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,: /posix/posix.
                                                             (line  413)
* proc pthread_attr_getscope*(a1: ptr PthreadAttr; a2: var cint): cint {.importc,: /posix/posix.
                                                             (line  417)
* proc pthread_attr_getstack*(a1: ptr PthreadAttr; a2: var pointer; a3: var int): cint {.: /posix/posix.
                                                             (line  421)
* proc pthread_attr_getstackaddr*(a1: ptr PthreadAttr; a2: var pointer): cint {.importc,: /posix/posix.
                                                             (line  425)
* proc pthread_attr_getstacksize*(a1: ptr PthreadAttr; a2: var int): cint {.importc,: /posix/posix.
                                                             (line  429)
* proc pthread_attr_init*(a1: ptr PthreadAttr): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  433)
* proc pthread_attr_setdetachstate*(a1: ptr PthreadAttr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  436)
* proc pthread_attr_setguardsize*(a1: ptr PthreadAttr; a2: int): cint {.importc,: /posix/posix.
                                                             (line  440)
* proc pthread_attr_setinheritsched*(a1: ptr PthreadAttr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  444)
* proc pthread_attr_setschedparam*(a1: ptr PthreadAttr; a2: ptr Sched_param): cint {.: /posix/posix.
                                                             (line  448)
* proc pthread_attr_setschedpolicy*(a1: ptr PthreadAttr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  452)
* proc pthread_attr_setscope*(a1: ptr PthreadAttr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  456)
* proc pthread_attr_setstack*(a1: ptr PthreadAttr; a2: pointer; a3: int): cint {.importc,: /posix/posix.
                                                             (line  460)
* proc pthread_attr_setstackaddr*(a1: ptr PthreadAttr; a2: pointer): cint {.importc,: /posix/posix.
                                                             (line  464)
* proc pthread_attr_setstacksize*(a1: ptr PthreadAttr; a2: int): cint {.importc,: /posix/posix.
                                                             (line  468)
* proc pthread_barrierattr_destroy*(a1: ptr Pthread_barrierattr): cint {.importc,: /posix/posix.
                                                             (line  485)
* proc pthread_barrierattr_getpshared*(a1: ptr Pthread_barrierattr; a2: var cint): cint {.: /posix/posix.
                                                             (line  489)
* proc pthread_barrierattr_init*(a1: ptr Pthread_barrierattr): cint {.importc,: /posix/posix.
                                                             (line  493)
* proc pthread_barrierattr_setpshared*(a1: ptr Pthread_barrierattr; a2: cint): cint {.: /posix/posix.
                                                             (line  497)
* proc pthread_barrier_destroy*(a1: ptr Pthread_barrier): cint {.importc,: /posix/posix.
                                                             (line  472)
* proc pthread_barrier_init*(a1: ptr Pthread_barrier; a2: ptr Pthread_barrierattr;: /posix/posix.
                                                             (line  476)
* proc pthread_barrier_wait*(a1: ptr Pthread_barrier): cint {.importc,: /posix/posix.
                                                             (line  481)
* proc pthread_cancel*(a1: Pthread): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  501)
* proc pthread_cleanup_pop*(a1: cint) {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  508)
* proc pthread_cleanup_push*(a1: proc (x: pointer) {.noconv.}; a2: pointer) {.importc,: /posix/posix.
                                                             (line  504)
* proc pthread_condattr_destroy*(a1: ptr Pthread_condattr): cint {.importc,: /posix/posix.
                                                             (line  535)
* proc pthread_condattr_getclock*(a1: ptr Pthread_condattr; a2: var ClockId): cint {.: /posix/posix.
                                                             (line  539)
* proc pthread_condattr_getpshared*(a1: ptr Pthread_condattr; a2: var cint): cint {.: /posix/posix.
                                                             (line  543)
* proc pthread_condattr_init*(a1: ptr Pthread_condattr): cint {.importc,: /posix/posix.
                                                             (line  547)
* proc pthread_condattr_setclock*(a1: ptr Pthread_condattr; a2: ClockId): cint {.importc,: /posix/posix.
                                                             (line  551)
* proc pthread_condattr_setpshared*(a1: ptr Pthread_condattr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  555)
* proc pthread_cond_broadcast*(a1: ptr Pthread_cond): cint {.importc,: /posix/posix.
                                                             (line  511)
* proc pthread_cond_destroy*(a1: ptr Pthread_cond): cint {.importc,: /posix/posix.
                                                             (line  515)
* proc pthread_cond_init*(a1: ptr Pthread_cond; a2: ptr Pthread_condattr): cint {.importc,: /posix/posix.
                                                             (line  519)
* proc pthread_cond_signal*(a1: ptr Pthread_cond): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  523)
* proc pthread_cond_timedwait*(a1: ptr Pthread_cond; a2: ptr Pthread_mutex;: /posix/posix.
                                                             (line  526)
* proc pthread_cond_wait*(a1: ptr Pthread_cond; a2: ptr Pthread_mutex): cint {.importc,: /posix/posix.
                                                             (line  531)
* proc pthread_create*(a1: ptr Pthread; a2: ptr PthreadAttr;: /posix/posix.
                                                             (line  559)
* proc pthread_detach*(a1: Pthread): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  565)
* proc pthread_equal*(a1, a2: Pthread): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  568)
* proc pthread_exit*(a1: pointer) {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  571)
* proc pthread_getconcurrency*(): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  574)
* proc pthread_getcpuclockid*(a1: Pthread; a2: var ClockId): cint {.importc,: /posix/posix.
                                                             (line  577)
* proc pthread_getschedparam*(a1: Pthread; a2: var cint; a3: ptr Sched_param): cint {.: /posix/posix.
                                                             (line  581)
* proc pthread_getspecific*(a1: Pthread_key): pointer {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  585)
* proc pthread_join*(a1: Pthread; a2: ptr pointer): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  588)
* proc pthread_key_create*(a1: ptr Pthread_key; a2: proc (x: pointer) {.noconv.}): cint {.: /posix/posix.
                                                             (line  591)
* proc pthread_key_delete*(a1: Pthread_key): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  595)
* proc pthread_kill*(a1: Pthread; a2: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1311)
* proc pthread_mutexattr_destroy*(a1: ptr Pthread_mutexattr): cint {.importc,: /posix/posix.
                                                             (line  629)
* proc pthread_mutexattr_getprioceiling*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.: /posix/posix.
                                                             (line  633)
* proc pthread_mutexattr_getprotocol*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.: /posix/posix.
                                                             (line  637)
* proc pthread_mutexattr_getpshared*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.: /posix/posix.
                                                             (line  641)
* proc pthread_mutexattr_gettype*(a1: ptr Pthread_mutexattr; a2: var cint): cint {.: /posix/posix.
                                                             (line  645)
* proc pthread_mutexattr_init*(a1: ptr Pthread_mutexattr): cint {.importc,: /posix/posix.
                                                             (line  649)
* proc pthread_mutexattr_setprioceiling*(a1: ptr Pthread_mutexattr; a2: cint): cint {.: /posix/posix.
                                                             (line  653)
* proc pthread_mutexattr_setprotocol*(a1: ptr Pthread_mutexattr; a2: cint): cint {.: /posix/posix.
                                                             (line  657)
* proc pthread_mutexattr_setpshared*(a1: ptr Pthread_mutexattr; a2: cint): cint {.: /posix/posix.
                                                             (line  661)
* proc pthread_mutexattr_settype*(a1: ptr Pthread_mutexattr; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  665)
* proc pthread_mutex_destroy*(a1: ptr Pthread_mutex): cint {.importc,: /posix/posix.
                                                             (line  598)
* proc pthread_mutex_getprioceiling*(a1: ptr Pthread_mutex; a2: var cint): cint {.importc,: /posix/posix.
                                                             (line  602)
* proc pthread_mutex_init*(a1: ptr Pthread_mutex; a2: ptr Pthread_mutexattr): cint {.: /posix/posix.
                                                             (line  606)
* proc pthread_mutex_lock*(a1: ptr Pthread_mutex): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  610)
* proc pthread_mutex_setprioceiling*(a1: ptr Pthread_mutex; a2: cint; a3: var cint): cint {.: /posix/posix.
                                                             (line  613)
* proc pthread_mutex_timedlock*(a1: ptr Pthread_mutex; a2: ptr Timespec): cint {.importc,: /posix/posix.
                                                             (line  617)
* proc pthread_mutex_trylock*(a1: ptr Pthread_mutex): cint {.importc,: /posix/posix.
                                                             (line  621)
* proc pthread_mutex_unlock*(a1: ptr Pthread_mutex): cint {.importc,: /posix/posix.
                                                             (line  625)
* proc pthread_once*(a1: ptr Pthread_once; a2: proc () {.noconv.}): cint {.importc,: /posix/posix.
                                                             (line  669)
* proc pthread_rwlockattr_destroy*(a1: ptr Pthread_rwlockattr): cint {.importc,: /posix/posix.
                                                             (line  709)
* proc pthread_rwlockattr_getpshared*(a1: ptr Pthread_rwlockattr; a2: var cint): cint {.: /posix/posix.
                                                             (line  713)
* proc pthread_rwlockattr_init*(a1: ptr Pthread_rwlockattr): cint {.importc,: /posix/posix.
                                                             (line  717)
* proc pthread_rwlockattr_setpshared*(a1: ptr Pthread_rwlockattr; a2: cint): cint {.: /posix/posix.
                                                             (line  721)
* proc pthread_rwlock_destroy*(a1: ptr Pthread_rwlock): cint {.importc,: /posix/posix.
                                                             (line  673)
* proc pthread_rwlock_init*(a1: ptr Pthread_rwlock; a2: ptr Pthread_rwlockattr): cint {.: /posix/posix.
                                                             (line  677)
* proc pthread_rwlock_rdlock*(a1: ptr Pthread_rwlock): cint {.importc,: /posix/posix.
                                                             (line  681)
* proc pthread_rwlock_timedrdlock*(a1: ptr Pthread_rwlock; a2: ptr Timespec): cint {.: /posix/posix.
                                                             (line  685)
* proc pthread_rwlock_timedwrlock*(a1: ptr Pthread_rwlock; a2: ptr Timespec): cint {.: /posix/posix.
                                                             (line  689)
* proc pthread_rwlock_tryrdlock*(a1: ptr Pthread_rwlock): cint {.importc,: /posix/posix.
                                                             (line  693)
* proc pthread_rwlock_trywrlock*(a1: ptr Pthread_rwlock): cint {.importc,: /posix/posix.
                                                             (line  697)
* proc pthread_rwlock_unlock*(a1: ptr Pthread_rwlock): cint {.importc,: /posix/posix.
                                                             (line  701)
* proc pthread_rwlock_wrlock*(a1: ptr Pthread_rwlock): cint {.importc,: /posix/posix.
                                                             (line  705)
* proc pthread_self*(): Pthread {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  725)
* proc pthread_setcancelstate*(a1: cint; a2: var cint): cint {.importc,: /posix/posix.
                                                             (line  728)
* proc pthread_setcanceltype*(a1: cint; a2: var cint): cint {.importc,: /posix/posix.
                                                             (line  732)
* proc pthread_setconcurrency*(a1: cint): cint {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  736)
* proc pthread_setschedparam*(a1: Pthread; a2: cint; a3: ptr Sched_param): cint {.importc,: /posix/posix.
                                                             (line  739)
* proc pthread_setschedprio*(a1: Pthread; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  743)
* proc pthread_setspecific*(a1: Pthread_key; a2: pointer): cint {.importc,: /posix/posix.
                                                             (line  747)
* proc pthread_sigmask*(a1: cint; a2, a3: var Sigset): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1314)
* proc pthread_spin_destroy*(a1: ptr Pthread_spinlock): cint {.importc,: /posix/posix.
                                                             (line  751)
* proc pthread_spin_init*(a1: ptr Pthread_spinlock; a2: cint): cint {.importc,: /posix/posix.
                                                             (line  755)
* proc pthread_spin_lock*(a1: ptr Pthread_spinlock): cint {.importc,: /posix/posix.
                                                             (line  759)
* proc pthread_spin_trylock*(a1: ptr Pthread_spinlock): cint {.importc,: /posix/posix.
                                                             (line  763)
* proc pthread_spin_unlock*(a1: ptr Pthread_spinlock): cint {.importc,: /posix/posix.
                                                             (line  767)
* proc pthread_testcancel*() {.importc, header: "<pthread.h>".}: /posix/posix.
                                                             (line  771)
* proc push*(r: var RunningRegress; x, y: float): /pure/stats.
                                                             (line  157)
* proc push*(r: var RunningRegress; x, y: int) {.inline.}: /pure/stats.
                                                             (line  162)
* proc push*(r: var RunningRegress; x, y: openarray[float | int]): /pure/stats.
                                                             (line  170)
* proc push*(s: var RunningStat; x: float): /pure/stats.     (line   28)
* proc push*(s: var RunningStat; x: int): /pure/stats.       (line   33)
* proc push*(s: var RunningStat; x: openarray[float | int]): /pure/stats.
                                                             (line   41)
* proc put*(key, value: string):         /system/nimscript.  (line  156)
* proc putEnv*(key, val: string) {.tags: [WriteEnvEffect].}: /pure/os.
                                                             (line  292)
* proc putwin*(a2: ptr WINDOW; a3: File): cint {.extdecl, importc: "putwin",: /wrappers/pdcurses.
                                                             (line  661)
* proc pwd*(ftp: AsyncFtpClient): Future[TaintedString] {.async.}: /pure/asyncftpclient.
                                                             (line   26)
* proc pwd*[T](ftp: FtpBase[T]): string: /deprecated/pure/ftpclient.
                                                             (line   30)
* proc pwrite*(a1: cint; a2: pointer; a3: int; a4: Off): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  942)
* proc qiflush*() {.extdecl, importc: "qiflush", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  665)
* proc query*(MySQL: PMySQL; q: cstring): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  403)
* proc queue_work*(loop: PLoop; req: PWork; work_cb: WorkProc;: /wrappers/libuv.
                                                             (line  270)
* proc quit*(errorcode: int = QuitSuccess) {.magic: "Exit", importc: "exit",: /system.
                                                             (line 1344)
* proc quit*(errormsg: string; errorcode = QuitFailure) {.noReturn.}: /system.
                                                             (line 2426)
* proc quote*(bl: stmt; op = "``"): NimNode {.magic: "QuoteAst", noSideEffect.}: /core/macros.
                                                             (line  289)
* proc quoteIfContainsWhite*(s: string): string {.deprecated.}: /pure/strutils.
                                                             (line  537)
* proc quoteShell*(s: string): string {.noSideEffect, rtl, extern: "nosp$1".}: /pure/osproc.
                                                             (line   36)
* proc quoteShellPosix*(s: string): string {.noSideEffect, rtl, extern: "nosp$1".}: /pure/osproc.
                                                             (line   30)
* proc quoteShellWindows*(s: string): string {.noSideEffect, rtl, extern: "nosp$1".}: /pure/osproc.
                                                             (line   22)
* proc radio*(child: PIhandle): PIhandle {.importc: "IupRadio", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  400)
* proc radToDeg*(rad: float): float {.inline.}: /pure/basic2d.
                                                             (line  515)
* proc radToDeg*[T: float32 | float64](d: T): T {.inline.}: /pure/math.
                                                             (line  254)
* proc raiseAssert*(msg: string) {.noinline.}: /system.      (line 2602)
* proc raiseInvalidLibrary*(name: cstring) {.noinline, noreturn.}: /pure/dynlib.
                                                             (line   31)
* proc raiseOSError*(errorCode: OSErrorCode; additionalInfo = "") {.noinline.}: /pure/os.
                                                             (line  106)
* proc raiseOSError*(msg: string = "") {.noinline, rtl, extern: "nos$1", deprecated.}: /pure/os.
                                                             (line   74)
* proc raiseParseErr*(p: JsonParser; msg: string) {.noinline, noreturn.}: /pure/json.
                                                             (line   91)
* proc raiseScgiError*(msg: string) {.noreturn.}: /pure/scgi.
                                                             (line   17)
* proc raiseSocketError*(socket: Socket; err: int = - 1; async = false): /deprecated/pure/sockets.
                                                             (line  111)
* proc raiseSSLError*(s = ""):           /pure/net.          (line   93)
* proc random*(max: float): float {.benign.}: /pure/math.    (line   73)
* proc random*(max: int): int {.benign.}: /pure/math.        (line   65)
* proc random*[T](a: openArray[T]): T:   /pure/math.         (line  272)
* proc random*[T](x: Slice[T]): T:       /pure/math.         (line  267)
* proc randominit*(para1: Prand_struct; seed1: int; seed2: int) {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  179)
* proc randomize*() {.benign.}:          /pure/math.         (line   82)
* proc randomize*(seed: int) {.benign.}: /pure/math.         (line   90)
* proc raw*(): cint {.extdecl, importc: "raw", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  668)
* proc rawData*(my: XmlParser): string {.inline.}: /pure/parsexml.
                                                             (line   44)
* proc rawData*(s: var SharedString): pointer: /pure/collections/sharedstrings.
                                                             (line   45)
* proc rawData2*(my: XmlParser): string {.inline.}: /pure/parsexml.
                                                             (line   50)
* proc rawEnv*[T: proc](x: T): pointer {.noSideEffect, inline.}: /system.
                                                             (line 2415)
* proc rawMatch*(s: string; p: Peg; start: int; c: var Captures): int {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  204)
* proc rawProc*[T: proc](x: T): pointer {.noSideEffect, inline.}: /system.
                                                             (line 2409)
* proc rawTag*(n: XmlNode): string {.inline.}: /pure/xmltree.
                                                             (line   57)
* proc rawText*(n: XmlNode): string {.inline.}: /pure/xmltree.
                                                             (line   51)
* proc raw_output*(a2: cunsignedchar): cint {.extdecl, importc: "raw_output",: /wrappers/pdcurses.
                                                             (line 1624)
* proc rdFileSize*(f: WIN32_FIND_DATA): int64: /windows/winlean.
                                                             (line  322)
* proc rdFileTime*(f: FILETIME): int64:  /windows/winlean.   (line  319)
* proc re*(pattern: string): Regex:      /impure/nre.        (line   70)
* proc re*(s: string; flags = {reExtended, reStudy}): Regex {.deprecated.}: /impure/re.
                                                             (line   31)
* proc read*(a1: cint; a2: pointer; a3: int): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  945)
* proc read*(f: AsyncFile; size: int): Future[string]: /pure/asyncfile.
                                                             (line   22)
* proc read*(loop: PLoop; req: PFS; file: File; buf: pointer; length: csize; offset: coff;: /wrappers/libuv.
                                                             (line  287)
* proc read*[T](future: Future[T]): T:   /pure/asyncdispatch.
                                                             (line   83)
* proc readAll*(f: AsyncFile): Future[string] {.async.}: /pure/asyncfile.
                                                             (line   49)
* proc readAll*(file: File): TaintedString {.tags: [ReadIOEffect], benign.}: /system.
                                                             (line 2144)
* proc readAll*(s: Stream): string:      /pure/streams.      (line  105)
* proc readBool*(s: Stream): bool:       /pure/streams.      (line  170)
* proc readBuffer*(f: File; buffer: pointer; len: Natural): int {.tags: [ReadIOEffect],: /system.
                                                             (line 2248)
* proc readBytes*(f: File; a: var openArray[int8 | uint8]; start, len: Natural): int {.: /system.
                                                             (line 2232)
* proc readChar*(f: File): char {.importc: "fgetc", header: "<stdio.h>",: /system.
                                                             (line 2132)
* proc readChar*(s: Stream): char:       /pure/streams.      (line  158)
* proc readChars*(f: File; a: var openArray[char]; start, len: Natural): int {.: /system.
                                                             (line 2240)
* proc readConsoleInputW*(hConsoleInput: THANDLE; lpBuffer: var INPUTRECORD;: /impure/rdstdin.
                                                             (line   29)
* proc readData*(allowedMethods: set[RequestMethod] = {methodNone, methodPost, methodGet}): StringTableRef: /pure/cgi.
                                                             (line   51)
* proc readData*(s, unused: Stream; buffer: pointer; bufLen: int): int {.deprecated.}: /pure/streams.
                                                             (line  110)
* proc readData*(s: Stream; buffer: pointer; bufLen: int): int: /pure/streams.
                                                             (line   99)
* proc readdir*(a1: ptr DIR): ptr Dirent {.importc, header: "<dirent.h>".}: /posix/posix.
                                                             (line  210)
* proc readdir*(loop: PLoop; req: PFS; path: cstring; flags: cint; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  307)
* proc readdir_r*(a1: ptr DIR; a2: ptr Dirent; a3: ptr ptr Dirent): cint {.importc,: /posix/posix.
                                                             (line  213)
* proc readError*[T](future: Future[T]): ref Exception: /pure/asyncdispatch.
                                                             (line   92)
* proc readFile*(filename: string): TaintedString {.tags: [ReadIOEffect], benign.}: /system.
                                                             (line 2152)
* proc readFile*(hFile: Handle; Buffer: pointer; nNumberOfBytesToRead: int32;: /windows/winlean.
                                                             (line  124)
* proc readFloat32*(s: Stream): float32: /pure/streams.      (line  220)
* proc readFloat64*(s: Stream): float64: /pure/streams.      (line  232)
* proc readInt16*(s: Stream): int16:     /pure/streams.      (line  190)
* proc readInt32*(s: Stream): int32:     /pure/streams.      (line  200)
* proc readInt64*(s: Stream): int64:     /pure/streams.      (line  210)
* proc readInt8*(s: Stream): int8:       /pure/streams.      (line  180)
* proc readLine*(f: AsyncFile): Future[string] {.async.}: /pure/asyncfile.
                                                             (line   31)
* proc readLine*(f: File): TaintedString {.tags: [ReadIOEffect], benign.}: /system.
                                                             (line 2198)
* proc readLine*(f: File; line: var TaintedString): bool {.tags: [ReadIOEffect], benign.}: /system.
                                                             (line 2205)
* proc readLine*(prompt: cstring): cstring {.importc: "linenoise".}: /wrappers/linenoise/linenoise.
                                                             (line   20)
* proc readLine*(s: AsyncSocket; line: var TaintedString): bool: /deprecated/pure/asyncio.
                                                             (line  186)
* proc readLine*(s: Stream): TaintedString: /pure/streams.   (line  276)
* proc readLine*(s: Stream; line: var TaintedString): bool: /pure/streams.
                                                             (line  256)
* proc readLine*(socket: Socket; line: var TaintedString; timeout = - 1) {.: /deprecated/pure/sockets.
                                                             (line  421)
* proc readLine*(socket: Socket; line: var TaintedString; timeout = - 1;: /pure/net.
                                                             (line  319)
* proc readLineAsync*(socket: Socket; line: var TaintedString): ReadLineResult {.: /deprecated/pure/sockets.
                                                             (line  456)
* proc readLineFromStdin*(prompt: string): TaintedString {.: /impure/rdstdin.
                                                             (line   12)
* proc readLineFromStdin*(prompt: string; line: var TaintedString): bool {.: /impure/rdstdin.
                                                             (line   18)
* proc readlink*(a1, a2: cstring; a3: int): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  948)
* proc readlink*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  366)
* proc readPasswordFromStdin*(prompt: string): TaintedString: /impure/rdstdin.
                                                             (line   44)
* proc readPasswordFromStdin*(prompt: string; password: var TaintedString): bool {.: /impure/rdstdin.
                                                             (line   36)
* proc readRow*(my: var CsvParser; columns = 0): bool: /pure/parsecsv.
                                                             (line   38)
* proc readStr*(s: Stream; length: int): TaintedString: /pure/streams.
                                                             (line  244)
* proc reads_from_master_enabled*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  471)
* proc readv*(a1: cint; a2: ptr IOVec; a3: cint): int {.importc, header: "<sys/uio.h>".}: /posix/posix.
                                                             (line 1553)
* proc ready*[In, Out](a: PActor[In, Out]): bool: /deprecated/pure/actors.
                                                             (line   43)
* proc ready*[TMsg](c: var Channel[TMsg]): bool: /system/channels.
                                                             (line   49)
* proc read_query_result*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  638)
* proc read_start*(a2: PStream; alloc_cb: AllocProc; read_cb: ReadProc): cint {.: /wrappers/libuv.
                                                             (line   66)
* proc read_start*(a2: PStream; alloc_cb: AllocProc; read_cb: ReadProc2): cint {.: /wrappers/libuv.
                                                             (line   70)
* proc read_stop*(a2: PStream): cint {.importc: "uv_read_stop", header: "uv.h".}: /wrappers/libuv.
                                                             (line   74)
* proc realloc*(p: pointer; newSize: Natural): pointer {.noconv, rtl, tags: [], benign.}: /system.
                                                             (line 1569)
* proc reallocShared*(p: pointer; newSize: Natural): pointer {.noconv, rtl, benign.}: /system.
                                                             (line 1633)
* proc realpath*(name, resolved: cstring): cstring {.importc: "realpath",: /posix/posix.
                                                             (line 1800)
* proc real_connect*(MySQL: PMySQL; host: cstring; user: cstring; passwd: cstring;: /wrappers/mysql.
                                                             (line  392)
* proc real_escape_string*(MySQL: PMySQL; fto: cstring; `from`: cstring; len: int): int {.: /wrappers/mysql.
                                                             (line  597)
* proc real_query*(MySQL: PMySQL; q: cstring; len: int): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  411)
* proc reciprocal*[T](x: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line  149)
* proc rect*(r: float; phi: float): Complex: /pure/complex.  (line  304)
* proc recv*(a1: SocketHandle; a2: pointer; a3: int; a4: cint): int {.importc,: /posix/posix.
                                                             (line 1602)
* proc recv*(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall,: /windows/winlean.
                                                             (line  410)
* proc recv*(socket: AsyncFD; size: int; flags = {SocketFlag.SafeDisconn}): Future[string]: /pure/asyncdispatch.
                                                             (line  173)
* proc recv*(socket: AsyncSocket; size: int; flags = {SocketFlag.SafeDisconn}): Future[: /pure/asyncnet.
                                                             (line   46)
* proc recv*(socket: Socket): TaintedString {.tags: [ReadIOEffect], deprecated.}: /deprecated/pure/sockets.
                                                             (line  473)
* proc recv*(socket: Socket; data: pointer; size: int): int {.tags: [ReadIOEffect].}: /pure/net.
                                                             (line  286)
* proc recv*(socket: Socket; data: pointer; size: int): int {.tags: [ReadIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  359)
* proc recv*(socket: Socket; data: pointer; size: int; timeout: int): int {.: /pure/net.
                                                             (line  294)
* proc recv*(socket: Socket; data: pointer; size: int; timeout: int): int {. <1>: /deprecated/pure/sockets.
                                                             (line  367)
* proc recv*(socket: Socket; data: var string; size: int; timeout = - 1): int: /deprecated/pure/sockets.
                                                             (line  373)
* proc recv*(socket: Socket; data: var string; size: int; timeout = - 1;: /pure/net.
                                                             (line  300)
* proc recv*[In, Out](a: PActor[In, Out]): Task[In, Out]: /deprecated/pure/actors.
                                                             (line   53)
* proc recv*[TMsg](c: var Channel[TMsg]): TMsg: /system/channels.
                                                             (line   19)
* proc recvAsync*(socket: Socket; data: var string; size: int): int: /deprecated/pure/sockets.
                                                             (line  389)
* proc recvAsync*(socket: Socket; s: var TaintedString): bool {.tags: [ReadIOEffect],: /deprecated/pure/sockets.
                                                             (line  494)
* proc recvfrom*(a1: SocketHandle; a2: pointer; a3: int; a4: cint; a5: ptr SockAddr;: /posix/posix.
                                                             (line 1606)
* proc recvfrom*(s: SocketHandle; buf: cstring; len, flags: cint; fromm: ptr SockAddr;: /windows/winlean.
                                                             (line  414)
* proc recvFrom*(socket: Socket; data: var string; length: int; address: var string;: /pure/net.
                                                             (line  338)
* proc recvFrom*(socket: Socket; data: var string; length: int; address: var string; <1>: /deprecated/pure/sockets.
                                                             (line  507)
* proc recvFromAsync*(socket: Socket; data: var string; length: int; address: var string;: /deprecated/pure/sockets.
                                                             (line  524)
* proc recvInto*(socket: AsyncFD; buf: cstring; size: int;: /pure/asyncdispatch.
                                                             (line  183)
* proc recvLine*(s: AsyncSocket; line: var TaintedString): bool {.deprecated.}: /deprecated/pure/asyncio.
                                                             (line  171)
* proc recvLine*(sock: SecureSocket; line: var TaintedString): bool: /impure/ssl.
                                                             (line   22)
* proc recvLine*(socket: AsyncFD): Future[string] {.async.}: /pure/asyncdispatch.
                                                             (line  256)
* proc recvLine*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[string] {.: /pure/asyncnet.
                                                             (line  112)
* proc recvLine*(socket: Socket; line: var TaintedString; timeout = - 1): bool {.: /deprecated/pure/sockets.
                                                             (line  399)
* proc recvLineAsync*(socket: Socket; line: var TaintedString): RecvLineResult {.: /deprecated/pure/sockets.
                                                             (line  437)
* proc recvLineInto*(socket: AsyncSocket; resString: FutureVar[string];: /pure/asyncnet.
                                                             (line   88)
* proc recvmsg*(a1: SocketHandle; a2: ptr Tmsghdr; a3: cint): int {.importc,: /posix/posix.
                                                             (line 1611)
* proc recvTimeout*(socket: Socket; timeout: int): TaintedString {.tags: [ReadIOEffect],: /deprecated/pure/sockets.
                                                             (line  483)
* proc redraw*(ih: PIhandle; children: cint) {.importc: "IupRedraw", cdecl,: /wrappers/iup.
                                                             (line  124)
* proc redrawwin*(a2: ptr WINDOW): cint {.extdecl, importc: "redrawwin",: /wrappers/pdcurses.
                                                             (line  671)
* proc reduce*[T: SomeInteger](x: var Rational[T]): /pure/rationals.
                                                             (line   64)
* proc refcount*(code: ptr Pcre; adjust: cint): cint: /wrappers/pcre.
                                                             (line  184)
* proc refresh*(): cint {.extdecl, importc: "refresh", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  675)
* proc refresh*(ih: PIhandle) {.importc: "IupRefresh", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  128)
* proc refresh*(sql: PMySQL; refresh_options: cuint): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  502)
* proc register*(d: Dispatcher; deleg: Delegate): /deprecated/pure/asyncio.
                                                             (line  108)
* proc register*(d: Dispatcher; ftp: AsyncFTPClient): Delegate {.discardable.}: /deprecated/pure/ftpclient.
                                                             (line  135)
* proc register*(d: Dispatcher; monitor: FSMonitor;: /pure/fsmonitor.
                                                             (line   59)
* proc register*(d: Dispatcher; s: AsyncScgiState): Delegate {.discardable.}: /pure/scgi.
                                                             (line   65)
* proc register*(d: Dispatcher; s: PAsyncHTTPServer): /pure/httpserver.
                                                             (line   46)
* proc register*(d: Dispatcher; sock: AsyncSocket): Delegate {.discardable.}: /deprecated/pure/asyncio.
                                                             (line  113)
* proc register*(fd: AsyncFD):           /pure/asyncdispatch.
                                                             (line  154)
* proc register*(mimedb: var MimeDB; ext: string; mimetype: string): /pure/mimetypes.
                                                             (line  510)
* proc register*(s: Selector; fd: SocketHandle; events: set[Event]; data: SelectorData): SelectorKey {.: /pure/selectors.
                                                             (line   26)
* proc release*(lock: var Lock):         /core/locks.        (line   34)
* proc releaseEvents*(d: Document; eventMask: int) {.deprecated.}: /js/dom.
                                                             (line  196)
* proc releaseEvents*(w: Window; eventMask: int) {.deprecated.}: /js/dom.
                                                             (line   85)
* proc reload*(loc: Location):           /js/dom.            (line  241)
* proc reload*(x: PMySQL): cint:         /wrappers/mysql.    (line  775)
* proc relocate*(s: PccState; p: pointer): cint {.cdecl, importc: "tcc_relocate".}: /wrappers/tinyc.
                                                             (line  120)
* proc remove*(c: ClassList; class: cstring): /js/dom.       (line  262)
* proc remove*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T]): /pure/collections/lists.
                                                             (line  145)
* proc remove*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T]): /pure/collections/lists.
                                                             (line  190)
* proc removeAttribute*(el: PElement; name: string): /pure/xmldom.
                                                             (line  359)
* proc removeAttribute*(n: Node; attr: cstring): /js/dom.    (line  139)
* proc removeAttribute*(s: Style; attr: cstring; caseSensitive = false): /js/dom.
                                                             (line  274)
* proc removeAttributeNode*(el: PElement; oldAttr: PAttr): PAttr: /pure/xmldom.
                                                             (line  369)
* proc removeAttributeNode*(n, attr: Node): /js/dom.         (line  142)
* proc removeAttributeNS*(el: PElement; namespaceURI: string; localName: string): /pure/xmldom.
                                                             (line  364)
* proc removeChild*(n, child: Node):     /js/dom.            (line  145)
* proc removeChild*(n: PNode; oldChild: PNode): PNode: /pure/xmldom.
                                                             (line  213)
* proc removeDir*(dir: string) {.rtl, extern: "nos$1",: /pure/os.
                                                             (line  298)
* proc removeDirectoryW*(lpPathName: WideCString): int32 {.: /windows/winlean.
                                                             (line  241)
* proc removeFile*(file: string) {.rtl, extern: "nos$1", tags: [WriteDirEffect].}: /pure/os.
                                                             (line  259)
* proc removeHandler*(handler: var EventHandler; fn: proc (e: EventArgs) {.closure.}): /pure/events.
                                                             (line   27)
* proc removeNamedItem*(nList: var seq[PNode]; name: string): PNode: /pure/xmldom.
                                                             (line  255)
* proc removeNamedItemNS*(nList: var seq[PNode]; namespaceURI: string; localName: string): PNode: /pure/xmldom.
                                                             (line  261)
* proc removeSuffix*(s: var string; c: char) {.rtl, extern: "nsuRemoveSuffixChar".}: /pure/strutils.
                                                             (line  788)
* proc removeSuffix*(s: var string; chars: set[char] = Newlines) {.rtl,: /pure/strutils.
                                                             (line  771)
* proc removeSuffix*(s: var string; suffix: string) {.rtl,: /pure/strutils.
                                                             (line  800)
* proc rename*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  319)
* proc renderIndexTerm*(d: PDoc; n: PRstNode; result: var string): /packages/docutils/rstgen.
                                                             (line  124)
* proc renderRstToJson*(node: PRstNode): string: /packages/docutils/rstast.
                                                             (line   47)
* proc renderRstToOut*(d: var RstGenerator; n: PRstNode; result: var string): /packages/docutils/rstgen.
                                                             (line   85)
* proc renderRstToRst*(n: PRstNode; result: var string): /packages/docutils/rstast.
                                                             (line   42)
* proc renderSQL*(n: SqlNode): string:   /pure/parsesql.     (line   62)
* proc renderTocEntries*(d: var RstGenerator; j: var int; lvl: int; result: var string): /packages/docutils/rstgen.
                                                             (line  167)
* proc reopen*(f: File; filename: string; mode: FileMode = fmRead): bool {.tags: [], benign.}: /system.
                                                             (line 2113)
* proc reparent*(ih, newParent: PIhandle): cint {.importc: "IupReparent", cdecl,: /wrappers/iup.
                                                             (line  207)
* proc repeat*(c: char; count: Natural): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  344)
* proc repeat*(s: string; n: Natural): string {.noSideEffect, rtl, extern: "nsuRepeatStr".}: /pure/strutils.
                                                             (line  358)
* proc repeat*[T](x: T; n: Natural): seq[T]: /pure/collections/sequtils.
                                                             (line   33)
* proc repeatChar*(count: Natural; c: char = ' '): string {.deprecated.}: /pure/strutils.
                                                             (line  364)
* proc repeatStr*(count: Natural; s: string): string {.deprecated.}: /pure/strutils.
                                                             (line  369)
* proc replace*(loc: Location; s: cstring): /js/dom.         (line  244)
* proc replace*(s, sub: string; by = ""): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  561)
* proc replace*(s: string; sub, by: char): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  567)
* proc replace*(s: string; sub: Peg; by = ""): string {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line  310)
* proc replace*(s: string; sub: Regex; by = ""): string: /impure/re.
                                                             (line  127)
* proc replace*(str: string; pattern: Regex; sub: string): string: /impure/nre.
                                                             (line  144)
* proc replace*(str: string; pattern: Regex; subproc: proc (match: RegexMatch): string): string: /impure/nre.
                                                             (line  116)
* proc replace*(str: string; pattern: Regex; subproc: proc (match: string): string): string: /impure/nre.
                                                             (line  141)
* proc replaceChild*(n, newNode, oldNode: Node): /js/dom.    (line  148)
* proc replaceChild*(n: PNode; newChild: PNode; oldChild: PNode): PNode: /pure/xmldom.
                                                             (line  219)
* proc replaceData*(n: Node; start, len: int; text: cstring): /js/dom.
                                                             (line  151)
* proc replacef*(s: string; sub: Peg; by: string): string {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  299)
* proc replacef*(s: string; sub: Regex; by: string): string: /impure/re.
                                                             (line  137)
* proc replaceWord*(s, sub: string; by = ""): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  576)
* proc replace_panel*(pan: ptr PANEL; win: ptr WINDOW): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1744)
* proc reply*[In, Out](t: Task[In, Out]; m: Out): /deprecated/pure/actors.
                                                             (line   73)
* proc repr*[T](x: T): string {.magic: "Repr", noSideEffect.}: /system.
                                                             (line 1412)
* proc request*(client: AsyncHttpClient; url: string; httpMethod = httpGET; body = ""): Future[: /pure/httpclient.
                                                             (line  269)
* proc request*(client: AsyncHttpClient; url: string; httpMethod: string; body = ""): Future[: /pure/httpclient.
                                                             (line  256)
* proc request*(url: string; httpMethod = httpGET; extraHeaders = ""; body = "";: /pure/httpclient.
                                                             (line  144)
* proc request*(url: string; httpMethod: string; extraHeaders = ""; body = "";: /pure/httpclient.
                                                             (line  129)
* proc request_mouse_pos*(): cint {.extdecl, importc: "request_mouse_pos",: /wrappers/pdcurses.
                                                             (line 1512)
* proc requires*(deps: varargs[string]): /system/nimscript.  (line  193)
* proc req_cleanup*(req: PFS) {.importc: "uv_fs_req_cleanup", header: "uv.h".}: /wrappers/libuv.
                                                             (line  276)
* proc reset*(f: FormElement):           /js/dom.            (line  229)
* proc reset*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_reset".}: /wrappers/sqlite3.
                                                             (line  276)
* proc reset*[T](obj: var T) {.magic: "Reset", noSideEffect.}: /system.
                                                             (line  307)
* proc resetAttributes*() {.noconv.}:    /pure/terminal.     (line  131)
* proc resetAttributes*(f: File):        /pure/terminal.     (line   94)
* proc resetterm*(): cint {.extdecl, importc: "resetterm", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1488)
* proc resetty*(): cint {.extdecl, importc: "resetty", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  686)
* proc reset_prog_mode*(): cint {.extdecl, importc: "reset_prog_mode",: /wrappers/pdcurses.
                                                             (line  678)
* proc reset_shell_mode*(): cint {.extdecl, importc: "reset_shell_mode",: /wrappers/pdcurses.
                                                             (line  682)
* proc resize*[T](p: ptr T; newSize: Natural): ptr T {.inline, benign.}: /system.
                                                             (line 1579)
* proc resizeBy*(w: Window; x, y: int):  /js/dom.            (line   88)
* proc resizeShared*[T](p: ptr T; newSize: Natural): ptr T {.inline.}: /system.
                                                             (line 1642)
* proc resizeTo*(w: Window; x, y: int):  /js/dom.            (line   91)
* proc resize_term*(a2: cint; a3: cint): cint {.extdecl, importc: "resize_term",: /wrappers/pdcurses.
                                                             (line 1628)
* proc resize_window*(a2: ptr WINDOW; a3: cint; a4: cint): ptr WINDOW {.extdecl,: /wrappers/pdcurses.
                                                             (line 1632)
* proc respond*(req: Request; code: HttpCode; content: string;: /pure/asynchttpserver.
                                                             (line   26)
* proc result_blob*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.: /wrappers/sqlite3.
                                                             (line  367)
* proc result_double*(para1: Pcontext; para2: float64) {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  371)
* proc result_error*(para1: Pcontext; para2: cstring; para3: int32) {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  375)
* proc result_error16*(para1: Pcontext; para2: pointer; para3: int32) {.cdecl,: /wrappers/sqlite3.
                                                             (line  379)
* proc result_int*(para1: Pcontext; para2: int32) {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  383)
* proc result_int64*(para1: Pcontext; para2: int64) {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  387)
* proc result_null*(para1: Pcontext) {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  391)
* proc result_text*(para1: Pcontext; para2: cstring; para3: int32; para4: Result_func) {.: /wrappers/sqlite3.
                                                             (line  395)
* proc result_text16*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.: /wrappers/sqlite3.
                                                             (line  399)
* proc result_text16be*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.: /wrappers/sqlite3.
                                                             (line  409)
* proc result_text16le*(para1: Pcontext; para2: pointer; para3: int32; para4: Result_func) {.: /wrappers/sqlite3.
                                                             (line  404)
* proc result_value*(para1: Pcontext; para2: Pvalue) {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  414)
* proc resume*(p: Process) {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  116)
* proc resumeThread*(hThread: Handle): int32 {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  182)
* proc retrFile*(ftp: AsyncFtpClient; file, dest: string;: /pure/asyncftpclient.
                                                             (line   86)
* proc retrFile*[T](ftp: FtpBase[T]; file, dest: string; async = false): /deprecated/pure/ftpclient.
                                                             (line  100)
* proc retrText*(ftp: AsyncFtpClient; file: string): Future[string] {.async.}: /pure/asyncftpclient.
                                                             (line   75)
* proc retrText*[T](ftp: FtpBase[T]; file: string; async = false): string: /deprecated/pure/ftpclient.
                                                             (line   93)
* proc return_key_modifiers*(a2: cunsignedchar): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1694)
* proc reverse*[T](a: var openArray[T]): /pure/algorithm.    (line   37)
* proc reverse*[T](a: var openArray[T]; first, last: Natural): /pure/algorithm.
                                                             (line   32)
* proc reversed*(s: string): string:     /pure/unicode.      (line  123)
* proc reversed*[T](a: openArray[T]): seq[T]: /pure/algorithm.
                                                             (line   47)
* proc reversed*[T](a: openArray[T]; first: Natural; last: int): seq[T]: /pure/algorithm.
                                                             (line   42)
* proc rewinddir*(a1: ptr DIR) {.importc, header: "<dirent.h>".}: /posix/posix.
                                                             (line  217)
* proc rfind*(s, sub: string; start: int = - 1): int {.noSideEffect.}: /pure/strutils.
                                                             (line  502)
* proc rfind*(s: string; sub: char; start: int = - 1): int {.noSideEffect, rtl.}: /pure/strutils.
                                                             (line  510)
* proc rgb*(r, g, b: range[0 .. 255]): Color: /pure/colors.  (line   60)
* proc rightSize*(count: Natural): int {.inline.}: /pure/collections/tables.
                                                             (line   18)
* proc rightSize*(count: Natural): int {.inline.} <1>: /pure/collections/sets.
                                                             (line   68)
* proc rmdir*(a1: cstring): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  958)
* proc rmDir*(dir: string) {.raises: [OSError].}: /system/nimscript.
                                                             (line  119)
* proc rmdir*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  303)
* proc rmFile*(file: string) {.raises: [OSError].}: /system/nimscript.
                                                             (line  124)
* proc rollback*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  756)
* proc romanToDecimal*(romanVal: string): int: /pure/romans. (line   14)
* proc roots*(p: Poly; tol = 1e-09'f64; zerotol = 1e-06'f64; mergetol = 1e-12'f64;: /pure/poly.
                                                             (line  150)
* proc rope*(f: BiggestFloat): Rope {.rtl, extern: "nro$1BiggestFloat".}: /pure/ropes.
                                                             (line   21)
* proc rope*(i: BiggestInt): Rope {.rtl, extern: "nro$1BiggestInt".}: /pure/ropes.
                                                             (line   16)
* proc rope*(s: string): Rope {.rtl, extern: "nro$1Str".}: /pure/ropes.
                                                             (line   11)
* proc rotate*(angle: float; axis: Vector3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line   99)
* proc rotate*(angle: float; org: Point3d; axis: Vector3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  105)
* proc rotate*(p: var Point2d; rad: float): /pure/basic2d.   (line  442)
* proc rotate*(p: var Point2d; rad: float; org: Point2d): /pure/basic2d.
                                                             (line  447)
* proc rotate*(p: var Point3d; angle: float; org: Point3d; axis: Vector3d): /pure/basic3d.
                                                             (line  427)
* proc rotate*(p: var Point3d; rad: float; axis: Vector3d): /pure/basic3d.
                                                             (line  421)
* proc rotate*(rad: float): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   89)
* proc rotate*(rad: float; org: Point2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   95)
* proc rotate*(v: var Vector2d; rad: float): /pure/basic2d.  (line  284)
* proc rotate*(vec: var Vector3d; angle: float; axis: Vector3d): /pure/basic3d.
                                                             (line  280)
* proc rotate180*(v: var Vector2d) {.inline.}: /pure/basic2d.
                                                             (line  272)
* proc rotate270*(v: var Vector2d) {.inline.}: /pure/basic2d.
                                                             (line  278)
* proc rotate90*(v: var Vector2d) {.inline.}: /pure/basic2d. (line  266)
* proc rotateX*(angle: float): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  111)
* proc rotateY*(angle: float): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  117)
* proc rotateZ*(angle: float): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  123)
* proc round*(x: float): int {.importc: "lrint", header: "<math.h>".}: /pure/math.
                                                             (line  135)
* proc routeEvent*(d: Document; event: Event): /js/dom.      (line  199)
* proc routeEvent*(w: Window; event: Event): /js/dom.        (line   94)
* proc row_seek*(result: PRES; offset: ROW_OFFSET): ROW_OFFSET {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  566)
* proc row_tell*(res: PRES): ROW_OFFSET {.stdcall, dynlib: lib, importc: "mysql_row_tell".}: /wrappers/mysql.
                                                             (line  332)
* proc rpl_parse_enabled*(MySQL: PMySQL): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  457)
* proc rpl_probe*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  480)
* proc rpl_query_type*(q: cstring; length: cint): Rpl_type {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  476)
* proc rstnodeToRefname*(n: PRstNode): string: /packages/docutils/rst.
                                                             (line   15)
* proc rstParse*(text, filename: string; line, column: int; hasToc: var bool;: /packages/docutils/rst.
                                                             (line   48)
* proc rstToHtml*(s: string; options: RstParseOptions; config: StringTableRef): string: /packages/docutils/rstgen.
                                                             (line  190)
* proc run*():                           /pure/coro.         (line   19)
* proc run*(a2: PLoop): cint {.importc: "uv_run", header: "uv.h".}: /wrappers/libuv.
                                                             (line   21)
* proc run*(handleRequest: proc (client: Socket; input: string; headers: StringTableRef): bool {.: /pure/scgi.
                                                             (line   47)
* proc run*(handleRequest: proc (client: Socket; path, query: string): bool {.closure.};: /pure/httpserver.
                                                             (line   32)
* proc run*(s: PccState; argc: cint; argv: cstringArray): cint {.cdecl, importc: "tcc_run".}: /wrappers/tinyc.
                                                             (line  114)
* proc runeAt*(s: string; i: Natural): Rune: /pure/unicode.  (line   39)
* proc runeLen*(s: string): int {.rtl, extern: "nuc$1".}: /pure/unicode.
                                                             (line   23)
* proc runeLenAt*(s: string; i: Natural): int: /pure/unicode.
                                                             (line   28)
* proc runForever*():                    /pure/asyncdispatch.
                                                             (line  276)
* proc running*(p: Process): bool {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  135)
* proc running*[In, Out](a: PActor[In, Out]): bool: /deprecated/pure/actors.
                                                             (line   38)
* proc running*[TArg](t: Thread[TArg]): bool {.inline.}: /system/threads.
                                                             (line   14)
* proc safeAdd*(x: var string; y: char): /system.            (line 2642)
* proc safeAdd*(x: var string; y: string): /system.          (line 2647)
* proc safeAdd*[T](x: var seq[T]; y: T) {.noSideEffect.}: /system.
                                                             (line 2636)
* proc sameFile*(path1, path2: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}: /pure/os.
                                                             (line  203)
* proc sameFileContent*(path1, path2: string): bool {.rtl, extern: "nos$1",: /pure/os.
                                                             (line  213)
* proc sameType*(a, b: NimNode): bool {.magic: "SameNodeType", noSideEffect.}: /core/macros.
                                                             (line   80)
* proc saveClassAttributes*(ih: PIhandle) {.importc: "IupSaveClassAttributes", cdecl,: /wrappers/iup.
                                                             (line  376)
* proc saveterm*(): cint {.extdecl, importc: "saveterm", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1494)
* proc savetty*(): cint {.extdecl, importc: "savetty", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  689)
* proc save_key_modifiers*(a2: cunsignedchar): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1699)
* proc save_model*(model_file_name: cstring; model: ptr Model): cint {.cdecl,: /wrappers/libsvm.
                                                             (line   70)
* proc sbox*(child: PIhandle): PIhandle {.importc: "IupSbox", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  443)
* proc sb_get_horz*(a2: ptr cint; a3: ptr cint; a4: ptr cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1782)
* proc sb_get_vert*(a2: ptr cint; a3: ptr cint; a4: ptr cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1786)
* proc sb_init*(): cint {.extdecl, importc: "sb_init", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1771)
* proc sb_refresh*(): cint {.extdecl, importc: "sb_refresh", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1790)
* proc sb_set_horz*(a2: cint; a3: cint; a4: cint): cint {.extdecl, importc: "sb_set_horz",: /wrappers/pdcurses.
                                                             (line 1774)
* proc sb_set_vert*(a2: cint; a3: cint; a4: cint): cint {.extdecl, importc: "sb_set_vert",: /wrappers/pdcurses.
                                                             (line 1778)
* proc scale*(p: var Point2d; fac: float) {.inline.}: /pure/basic2d.
                                                             (line  453)
* proc scale*(p: var Point2d; fac: float; org: Point2d) {.inline.}: /pure/basic2d.
                                                             (line  458)
* proc scale*(p: var Point3d; fac: float) {.inline.}: /pure/basic3d.
                                                             (line  433)
* proc scale*(p: var Point3d; fac: float; org: Point3d) {.inline.}: /pure/basic3d.
                                                             (line  438)
* proc scale*(s: float): Matrix2d {.noInit.}: /pure/basic2d. (line   57)
* proc scale*(s: float): Matrix3d {.noInit.}: /pure/basic3d. (line   67)
* proc scale*(s: float; org: Point2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   62)
* proc scale*(s: float; org: Point3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line   72)
* proc scale*(v: var Vector2d; fac: float) {.inline.}: /pure/basic2d.
                                                             (line  289)
* proc scale*(v: var Vector3d; s: float): /pure/basic3d.     (line  286)
* proc scanf*(format: cstring): cint {.importc: "IupScanf", dynlib: dllname, cdecl, varargs.}: /wrappers/iup.
                                                             (line   65)
* proc scanw*(a2: cstring): cint {.varargs, extdecl, importc: "scanw", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  692)
* proc sched_getparam*(a1: Pid; a2: var Sched_param): cint {.importc, header: "<sched.h>".}: /posix/posix.
                                                             (line 1400)
* proc sched_getscheduler*(a1: Pid): cint {.importc, header: "<sched.h>".}: /posix/posix.
                                                             (line 1403)
* proc sched_get_priority_max*(a1: cint): cint {.importc, header: "<sched.h>".}: /posix/posix.
                                                             (line 1394)
* proc sched_get_priority_min*(a1: cint): cint {.importc, header: "<sched.h>".}: /posix/posix.
                                                             (line 1397)
* proc sched_rr_get_interval*(a1: Pid; a2: var Timespec): cint {.importc,: /posix/posix.
                                                             (line 1406)
* proc sched_setparam*(a1: Pid; a2: var Sched_param): cint {.importc, header: "<sched.h>".}: /posix/posix.
                                                             (line 1410)
* proc sched_setscheduler*(a1: Pid; a2: cint; a3: var Sched_param): cint {.importc,: /posix/posix.
                                                             (line 1413)
* proc sched_yield*(): cint {.importc, header: "<sched.h>".}: /posix/posix.
                                                             (line 1417)
* proc scramble*(fto: cstring; message: cstring; password: cstring) {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  224)
* proc scramble_323*(fto: cstring; message: cstring; password: cstring) {.cdecl,: /wrappers/mysql.
                                                             (line  199)
* proc scrl*(a2: cint): cint {.extdecl, importc: "scrl", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  708)
* proc scroll*(a2: ptr WINDOW): cint {.extdecl, importc: "scroll", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  711)
* proc scrollBy*(w: Window; x, y: int):  /js/dom.            (line   97)
* proc scrollIntoView*(n: Node):         /js/dom.            (line  154)
* proc scrollok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "scrollok",: /wrappers/pdcurses.
                                                             (line  714)
* proc scrollTo*(w: Window; x, y: int):  /js/dom.            (line  100)
* proc scr_dump*(a2: cstring): cint {.extdecl, importc: "scr_dump", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  695)
* proc scr_init*(a2: cstring): cint {.extdecl, importc: "scr_init", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  698)
* proc scr_restore*(a2: cstring): cint {.extdecl, importc: "scr_restore",: /wrappers/pdcurses.
                                                             (line  701)
* proc scr_set*(a2: cstring): cint {.extdecl, importc: "scr_set", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  705)
* proc sec*(z: Complex): Complex:        /pure/complex.      (line  214)
* proc sech*(z: Complex): Complex:       /pure/complex.      (line  264)
* proc seconds*(s: int): TimeInterval {.inline.}: /pure/times.
                                                             (line  250)
* proc secureHash*(str: string): SecureHash: /pure/securehash.
                                                             (line   12)
* proc secureHashFile*(filename: string): SecureHash: /pure/securehash.
                                                             (line   15)
* proc seekdir*(a1: ptr DIR; a2: int) {.importc, header: "<dirent.h>".}: /posix/posix.
                                                             (line  220)
* proc select*(a1: cint | SocketHandle; a2, a3, a4: ptr TFdSet; a5: ptr Timeval): cint {.: /posix/posix.
                                                             (line 1444)
* proc select*(e: Element):              /js/dom.            (line  220)
* proc select*(nfds: cint; readfds, writefds, exceptfds: ptr TFdSet; timeout: ptr Timeval): cint {.: /windows/winlean.
                                                             (line  420)
* proc select*(readfds, writefds, exceptfds: var seq[Socket]; timeout = 500): int {.: /deprecated/pure/sockets.
                                                             (line  324)
* proc select*(readfds, writefds: var seq[Socket]; timeout = 500): int {.: /deprecated/pure/sockets.
                                                             (line  337)
* proc select*(readfds: var seq[Process]; timeout = 500): int {.benign.}: /pure/osproc.
                                                             (line  230)
* proc select*(readfds: var seq[SocketHandle]; timeout = 500): int: /pure/nativesockets.
                                                             (line  190)
* proc select*(readfds: var seq[Socket]; timeout = 500): int: /deprecated/pure/sockets.
                                                             (line  354)
* proc select*(s: Selector; timeout: int): seq[ReadyInfo]: /pure/selectors.
                                                             (line   49)
* proc selectWrite*(writefds: var seq[SocketHandle]; timeout = 500): int {.: /pure/nativesockets.
                                                             (line  201)
* proc selectWrite*(writefds: var seq[Socket]; timeout = 500): int {.tags: [ReadIOEffect].}: /deprecated/pure/sockets.
                                                             (line  343)
* proc select_db*(MySQL: PMySQL; db: cstring): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  399)
* proc sem_close*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1033)
* proc sem_destroy*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1036)
* proc sem_getvalue*(a1: ptr Sem; a2: var cint): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1039)
* proc sem_init*(a1: ptr Sem; a2: cint; a3: cint): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1042)
* proc sem_open*(a1: cstring; a2: cint): ptr Sem {.varargs, importc,: /posix/posix.
                                                             (line 1045)
* proc sem_post*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1049)
* proc sem_timedwait*(a1: ptr Sem; a2: ptr Timespec): cint {.importc,: /posix/posix.
                                                             (line 1052)
* proc sem_trywait*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1056)
* proc sem_unlink*(a1: cstring): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1059)
* proc sem_wait*(a1: ptr Sem): cint {.importc, header: "<semaphore.h>".}: /posix/posix.
                                                             (line 1062)
* proc send*(a1: SocketHandle; a2: pointer; a3: int; a4: cint): int {.importc,: /posix/posix.
                                                             (line 1615)
* proc send*(ftp: AsyncFtpClient; m: string): Future[TaintedString] {.async.}: /pure/asyncftpclient.
                                                             (line   13)
* proc send*(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall,: /windows/winlean.
                                                             (line  424)
* proc send*(sock: AsyncSocket; data: string): /deprecated/pure/asyncio.
                                                             (line  201)
* proc send*(sock: SecureSocket; data: string): /impure/ssl. (line   29)
* proc send*(socket: AsyncFD; data: string; flags = {SocketFlag.SafeDisconn}): Future[void]: /pure/asyncdispatch.
                                                             (line  195)
* proc send*(socket: AsyncSocket; data: string; flags = {SocketFlag.SafeDisconn}) {.async.}: /pure/asyncnet.
                                                             (line   65)
* proc send*(socket: Socket; data: pointer; size: int): int {.tags: [WriteIOEffect].}: /pure/net.
                                                             (line  366)
* proc send*(socket: Socket; data: pointer; size: int): int {.tags: [WriteIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  555)
* proc send*(socket: Socket; data: string) {.tags: [WriteIOEffect].}: /deprecated/pure/sockets.
                                                             (line  560)
* proc send*(socket: Socket; data: string; flags = {SocketFlag.SafeDisconn}) {.: /pure/net.
                                                             (line  374)
* proc send*[In, Out, X, Y](receiver: PActor[In, Out]; msg: In; sender: PActor[X, Y]): /deprecated/pure/actors.
                                                             (line   58)
* proc send*[In, Out](receiver: PActor[In, Out]; msg: In; sender: ptr Channel[Out] = nil): /deprecated/pure/actors.
                                                             (line   63)
* proc send*[TMsg](c: var Channel[TMsg]; msg: TMsg): /system/channels.
                                                             (line   14)
* proc send*[T](ftp: FtpBase[T]; m: string): TaintedString: /deprecated/pure/ftpclient.
                                                             (line   17)
* proc sendAsync*(socket: Socket; data: string): int {.tags: [WriteIOEffect].}: /deprecated/pure/sockets.
                                                             (line  565)
* proc sendfile*(loop: PLoop; req: PFS; out_fd: File; in_fd: File; in_offset: coff;: /wrappers/libuv.
                                                             (line  335)
* proc sendHeaders*(req: Request; headers: StringTableRef): Future[void]: /pure/asynchttpserver.
                                                             (line   21)
* proc sendMail*(smtp: AsyncSmtp; fromAddr: string; toAddrs: seq[string]; msg: string) {.: /pure/smtp.
                                                             (line   79)
* proc sendmail*(smtp: var Smtp; fromaddr: string; toaddrs: seq[string]; msg: string): /pure/smtp.
                                                             (line   33)
* proc sendmsg*(a1: SocketHandle; a2: ptr Tmsghdr; a3: cint): int {.importc,: /posix/posix.
                                                             (line 1619)
* proc sendShutdown*[In, Out](receiver: PActor[In, Out]): /deprecated/pure/actors.
                                                             (line   68)
* proc sendto*(a1: SocketHandle; a2: pointer; a3: int; a4: cint; a5: ptr SockAddr; a6: Socklen): int {.: /posix/posix.
                                                             (line 1623)
* proc sendto*(s: SocketHandle; buf: pointer; len, flags: cint; to: ptr SockAddr;: /windows/winlean.
                                                             (line  428)
* proc sendTo*(socket: Socket; address: string; port: Port; data: pointer; size: int;: /pure/net.
                                                             (line  386)
* proc sendTo*(socket: Socket; address: string; port: Port; data: pointer; size: int; <1>: /deprecated/pure/sockets.
                                                             (line  582)
* proc sendTo*(socket: Socket; address: string; port: Port; data: string): int {.: /pure/net.
                                                             (line  400)
* proc sendTo*(socket: Socket; address: string; port: Port; data: string): int {. <1>: /deprecated/pure/sockets.
                                                             (line  593)
* proc send_query*(MySQL: PMySQL; q: cstring; len: int): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  407)
* proc separator*(): PIhandle {.importc: "IupSeparator", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  469)
* proc sequence*(a: varargs[Peg]): Peg {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line   64)
* proc serve*(server: AsyncHttpServer; port: Port;: /pure/asynchttpserver.
                                                             (line   35)
* proc serveFile*(client: Socket; filename: string): /pure/httpserver.
                                                             (line    6)
* proc server_end*() {.cdecl, dynlib: lib, importc: "mysql_server_end".}: /wrappers/mysql.
                                                             (line  294)
* proc server_init*(argc: cint; argv: cstringArray; groups: cstringArray): cint {.cdecl,: /wrappers/mysql.
                                                             (line  290)
* proc setAtt*(handleName: cstring; ih: PIhandle; name: cstring): PIhandle {.: /wrappers/iup.
                                                             (line  278)
* proc setAttribute*(el: PElement; name: string; value: string): /pure/xmldom.
                                                             (line  390)
* proc setAttribute*(ih: PIhandle; name, value: cstring) {.importc: "IupSetAttribute",: /wrappers/iup.
                                                             (line  231)
* proc setAttribute*(n: Node; name, value: cstring): /js/dom.
                                                             (line  157)
* proc setAttribute*(s: Style; attr, value: cstring; caseSensitive = false): /js/dom.
                                                             (line  277)
* proc setAttributeHandle*(ih: PIhandle; name: cstring; ihNamed: PIhandle) {.: /wrappers/iup.
                                                             (line  353)
* proc setAttributeNode*(el: PElement; newAttr: PAttr): PAttr: /pure/xmldom.
                                                             (line  375)
* proc setAttributeNode*(n: Node; attr: Node): /js/dom.      (line  160)
* proc setAttributeNodeNS*(el: PElement; newAttr: PAttr): PAttr: /pure/xmldom.
                                                             (line  382)
* proc setAttributeNS*(el: PElement; namespaceURI, localName, value: string): /pure/xmldom.
                                                             (line  399)
* proc setAttributes*(ih: PIhandle; str: cstring): PIhandle {.: /wrappers/iup.
                                                             (line  240)
* proc setBackgroundColor*(f: File; bg: BackgroundColor; bright = false): /pure/terminal.
                                                             (line  114)
* proc setBiggestFloat*(x: Any; y: BiggestFloat): /core/typeinfo.
                                                             (line  255)
* proc setBiggestInt*(x: Any; y: BiggestInt): /core/typeinfo.
                                                             (line  154)
* proc setBiggestUint*(x: Any; y: uint64): /core/typeinfo.   (line  191)
* proc setBlocking*(s: Socket; blocking: bool) {.tags: [], gcsafe.}: /deprecated/pure/sockets.
                                                             (line  168)
* proc setBlocking*(s: SocketHandle; blocking: bool): /pure/nativesockets.
                                                             (line  183)
* proc setCallback*(ih: PIhandle; name: cstring; fn: Icallback): Icallback {.: /wrappers/iup.
                                                             (line  312)
* proc setCallbacks*(ih: PIhandle; name: cstring; fn: Icallback): PIhandle {.: /wrappers/iup.
                                                             (line  317)
* proc setcchar*(a2: ptr cunsignedlong; a3: cstring; a4: cunsignedlong; a5: cshort;: /wrappers/pdcurses.
                                                             (line 1324)
* proc setClassDefaultAttribute*(classname, name, value: cstring) {.: /wrappers/iup.
                                                             (line  380)
* proc setclipboard*(a2: cstring; a3: clong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1680)
* proc setCommand*(cmd: string; project = ""): /system/nimscript.
                                                             (line   66)
* proc setCompletionCallback*(a2: ptr CompletionCallback) {.: /wrappers/linenoise/linenoise.
                                                             (line   12)
* proc setcontext*(a1: var Ucontext): cint {.importc, header: "<ucontext.h>".}: /posix/posix.
                                                             (line 1547)
* proc setControlCHook*(hook: proc () {.noconv.} not nil): /system.
                                                             (line 2331)
* proc setCookie*(key, value: string; domain = ""; path = ""; expires = ""; noName = false;: /pure/cookies.
                                                             (line   11)
* proc setCookie*(key, value: string; expires: TimeInfo; domain = ""; path = "";: /pure/cookies.
                                                             (line   18)
* proc setCookie*(name, value: string):  /pure/cgi.          (line  255)
* proc setCurrentDir*(newDir: string) {.inline, tags: [].}: /pure/os.
                                                             (line  190)
* proc setCurrentDirectoryW*(lpPathName: WideCString): int32 {.: /windows/winlean.
                                                             (line  231)
* proc setCurrentException*(exc: ref Exception) {.inline, benign.}: /system.
                                                             (line 2374)
* proc setCursorPos*(f: File; x, y: int): /pure/terminal.    (line   45)
* proc setCursorXPos*(f: File; x: int):  /pure/terminal.     (line   51)
* proc setCursorYPos*(f: File; y: int):  /pure/terminal.     (line   57)
* proc setegid*(a1: Gid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  961)
* proc setElements*(t: var Matrix2d; ax, ay, bx, by, tx, ty: float) {.inline.}: /pure/basic2d.
                                                             (line   44)
* proc setElements*(t: var Matrix3d; ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float) {.: /pure/basic3d.
                                                             (line   53)
* proc setEncoding*(connection: DbConn; encoding: string): bool {.: /impure/db_odbc.
                                                             (line  106)
* proc setEncoding*(connection: DbConn; encoding: string): bool {.tags: [DbEffect].}: /impure/db_postgres.
                                                             (line  159)
* proc setEncoding*(connection: DbConn; encoding: string): bool {.tags: [DbEffect].} <1>: /impure/db_mysql.
                                                             (line  104)
* proc setEncoding*(connection: DbConn; encoding: string): bool {.tags: [DbEffect].} <2>: /impure/db_sqlite.
                                                             (line  102)
* proc setEndOfFile*(hFile: Handle): WINBOOL {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  510)
* proc setEnvironmentVariableW*(lpName, lpValue: WideCString): int32 {.stdcall,: /windows/winlean.
                                                             (line  246)
* proc setErrorFunc*(s: PccState; errorOpaque: pointer; errorFun: ErrorFunc) {.cdecl,: /wrappers/tinyc.
                                                             (line   35)
* proc seteuid*(a1: Uid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  964)
* proc setfAttribute*(ih: PIhandle; name, format: cstring) {.: /wrappers/iup.
                                                             (line  268)
* proc setFileAttributesW*(lpFileName: WideCString; dwFileAttributes: int32): WINBOOL {.: /windows/winlean.
                                                             (line  293)
* proc setFilePermissions*(filename: string; permissions: set[FilePermission]) {.rtl,: /pure/os.
                                                             (line  228)
* proc setFilePointer*(hFile: Handle; lDistanceToMove: LONG;: /windows/winlean.
                                                             (line  514)
* proc setFilePos*(f: AsyncFile; pos: int64): /pure/asyncfile.
                                                             (line   43)
* proc setFilePos*(f: File; pos: int64) {.benign.}: /system. (line 2280)
* proc setFocus*(ih: PIhandle): PIhandle {.importc: "IupSetFocus", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  294)
* proc setForegroundColor*(f: File; fg: ForegroundColor; bright = false): /pure/terminal.
                                                             (line  109)
* proc setFrame*(s: PFrame) {.compilerRtl, inl.}: /system/excpt.
                                                             (line   18)
* proc setFunction*(name: cstring; fn: Icallback): Icallback {.: /wrappers/iup.
                                                             (line  326)
* proc setgid*(a1: Gid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  967)
* proc setGlobal*(name, value: cstring) {.importc: "IupSetGlobal", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  283)
* proc setgrent*() {.importc, header: "<grp.h>".}: /posix/posix.
                                                             (line  299)
* proc setHandle*(name: cstring; ih: PIhandle): PIhandle {.importc: "IupSetHandle", cdecl,: /wrappers/iup.
                                                             (line  338)
* proc setHandleWrite*(s: AsyncSocket;:  /deprecated/pure/asyncio.
                                                             (line  154)
* proc sethostent*(a1: cint) {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1785)
* proc setIndexTerm*(d: var RstGenerator; id, term: string; linkTitle, linkDesc = ""): /packages/docutils/rstgen.
                                                             (line   98)
* proc setInterval*(w: Window; code: cstring; pause: int): ref TInterval: /js/dom.
                                                             (line  103)
* proc setLanguage*(lng: cstring) {.importc: "IupSetLanguage", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  154)
* proc setLen*(s: var string; newlen: Natural) {.magic: "SetLengthStr", noSideEffect.}: /system.
                                                             (line 1256)
* proc setLen*[T](s: var seq[T]; newlen: Natural) {.magic: "SetLengthSeq", noSideEffect.}: /system.
                                                             (line 1248)
* proc setLibPath*(s: PccState; path: cstring) {.cdecl, importc: "tcc_set_lib_path".}: /wrappers/tinyc.
                                                             (line  132)
* proc setlocale*(a1: cint; a2: cstring): cstring {.importc, header: "<locale.h>".}: /posix/posix.
                                                             (line  324)
* proc setLogFilter*(lvl: Level):        /pure/logging.      (line   93)
* proc setMaxPoolSize*(size: range[1 .. MaxThreadPoolSize]): /pure/concurrency/threadpool.
                                                             (line   72)
* proc setMinPoolSize*(size: range[1 .. MaxThreadPoolSize]): /pure/concurrency/threadpool.
                                                             (line   67)
* proc setMultiLine*(ml: cint) {.importc: "linenoiseSetMultiLine".}: /wrappers/linenoise/linenoise.
                                                             (line   38)
* proc setNamedItem*(nList: var seq[PAttr]; arg: PAttr): PAttr: /pure/xmldom.
                                                             (line  272)
* proc setNamedItem*(nList: var seq[PNode]; arg: PNode): PNode: /pure/xmldom.
                                                             (line  266)
* proc setNamedItemNS*(nList: var seq[PAttr]; arg: PAttr): PAttr: /pure/xmldom.
                                                             (line  283)
* proc setNamedItemNS*(nList: var seq[PNode]; arg: PNode): PNode: /pure/xmldom.
                                                             (line  278)
* proc setnetent*(a1: cint) {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1788)
* proc setObjectRuntimeType*(x: Any):    /core/typeinfo.     (line   58)
* proc setOutputType*(s: PCCState; outputType: cint): cint {.cdecl,: /wrappers/tinyc.
                                                             (line   83)
* proc setpgid*(a1, a2: Pid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  970)
* proc setpgrp*(): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  973)
* proc setPointer*(x: Any; y: pointer):  /core/typeinfo.     (line   96)
* proc setPosition*(s, unused: Stream; pos: int) {.deprecated.}: /pure/streams.
                                                             (line   84)
* proc setPosition*(s: Stream; pos: int): /pure/streams.     (line   79)
* proc setprotoent*(a1: cint) {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1791)
* proc setpwent*() {.importc, header: "<pwd.h>".}: /posix/posix.
                                                             (line  384)
* proc setregid*(a1, a2: Gid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  976)
* proc setreuid*(a1, a2: Uid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  979)
* proc setSamplingFrequency*(intervalInUs: int): /pure/nimprof.
                                                             (line    6)
* proc setscrreg*(a2: cint; a3: cint): cint {.extdecl, importc: "setscrreg",: /wrappers/pdcurses.
                                                             (line  722)
* proc setservent*(a1: cint) {.importc, header: "<netdb.h>".}: /posix/posix.
                                                             (line 1794)
* proc setsid*(): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  982)
* proc setsockopt*(a1: SocketHandle; a2, a3: cint; a4: pointer; a5: Socklen): cint {.importc,: /posix/posix.
                                                             (line 1627)
* proc setsockopt*(s: SocketHandle; level, optname: cint; optval: pointer; optlen: SockLen): cint {.: /windows/winlean.
                                                             (line  402)
* proc setSockOpt*(socket: AsyncSocket; opt: SOBool; value: bool; level = SOL_SOCKET) {.: /pure/asyncnet.
                                                             (line  181)
* proc setSockOpt*(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {.: /pure/net.
                                                             (line  244)
* proc setSockOpt*(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {. <1>: /deprecated/pure/sockets.
                                                             (line  267)
* proc setSockOptInt*(socket: Socket; level, optname, optval: int) {.: /deprecated/pure/sockets.
                                                             (line  255)
* proc setSockOptInt*(socket: SocketHandle; level, optname, optval: int) {.: /pure/nativesockets.
                                                             (line  177)
* proc setStackTraceNewLine*() {.deprecated.}: /pure/cgi.    (line  249)
* proc setStackTraceStdout*():           /pure/cgi.          (line  244)
* proc setStdHandle*(nStdHandle: int32; hHandle: Handle): WINBOOL {.stdcall,: /windows/winlean.
                                                             (line  204)
* proc setString*(x: Any; y: string):    /core/typeinfo.     (line  265)
* proc setStyle*(f: File; style: set[Style]): /pure/terminal.
                                                             (line   99)
* proc setsyx*(a2: cint; a3: cint): cint {.extdecl, importc: "setsyx", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1497)
* proc setTestData*(keysvalues: varargs[string]): /pure/cgi. (line  223)
* proc setTimeout*(w: Window; code: cstring; pause: int): ref TTimeOut: /js/dom.
                                                             (line  106)
* proc setuid*(a1: Uid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  985)
* proc setupForeignThreadGc*():          /system/gc_common.  (line   15)
* proc setWarning*(s: PccState; warningName: cstring; value: int) {.cdecl,: /wrappers/tinyc.
                                                             (line   41)
* proc set_authorizer*(para1: PSqlite3; xAuth: proc (para1: pointer; para2: int32;: /wrappers/sqlite3.
                                                             (line   84)
* proc set_auxdata*(para1: Pcontext; para2: int32; para3: pointer;: /wrappers/sqlite3.
                                                             (line  361)
* proc set_blink*(a2: cunsignedchar): cint {.extdecl, importc: "PDC_set_blink",: /wrappers/pdcurses.
                                                             (line 1657)
* proc set_character_set*(MySQL: PMySQL; csname: cstring): int32 {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  375)
* proc set_line_color*(a2: cshort): cint {.extdecl, importc: "PDC_set_line_color",: /wrappers/pdcurses.
                                                             (line 1661)
* proc set_local_infile_default*(MySQL: PMySQL) {.cdecl, dynlib: lib,: /wrappers/mysql.
                                                             (line  444)
* proc set_master*(MySQL: PMySQL; host: cstring; port: cuint; user: cstring;: /wrappers/mysql.
                                                             (line  484)
* proc set_panel_userptr*(pan: ptr PANEL; uptr: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1748)
* proc set_print_string_function*(print_func: proc (arg: cstring) {.cdecl.}) {.cdecl,: /wrappers/libsvm.
                                                             (line  132)
* proc set_server_option*(MySQL: PMySQL; option: Enum_mysql_set_option): cint {.stdcall,: /wrappers/mysql.
                                                             (line  509)
* proc set_term*(a2: ptr SCREEN): ptr SCREEN {.extdecl, importc: "set_term",: /wrappers/pdcurses.
                                                             (line  718)
* proc set_title*(a2: cstring) {.extdecl, importc: "PDC_set_title", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1665)
* proc sgnArea*(a, b, c: Point2d): float: /pure/basic2d.     (line  485)
* proc shallow*(s: var string) {.noSideEffect, inline.}: /system.
                                                             (line 2615)
* proc shallow*[T](s: var seq[T]) {.noSideEffect, inline.}: /system.
                                                             (line 2608)
* proc shallowCopy*[T](x: var T; y: T) {.noSideEffect, magic: "ShallowCopy".}: /system.
                                                             (line 1380)
* proc shellExecuteW*(HWND: Handle;:     /windows/winlean.   (line  333)
* proc shm_open*(a1: cstring; a2: cint; a3: Mode): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1197)
* proc shm_unlink*(a1: cstring): cint {.importc, header: "<sys/mman.h>".}: /posix/posix.
                                                             (line 1200)
* proc show*(ih: PIhandle): cint {.importc: "IupShow", cdecl, dynlib: dllname, discardable.}: /wrappers/iup.
                                                             (line  215)
* proc showXY*(ih: PIhandle; x, y: cint): cint {.importc: "IupShowXY", cdecl,: /wrappers/iup.
                                                             (line  218)
* proc show_panel*(pan: ptr PANEL): cint {.extdecl, importc: "show_panel",: /wrappers/pdcurses.
                                                             (line 1753)
* proc shutdown*(a1: SocketHandle; a2: cint): cint {.importc, header: "<sys/socket.h>".}: /posix/posix.
                                                             (line 1631)
* proc shutdown*(MySQL: PMySQL; shutdown_level: Enum_shutdown_level): cint {.stdcall,: /wrappers/mysql.
                                                             (line  494)
* proc shutdown*(req: PShutdown; handle: PStream; cb: ShutdownProc): cint {.: /wrappers/libuv.
                                                             (line   45)
* proc shutdown*(s: SocketHandle; how: cint): cint {.stdcall, importc: "shutdown",: /windows/winlean.
                                                             (line  433)
* proc sigaction*(a1: cint; a2, a3: var Sigaction): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1320)
* proc sigaddset*(a1: var Sigset; a2: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1323)
* proc sigaltstack*(a1, a2: var Stack): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1326)
* proc sigdelset*(a1: var Sigset; a2: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1329)
* proc sigemptyset*(a1: var Sigset): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1332)
* proc sigfillset*(a1: var Sigset): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1335)
* proc sighold*(a1: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1338)
* proc sigignore*(a1: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1341)
* proc siginterrupt*(a1, a2: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1344)
* proc sigismember*(a1: var Sigset; a2: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1347)
* proc signal*(a1: cint; a2: proc (x: cint) {.noconv.}) {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1350)
* proc signal*(cond: var Cond) {.inline.}: /core/locks.      (line   54)
* proc sigpause*(a1: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1353)
* proc sigpending*(a1: var Sigset): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1356)
* proc sigprocmask*(a1: cint; a2, a3: var Sigset): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1359)
* proc sigqueue*(a1: Pid; a2: cint; a3: SigVal): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1362)
* proc sigrelse*(a1: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1365)
* proc sigset*(a1: int; a2: proc (x: cint) {.noconv.}) {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1368)
* proc sigsuspend*(a1: var Sigset): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1371)
* proc sigtimedwait*(a1: var Sigset; a2: var SigInfo; a3: var Timespec): cint {.importc,: /posix/posix.
                                                             (line 1374)
* proc sigwait*(a1: var Sigset; a2: var cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1378)
* proc sigwaitinfo*(a1: var Sigset; a2: var SigInfo): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1381)
* proc sin*(x: float): float {.importc: "sin", header: "<math.h>".}: /pure/math.
                                                             (line  183)
* proc sin*(z: Complex): Complex:        /pure/complex.      (line  174)
* proc sinh*(x: float): float {.importc: "sinh", header: "<math.h>".}: /pure/math.
                                                             (line  178)
* proc sinh*(z: Complex): Complex:       /pure/complex.      (line  234)
* proc size*(x: Any): int {.inline.}:    /core/typeinfo.     (line   27)
* proc sizeof*(x: typedesc): int {.magic: "SizeOf", noSideEffect.}: /system.
                                                             (line  486)
* proc sizeof*[T](x: T): int {.magic: "SizeOf", noSideEffect.}: /system.
                                                             (line  476)
* proc skew*(xskew, yskew: float): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line  113)
* proc skewness*(s: RunningStat): float: /pure/stats.        (line   74)
* proc skewness*[T](x: openArray[T]): float: /pure/stats.    (line  132)
* proc skewnessS*(s: RunningStat): float: /pure/stats.       (line   79)
* proc skewnessS*[T](x: openArray[T]): float: /pure/stats.   (line  137)
* proc skip*(s, token: string; start = 0): int {.inline.}: /pure/parseutils.
                                                             (line   80)
* proc skip*(socket: Socket) {.tags: [ReadIOEffect], deprecated.}: /deprecated/pure/sockets.
                                                             (line  536)
* proc skip*(socket: Socket; size: int; timeout = - 1): /pure/net.
                                                             (line  355)
* proc skip*(socket: Socket; size: int; timeout = - 1) <1>: /deprecated/pure/sockets.
                                                             (line  544)
* proc skipIgnoreCase*(s, token: string; start = 0): int: /pure/parseutils.
                                                             (line   86)
* proc skipRange*(x: Any): Any:          /core/typeinfo.     (line  207)
* proc skipUntil*(s: string; until: char; start = 0): int {.inline.}: /pure/parseutils.
                                                             (line   97)
* proc skipUntil*(s: string; until: set[char]; start = 0): int {.inline.}: /pure/parseutils.
                                                             (line   91)
* proc skipWhile*(s: string; toSkip: set[char]; start = 0): int {.inline.}: /pure/parseutils.
                                                             (line  103)
* proc skipWhitespace*(s: string; start = 0): int {.inline.}: /pure/parseutils.
                                                             (line   74)
* proc slave_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  431)
* proc slave_send_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall,: /wrappers/mysql.
                                                             (line  435)
* proc sleep*(a1: cint): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  988)
* proc sleep*(dwMilliseconds: int32) {.stdcall, dynlib: "kernel32", importc: "Sleep".}: /windows/winlean.
                                                             (line  330)
* proc sleep*(milsecs: int) {.rtl, extern: "nos$1", tags: [TimeEffect].}: /pure/os.
                                                             (line  536)
* proc sleepAsync*(ms: int): Future[void]: /pure/asyncdispatch.
                                                             (line  243)
* proc slk_attroff*(a2: cunsignedlong): cint {.extdecl, importc: "slk_attroff",: /wrappers/pdcurses.
                                                             (line  726)
* proc slk_attron*(a2: cunsignedlong): cint {.extdecl, importc: "slk_attron",: /wrappers/pdcurses.
                                                             (line  734)
* proc slk_attrset*(a2: cunsignedlong): cint {.extdecl, importc: "slk_attrset",: /wrappers/pdcurses.
                                                             (line  742)
* proc slk_attr_off*(a2: cunsignedlong; a3: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  730)
* proc slk_attr_on*(a2: cunsignedlong; a3: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  738)
* proc slk_attr_set*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  746)
* proc slk_clear*(): cint {.extdecl, importc: "slk_clear", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  750)
* proc slk_color*(a2: cshort): cint {.extdecl, importc: "slk_color", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  753)
* proc slk_init*(a2: cint): cint {.extdecl, importc: "slk_init", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  756)
* proc slk_label*(a2: cint): cstring {.extdecl, importc: "slk_label", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  759)
* proc slk_noutrefresh*(): cint {.extdecl, importc: "slk_noutrefresh",: /wrappers/pdcurses.
                                                             (line  762)
* proc slk_refresh*(): cint {.extdecl, importc: "slk_refresh", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  766)
* proc slk_restore*(): cint {.extdecl, importc: "slk_restore", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  769)
* proc slk_set*(a2: cint; a3: cstring; a4: cint): cint {.extdecl, importc: "slk_set",: /wrappers/pdcurses.
                                                             (line  772)
* proc slk_touch*(): cint {.extdecl, importc: "slk_touch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  776)
* proc slk_wlabel*(a2: cint): cstring {.extdecl, importc: "slk_wlabel",: /wrappers/pdcurses.
                                                             (line 1647)
* proc slk_wset*(a2: cint; a3: cstring; a4: cint): cint {.extdecl, importc: "slk_wset",: /wrappers/pdcurses.
                                                             (line 1329)
* proc slope*(r: RunningRegress): float: /pure/stats.        (line  175)
* proc slopeVector2d*(slope: float; len: float): Vector2d {.noInit.}: /pure/basic2d.
                                                             (line  183)
* proc slurp*(filename: string): string {.magic: "Slurp".}: /system.
                                                             (line 2482)
* proc smallest*[A](t: CountTableRef[A]): (A, int): /pure/collections/tables.
                                                             (line  520)
* proc smallest*[A](t: CountTable[A]): tuple[key: A, val: int]: /pure/collections/tables.
                                                             (line  440)
* proc smartBinarySearch*[T](a: openArray[T]; key: T): int: /pure/algorithm.
                                                             (line   57)
* proc snprintf*(para1: int32; para2: cstring; para3: cstring): cstring {.cdecl,: /wrappers/sqlite3.
                                                             (line   80)
* proc sockatmark*(a1: cint): cint {.importc, header: "<sys/socket.h>".}: /posix/posix.
                                                             (line 1637)
* proc socket*(a1, a2, a3: cint): SocketHandle {.importc, header: "<sys/socket.h>".}: /posix/posix.
                                                             (line 1634)
* proc socket*(af, typ, protocol: cint): SocketHandle {.stdcall, importc: "socket",: /windows/winlean.
                                                             (line  368)
* proc socket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM;: /deprecated/pure/sockets.
                                                             (line   75)
* proc socketError*(socket: Socket; err: int = - 1; async = false;: /pure/net.
                                                             (line   54)
* proc socketError*(socket: Socket; err: int = - 1; async = false; <1>: /pure/net.
                                                             (line  150)
* proc socketpair*(a1, a2, a3: cint; a4: var array[0 .. 1, cint]): cint {.importc,: /posix/posix.
                                                             (line 1640)
* proc solveQuadric*(a, b, c: float; zerotol = 0.0'f64): seq[float]: /pure/poly.
                                                             (line  143)
* proc some*[T](val: T): Option[T]:      /pure/options.      (line   12)
* proc sort*[A, B](t: OrderedTableRef[A, B]; cmp: proc (x, y: (A, B)): int): /pure/collections/tables.
                                                             (line  363)
* proc sort*[A, B](t: var OrderedTable[A, B]; cmp: proc (x, y: (A, B)): int): /pure/collections/tables.
                                                             (line  281)
* proc sort*[A](t: CountTableRef[A]):    /pure/collections/tables.
                                                             (line  530)
* proc sort*[A](t: var CountTable[A]):   /pure/collections/tables.
                                                             (line  450)
* proc sort*[T](a: var openArray[T]; cmp: proc (x, y: T): int {.closure.};: /pure/algorithm.
                                                             (line   81)
* proc sorted*[T](a: openArray[T]; cmp: proc (x, y: T): int {.closure.};: /pure/algorithm.
                                                             (line  105)
* proc spawn*(a2: PLoop; a3: PProcess; options: ProcessOptions): cint {.: /wrappers/libuv.
                                                             (line  262)
* proc spawn*(call: expr): expr {.magic: "Spawn".}: /pure/concurrency/threadpool.
                                                             (line   86)
* proc spawn*(call: stmt) {.magic: "Spawn".}: /system/sysspawn.
                                                             (line   36)
* proc spawn*[In, Out](action: proc (self: PActor[In, Out]) {.thread.}): PActor[In, Out]: /deprecated/pure/actors.
                                                             (line   26)
* proc spawn*[In, Out](p: var ActorPool[In, Out]; input: In;: /deprecated/pure/actors.
                                                             (line  108)
* proc spawn*[In](p: var ActorPool[In, void]; input: In;: /deprecated/pure/actors.
                                                             (line  115)
* proc specified*(a: PAttr): bool:       /pure/xmldom.       (line  293)
* proc spin*(): PIhandle {.importc: "IupSpin", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  533)
* proc spinbox*(child: PIhandle): PIhandle {.importc: "IupSpinbox", cdecl,: /wrappers/iup.
                                                             (line  536)
* proc split*(s: string; sep: char): seq[string] {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  251)
* proc split*(s: string; sep: Peg): seq[string] {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line  333)
* proc split*(s: string; sep: Regex): seq[string]: /impure/re.
                                                             (line  164)
* proc split*(s: string; sep: string): seq[string] {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  258)
* proc split*(s: string; seps: set[char] = Whitespace): seq[string] {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  244)
* proc split*(str: string; pattern: Regex; maxSplit = - 1; start = 0): seq[string]: /impure/nre.
                                                             (line   98)
* proc splitData*(textNode: PText; offset: int): PText: /pure/xmldom.
                                                             (line  405)
* proc splitFile*(path: string): tuple[dir, name, ext: string] {.noSideEffect, rtl,: /pure/ospaths.
                                                             (line  114)
* proc splitLines*(s: string): seq[string] {.noSideEffect, rtl, extern: "nsuSplitLines".}: /pure/strutils.
                                                             (line  220)
* proc splitPath*(path: string): tuple[head, tail: string] {.noSideEffect, rtl,: /pure/ospaths.
                                                             (line   69)
* proc SQLAllocHandle*(HandleType: TSqlSmallInt; InputHandle: SqlHandle;: /wrappers/odbcsql.
                                                             (line   39)
* proc SQLBindCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  208)
* proc SQLBindParameter*(hstmt: SqlHStmt; ipar: SqlUSmallInt; fParamType: TSqlSmallInt;: /wrappers/odbcsql.
                                                             (line  263)
* proc SQLBrowseConnect*(hdbc: SqlHDBC; szConnStrIn: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  103)
* proc SQLBulkOperations*(StatementHandle: SqlHStmt; Operation: TSqlSmallInt): TSqlSmallInt {.: /wrappers/odbcsql.
                                                             (line  199)
* proc SQLCloseCursor*(StatementHandle: SqlHStmt): TSqlSmallInt {.dynlib: odbclib,: /wrappers/odbcsql.
                                                             (line  132)
* proc SQLColAttribute*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  277)
* proc SQLColumns*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  303)
* proc SQLConnect*(ConnectionHandle: SqlHDBC; ServerName: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line   83)
* proc SQLDataSources*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  221)
* proc SQLDescribeCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  146)
* proc SQLDisconnect*(ConnectionHandle: SqlHDBC): TSqlSmallInt {.dynlib: odbclib,: /wrappers/odbcsql.
                                                             (line   91)
* proc SQLDriverConnect*(hdbc: SqlHDBC; hwnd: SqlHWND; szCsin: cstring;: /wrappers/odbcsql.
                                                             (line   95)
* proc SQLDrivers*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  231)
* proc SQLEndTran*(HandleType: TSqlSmallInt; Handle: SqlHandle;: /wrappers/odbcsql.
                                                             (line  287)
* proc SQLErr*(henv: SqlHEnv; hdbc: SqlHDBC; hstmt: SqlHStmt;: /wrappers/odbcsql.
                                                             (line  364)
* proc SQLExecDirect*(StatementHandle: SqlHStmt; StatementText: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  112)
* proc SQLExecDirectW*(StatementHandle: SqlHStmt; StatementText: WideCString;: /wrappers/odbcsql.
                                                             (line  117)
* proc SQLExecute*(StatementHandle: SqlHStmt): TSqlSmallInt {.dynlib: odbclib, importc.}: /wrappers/odbcsql.
                                                             (line  136)
* proc SQLExtendedFetch*(hstmt: SqlHStmt; fFetchType: SqlUSmallInt; irow: TSqlInteger;: /wrappers/odbcsql.
                                                             (line  164)
* proc SQLFetch*(StatementHandle: SqlHStmt): TSqlSmallInt {.dynlib: odbclib, importc.}: /wrappers/odbcsql.
                                                             (line  139)
* proc SQLFetchScroll*(StatementHandle: SqlHStmt; FetchOrientation: TSqlSmallInt;: /wrappers/odbcsql.
                                                             (line  158)
* proc SQLFreeHandle*(HandleType: TSqlSmallInt; Handle: SqlHandle): TSqlSmallInt {.: /wrappers/odbcsql.
                                                             (line   59)
* proc SQLFreeStmt*(StatementHandle: SqlHStmt; Option: SqlUSmallInt): TSqlSmallInt {.: /wrappers/odbcsql.
                                                             (line  273)
* proc SQLGetCursorName*(StatementHandle: SqlHStmt; CursorName: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  247)
* proc SQLGetData*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  170)
* proc SQLGetDiagField*(HandleType: TSqlSmallInt; Handle: SqlHandle;: /wrappers/odbcsql.
                                                             (line   73)
* proc SQLGetDiagRec*(HandleType: TSqlSmallInt; Handle: SqlHandle;: /wrappers/odbcsql.
                                                             (line   63)
* proc SQLGetEnvAttr*(EnvironmentHandle: SqlHEnv; Attribute: TSqlInteger;: /wrappers/odbcsql.
                                                             (line   51)
* proc SQLGetInfo*(ConnectionHandle: SqlHDBC; InfoType: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  192)
* proc SQLGetStmtAttr*(StatementHandle: SqlHStmt; Attribute: TSqlInteger;: /wrappers/odbcsql.
                                                             (line  184)
* proc SQLNumResultCols*(StatementHandle: SqlHStmt; ColumnCount: var TSqlSmallInt): TSqlSmallInt {.: /wrappers/odbcsql.
                                                             (line  142)
* proc SQLPrepare*(StatementHandle: SqlHStmt; StatementText: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  122)
* proc SQLPrepareW*(StatementHandle: SqlHStmt; StatementText: WideCString;: /wrappers/odbcsql.
                                                             (line  127)
* proc SQLPrimaryKeys*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  334)
* proc SQLProcedureColumns*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  343)
* proc SQLProcedures*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  324)
* proc SQLPutData*(StatementHandle: SqlHStmt; Data: SqlPointer;: /wrappers/odbcsql.
                                                             (line  203)
* proc SQLRowCount*(StatementHandle: SqlHStmt; RowCount: var TSqlInteger): TSqlSmallInt {.: /wrappers/odbcsql.
                                                             (line  259)
* proc SQLSetConnectAttr*(ConnectionHandle: SqlHDBC; Attribute: TSqlInteger;: /wrappers/odbcsql.
                                                             (line  241)
* proc SQLSetCursorName*(StatementHandle: SqlHStmt; CursorName: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  253)
* proc SQLSetEnvAttr*(EnvironmentHandle: SqlHEnv; Attribute: TSqlInteger;: /wrappers/odbcsql.
                                                             (line   45)
* proc SQLSetPos*(hstmt: SqlHStmt; irow: SqlUSmallInt; fOption: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  216)
* proc SQLSetStmtAttr*(StatementHandle: SqlHStmt; Attribute: TSqlInteger;: /wrappers/odbcsql.
                                                             (line  178)
* proc SQLSpecialColumns*(StatementHandle: SqlHStmt; IdentifierType: SqlUSmallInt;: /wrappers/odbcsql.
                                                             (line  313)
* proc sqlstate*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  357)
* proc SQLStatistics*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  354)
* proc SQLTables*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;: /wrappers/odbcsql.
                                                             (line  293)
* proc sqrDist*(a, b: Point2d): float:   /pure/basic2d.      (line  368)
* proc sqrDist*(a, b: Point3d): float:   /pure/basic3d.      (line  357)
* proc sqrLen*(v: Vector2d): float {.inline.}: /pure/basic2d.
                                                             (line  199)
* proc sqrLen*(v: Vector3d): float {.inline.}: /pure/basic3d.
                                                             (line  220)
* proc sqrt*(x: float): float {.importc: "sqrt", header: "<math.h>".}: /pure/math.
                                                             (line   97)
* proc sqrt*(z: Complex): Complex:       /pure/complex.      (line  144)
* proc SSLCTXSetMode*(ctx: SslCtx; mode: int): int: /wrappers/openssl.
                                                             (line  192)
* proc sslDoHandshake*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  281)
* proc sslPeek*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  269)
* proc sslRead*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  265)
* proc sslSetAcceptState*(s: SslPtr) {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  261)
* proc sslSetBio*(ssl: SslPtr; rbio, wbio: BIO) {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  277)
* proc sslSetConnectState*(s: SslPtr) {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  257)
* proc SSLv23_client_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   39)
* proc SSLv23_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   42)
* proc SSLv2_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   45)
* proc SSLv3_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   48)
* proc sslWrite*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  273)
* proc SSL_accept*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  128)
* proc SSL_connect*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  114)
* proc SSL_ctrl*(ssl: SslPtr; cmd: cInt; larg: int; parg: pointer): int {.cdecl,: /wrappers/openssl.
                                                             (line  195)
* proc SSL_CTX_check_private_key*(ctx: SslCtx): cInt {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   96)
* proc SSL_CTX_ctrl*(ctx: SslCtx; cmd: cInt; larg: int; parg: pointer): int {.cdecl,: /wrappers/openssl.
                                                             (line  188)
* proc SSL_CTX_free*(arg0: SslCtx) {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   67)
* proc SSL_CTX_load_verify_locations*(ctx: SslCtx; CAfile: cstring; CApath: cstring): cInt {.: /wrappers/openssl.
                                                             (line   63)
* proc SSL_CTX_new*(meth: PSSL_METHOD): SslCtx {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   60)
* proc SSL_CTX_set_cipher_list*(s: SslCtx; ciphers: cstring): cint {.cdecl,: /wrappers/openssl.
                                                             (line   79)
* proc SSL_CTX_set_tlsext_servername_arg*(ctx: SslCtx; arg: pointer): int: /wrappers/openssl.
                                                             (line  230)
* proc SSL_CTX_set_tlsext_servername_callback*(ctx: SslCtx;: /wrappers/openssl.
                                                             (line  215)
* proc SSL_CTX_set_verify*(s: SslCtx; mode: int;: /wrappers/openssl.
                                                             (line   70)
* proc SSL_CTX_use_certificate_chain_file*(ctx: SslCtx; filename: cstring): cInt {.: /wrappers/openssl.
                                                             (line   87)
* proc SSL_CTX_use_certificate_file*(ctx: SslCtx; filename: cstring; typ: cInt): cInt {.: /wrappers/openssl.
                                                             (line   83)
* proc SSL_CTX_use_PrivateKey_file*(ctx: SslCtx; filename: cstring; typ: cInt): cInt {.: /wrappers/openssl.
                                                             (line   92)
* proc SSL_free*(ssl: SslPtr) {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   57)
* proc SSL_get_error*(s: SslPtr; ret_code: cInt): cInt {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  125)
* proc SSL_get_servername*(ssl: SslPtr; typ: cInt = TLSEXT_NAMETYPE_host_name): cstring {.: /wrappers/openssl.
                                                             (line  206)
* proc SSL_get_shutdown*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  110)
* proc SSL_get_verify_result*(ssl: SslPtr): int {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   76)
* proc SSL_library_init*(): cInt {.cdecl, dynlib: DLLSSLName, importc, discardable.}: /wrappers/openssl.
                                                             (line   30)
* proc SSL_load_error_strings*() {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   33)
* proc SSL_new*(context: SslCtx): SslPtr {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   54)
* proc SSL_pending*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  131)
* proc SSL_read*(ssl: SslPtr; buf: pointer; num: int): cint {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  117)
* proc ssl_set*(MySQL: PMySQL; key: cstring; cert: cstring; ca: cstring; capath: cstring;: /wrappers/mysql.
                                                             (line  382)
* proc SSL_set_fd*(ssl: SslPtr; fd: SocketHandle): cint {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line   99)
* proc SSL_set_shutdown*(ssl: SslPtr; mode: cint) {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  106)
* proc SSL_set_tlsext_host_name*(ssl: SslPtr; name: cstring): int: /wrappers/openssl.
                                                             (line  199)
* proc SSL_shutdown*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line  103)
* proc SSL_write*(ssl: SslPtr; buf: cstring; num: int): cint {.cdecl, dynlib: DLLSSLName,: /wrappers/openssl.
                                                             (line  121)
* proc stackTraceAvailable*(): bool:     /system/excpt.      (line   21)
* proc standardDeviation*(s: RunningStat): float: /pure/stats.
                                                             (line   64)
* proc standardDeviation*[T](x: openArray[T]): float: /pure/stats.
                                                             (line  122)
* proc standardDeviationS*(s: RunningStat): float: /pure/stats.
                                                             (line   69)
* proc standardDeviationS*[T](x: openArray[T]): float: /pure/stats.
                                                             (line  127)
* proc standend*(): cint {.extdecl, importc: "standend", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  779)
* proc standout*(): cint {.extdecl, importc: "standout", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  782)
* proc start*(c: proc (); stacksize: int = defaultStackSize): /pure/coro.
                                                             (line    6)
* proc startAnchor*(): Peg {.inline.}:   /pure/pegs.         (line  147)
* proc startCmd*(command: string;:       /pure/osproc.       (line   97)
* proc startProcess*(command: string; workingDir: string = "";: /pure/osproc.
                                                             (line   65)
* proc startsWith*(s, prefix: string): bool {.noSideEffect, rtl, extern: "nsuStartsWith".}: /pure/strutils.
                                                             (line  412)
* proc startsWith*(s: string; prefix: Peg; start = 0): bool {.nosideEffect, rtl,: /pure/pegs.
                                                             (line  287)
* proc startsWith*(s: string; prefix: Regex): bool: /impure/re.
                                                             (line  117)
* proc start_color*(): cint {.extdecl, importc: "start_color", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  785)
* proc stat*(a1: cstring; a2: var Stat): cint {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1095)
* proc stat*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  311)
* proc stat*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: "mysql_stat".}: /wrappers/mysql.
                                                             (line  516)
* proc staticExec*(command: string; input = ""; cache = ""): string {.magic: "StaticExec".}: /system.
                                                             (line 2500)
* proc staticRead*(filename: string): string {.magic: "Slurp".}: /system.
                                                             (line 2487)
* proc statvfs*(a1: cstring; a2: var Statvfs): cint {.importc, header: "<sys/statvfs.h>".}: /posix/posix.
                                                             (line 1068)
* proc step*(para1: Pstmt): int32 {.cdecl, dynlib: Lib, importc: "sqlite3_step".}: /wrappers/sqlite3.
                                                             (line  230)
* proc stmt_affected_rows*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  741)
* proc stmt_attr_get*(stmt: PSTMT; attr_type: Enum_stmt_attr_type; attr: pointer): my_bool {.: /wrappers/mysql.
                                                             (line  675)
* proc stmt_attr_set*(stmt: PSTMT; attr_type: Enum_stmt_attr_type; attr: pointer): my_bool {.: /wrappers/mysql.
                                                             (line  670)
* proc stmt_bind_param*(stmt: PSTMT; bnd: PBIND): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  680)
* proc stmt_bind_result*(stmt: PSTMT; bnd: PBIND): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  684)
* proc stmt_close*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  688)
* proc stmt_data_seek*(stmt: PSTMT; offset: my_ulonglong) {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  733)
* proc stmt_errno*(stmt: PSTMT): cuint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  713)
* proc stmt_error*(stmt: PSTMT): cstring {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  717)
* proc stmt_execute*(stmt: PSTMT): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  650)
* proc stmt_fetch*(stmt: PSTMT): cint {.stdcall, dynlib: lib, importc: "mysql_stmt_fetch".}: /wrappers/mysql.
                                                             (line  654)
* proc stmt_fetch_column*(stmt: PSTMT; `bind`: PBIND; column: cuint; offset: int): cint {.: /wrappers/mysql.
                                                             (line  657)
* proc stmt_field_count*(stmt: PSTMT): cuint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  749)
* proc stmt_free_result*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  696)
* proc stmt_init*(MySQL: PMySQL): PSTMT {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  642)
* proc stmt_insert_id*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  745)
* proc stmt_num_rows*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  737)
* proc stmt_param_count*(stmt: PSTMT): int {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  666)
* proc stmt_param_metadata*(stmt: PSTMT): PRES {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  709)
* proc stmt_prepare*(stmt: PSTMT; query: cstring; len: int): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  646)
* proc stmt_reset*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  692)
* proc stmt_result_metadata*(stmt: PSTMT): PRES {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  705)
* proc stmt_row_seek*(stmt: PSTMT; offset: ROW_OFFSET): ROW_OFFSET {.stdcall,: /wrappers/mysql.
                                                             (line  725)
* proc stmt_row_tell*(stmt: PSTMT): ROW_OFFSET {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  729)
* proc stmt_send_long_data*(stmt: PSTMT; param_number: cuint; data: cstring; len: int): my_bool {.: /wrappers/mysql.
                                                             (line  700)
* proc stmt_sqlstate*(stmt: PSTMT): cstring {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  721)
* proc stmt_store_result*(stmt: PSTMT): cint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  662)
* proc stop*(e: EmbedElement):           /js/dom.            (line  238)
* proc stop*(w: Window):                 /js/dom.            (line  109)
* proc store*(ftp: AsyncFtpClient; file, dest: string;: /pure/asyncftpclient.
                                                             (line   96)
* proc store*[T](ftp: FtpBase[T]; file, dest: string; async = false): /deprecated/pure/ftpclient.
                                                             (line  109)
* proc store*[T](s: Stream; data: T):    /pure/marshal.      (line   11)
* proc storeAttribute*(ih: PIhandle; name, value: cstring) {.: /wrappers/iup.
                                                             (line  235)
* proc storeGlobal*(name, value: cstring) {.importc: "IupStoreGlobal", cdecl,: /wrappers/iup.
                                                             (line  286)
* proc store_result*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  415)
* proc str*(my: JsonParser): string {.inline.}: /pure/json.  (line   39)
* proc strerror*(err: Err): cstring {.importc: "uv_strerror", header: "uv.h".}: /wrappers/libuv.
                                                             (line   39)
* proc strerror*(errnum: cint): cstring {.importc, header: "<string.h>".}: /posix/posix.
                                                             (line 1420)
* proc stretch*(p: var Point2d; facx, facy: float) {.inline.}: /pure/basic2d.
                                                             (line  463)
* proc stretch*(p: var Point2d; facx, facy: float; org: Point2d) {.inline.}: /pure/basic2d.
                                                             (line  469)
* proc stretch*(p: var Point3d; facx, facy, facz: float) {.inline.}: /pure/basic3d.
                                                             (line  443)
* proc stretch*(p: var Point3d; facx, facy, facz: float; org: Point3d) {.inline.}: /pure/basic3d.
                                                             (line  449)
* proc stretch*(sx, sy, sz: float): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line   77)
* proc stretch*(sx, sy, sz: float; org: Point3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line   83)
* proc stretch*(sx, sy: float): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   67)
* proc stretch*(sx, sy: float; org: Point2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   73)
* proc stretch*(v: var Vector2d; facx, facy: float) {.inline.}: /pure/basic2d.
                                                             (line  294)
* proc stretch*(v: var Vector3d; sx, sy, sz: float): /pure/basic3d.
                                                             (line  291)
* proc strfmon*(a1: cstring; a2: int; a3: cstring): int {.varargs, importc,: /posix/posix.
                                                             (line  327)
* proc strftime*(a1: cstring; a2: int; a3: cstring; a4: var Tm): int {.importc,: /posix/posix.
                                                             (line 1261)
* proc strip*(s: string; leading = true; trailing = true; chars: set[char] = Whitespace): string {.: /pure/strutils.
                                                             (line  203)
* proc strptime*(a1, a2: cstring; a3: var Tm): cstring {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1265)
* proc strVal*(n: NimNode): string {.magic: "NStrVal", noSideEffect.}: /core/macros.
                                                             (line  152)
* proc study*(code: ptr Pcre; options: cint; errptr: ptr cstring): ptr ExtraData: /wrappers/pcre.
                                                             (line  187)
* proc study*(code: ptr Pcre; options: cint; errptr: var cstring): ptr ExtraData {.deprecated.}: /wrappers/pcre.
                                                             (line  211)
* proc subex*(s: string): Subex:         /pure/subexes.      (line   19)
* proc submenu*(title: cstring; child: PIhandle): PIhandle {.importc: "IupSubmenu", cdecl,: /wrappers/iup.
                                                             (line  465)
* proc submit*(f: FormElement):          /js/dom.            (line  232)
* proc subpad*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr WINDOW {.extdecl,: /wrappers/pdcurses.
                                                             (line  788)
* proc substituteLog*(frmt: string; level: Level; args: varargs[string, `$`]): string: /pure/logging.
                                                             (line   45)
* proc substr*(s: string; first = 0): string {.magic: "CopyStr", importc: "copyStr",: /system.
                                                             (line 1480)
* proc substr*(s: string; first, last: int): string {.magic: "CopyStrLast",: /system.
                                                             (line 1484)
* proc subwin*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr WINDOW {.extdecl,: /wrappers/pdcurses.
                                                             (line  792)
* proc succ*[T](x: Ordinal[T]; y = 1): T {.magic: "Succ", noSideEffect.}: /system.
                                                             (line  497)
* proc sum*[T](x: openArray[T]): T {.noSideEffect.}: /pure/math.
                                                             (line   59)
* proc suspend*(p: Process) {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  111)
* proc suspend*(sleepTime: float = 0):   /pure/coro.         (line   11)
* proc suspendThread*(hThread: Handle): int32 {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  178)
* proc swab*(a1, a2: pointer; a3: int) {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  991)
* proc swap*[T](a, b: var T) {.magic: "Swap", noSideEffect.}: /system.
                                                             (line 1669)
* proc swapcontext*(a1, a2: var Ucontext): cint {.importc, header: "<ucontext.h>".}: /posix/posix.
                                                             (line 1550)
* proc swapEndian16*(outp, inp: pointer): /pure/endians.     (line   18)
* proc swapEndian32*(outp, inp: pointer): /pure/endians.     (line   12)
* proc swapEndian64*(outp, inp: pointer): /pure/endians.     (line    6)
* proc switch*(key: string; val = ""):   /system/nimscript.  (line   54)
* proc symAddr*(lib: LibHandle; name: cstring): pointer: /pure/dynlib.
                                                             (line   36)
* proc symbol*(n: NimNode): NimSym {.magic: "NSymbol", noSideEffect.}: /core/macros.
                                                             (line  121)
* proc symlink*(a1, a2: cstring): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  994)
* proc symlink*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; flags: cint;: /wrappers/libuv.
                                                             (line  361)
* proc symlinkExists*(link: string): bool {.rtl, extern: "nos$1", tags: [ReadDirEffect].}: /pure/os.
                                                             (line  144)
* proc symmetricDifference*[A](s1, s2: HashSet[A]): HashSet[A]: /pure/collections/sets.
                                                             (line  265)
* proc sync*():                          /pure/concurrency/threadpool.
                                                             (line  109)
* proc sync*() <1>:                      /system/sysspawn.   (line   43)
* proc sync*() {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line  997)
* proc sync*[In, Out](a: var ActorPool[In, Out]; polling = 50): /deprecated/pure/actors.
                                                             (line   88)
* proc syncok*(a2: ptr WINDOW; a3: cunsignedchar): cint {.extdecl, importc: "syncok",: /wrappers/pdcurses.
                                                             (line  796)
* proc sysconf*(a1: cint): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1000)
* proc S_ISBLK*(m: Mode): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1101)
* proc S_ISCHR*(m: Mode): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1106)
* proc S_ISDIR*(m: Mode): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1111)
* proc S_ISFIFO*(m: Mode): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1116)
* proc S_ISLNK*(m: Mode): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1126)
* proc S_ISREG*(m: Mode): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1121)
* proc S_ISSOCK*(m: Mode): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1131)
* proc S_TYPEISMQ*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1136)
* proc S_TYPEISSEM*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1141)
* proc S_TYPEISSHM*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1146)
* proc S_TYPEISTMO*(buf: var Stat): bool {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1151)
* proc tabs*(child: PIhandle): PIhandle {.importc: "IupTabs", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  522)
* proc tabsv*(children: ptr PIhandle): PIhandle {.importc: "IupTabsv", cdecl,: /wrappers/iup.
                                                             (line  526)
* proc tag*(n: XmlNode): string {.inline.}: /pure/xmltree.   (line   70)
* proc tagName*(el: PElement): string:   /pure/xmldom.       (line  304)
* proc tailDir*(path: string): string {.noSideEffect, rtl, extern: "nos$1".}: /pure/ospaths.
                                                             (line   94)
* proc tan*(x: float): float {.importc: "tan", header: "<math.h>".}: /pure/math.
                                                             (line  188)
* proc tan*(z: Complex): Complex:        /pure/complex.      (line  194)
* proc tanh*(x: float): float {.importc: "tanh", header: "<math.h>".}: /pure/math.
                                                             (line  193)
* proc tanh*(z: Complex): Complex:       /pure/complex.      (line  254)
* proc target*(pi: PProcessingInstruction): string: /pure/xmldom.
                                                             (line  411)
* proc tcDrain*(fd: cint): cint {.importc: "tcdrain", header: "<termios.h>".}: /posix/termios.
                                                             (line   88)
* proc tcFlow*(fd: cint; action: cint): cint {.importc: "tcflow", header: "<termios.h>".}: /posix/termios.
                                                             (line   95)
* proc tcFlush*(fd: cint; queue_selector: cint): cint {.importc: "tcflush",: /posix/termios.
                                                             (line   91)
* proc tcGetAttr*(fd: cint; termios: ptr Termios): cint {.importc: "tcgetattr",: /posix/termios.
                                                             (line   73)
* proc tcgetpgrp*(a1: cint): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1003)
* proc tcGetSid*(fd: cint): Pid {.importc: "tcgetsid", header: "<termios.h>".}: /posix/termios.
                                                             (line   98)
* proc tcp_bind*(handle: PTcp; a3: SockAddrIn): cint {.importc: "uv_tcp_bind",: /wrappers/libuv.
                                                             (line   90)
* proc tcp_bind6*(handle: PTcp; a3: TSockAddrIn6): cint {.importc: "uv_tcp_bind6",: /wrappers/libuv.
                                                             (line   94)
* proc tcp_connect*(req: PConnect; handle: PTcp; address: SockAddrIn; cb: ConnectProc): cint {.: /wrappers/libuv.
                                                             (line  106)
* proc tcp_connect6*(req: PConnect; handle: PTcp; address: TSockAddrIn6; cb: ConnectProc): cint {.: /wrappers/libuv.
                                                             (line  110)
* proc tcp_getpeername*(handle: PTcp; name: ptr SockAddr; namelen: var cint): cint {.: /wrappers/libuv.
                                                             (line  102)
* proc tcp_getsockname*(handle: PTcp; name: ptr SockAddr; namelen: var cint): cint {.: /wrappers/libuv.
                                                             (line   98)
* proc tcp_init*(a2: PLoop; handle: PTcp): cint {.importc: "uv_tcp_init", header: "uv.h".}: /wrappers/libuv.
                                                             (line   87)
* proc tcSendBreak*(fd: cint; duration: cint): cint {.importc: "tcsendbreak",: /posix/termios.
                                                             (line   84)
* proc tcSetAttr*(fd: cint; optional_actions: cint; termios: ptr Termios): cint {.: /posix/termios.
                                                             (line   77)
* proc tcsetpgrp*(a1: cint; a2: Pid): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1006)
* proc telldir*(a1: ptr DIR): int {.importc, header: "<dirent.h>".}: /posix/posix.
                                                             (line  223)
* proc term*(t: char): Peg {.nosideEffect, rtl, extern: "npegs$1Char".}: /pure/pegs.
                                                             (line   49)
* proc term*(t: string): Peg {.nosideEffect, rtl, extern: "npegs$1Str".}: /pure/pegs.
                                                             (line   34)
* proc termattrs*(): cunsignedlong {.extdecl, importc: "termattrs", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  800)
* proc termattrs2*(): cunsignedlong {.extdecl, importc: "term_attrs",: /wrappers/pdcurses.
                                                             (line  803)
* proc termIgnoreCase*(t: string): Peg {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line   39)
* proc termIgnoreStyle*(t: string): Peg {.nosideEffect, rtl, extern: "npegs$1".}: /pure/pegs.
                                                             (line   44)
* proc terminate*(p: Process) {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  121)
* proc terminate*[In, Out](a: var ActorPool[In, Out]): /deprecated/pure/actors.
                                                             (line   97)
* proc terminateProcess*(hProcess: Handle; uExitCode: int): WINBOOL {.stdcall,: /windows/winlean.
                                                             (line  191)
* proc termname*(): cstring {.extdecl, importc: "termname", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  807)
* proc text*(action: cstring): PIhandle {.importc: "IupText", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  502)
* proc text*(n: XmlNode): string {.inline.}: /pure/xmltree.  (line   39)
* proc textConvertLinColToPos*(ih: PIhandle; lin, col: cint; pos: var cint) {.: /wrappers/iup.
                                                             (line  540)
* proc textConvertPosToLinCol*(ih: PIhandle; pos: cint; lin, col: var cint) {.: /wrappers/iup.
                                                             (line  545)
* proc tgamma*(x: float): float {.importc: "tgamma", header: "<math.h>".}: /pure/math.
                                                             (line  218)
* proc thisDir*(): string:               /system/nimscript.  (line  177)
* proc threadId*[TArg](t: var Thread[TArg]): ThreadId[TArg] {.inline.}: /system/threads.
                                                             (line   46)
* proc thread_end*() {.stdcall, dynlib: lib, importc: "mysql_thread_end".}: /wrappers/mysql.
                                                             (line  311)
* proc thread_id*(MySQL: PMySQL): int {.stdcall, dynlib: lib, importc: "mysql_thread_id".}: /wrappers/mysql.
                                                             (line  368)
* proc thread_init*(): my_bool {.stdcall, dynlib: lib, importc: "mysql_thread_init".}: /wrappers/mysql.
                                                             (line  308)
* proc thread_safe*(): cuint {.stdcall, dynlib: lib, importc: "mysql_thread_safe".}: /wrappers/mysql.
                                                             (line  609)
* proc time*(a1: var Time): Time {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1268)
* proc timegm*(a1: var Tm): Time {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1255)
* proc timeInfoToTime*(timeInfo: TimeInfo): Time {.tags: [], benign.}: /pure/times.
                                                             (line   52)
* proc timeout*(a2: cint) {.extdecl, importc: "timeout", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  810)
* proc timer*(): PIhandle {.importc: "IupTimer", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  513)
* proc timer_again*(timer: PTimer): cint {.importc: "uv_timer_again", header: "uv.h".}: /wrappers/libuv.
                                                             (line  232)
* proc timer_create*(a1: var ClockId; a2: var SigEvent; a3: var Timer): cint {.importc,: /posix/posix.
                                                             (line 1271)
* proc timer_delete*(a1: var Timer): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1275)
* proc timer_getoverrun*(a1: Timer): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1281)
* proc timer_gettime*(a1: Timer; a2: var Itimerspec): cint {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1278)
* proc timer_get_repeat*(timer: PTimer): int64 {.importc: "uv_timer_get_repeat",: /wrappers/libuv.
                                                             (line  239)
* proc timer_init*(a2: PLoop; timer: PTimer): cint {.importc: "uv_timer_init",: /wrappers/libuv.
                                                             (line  221)
* proc timer_settime*(a1: Timer; a2: cint; a3: var Itimerspec; a4: var Itimerspec): cint {.: /posix/posix.
                                                             (line 1284)
* proc timer_set_repeat*(timer: PTimer; repeat: int64) {.: /wrappers/libuv.
                                                             (line  235)
* proc timer_start*(timer: PTimer; cb: TimerProc; timeout: int64; repeat: int64): cint {.: /wrappers/libuv.
                                                             (line  225)
* proc timer_stop*(timer: PTimer): cint {.importc: "uv_timer_stop", header: "uv.h".}: /wrappers/libuv.
                                                             (line  229)
* proc timeToTimeInfo*(t: Time): TimeInfo: /pure/times.      (line  445)
* proc timeToTimeInterval*(t: Time): TimeInterval: /pure/times.
                                                             (line  450)
* proc TLSv1_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}: /wrappers/openssl.
                                                             (line   51)
* proc to*[T](data: string): T:          /pure/marshal.      (line   21)
* proc toAny*(x: VarSlot): Any {.inline.}: /core/typeinfo.   (line    6)
* proc toAny*[T](x: var T): Any {.inline.}: /core/typeinfo.  (line   15)
* proc toAsyncSocket*(sock: Socket; state: SocketStatus = SockConnected): AsyncSocket: /deprecated/pure/asyncio.
                                                             (line   27)
* proc toBiggestFloat*(i: BiggestInt): BiggestFloat {.magic: "ToBiggestFloat",: /system.
                                                             (line 1430)
* proc toBiggestInt*(f: BiggestFloat): BiggestInt {.magic: "ToBiggestInt", noSideEffect,: /system.
                                                             (line 1446)
* proc toBin*(x: BiggestInt; len: Positive): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  611)
* proc toCInt*(opt: SOBool): cint:       /pure/net.          (line  219)
* proc toComplex*(x: SomeInteger): Complex: /pure/complex.   (line   14)
* proc toCountTable*[A](keys: openArray[A]): CountTable[A]: /pure/collections/tables.
                                                             (line  424)
* proc toDll*(filename: string): string: /system/nimscript.  (line  113)
* proc toExe*(filename: string): string: /system/nimscript.  (line  107)
* proc toFloat*(i: int): float {.magic: "ToFloat", noSideEffect, importc: "toFloat".}: /system.
                                                             (line 1423)
* proc toFloat*[T](x: Rational[T]): float: /pure/rationals.  (line   53)
* proc toggle*(c: ClassList; class: cstring): /js/dom.       (line  268)
* proc toggle*(title, action: cstring): PIhandle {.importc: "IupToggle", cdecl,: /wrappers/iup.
                                                             (line  509)
* proc toHex*(x: BiggestInt; len: Positive): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  267)
* proc toInt*(domain: Domain): cint:     /pure/nativesockets.
                                                             (line   42)
* proc toInt*(f: float): int {.magic: "ToInt", noSideEffect, importc: "toInt".}: /system.
                                                             (line 1438)
* proc toInt*(p: Protocol): cint:        /pure/nativesockets.
                                                             (line   52)
* proc toInt*(typ: SockType): cint:      /pure/nativesockets.
                                                             (line   47)
* proc toInt*[T](x: Rational[T]): int:   /pure/rationals.    (line   58)
* proc toLower*(c: char): char {.noSideEffect, procvar, rtl, extern: "nsuToLowerChar".}: /pure/strutils.
                                                             (line  130)
* proc toLower*(c: Rune): Rune {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   59)
* proc toLower*(s: string): string {.noSideEffect, procvar, rtl, extern: "nsuToLowerStr".}: /pure/strutils.
                                                             (line  139)
* proc toMD5*(s: string): MD5Digest:     /pure/md5.          (line   33)
* proc toOct*(x: BiggestInt; len: Positive): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  602)
* proc toOctal*(c: char): string {.noSideEffect, rtl, extern: "nsuToOctal".}: /pure/strutils.
                                                             (line  212)
* proc toOrderedSet*[A](keys: openArray[A]): OrderedSet[A]: /pure/collections/sets.
                                                             (line  476)
* proc toOrderedTable*[A, B](pairs: openArray[(A, B)]): OrderedTable[A, B]: /pure/collections/tables.
                                                             (line  271)
* proc toOSFlags*(socketFlags: set[SocketFlag]): cint: /pure/net.
                                                             (line   64)
* proc top_panel*(pan: ptr PANEL): cint {.extdecl, importc: "top_panel",: /wrappers/pdcurses.
                                                             (line 1757)
* proc toRational*(x: float; n: int = high(int)): Rational[int]: /pure/rationals.
                                                             (line   38)
* proc toRational*[T: SomeInteger](x: T): Rational[T]: /pure/rationals.
                                                             (line   33)
* proc toRunes*(s: string): seq[Rune]:   /pure/unicode.      (line  109)
* proc toSeconds*(time: Time): float {.tags: [], raises: [], benign.}: /pure/times.
                                                             (line   72)
* proc toSeq*(pattern: CaptureBounds; default = none(Slice[int])): seq[: /impure/nre.
                                                             (line   54)
* proc toSeq*(pattern: Captures; default: string = nil): seq[string]: /impure/nre.
                                                             (line   58)
* proc toSet*[A](keys: openArray[A]): HashSet[A]: /pure/collections/sets.
                                                             (line  199)
* proc toStrLit*(n: NimNode): NimNode {.compileTime.}: /core/macros.
                                                             (line  251)
* proc toTable*(pattern: CaptureBounds; default = none(Slice[int])): Table[string,: /impure/nre.
                                                             (line   50)
* proc toTable*(pattern: Captures; default: string = nil): Table[string, string]: /impure/nre.
                                                             (line   47)
* proc toTable*[A, B](pairs: openArray[(A, B)]): Table[A, B]: /pure/collections/tables.
                                                             (line  108)
* proc total_changes*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line   37)
* proc toTitle*(c: Rune): Rune {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   71)
* proc toU16*(a: int): int16 {.asmNoStackFrame, compilerproc.}: /system/jssys.
                                                             (line   24)
* proc toU16*(x: int): int16 {.magic: "ToU16", noSideEffect.}: /system.
                                                             (line  668)
* proc toU32*(a: int64): int32 {.asmNoStackFrame, compilerproc.}: /system/jssys.
                                                             (line   27)
* proc toU32*(x: int64): int32 {.magic: "ToU32", noSideEffect.}: /system.
                                                             (line  674)
* proc toU8*(a: int): int8 {.asmNoStackFrame, compilerproc.}: /system/jssys.
                                                             (line   21)
* proc toU8*(x: int): int8 {.magic: "ToU8", noSideEffect.}: /system.
                                                             (line  662)
* proc touchline*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "touchline",: /wrappers/pdcurses.
                                                             (line  813)
* proc touchwin*(a2: ptr WINDOW): cint {.extdecl, importc: "touchwin", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  817)
* proc toUgly*(result: var string; node: JsonNode): /pure/json.
                                                             (line  295)
* proc toUpper*(c: char): char {.noSideEffect, procvar, rtl, extern: "nsuToUpperChar".}: /pure/strutils.
                                                             (line  148)
* proc toUpper*(c: Rune): Rune {.rtl, extern: "nuc$1", procvar.}: /pure/unicode.
                                                             (line   65)
* proc toUpper*(s: string): string {.noSideEffect, procvar, rtl, extern: "nsuToUpperStr".}: /pure/strutils.
                                                             (line  157)
* proc toUTF8*(c: Rune): string {.rtl, extern: "nuc$1".}: /pure/unicode.
                                                             (line   44)
* proc trace*(para1: PSqlite3;:          /wrappers/sqlite3.  (line   92)
* proc traceoff*() {.extdecl, importc: "traceoff", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1469)
* proc traceon*() {.extdecl, importc: "traceon", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1472)
* proc train*(prob: ptr Problem; param: ptr Parameter): ptr Model {.cdecl,: /wrappers/libsvm.
                                                             (line   60)
* proc transformFile*(infile, outfile: string;: /impure/re.  (line  156)
* proc transformFile*(infile, outfile: string; <1>: /pure/pegs.
                                                             (line  323)
* proc transformInv*(p: var Point2d; t: Matrix2d) {.inline.}: /pure/basic2d.
                                                             (line  399)
* proc transformInv*(p: var Point3d; m: Matrix3d): /pure/basic3d.
                                                             (line  383)
* proc transformInv*(v: var Vector2d; t: Matrix2d): /pure/basic2d.
                                                             (line  249)
* proc transformInv*(v: var Vector3d; m: Matrix3d): /pure/basic3d.
                                                             (line  251)
* proc transformNorm*(v: var Vector2d; t: Matrix2d): /pure/basic2d.
                                                             (line  241)
* proc transformNorm*(v: var Vector3d; m: Matrix3d): /pure/basic3d.
                                                             (line  243)
* proc transformNormInv*(v: var Vector2d; t: Matrix2d): /pure/basic2d.
                                                             (line  258)
* proc transformNormInv*(vec: var Vector3d; m: Matrix3d): /pure/basic3d.
                                                             (line  259)
* proc transpose*(m: Matrix3d): Matrix3d {.noInit.}: /pure/basic3d.
                                                             (line  174)
* proc tree*(): PIhandle {.importc: "IupTree", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  530)
* proc treeGetAttribute*(ih: PIhandle; name: cstring; id: cint): cstring {.: /wrappers/iup.
                                                             (line  577)
* proc treeGetFloat*(ih: PIhandle; name: cstring; id: cint): cfloat {.: /wrappers/iup.
                                                             (line  586)
* proc treeGetId*(ih: PIhandle; userid: pointer): cint {.importc: "IupTreeGetId", cdecl,: /wrappers/iup.
                                                             (line  563)
* proc treeGetInt*(ih: PIhandle; name: cstring; id: cint): cint {.: /wrappers/iup.
                                                             (line  582)
* proc treeGetUserId*(ih: PIhandle; id: cint): pointer {.importc: "IupTreeGetUserId",: /wrappers/iup.
                                                             (line  559)
* proc treeRepr*(n: NimNode): string {.compileTime, benign.}: /core/macros.
                                                             (line  395)
* proc treeSetAttribute*(ih: PIhandle; name: cstring; id: cint; value: cstring) {.: /wrappers/iup.
                                                             (line  567)
* proc treeSetfAttribute*(ih: PIhandle; name: cstring; id: cint; format: cstring) {.: /wrappers/iup.
                                                             (line  590)
* proc treeSetUserId*(ih: PIhandle; id: cint; userid: pointer): cint {.: /wrappers/iup.
                                                             (line  554)
* proc treeStoreAttribute*(ih: PIhandle; name: cstring; id: cint; value: cstring) {.: /wrappers/iup.
                                                             (line  572)
* proc trunc*(x: float): float {.importc: "trunc", header: "<math.h>".}: /pure/math.
                                                             (line  223)
* proc truncate*(a1: cstring; a2: Off): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1009)
* proc tryAcquire*(lock: var Lock): bool: /core/locks.       (line   24)
* proc tryExec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.: /impure/db_postgres.
                                                             (line   24)
* proc tryExec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {. <1>: /impure/db_mysql.
                                                             (line   28)
* proc tryExec*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {. <2>: /impure/db_sqlite.
                                                             (line   24)
* proc tryExec*(db: DbConn; stmtName: SqlPrepared; args: varargs[string, `$`]): bool {.: /impure/db_postgres.
                                                             (line   31)
* proc tryExec*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): bool {.: /impure/db_odbc.
                                                             (line   24)
* proc tryInsertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_postgres.
                                                             (line  103)
* proc tryInsertId*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_mysql.
                                                             (line   72)
* proc tryInsertID*(db: DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {. <1>: /impure/db_sqlite.
                                                             (line   68)
* proc tryInsertId*(db: var DbConn; query: SqlQuery; args: varargs[string, `$`]): int64 {.: /impure/db_odbc.
                                                             (line   68)
* proc tryNormalize*(v: var Vector2d): bool: /pure/basic2d.  (line  228)
* proc tryNormalize*(v: var Vector3d): bool: /pure/basic3d.  (line   46)
* proc tryNormalize*(v: var Vector3d): bool <1>: /pure/basic3d.
                                                             (line  267)
* proc tryRecv*[TMsg](c: var Channel[TMsg]): tuple[dataAvailable: bool, msg: TMsg]: /system/channels.
                                                             (line   25)
* proc trySend*(socket: Socket; data: string): bool {.tags: [WriteIOEffect].}: /pure/net.
                                                             (line  380)
* proc trySend*(socket: Socket; data: string): bool {.tags: [WriteIOEffect].} <1>: /deprecated/pure/sockets.
                                                             (line  576)
* proc ttyname*(a1: cint): cstring {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1012)
* proc ttyname_r*(a1: cint; a2: cstring; a3: int): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1015)
* proc tty_get_winsize*(a2: pTTy; width: var cint; height: var cint): cint {.: /wrappers/libuv.
                                                             (line  155)
* proc tty_init*(a2: PLoop; a3: pTTy; fd: File): cint {.importc: "uv_tty_init",: /wrappers/libuv.
                                                             (line  147)
* proc tty_reset_mode*() {.importc: "uv_tty_reset_mode", header: "uv.h".}: /wrappers/libuv.
                                                             (line  159)
* proc tty_set_mode*(a2: pTTy; mode: cint): cint {.importc: "uv_tty_set_mode",: /wrappers/libuv.
                                                             (line  151)
* proc turnAngle*(v1, v2: Vector2d): float: /pure/basic2d.   (line  351)
* proc typeahead*(a2: cint): cint {.extdecl, importc: "typeahead", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  820)
* proc typeKind*(n: NimNode): NimTypeKind {.magic: "NGetType", noSideEffect.}: /core/macros.
                                                             (line  146)
* proc tzset*() {.importc, header: "<time.h>".}: /posix/posix.
                                                             (line 1288)
* proc ualarm*(a1, a2: Useconds): Useconds {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1018)
* proc udp_bind*(handle: PUdp; adr: SockAddrIn; flags: cunsigned): cint {.: /wrappers/libuv.
                                                             (line  117)
* proc udp_bind6*(handle: PUdp; adr: TSockAddrIn6; flags: cunsigned): cint {.: /wrappers/libuv.
                                                             (line  121)
* proc udp_getsockname*(handle: PUdp; name: ptr SockAddr; namelen: var cint): cint {.: /wrappers/libuv.
                                                             (line  125)
* proc udp_init*(a2: PLoop; handle: PUdp): cint {.importc: "uv_udp_init", header: "uv.h".}: /wrappers/libuv.
                                                             (line  114)
* proc udp_recv_start*(handle: PUdp; alloc_cb: AllocProc; recv_cb: UdpRecvProc): cint {.: /wrappers/libuv.
                                                             (line  140)
* proc udp_recv_stop*(handle: PUdp): cint {.importc: "uv_udp_recv_stop", header: "uv.h".}: /wrappers/libuv.
                                                             (line  144)
* proc udp_send*(req: PUdpSend; handle: PUdp; bufs: ptr Buf; bufcnt: cint; adr: SockAddrIn;: /wrappers/libuv.
                                                             (line  129)
* proc udp_send6*(req: PUdpSend; handle: PUdp; bufs: ptr Buf; bufcnt: cint;: /wrappers/libuv.
                                                             (line  134)
* proc umask*(a1: Mode): Mode {.importc, header: "<sys/stat.h>".}: /posix/posix.
                                                             (line 1098)
* proc uname*(a1: var Utsname): cint {.importc, header: "<sys/utsname.h>".}: /posix/posix.
                                                             (line  387)
* proc unctrl*(a2: cunsignedlong): cstring {.extdecl, importc: "unctrl",: /wrappers/pdcurses.
                                                             (line 1475)
* proc undefineSymbol*(s: PccState; sym: cstring) {.cdecl,: /wrappers/tinyc.
                                                             (line   65)
* proc unescape*(s: string; prefix = "\""; suffix = "\""): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  649)
* proc unescape*(uri: cstring): cstring {.importc, nodecl.}: /js/dom.
                                                             (line  289)
* proc ungetch*(a2: cint): cint {.extdecl, importc: "PDC_ungetch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1654)
* proc ungetmouse*(a2: ptr MEVENT): cint {.extdecl, importc: "ungetmouse",: /wrappers/pdcurses.
                                                             (line 1567)
* proc unget_wch*(a2: char): cint {.extdecl, importc: "unget_wch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1333)
* proc unicodeLetter*(): Peg {.inline.}: /pure/pegs.         (line  119)
* proc unicodeLower*(): Peg {.inline.}:  /pure/pegs.         (line  124)
* proc unicodeTitle*(): Peg {.inline.}:  /pure/pegs.         (line  136)
* proc unicodeUpper*(): Peg {.inline.}:  /pure/pegs.         (line  130)
* proc unicodeWhitespace*(): Peg {.inline.}: /pure/pegs.     (line  141)
* proc unidecode*(s: string): string:    /pure/unidecode/unidecode.
                                                             (line   14)
* proc unindent*(s: string; eatAllIndent = false): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  406)
* proc union*[A](s1, s2: HashSet[A]): HashSet[A]: /pure/collections/sets.
                                                             (line  223)
* proc unixTimeToWinTime*(t: Time): int64: /pure/times.      (line  213)
* proc unixToNativePath*(path: string; drive = ""): string {.noSideEffect, rtl,: /pure/ospaths.
                                                             (line  176)
* proc unlikely*(val: bool): bool {.importc: "unlikely", nodecl, nosideeffect.}: /system.
                                                             (line 2395)
* proc unlink*(a1: cstring): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1021)
* proc unlink*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.: /wrappers/libuv.
                                                             (line  291)
* proc unloadLib*(lib: LibHandle):       /pure/dynlib.       (line   26)
* proc unmap*(ih: PIhandle) {.importc: "IupUnmap", cdecl, dynlib: dllname, discardable.}: /wrappers/iup.
                                                             (line  228)
* proc unMapFont*(driverfont: cstring): cstring {.importc: "IupUnMapFont", cdecl,: /wrappers/iup.
                                                             (line  135)
* proc unmapMem*(f: var MemFile; p: pointer; size: int): /pure/memfiles.
                                                             (line   47)
* proc unmapViewOfFile*(lpBaseAddress: pointer): WINBOOL {.stdcall, dynlib: "kernel32",: /windows/winlean.
                                                             (line  549)
* proc unpackInfix*(node: NimNode): tuple[left: NimNode, op: string, right: NimNode] {.: /core/macros.
                                                             (line  595)
* proc unpackPostfix*(node: NimNode): tuple[node: NimNode, op: string] {.compileTime.}: /core/macros.
                                                             (line  589)
* proc unpackPrefix*(node: NimNode): tuple[node: NimNode, op: string] {.compileTime.}: /core/macros.
                                                             (line  592)
* proc unref*(a2: PLoop) {.importc: "uv_unref", header: "uv.h".}: /wrappers/libuv.
                                                             (line   27)
* proc unregister*(d: Dispatcher; deleg: Delegate): /deprecated/pure/asyncio.
                                                             (line  118)
* proc unregister*(fd: AsyncFD):         /pure/asyncdispatch.
                                                             (line  238)
* proc unregister*(s: Selector; fd: SocketHandle): SelectorKey {.discardable.}: /pure/selectors.
                                                             (line   39)
* proc unsafeAddr*[T](x: var T): ptr T {.magic: "Addr", noSideEffect.}: /system.
                                                             (line  239)
* proc unsafeGet*[T](self: Option[T]): T: /pure/options.     (line   28)
* proc unsafeNew*[T](a: var ref T; size: Natural) {.magic: "New", noSideEffect.}: /system.
                                                             (line  468)
* proc unsafeRead*[T](fv: FlowVar[ref T]): foreign ptr T: /pure/concurrency/threadpool.
                                                             (line   34)
* proc untouchwin*(a2: ptr WINDOW): cint {.extdecl, importc: "untouchwin",: /wrappers/pdcurses.
                                                             (line  823)
* proc update*(ih: PIhandle) {.importc: "IupUpdate", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  117)
* proc update*(s: Selector; fd: SocketHandle; events: set[Event]): SelectorKey {.: /pure/selectors.
                                                             (line   33)
* proc updateChildren*(ih: PIhandle) {.importc: "IupUpdateChildren", cdecl,: /wrappers/iup.
                                                             (line  120)
* proc update_panels*() {.extdecl, importc: "update_panels", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1761)
* proc update_time*(a2: PLoop) {.importc: "uv_update_time", header: "uv.h".}: /wrappers/libuv.
                                                             (line   30)
* proc user*(): PIhandle {.importc: "IupUser", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  493)
* proc user_data*(para1: Pcontext): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  353)
* proc use_default_colors*(): cint {.extdecl, importc: "use_default_colors",: /wrappers/pdcurses.
                                                             (line 1543)
* proc use_env*(a2: cunsignedchar) {.extdecl, importc: "use_env", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  827)
* proc use_result*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  419)
* proc usleep*(a1: Useconds): cint {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1024)
* proc utime*(loop: PLoop; req: PFS; path: cstring; atime: cdouble; mtime: cdouble;: /wrappers/libuv.
                                                             (line  345)
* proc utimes*(path: cstring; times: ptr array[2, Timeval]): int {.importc: "utimes",: /posix/posix.
                                                             (line 1804)
* proc val*(theType: cstring): PIhandle {.importc: "IupVal", cdecl, dynlib: dllname.}: /wrappers/iup.
                                                             (line  519)
* proc validateData*(data: StringTableRef; validKeys: varargs[string]): /pure/cgi.
                                                             (line   57)
* proc validateUtf8*(s: string): int:    /pure/unicode.      (line   33)
* proc validEmailAddress*(s: string): bool {.noSideEffect, rtl,: /pure/matchers.
                                                             (line    6)
* proc validIdentifier*(s: string): bool {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  661)
* proc value_blob*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  305)
* proc value_bytes*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  309)
* proc value_bytes16*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  313)
* proc value_double*(para1: Pvalue): float64 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  317)
* proc value_int*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  321)
* proc value_int64*(para1: Pvalue): int64 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  325)
* proc value_text*(para1: Pvalue): cstring {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  329)
* proc value_text16*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  333)
* proc value_text16be*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  341)
* proc value_text16le*(para1: Pvalue): pointer {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  337)
* proc value_type*(para1: Pvalue): int32 {.cdecl, dynlib: Lib,: /wrappers/sqlite3.
                                                             (line  345)
* proc variance*(s: RunningStat): float: /pure/stats.        (line   54)
* proc variance*[T](x: openArray[T]): float: /pure/stats.    (line  112)
* proc varianceS*(s: RunningStat): float: /pure/stats.       (line   59)
* proc varianceS*[T](x: openArray[T]): float: /pure/stats.   (line  117)
* proc vbox*(child: PIhandle): PIhandle {.importc: "IupVbox", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  403)
* proc vboxv*(children: ptr PIhandle): PIhandle {.importc: "IupVboxv", cdecl,: /wrappers/iup.
                                                             (line  407)
* proc vector2d*(x, y: float): Vector2d: /pure/basic2d.      (line  175)
* proc vector2d*(x, y: float): Vector2d {.noInit, inline.}: /pure/basic2d.
                                                             (line   34)
* proc vector3d*(x, y, z: float): Vector3d: /pure/basic3d.   (line  205)
* proc vector3d*(x, y, z: float): Vector3d {.noInit, inline.}: /pure/basic3d.
                                                             (line   36)
* proc version*(): cstring:              /wrappers/pcre.     (line  193)
* proc version*(): cstring {.cdecl, dynlib: Lib, importc: "sqlite3_libversion".}: /wrappers/sqlite3.
                                                             (line  445)
* proc vfork*(): Pid {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1027)
* proc vidattr*(a2: cunsignedlong): cint {.extdecl, importc: "vidattr",: /wrappers/pdcurses.
                                                             (line  830)
* proc vid_attr*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  834)
* proc vline*(a2: cunsignedlong; a3: cint): cint {.extdecl, importc: "vline",: /wrappers/pdcurses.
                                                             (line  838)
* proc vline_set*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, importc: "vline_set",: /wrappers/pdcurses.
                                                             (line 1336)
* proc vwprintw*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs,: /wrappers/pdcurses.
                                                             (line  842)
* proc vwprintw2*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs,: /wrappers/pdcurses.
                                                             (line  846)
* proc vwscanw*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs, importc: "vw_scanw",: /wrappers/pdcurses.
                                                             (line  850)
* proc vwscanw2*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, varargs, importc: "vwscanw",: /wrappers/pdcurses.
                                                             (line  854)
* proc waddch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "waddch",: /wrappers/pdcurses.
                                                             (line  866)
* proc waddchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  858)
* proc waddchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  862)
* proc waddnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  870)
* proc waddnwstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1340)
* proc waddrawch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1636)
* proc waddstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "waddstr",: /wrappers/pdcurses.
                                                             (line  874)
* proc waddwstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "waddwstr",: /wrappers/pdcurses.
                                                             (line 1344)
* proc wadd_wch*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1348)
* proc wadd_wchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1352)
* proc wadd_wchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1356)
* proc wait*(a1: ptr cint): Pid {.importc, discardable, header: "<sys/wait.h>".}: /posix/posix.
                                                             (line 1291)
* proc wait*(c: proc (); interval = 0.01'f64): /pure/coro.   (line   30)
* proc wait*(cond: var Cond; lock: var Lock) {.inline.}: /core/locks.
                                                             (line   49)
* proc waitFor*[T](fut: Future[T]): T:   /pure/asyncdispatch.
                                                             (line  281)
* proc waitForExit*(p: Process; timeout: int = - 1): int {.rtl, extern: "nosp$1", tags: [].}: /pure/osproc.
                                                             (line  146)
* proc waitForMultipleObjects*(nCount: DWORD; lpHandles: PWOHandleArray;: /windows/winlean.
                                                             (line  476)
* proc waitForSingleObject*(hHandle: Handle; dwMilliseconds: int32): int32 {.stdcall,: /windows/winlean.
                                                             (line  186)
* proc waitid*(a1: cint; a2: Id; a3: var SigInfo; a4: cint): cint {.importc,: /posix/posix.
                                                             (line 1294)
* proc waitpid*(a1: Pid; a2: var cint; a3: cint): Pid {.importc, header: "<sys/wait.h>".}: /posix/posix.
                                                             (line 1298)
* proc warning*(msg: string) {.magic: "NWarning", benign.}: /core/macros.
                                                             (line  191)
* proc warningStr*(c: CfgParser; msg: string): string {.rtl, extern: "npc$1".}: /pure/parsecfg.
                                                             (line   52)
* proc warning_count*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib,: /wrappers/mysql.
                                                             (line  361)
* proc wattroff*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wattroff",: /wrappers/pdcurses.
                                                             (line  878)
* proc wattron*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wattron",: /wrappers/pdcurses.
                                                             (line  882)
* proc wattrset*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wattrset",: /wrappers/pdcurses.
                                                             (line  886)
* proc wattr_get*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cshort; a5: pointer): cint {.: /wrappers/pdcurses.
                                                             (line  890)
* proc wattr_off*(a2: ptr WINDOW; a3: cunsignedlong; a4: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  894)
* proc wattr_on*(a2: ptr WINDOW; a3: cunsignedlong; a4: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  898)
* proc wattr_set*(a2: ptr WINDOW; a3: cunsignedlong; a4: cshort; a5: pointer): cint {.: /wrappers/pdcurses.
                                                             (line  902)
* proc wbkgd*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "wbkgd",: /wrappers/pdcurses.
                                                             (line  910)
* proc wbkgdset*(a2: ptr WINDOW; a3: cunsignedlong) {.extdecl, importc: "wbkgdset",: /wrappers/pdcurses.
                                                             (line  906)
* proc wbkgrnd*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl, importc: "wbkgrnd",: /wrappers/pdcurses.
                                                             (line 1360)
* proc wbkgrndset*(a2: ptr WINDOW; a3: ptr cunsignedlong) {.extdecl,: /wrappers/pdcurses.
                                                             (line 1364)
* proc wborder*(a2: ptr WINDOW; a3: cunsignedlong; a4: cunsignedlong; a5: cunsignedlong;: /wrappers/pdcurses.
                                                             (line  914)
* proc wborder_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong;: /wrappers/pdcurses.
                                                             (line 1368)
* proc wchgat*(a2: ptr WINDOW; a3: cint; a4: cunsignedlong; a5: cshort; a6: pointer): cint {.: /wrappers/pdcurses.
                                                             (line  922)
* proc wclear*(a2: ptr WINDOW): cint {.extdecl, importc: "wclear", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  926)
* proc wclrtobot*(a2: ptr WINDOW): cint {.extdecl, importc: "wclrtobot",: /wrappers/pdcurses.
                                                             (line  929)
* proc wclrtoeol*(a2: ptr WINDOW): cint {.extdecl, importc: "wclrtoeol",: /wrappers/pdcurses.
                                                             (line  933)
* proc wcolor_set*(a2: ptr WINDOW; a3: cshort; a4: pointer): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  937)
* proc wcursyncup*(a2: ptr WINDOW) {.extdecl, importc: "wcursyncup", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  941)
* proc wdelch*(a2: ptr WINDOW): cint {.extdecl, importc: "wdelch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  944)
* proc wdeleteln*(a2: ptr WINDOW): cint {.extdecl, importc: "wdeleteln",: /wrappers/pdcurses.
                                                             (line  947)
* proc wechochar*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  951)
* proc wecho_wchar*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1377)
* proc wenclose*(a2: ptr WINDOW; a3: cint; a4: cint): cunsignedchar {.extdecl,: /wrappers/pdcurses.
                                                             (line 1571)
* proc werase*(a2: ptr WINDOW): cint {.extdecl, importc: "werase", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  955)
* proc wgetbkgrnd*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1381)
* proc wgetch*(a2: ptr WINDOW): cint {.extdecl, importc: "wgetch", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line  958)
* proc wgetnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  961)
* proc wgetn_wstr*(a2: ptr WINDOW; a3: ptr cint; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1385)
* proc wgetstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "wgetstr",: /wrappers/pdcurses.
                                                             (line  965)
* proc wget_wch*(a2: ptr WINDOW; a3: ptr cint): cint {.extdecl, importc: "wget_wch",: /wrappers/pdcurses.
                                                             (line 1389)
* proc wget_wstr*(a2: ptr WINDOW; a3: ptr cint): cint {.extdecl, importc: "wget_wstr",: /wrappers/pdcurses.
                                                             (line 1393)
* proc whichMsgClass*(k: MsgKind): MsgClass: /packages/docutils/rst.
                                                             (line   27)
* proc whline*(a2: ptr WINDOW; a3: cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  969)
* proc whline_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1397)
* proc WIFCONTINUED*(s: cint): bool {.importc, header: "<sys/wait.h>".}: /posix/posix.
                                                             (line  126)
* proc WIFEXITED*(s: cint): bool {.importc, header: "<sys/wait.h>".}: /posix/posix.
                                                             (line  131)
* proc WIFSIGNALED*(s: cint): bool {.importc, header: "<sys/wait.h>".}: /posix/posix.
                                                             (line  136)
* proc WIFSTOPPED*(s: cint): bool {.importc, header: "<sys/wait.h>".}: /posix/posix.
                                                             (line  141)
* proc winch*(a2: ptr WINDOW): cunsignedlong {.extdecl, importc: "winch",: /wrappers/pdcurses.
                                                             (line  981)
* proc winchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  973)
* proc winchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line  977)
* proc winnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl, importc: "winnstr",: /wrappers/pdcurses.
                                                             (line  985)
* proc winnwstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1401)
* proc winsch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl, importc: "winsch",: /wrappers/pdcurses.
                                                             (line  989)
* proc winsdelln*(a2: ptr WINDOW; a3: cint): cint {.extdecl, importc: "winsdelln",: /wrappers/pdcurses.
                                                             (line  993)
* proc winsertln*(a2: ptr WINDOW): cint {.extdecl, importc: "winsertln",: /wrappers/pdcurses.
                                                             (line  997)
* proc winsnstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1001)
* proc winsrawch*(a2: ptr WINDOW; a3: cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1640)
* proc winsstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "winsstr",: /wrappers/pdcurses.
                                                             (line 1005)
* proc winstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "winstr",: /wrappers/pdcurses.
                                                             (line 1009)
* proc wins_nwstr*(a2: ptr WINDOW; a3: cstring; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1405)
* proc wins_wch*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1409)
* proc wins_wstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "wins_wstr",: /wrappers/pdcurses.
                                                             (line 1413)
* proc winTimeToUnixTime*(t: int64): Time: /pure/times.      (line  218)
* proc winwstr*(a2: ptr WINDOW; a3: cstring): cint {.extdecl, importc: "winwstr",: /wrappers/pdcurses.
                                                             (line 1417)
* proc win_wch*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl, importc: "win_wch",: /wrappers/pdcurses.
                                                             (line 1421)
* proc win_wchnstr*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1425)
* proc win_wchstr*(a2: ptr WINDOW; a3: ptr cunsignedlong): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1429)
* proc wmouse_position*(a2: ptr WINDOW; a3: ptr cint; a4: ptr cint) {.extdecl,: /wrappers/pdcurses.
                                                             (line 1520)
* proc wmouse_trafo*(a2: ptr WINDOW; a3: ptr cint; a4: ptr cint; a5: cunsignedchar): cunsignedchar {.: /wrappers/pdcurses.
                                                             (line 1575)
* proc wmove*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "wmove",: /wrappers/pdcurses.
                                                             (line 1013)
* proc wnoutrefresh*(a2: ptr WINDOW): cint {.extdecl, importc: "wnoutrefresh",: /wrappers/pdcurses.
                                                             (line 1017)
* proc wordchar*(): char {.extdecl, importc: "wordchar", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1644)
* proc wordWrap*(s: string; maxLineWidth = 80; splitLongWords = true;: /pure/strutils.
                                                             (line  389)
* proc wprintw*(a2: ptr WINDOW; a3: cstring): cint {.varargs, extdecl, importc: "wprintw",: /wrappers/pdcurses.
                                                             (line 1021)
* proc wrapConnectedSocket*(ctx: SslContext; socket: AsyncSocket;: /pure/asyncnet.
                                                             (line  162)
* proc wrapConnectedSocket*(ctx: SSLContext; socket: Socket;: /pure/net.
                                                             (line  131)
* proc wrapSocket*(ctx: SslContext; socket: AsyncSocket): /pure/asyncnet.
                                                             (line  153)
* proc wrapSocket*(ctx: SSLContext; socket: Socket): /pure/net.
                                                             (line  119)
* proc wrapSocket*(ctx: SSLContext; socket: Socket) <1>: /deprecated/pure/sockets.
                                                             (line  102)
* proc wredrawln*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "wredrawln",: /wrappers/pdcurses.
                                                             (line 1025)
* proc wrefresh*(a2: ptr WINDOW): cint {.extdecl, importc: "wrefresh", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1029)
* proc wresize*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl, importc: "wresize",: /wrappers/pdcurses.
                                                             (line 1547)
* proc write*(a1: cint; a2: pointer; a3: int): int {.importc, header: "<unistd.h>".}: /posix/posix.
                                                             (line 1030)
* proc write*(d: Document; text: cstring): /js/dom.          (line  202)
* proc write*(f: AsyncFile; data: string): Future[void]: /pure/asyncfile.
                                                             (line   54)
* proc write*(f: File; a: varargs[string, `$`]) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2193)
* proc write*(f: File; b: bool) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2184)
* proc write*(f: File; c: char) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2187)
* proc write*(f: File; c: cstring) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2190)
* proc write*(f: File; i: BiggestInt) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2175)
* proc write*(f: File; i: int) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2172)
* proc write*(f: File; r: BiggestFloat) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2178)
* proc write*(f: File; r: float32) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2169)
* proc write*(f: File; r: Rope) {.rtl, extern: "nro$1".}: /pure/ropes.
                                                             (line   74)
* proc write*(f: File; s: string) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2181)
* proc write*(loop: PLoop; req: PFS; file: File; buf: pointer; length: csize; offset: coff;: /wrappers/libuv.
                                                             (line  295)
* proc write*(req: PWrite; handle: PStream; bufs: ptr Buf; bufcnt: cint;: /wrappers/libuv.
                                                             (line   81)
* proc write*(req: PWrite; handle: PStream; bufs: ptr Buf; bufcnt: cint; cb: WriteProc): cint {.: /wrappers/libuv.
                                                             (line   77)
* proc write*(s: Stream; x: string):     /pure/streams.      (line  141)
* proc write*[T](s: Stream; x: T):       /pure/streams.      (line  134)
* proc writeBuffer*(f: File; buffer: pointer; len: Natural): int {.tags: [WriteIOEffect],: /system.
                                                             (line 2272)
* proc writeBytes*(f: File; a: openArray[int8 | uint8]; start, len: Natural): int {.: /system.
                                                             (line 2256)
* proc writeChars*(f: File; a: openArray[char]; start, len: Natural): int {.: /system.
                                                             (line 2264)
* proc writeContentType*():              /pure/cgi.          (line  231)
* proc writeData*(s, unused: Stream; buffer: pointer; bufLen: int) {.deprecated.}: /pure/streams.
                                                             (line  128)
* proc writeData*(s: Stream; buffer: pointer; bufLen: int): /pure/streams.
                                                             (line  122)
* proc writeErrorMessage*(data: string): /pure/cgi.          (line  238)
* proc writeFile*(filename, content: string) {.tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2162)
* proc writeFile*(hFile: Handle; Buffer: pointer; nNumberOfBytesToWrite: int32;: /windows/winlean.
                                                             (line  130)
* proc writeIndexFile*(g: var RstGenerator; outfile: string): /packages/docutils/rstgen.
                                                             (line   67)
* proc writeLine*(s: Stream; args: varargs[string, `$`]): /pure/streams.
                                                             (line  152)
* proc writeLine*[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect], benign.}: /system.
                                                             (line 2221)
* proc writeln*(d: Document; text: cstring): /js/dom.        (line  205)
* proc writeLn*(s: Stream; args: varargs[string, `$`]) {.deprecated.}: /pure/streams.
                                                             (line  147)
* proc writeLn*[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect], benign,: /system.
                                                             (line 2215)
* proc writeStackTrace*() {.tags: [WriteIOEffect].}: /system.
                                                             (line 2337)
* proc writeStatusOkTextContent*(c: Socket; contentType = "text/html"): /pure/scgi.
                                                             (line   39)
* proc writeStyled*(txt: string; style: set[Style] = {styleBright}): /pure/terminal.
                                                             (line  104)
* proc writev*(a1: cint; a2: ptr IOVec; a3: cint): int {.importc, header: "<sys/uio.h>".}: /posix/posix.
                                                             (line 1556)
* proc wsaGetLastError*(): cint {.importc: "WSAGetLastError", dynlib: ws2dll.}: /windows/winlean.
                                                             (line  346)
* proc WSAIoctl*(s: SocketHandle; dwIoControlCode: DWORD; lpvInBuffer: pointer;: /windows/winlean.
                                                             (line  577)
* proc WSARecv*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;: /windows/winlean.
                                                             (line  587)
* proc WSASend*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; bytesSent: PDWORD;: /windows/winlean.
                                                             (line  595)
* proc wsaStartup*(wVersionRequired: int16; WSData: ptr WSAData): cint {.stdcall,: /windows/winlean.
                                                             (line  455)
* proc wscanw*(a2: ptr WINDOW; a3: cstring): cint {.varargs, extdecl, importc: "wscanw",: /wrappers/pdcurses.
                                                             (line 1032)
* proc wscrl*(a2: ptr WINDOW; a3: cint): cint {.extdecl, importc: "wscrl",: /wrappers/pdcurses.
                                                             (line 1036)
* proc wsetscrreg*(a2: ptr WINDOW; a3: cint; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1040)
* proc wstandend*(a2: ptr WINDOW): cint {.extdecl, importc: "wstandend",: /wrappers/pdcurses.
                                                             (line 1044)
* proc wstandout*(a2: ptr WINDOW): cint {.extdecl, importc: "wstandout",: /wrappers/pdcurses.
                                                             (line 1048)
* proc wsyncdown*(a2: ptr WINDOW) {.extdecl, importc: "wsyncdown", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1052)
* proc wsyncup*(a2: ptr WINDOW) {.extdecl, importc: "wsyncup", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1055)
* proc wtimeout*(a2: ptr WINDOW; a3: cint) {.extdecl, importc: "wtimeout",: /wrappers/pdcurses.
                                                             (line 1058)
* proc wtouchln*(a2: ptr WINDOW; a3: cint; a4: cint; a5: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1062)
* proc wunctrl*(a2: ptr cunsignedlong): cstring {.extdecl, importc: "wunctrl",: /wrappers/pdcurses.
                                                             (line 1433)
* proc wvline*(a2: ptr WINDOW; a3: cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1066)
* proc wvline_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: cint): cint {.extdecl,: /wrappers/pdcurses.
                                                             (line 1437)
* proc XCursesExit*() {.extdecl, importc: "XCursesExit", dynlib: pdcursesdll.}: /wrappers/pdcurses.
                                                             (line 1768)
* proc Xinitscr*(a2: cint; a3: cstringArray): ptr WINDOW {.extdecl, importc: "Xinitscr",: /wrappers/pdcurses.
                                                             (line 1764)
* proc xlen*(x: string): int {.magic: "XLenStr", noSideEffect.}: /system.
                                                             (line 2703)
* proc xlen*[T](x: seq[T]): int {.magic: "XLenSeq", noSideEffect.}: /system.
                                                             (line 2706)
* proc xmlCheckedTag*(e: NimNode; tag: string; optAttr = ""; reqAttr = ""; isLeaf = false): NimNode {.: /pure/htmlgen.
                                                             (line   12)
* proc xmlEncode*(s: string): string:    /pure/cgi.          (line   35)
* proc years*(y: int): TimeInterval {.inline.}: /pure/times. (line  285)
* proc zbox*(child: PIhandle): PIhandle {.importc: "IupZbox", cdecl, dynlib: dllname,: /wrappers/iup.
                                                             (line  411)
* proc zboxv*(children: ptr PIhandle): PIhandle {.importc: "IupZboxv", cdecl,: /wrappers/iup.
                                                             (line  415)
* proc ze*(a: int): int {.compilerproc.}: /system/jssys.     (line   15)
* proc ze*(x: int16): int {.magic: "Ze16ToI", noSideEffect.}: /system.
                                                             (line  631)
* proc ze*(x: int8): int {.magic: "Ze8ToI", noSideEffect.}: /system.
                                                             (line  625)
* proc ze64*(a: int64): int64 {.compilerproc.}: /system/jssys.
                                                             (line   18)
* proc ze64*(x: int): int64 {.magic: "ZeIToI64", noSideEffect.}: /system.
                                                             (line  655)
* proc ze64*(x: int16): int64 {.magic: "Ze16ToI64", noSideEffect.}: /system.
                                                             (line  643)
* proc ze64*(x: int32): int64 {.magic: "Ze32ToI64", noSideEffect.}: /system.
                                                             (line  649)
* proc ze64*(x: int8): int64 {.magic: "Ze8ToI64", noSideEffect.}: /system.
                                                             (line  637)
* proc zeroMem*(p: pointer; size: Natural) {.importc, noDecl, benign.}: /system.
                                                             (line 1495)
* proc zip*[S, T](seq1: seq[S]; seq2: seq[T]): seq[tuple[a: S, b: T]]: /pure/collections/sequtils.
                                                             (line   58)
* proc `!$`*(h: Hash): Hash {.inline.}:  /pure/hashes.       (line   23)
* proc `!&`*(h: Hash; val: int): Hash {.inline.}: /pure/hashes.
                                                             (line   16)
* proc `!*\`*(a: Peg): Peg {.noSideEffect, rtl, extern: "npgegsCapturedSearch".}: /pure/pegs.
                                                             (line   84)
* proc `!*`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsSearch".}: /pure/pegs.
                                                             (line   79)
* proc `!`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsNotPredicate".}: /pure/pegs.
                                                             (line   99)
* proc `!`*(s: string): NimIdent {.magic: "StrToIdent", noSideEffect.}: /core/macros.
                                                             (line   55)
* proc `$$`*[T](x: T): string:           /pure/marshal.      (line   16)
* proc `$`*(address: IpAddress): string: /pure/net.          (line  463)
* proc `$`*(c: Color): string:           /pure/colors.       (line   42)
* proc `$`*(d: MD5Digest): string:       /pure/md5.          (line   38)
* proc `$`*(day: WeekDay): string:       /pure/times.        (line  233)
* proc `$`*(doc: PDocument): string:     /pure/xmldom.       (line  416)
* proc `$`*(err: OSErrorCode): string {.borrow.}: /pure/os.  (line   89)
* proc `$`*(i: NimIdent): string {.magic: "IdentToStr", noSideEffect.}: /core/macros.
                                                             (line   60)
* proc `$`*(m: Matrix3d): string:        /pure/basic3d.      (line  194)
* proc `$`*(m: Month): string:           /pure/times.        (line  238)
* proc `$`*(ms: MemSlice): string {.inline.}: /pure/memfiles.
                                                             (line   81)
* proc `$`*(msg: Message): string:       /pure/smtp.         (line   56)
* proc `$`*(n: XmlNode): string:         /pure/xmltree.      (line  173)
* proc `$`*(node: JsonNode): string:     /pure/json.         (line  305)
* proc `$`*(node: NimNode): string {.compileTime.}: /core/macros.
                                                             (line  557)
* proc `$`*(oid: Oid): string:           /pure/oids.         (line   35)
* proc `$`*(p: Point2d): string:         /pure/basic2d.      (line  383)
* proc `$`*(p: Point3d): string:         /pure/basic3d.      (line  367)
* proc `$`*(p: Poly): string:            /pure/poly.         (line   47)
* proc `$`*(p: Port): string {.borrow.}: /pure/nativesockets.
                                                             (line   37)
* proc `$`*(p: Port): string {.borrow.} <1>: /deprecated/pure/sockets.
                                                             (line   38)
* proc `$`*(pattern: RegexMatch): string: /impure/nre.       (line   61)
* proc `$`*(r: Peg): string {.nosideEffect, rtl, extern: "npegsToString".}: /pure/pegs.
                                                             (line  194)
* proc `$`*(r: Rope): string {.rtl, extern: "nroToString".}: /pure/ropes.
                                                             (line   79)
* proc `$`*(rune: Rune): string:         /pure/unicode.      (line   49)
* proc `$`*(runes: seq[Rune]): string:   /pure/unicode.      (line   54)
* proc `$`*(s: IntSet): string:          /pure/collections/intsets.
                                                             (line   54)
* proc `$`*(s: NimSym): string {.magic: "IdentToStr", noSideEffect.}: /core/macros.
                                                             (line   65)
* proc `$`*(s: SharedString): string:    /pure/collections/sharedstrings.
                                                             (line   51)
* proc `$`*(s: WideCString): string:     /system/widestrs.   (line   30)
* proc `$`*(self: SecureHash): string:   /pure/securehash.   (line   18)
* proc `$`*(t: Matrix2d): string {.noInit.}: /pure/basic2d.  (line  120)
* proc `$`*(t: StringTableRef): string {.rtl, extern: "nstDollar".}: /pure/strtabs.
                                                             (line   96)
* proc `$`*(time: Time): string {.tags: [], raises: [], benign.}: /pure/times.
                                                             (line   82)
* proc `$`*(timeInfo: TimeInfo): string {.tags: [], raises: [], benign.}: /pure/times.
                                                             (line   77)
* proc `$`*(u: Uri): string:             /pure/uri.          (line   99)
* proc `$`*(u: Url): string {.deprecated.}: /deprecated/pure/parseurl.
                                                             (line   18)
* proc `$`*(url: Url): string {.deprecated.}: /pure/uri.     (line   18)
* proc `$`*(v: Vector2d): string:        /pure/basic2d.      (line  211)
* proc `$`*(v: Vector3d): string:        /pure/basic3d.      (line  226)
* proc `$`*(w: WideCString; estimate: int; replacement: int = 0x0000FFFD): string: /system/widestrs.
                                                             (line   27)
* proc `$`*(x: bool): string {.magic: "BoolToStr", noSideEffect.}: /system.
                                                             (line 1700)
* proc `$`*(x: char): string {.magic: "CharToStr", noSideEffect.}: /system.
                                                             (line 1706)
* proc `$`*(x: cstring): string {.magic: "CStrToStr", noSideEffect.}: /system.
                                                             (line 1712)
* proc `$`*(x: float): string {.magic: "FloatToStr", noSideEffect.}: /system.
                                                             (line 1694)
* proc `$`*(x: int): string {.magic: "IntToStr", noSideEffect.}: /system.
                                                             (line 1675)
* proc `$`*(x: int64): string {.magic: "Int64ToStr", noSideEffect.}: /system.
                                                             (line 1682)
* proc `$`*(x: SocketHandle): string {.borrow.}: /pure/selectors.
                                                             (line   23)
* proc `$`*(x: string): string {.magic: "StrToStr", noSideEffect.}: /system.
                                                             (line 1718)
* proc `$`*(x: uint64): string {.noSideEffect.}: /system.    (line 1688)
* proc `$`*(z: Complex): string:         /pure/complex.      (line  309)
* proc `$`*[A, B](t: OrderedTableRef[A, B]): string: /pure/collections/tables.
                                                             (line  358)
* proc `$`*[A, B](t: OrderedTable[A, B]): string: /pure/collections/tables.
                                                             (line  276)
* proc `$`*[A, B](t: TableRef[A, B]): string: /pure/collections/tables.
                                                             (line  188)
* proc `$`*[A, B](t: Table[A, B]): string: /pure/collections/tables.
                                                             (line  113)
* proc `$`*[A](s: HashSet[A]): string:   /pure/collections/sets.
                                                             (line  209)
* proc `$`*[A](s: OrderedSet[A]): string: /pure/collections/sets.
                                                             (line  486)
* proc `$`*[A](t: CountTableRef[A]): string: /pure/collections/tables.
                                                             (line  510)
* proc `$`*[A](t: CountTable[A]): string: /pure/collections/tables.
                                                             (line  430)
* proc `$`*[Enum: enum](x: Enum): string {.magic: "EnumToStr", noSideEffect.}: /system.
                                                             (line 1725)
* proc `$`*[T: tuple |:                  /system.            (line 1939)
* proc `$`*[T](c: CritBitTree[T]): string: /pure/collections/critbits.
                                                             (line   87)
* proc `$`*[T](L: DoublyLinkedList[T]): string: /pure/collections/lists.
                                                             (line   52)
* proc `$`*[T](L: DoublyLinkedRing[T]): string: /pure/collections/lists.
                                                             (line   62)
* proc `$`*[T](L: SinglyLinkedList[T]): string: /pure/collections/lists.
                                                             (line   47)
* proc `$`*[T](L: SinglyLinkedRing[T]): string: /pure/collections/lists.
                                                             (line   57)
* proc `$`*[T](q: Queue[T]): string:     /pure/collections/queues.
                                                             (line   43)
* proc `$`*[T](self: Option[T]): string: /pure/options.      (line   70)
* proc `$`*[T](x: Rational[T]): string:  /pure/rationals.    (line   28)
* proc `$`*[T](x: seq[T]): string:       /system.            (line 1955)
* proc `$`*[T](x: set[T]): string:       /system.            (line 1948)
* proc `%%`*(x, y: int64): int64 {.magic: "ModU", noSideEffect.}: /system.
                                                             (line 1008)
* proc `%%`*(x, y: IntMax32): IntMax32 {.magic: "ModU", noSideEffect.}: /system.
                                                             (line 1005)
* proc `%`*(b: bool): JsonNode:          /pure/json.         (line  190)
* proc `%`*(elements: openArray[JsonNode]): JsonNode: /pure/json.
                                                             (line  200)
* proc `%`*(f: string; t: StringTableRef; flags: set[FormatFlag] = {}): string {.rtl,: /pure/strtabs.
                                                             (line   90)
* proc `%`*(formatstr, a: string): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  758)
* proc `%`*(formatstr: string; a: openArray[string]): string {.noSideEffect, rtl,: /pure/strutils.
                                                             (line  723)
* proc `%`*(formatstr: Subex; a: openarray[string]): string {.noSideEffect, rtl,: /pure/subexes.
                                                             (line   31)
* proc `%`*(formatstr: Subex; a: string): string {.noSideEffect, rtl,: /pure/subexes.
                                                             (line   39)
* proc `%`*(frmt: string; args: openArray[Rope]): Rope {.rtl, extern: "nroFormat".}: /pure/ropes.
                                                             (line   84)
* proc `%`*(keyVals: openArray[tuple[key: string, val: JsonNode]]): JsonNode: /pure/json.
                                                             (line  195)
* proc `%`*(n: BiggestInt): JsonNode:    /pure/json.         (line  180)
* proc `%`*(n: float): JsonNode:         /pure/json.         (line  185)
* proc `%`*(s: string): JsonNode:        /pure/json.         (line  175)
* proc `&=`*(p: var Point2d; t: Matrix2d) {.inline.}: /pure/basic2d.
                                                             (line  394)
* proc `&=`*(p: var Point3d; m: Matrix3d): /pure/basic3d.    (line  378)
* proc `&=`*(v: var Vector2d; m: Matrix2d) {.inline.}: /pure/basic2d.
                                                             (line  222)
* proc `&=`*(v: var Vector3d; m: Matrix3d) {.noInit.}: /pure/basic3d.
                                                             (line  237)
* proc `&=`*(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect.}: /system.
                                                             (line 2561)
* proc `&`*(a, b: Matrix2d): Matrix2d {.noInit.}: /pure/basic2d.
                                                             (line   52)
* proc `&`*(a, b: Matrix3d): Matrix3d {.noinit.}: /pure/basic3d.
                                                             (line   62)
* proc `&`*(a, b: Rope): Rope {.rtl, extern: "nroConcRopeRope".}: /pure/ropes.
                                                             (line   38)
* proc `&`*(a: openArray[Rope]): Rope {.rtl, extern: "nroConcOpenArray".}: /pure/ropes.
                                                             (line   53)
* proc `&`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsAndPredicate".}: /pure/pegs.
                                                             (line   94)
* proc `&`*(a: Rope; b: string): Rope {.rtl, extern: "nroConcRopeStr".}: /pure/ropes.
                                                             (line   43)
* proc `&`*(a: string; b: Rope): Rope {.rtl, extern: "nroConcStrRope".}: /pure/ropes.
                                                             (line   48)
* proc `&`*(p: Point2d; t: Matrix2d): Point2d {.noInit, inline.}: /pure/basic2d.
                                                             (line  388)
* proc `&`*(p: Point3d; m: Matrix3d): Point3d: /pure/basic3d.
                                                             (line  372)
* proc `&`*(v: Vector2d; m: Matrix2d): Vector2d {.noInit.}: /pure/basic2d.
                                                             (line  216)
* proc `&`*(v: Vector3d; m: Matrix3d): Vector3d {.noInit.}: /pure/basic3d.
                                                             (line  231)
* proc `&`*(x, y: char): string {.magic: "ConStrStr", noSideEffect, merge.}: /system.
                                                             (line 1290)
* proc `&`*(x, y: string): string {.magic: "ConStrStr", noSideEffect, merge.}: /system.
                                                             (line 1296)
* proc `&`*(x: char; y: string): string {.magic: "ConStrStr", noSideEffect, merge.}: /system.
                                                             (line 1302)
* proc `&`*(x: string; y: char): string {.magic: "ConStrStr", noSideEffect, merge.}: /system.
                                                             (line 1284)
* proc `&`*[T](x, y: seq[T]): seq[T] {.noSideEffect.}: /system.
                                                             (line 1876)
* proc `&`*[T](x: seq[T]; y: T): seq[T] {.noSideEffect.}: /system.
                                                             (line 1882)
* proc `&`*[T](x: T; y: seq[T]): seq[T] {.noSideEffect.}: /system.
                                                             (line 1889)
* proc `*%`*(x, y: int64): int64 {.magic: "MulU", noSideEffect.}: /system.
                                                             (line  988)
* proc `*%`*(x, y: IntMax32): IntMax32 {.magic: "MulU", noSideEffect.}: /system.
                                                             (line  985)
* proc `*=`*(x: var Complex; y: Complex): /pure/complex.     (line  114)
* proc `*=`*(x: var Complex; y: float):  /pure/complex.      (line  119)
* proc `*=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}: /system.
                                                             (line 2546)
* proc `*=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.inline, noSideEffect.}: /system.
                                                             (line 2531)
* proc `*=`*[T](x: var Rational[T]; y: Rational[T]): /pure/rationals.
                                                             (line  139)
* proc `*=`*[T](x: var Rational[T]; y: T): /pure/rationals.  (line  144)
* proc `*`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsGreedyRep".}: /pure/pegs.
                                                             (line   74)
* proc `*`*(f: float; p: Poly): Poly:    /pure/poly.         (line  105)
* proc `*`*(p1: Poly; p2: Poly): Poly:   /pure/poly.         (line   95)
* proc `*`*(p: Poly; f: float): Poly:    /pure/poly.         (line  100)
* proc `*`*(x, y: Complex): Complex:     /pure/complex.      (line   79)
* proc `*`*(x, y: float): float {.magic: "MulF64", noSideEffect.}: /system.
                                                             (line 1137)
* proc `*`*(x, y: float32): float32 {.magic: "MulF64", noSideEffect.}: /system.
                                                             (line 1119)
* proc `*`*(x, y: int): int {.magic: "MulI", noSideEffect.}: /system.
                                                             (line  765)
* proc `*`*(x, y: int16): int16 {.magic: "MulI", noSideEffect.}: /system.
                                                             (line  771)
* proc `*`*(x, y: int32): int32 {.magic: "MulI", noSideEffect.}: /system.
                                                             (line  774)
* proc `*`*(x, y: int64): int64 {.magic: "MulI", noSideEffect.}: /system.
                                                             (line  779)
* proc `*`*(x, y: int8): int8 {.magic: "MulI", noSideEffect.}: /system.
                                                             (line  768)
* proc `*`*(x: Complex; y: float): Complex: /pure/complex.   (line   89)
* proc `*`*(x: float; y: Complex): Complex: /pure/complex.   (line   84)
* proc `*`*(x: int; order: SortOrder): int {.inline.}: /pure/algorithm.
                                                             (line   15)
* proc `*`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}: /pure/collections/sets.
                                                             (line  284)
* proc `*`*[T: SomeUnsignedInt](x, y: T): T {.magic: "MulU", noSideEffect.}: /system.
                                                             (line 1078)
* proc `*`*[T](x, y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line  124)
* proc `*`*[T](x, y: set[T]): set[T] {.magic: "MulSet", noSideEffect.}: /system.
                                                             (line 1163)
* proc `*`*[T](x: Rational[T]; y: T): Rational[T]: /pure/rationals.
                                                             (line  129)
* proc `*`*[T](x: T; y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line  134)
* proc `+%`*(x, y: int64): int64 {.magic: "AddU", noSideEffect.}: /system.
                                                             (line  968)
* proc `+%`*(x, y: IntMax32): IntMax32 {.magic: "AddU", noSideEffect.}: /system.
                                                             (line  965)
* proc `+=`*(a: var RunningRegress; b: RunningRegress): /pure/stats.
                                                             (line  198)
* proc `+=`*(a: var RunningStat; b: RunningStat) {.inline.}: /pure/stats.
                                                             (line  102)
* proc `+=`*(p: var Point2d; v: Vector2d) {.noInit, inline.}: /pure/basic2d.
                                                             (line  411)
* proc `+=`*(p: var Point3d; v: Vector3d) {.noInit, inline.}: /pure/basic3d.
                                                             (line  395)
* proc `+=`*(t: var Time; ti: TimeInterval): /pure/times.    (line  292)
* proc `+=`*(x: var Complex; y: Complex): /pure/complex.     (line   94)
* proc `+=`*(x: var Complex; y: float):  /pure/complex.      (line   99)
* proc `+=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}: /system.
                                                             (line 2536)
* proc `+=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: "Inc", noSideEffect.}: /system.
                                                             (line 2521)
* proc `+=`*[T](x: var Rational[T]; y: Rational[T]): /pure/rationals.
                                                             (line   84)
* proc `+=`*[T](x: var Rational[T]; y: T): /pure/rationals.  (line   89)
* proc `+`*(a, b: Color): Color:         /pure/colors.       (line   19)
* proc `+`*(a, b: RunningRegress): RunningRegress: /pure/stats.
                                                             (line  190)
* proc `+`*(a, b: RunningStat): RunningStat: /pure/stats.    (line   94)
* proc `+`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsGreedyPosRep".}: /pure/pegs.
                                                             (line   89)
* proc `+`*(a: TimeInfo; interval: TimeInterval): TimeInfo: /pure/times.
                                                             (line  165)
* proc `+`*(p1: Poly; p2: Poly): Poly:   /pure/poly.         (line   90)
* proc `+`*(p: Point2d; v: Vector2d): Point2d {.noInit, inline.}: /pure/basic2d.
                                                             (line  406)
* proc `+`*(p: Point3d; v: Vector3d): Point3d {.noInit, inline.}: /pure/basic3d.
                                                             (line  390)
* proc `+`*(t: Time; ti: TimeInterval): Time: /pure/times.   (line  297)
* proc `+`*(ti1, ti2: TimeInterval): TimeInterval: /pure/times.
                                                             (line  140)
* proc `+`*(x, y: Complex): Complex:     /pure/complex.      (line   29)
* proc `+`*(x, y: float): float {.magic: "AddF64", noSideEffect.}: /system.
                                                             (line 1131)
* proc `+`*(x, y: float32): float32 {.magic: "AddF64", noSideEffect.}: /system.
                                                             (line 1113)
* proc `+`*(x, y: int): int {.magic: "AddI", noSideEffect.}: /system.
                                                             (line  731)
* proc `+`*(x, y: int16): int16 {.magic: "AddI", noSideEffect.}: /system.
                                                             (line  737)
* proc `+`*(x, y: int32): int32 {.magic: "AddI", noSideEffect.}: /system.
                                                             (line  740)
* proc `+`*(x, y: int64): int64 {.magic: "AddI", noSideEffect.}: /system.
                                                             (line  745)
* proc `+`*(x, y: int8): int8 {.magic: "AddI", noSideEffect.}: /system.
                                                             (line  734)
* proc `+`*(x: Complex; y: float): Complex: /pure/complex.   (line   34)
* proc `+`*(x: float): float {.magic: "UnaryPlusF64", noSideEffect.}: /system.
                                                             (line 1125)
* proc `+`*(x: float32): float32 {.magic: "UnaryPlusF64", noSideEffect.}: /system.
                                                             (line 1107)
* proc `+`*(x: float; y: Complex): Complex: /pure/complex.   (line   39)
* proc `+`*(x: int): int {.magic: "UnaryPlusI", noSideEffect.}: /system.
                                                             (line  680)
* proc `+`*(x: int16): int16 {.magic: "UnaryPlusI", noSideEffect.}: /system.
                                                             (line  686)
* proc `+`*(x: int32): int32 {.magic: "UnaryPlusI", noSideEffect.}: /system.
                                                             (line  689)
* proc `+`*(x: int64): int64 {.magic: "UnaryPlusI", noSideEffect.}: /system.
                                                             (line  692)
* proc `+`*(x: int8): int8 {.magic: "UnaryPlusI", noSideEffect.}: /system.
                                                             (line  683)
* proc `+`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}: /pure/collections/sets.
                                                             (line  279)
* proc `+`*[T: SomeUnsignedInt](x, y: T): T {.magic: "AddU", noSideEffect.}: /system.
                                                             (line 1068)
* proc `+`*[T](x, y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line   69)
* proc `+`*[T](x, y: set[T]): set[T] {.magic: "PlusSet", noSideEffect.}: /system.
                                                             (line 1168)
* proc `+`*[T](x: Rational[T]; y: T): Rational[T]: /pure/rationals.
                                                             (line   74)
* proc `+`*[T](x: T; y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line   79)
* proc `-%`*(x, y: int64): int64 {.magic: "SubU", noSideEffect.}: /system.
                                                             (line  978)
* proc `-%`*(x, y: IntMax32): IntMax32 {.magic: "SubU", noSideEffect.}: /system.
                                                             (line  975)
* proc `-+-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}: /pure/collections/sets.
                                                             (line  294)
* proc `-=`*(p: var Point2d; v: Vector2d) {.noInit, inline.}: /pure/basic2d.
                                                             (line  426)
* proc `-=`*(p: var Point3d; v: Vector3d) {.noInit, inline.}: /pure/basic3d.
                                                             (line  410)
* proc `-=`*(t: var Time; ti: TimeInterval): /pure/times.    (line  305)
* proc `-=`*(x: var Complex; y: Complex): /pure/complex.     (line  104)
* proc `-=`*(x: var Complex; y: float):  /pure/complex.      (line  109)
* proc `-=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}: /system.
                                                             (line 2541)
* proc `-=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: "Dec", noSideEffect.}: /system.
                                                             (line 2526)
* proc `-=`*[T](x: var Rational[T]; y: Rational[T]): /pure/rationals.
                                                             (line  114)
* proc `-=`*[T](x: var Rational[T]; y: T): /pure/rationals.  (line  119)
* proc `-`*(a, b: Color): Color:         /pure/colors.       (line   25)
* proc `-`*(a, b: Time): int64 {.rtl, extern: "ntDiffTime", tags: [], raises: [], benign.}: /pure/times.
                                                             (line   87)
* proc `-`*(a: TimeInfo; interval: TimeInterval): TimeInfo: /pure/times.
                                                             (line  173)
* proc `-`*(p1, p2: Point2d): Vector2d {.noInit, inline.}: /pure/basic2d.
                                                             (line  421)
* proc `-`*(p1, p2: Point3d): Vector3d {.noInit, inline.}: /pure/basic3d.
                                                             (line  405)
* proc `-`*(p1: Poly; p2: Poly): Poly:   /pure/poly.         (line  115)
* proc `-`*(p: Point2d; v: Vector2d): Point2d {.noInit, inline.}: /pure/basic2d.
                                                             (line  416)
* proc `-`*(p: Point3d; v: Vector3d): Point3d {.noInit, inline.}: /pure/basic3d.
                                                             (line  400)
* proc `-`*(p: Poly): Poly:              /pure/poly.         (line  110)
* proc `-`*(t: Time; ti: TimeInterval): Time: /pure/times.   (line  310)
* proc `-`*(ti1, ti2: TimeInterval): TimeInterval: /pure/times.
                                                             (line  145)
* proc `-`*(v: Vector2d): Vector2d:      /pure/basic2d.      (line  305)
* proc `-`*(v: Vector3d): Vector3d:      /pure/basic3d.      (line  302)
* proc `-`*(x, y: Complex): Complex:     /pure/complex.      (line   49)
* proc `-`*(x, y: float): float {.magic: "SubF64", noSideEffect.}: /system.
                                                             (line 1134)
* proc `-`*(x, y: float32): float32 {.magic: "SubF64", noSideEffect.}: /system.
                                                             (line 1116)
* proc `-`*(x, y: int): int {.magic: "SubI", noSideEffect.}: /system.
                                                             (line  748)
* proc `-`*(x, y: int16): int16 {.magic: "SubI", noSideEffect.}: /system.
                                                             (line  754)
* proc `-`*(x, y: int32): int32 {.magic: "SubI", noSideEffect.}: /system.
                                                             (line  757)
* proc `-`*(x, y: int64): int64 {.magic: "SubI", noSideEffect.}: /system.
                                                             (line  762)
* proc `-`*(x, y: int8): int8 {.magic: "SubI", noSideEffect.}: /system.
                                                             (line  751)
* proc `-`*(x: Complex; y: float): Complex: /pure/complex.   (line   54)
* proc `-`*(x: float): float {.magic: "UnaryMinusF64", noSideEffect.}: /system.
                                                             (line 1128)
* proc `-`*(x: float32): float32 {.magic: "UnaryMinusF64", noSideEffect.}: /system.
                                                             (line 1110)
* proc `-`*(x: float; y: Complex): Complex: /pure/complex.   (line   59)
* proc `-`*(x: int): int {.magic: "UnaryMinusI", noSideEffect.}: /system.
                                                             (line  697)
* proc `-`*(x: int16): int16 {.magic: "UnaryMinusI", noSideEffect.}: /system.
                                                             (line  703)
* proc `-`*(x: int32): int32 {.magic: "UnaryMinusI", noSideEffect.}: /system.
                                                             (line  706)
* proc `-`*(x: int64): int64 {.magic: "UnaryMinusI64", noSideEffect.}: /system.
                                                             (line  709)
* proc `-`*(x: int8): int8 {.magic: "UnaryMinusI", noSideEffect.}: /system.
                                                             (line  700)
* proc `-`*(z: Complex): Complex:        /pure/complex.      (line   44)
* proc `-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}: /pure/collections/sets.
                                                             (line  289)
* proc `-`*[T: SomeUnsignedInt](x, y: T): T {.magic: "SubU", noSideEffect.}: /system.
                                                             (line 1073)
* proc `-`*[T](x, y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line   99)
* proc `-`*[T](x, y: set[T]): set[T] {.magic: "MinusSet", noSideEffect.}: /system.
                                                             (line 1173)
* proc `-`*[T](x: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line   94)
* proc `-`*[T](x: Rational[T]; y: T): Rational[T]: /pure/rationals.
                                                             (line  104)
* proc `-`*[T](x: T; y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line  109)
* proc `..`*[T](a, b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".}: /system.
                                                             (line  343)
* proc `..`*[T](b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".}: /system.
                                                             (line  351)
* proc `/%`*(x, y: int64): int64 {.magic: "DivU", noSideEffect.}: /system.
                                                             (line  998)
* proc `/%`*(x, y: IntMax32): IntMax32 {.magic: "DivU", noSideEffect.}: /system.
                                                             (line  995)
* proc `/../`*(head, tail: string): string {.noSideEffect.}: /pure/ospaths.
                                                             (line  108)
* proc `//`*[T](num, den: T): Rational[T]: /pure/rationals.  (line   22)
* proc `/=`*(x: var Complex; y: Complex): /pure/complex.     (line  124)
* proc `/=`*(x: var Complex; y: float):  /pure/complex.      (line  129)
* proc `/=`*(x: var float64; y: float64) {.inline, noSideEffect.}: /system.
                                                             (line 2551)
* proc `/=`*[T: float | float32](x: var T; y: T) {.inline, noSideEffect.}: /system.
                                                             (line 2556)
* proc `/=`*[T](x: var Rational[T]; y: Rational[T]): /pure/rationals.
                                                             (line  169)
* proc `/=`*[T](x: var Rational[T]; y: T): /pure/rationals.  (line  174)
* proc `/`*(a, b: Url): Url {.deprecated.}: /pure/uri.       (line   23)
* proc `/`*(a: varargs[Peg]): Peg {.nosideEffect, rtl, extern: "npegsOrderedChoice".}: /pure/pegs.
                                                             (line   59)
* proc `/`*(head, tail: string): string {.noSideEffect.}: /pure/ospaths.
                                                             (line   58)
* proc `/`*(p, q: Poly): Poly:           /pure/poly.         (line  125)
* proc `/`*(p: Poly; f: float): Poly:    /pure/poly.         (line  120)
* proc `/`*(x, y: Complex): Complex:     /pure/complex.      (line   64)
* proc `/`*(x, y: float): float {.magic: "DivF64", noSideEffect.}: /system.
                                                             (line 1140)
* proc `/`*(x, y: float32): float32 {.magic: "DivF64", noSideEffect.}: /system.
                                                             (line 1122)
* proc `/`*(x, y: int): float {.inline, noSideEffect.}: /system.
                                                             (line 2431)
* proc `/`*(x: Complex; y: float): Complex: /pure/complex.   (line   69)
* proc `/`*(x: float; y: Complex): Complex: /pure/complex.   (line   74)
* proc `/`*(x: Uri; path: string): Uri:  /pure/uri.          (line   80)
* proc `/`*[T](x, y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line  154)
* proc `/`*[T](x: Rational[T]; y: T): Rational[T]: /pure/rationals.
                                                             (line  159)
* proc `/`*[T](x: T; y: Rational[T]): Rational[T]: /pure/rationals.
                                                             (line  164)
* proc `<%`*(a, b: Rune): bool:          /pure/unicode.      (line   17)
* proc `<%`*(x, y: int64): bool {.magic: "LtU64", noSideEffect.}: /system.
                                                             (line 1027)
* proc `<%`*(x, y: IntMax32): bool {.magic: "LtU", noSideEffect.}: /system.
                                                             (line 1024)
* proc `<=%`*(a, b: Rune): bool:         /pure/unicode.      (line   14)
* proc `<=%`*(x, y: int64): bool {.magic: "LeU64", noSideEffect.}: /system.
                                                             (line 1018)
* proc `<=%`*(x, y: IntMax32): bool {.magic: "LeU", noSideEffect.}: /system.
                                                             (line 1015)
* proc `<=`*(a, b: Time): bool {.rtl, extern: "ntLeTime", tags: [], raises: [].}: /pure/times.
                                                             (line   98)
* proc `<=`*(x, y: bool): bool {.magic: "LeB", noSideEffect.}: /system.
                                                             (line  435)
* proc `<=`*(x, y: char): bool {.magic: "LeCh", noSideEffect.}: /system.
                                                             (line  429)
* proc `<=`*(x, y: float): bool {.magic: "LeF64", noSideEffect.}: /system.
                                                             (line 1157)
* proc `<=`*(x, y: float32): bool {.magic: "LeF64", noSideEffect.}: /system.
                                                             (line 1148)
* proc `<=`*(x, y: int): bool {.magic: "LeI", noSideEffect.}: /system.
                                                             (line  931)
* proc `<=`*(x, y: int16): bool {.magic: "LeI", noSideEffect.}: /system.
                                                             (line  937)
* proc `<=`*(x, y: int32): bool {.magic: "LeI", noSideEffect.}: /system.
                                                             (line  940)
* proc `<=`*(x, y: int64): bool {.magic: "LeI", noSideEffect.}: /system.
                                                             (line  943)
* proc `<=`*(x, y: int8): bool {.magic: "LeI", noSideEffect.}: /system.
                                                             (line  934)
* proc `<=`*(x, y: pointer): bool {.magic: "LePtr", noSideEffect.}: /system.
                                                             (line  441)
* proc `<=`*(x, y: Rational): bool:      /pure/rationals.    (line  187)
* proc `<=`*(x, y: string): bool {.magic: "LeStr", noSideEffect.}: /system.
                                                             (line  426)
* proc `<=`*[A](s, t: HashSet[A]): bool: /pure/collections/sets.
                                                             (line  325)
* proc `<=`*[Enum: enum](x, y: Enum): bool {.magic: "LeEnum", noSideEffect.}: /system.
                                                             (line  423)
* proc `<=`*[T: SomeUnsignedInt](x, y: T): bool {.magic: "LeU", noSideEffect.}: /system.
                                                             (line 1097)
* proc `<=`*[T: tuple](x, y: T): bool:   /system.            (line 1927)
* proc `<=`*[T](x, y: ref T): bool {.magic: "LePtr", noSideEffect.}: /system.
                                                             (line  438)
* proc `<=`*[T](x, y: set[T]): bool {.magic: "LeSet", noSideEffect.}: /system.
                                                             (line  432)
* proc `<`*(a, b: Time): bool {.rtl, extern: "ntLtTime", tags: [], raises: [].}: /pure/times.
                                                             (line   93)
* proc `<`*(x, y: bool): bool {.magic: "LtB", noSideEffect.}: /system.
                                                             (line  456)
* proc `<`*(x, y: char): bool {.magic: "LtCh", noSideEffect.}: /system.
                                                             (line  450)
* proc `<`*(x, y: float): bool {.magic: "LtF64", noSideEffect.}: /system.
                                                             (line 1160)
* proc `<`*(x, y: float32): bool {.magic: "LtF64", noSideEffect.}: /system.
                                                             (line 1151)
* proc `<`*(x, y: int): bool {.magic: "LtI", noSideEffect.}: /system.
                                                             (line  948)
* proc `<`*(x, y: int16): bool {.magic: "LtI", noSideEffect.}: /system.
                                                             (line  954)
* proc `<`*(x, y: int32): bool {.magic: "LtI", noSideEffect.}: /system.
                                                             (line  957)
* proc `<`*(x, y: int64): bool {.magic: "LtI", noSideEffect.}: /system.
                                                             (line  960)
* proc `<`*(x, y: int8): bool {.magic: "LtI", noSideEffect.}: /system.
                                                             (line  951)
* proc `<`*(x, y: pointer): bool {.magic: "LtPtr", noSideEffect.}: /system.
                                                             (line  465)
* proc `<`*(x, y: Rational): bool:       /pure/rationals.    (line  184)
* proc `<`*(x, y: string): bool {.magic: "LtStr", noSideEffect.}: /system.
                                                             (line  447)
* proc `<`*[A](s, t: HashSet[A]): bool:  /pure/collections/sets.
                                                             (line  311)
* proc `<`*[Enum: enum](x, y: Enum): bool {.magic: "LtEnum", noSideEffect.}: /system.
                                                             (line  444)
* proc `<`*[T: SomeUnsignedInt](x, y: T): bool {.magic: "LtU", noSideEffect.}: /system.
                                                             (line 1102)
* proc `<`*[T: tuple](x, y: T): bool:    /system.            (line 1933)
* proc `<`*[T](x, y: ptr T): bool {.magic: "LtPtr", noSideEffect.}: /system.
                                                             (line  462)
* proc `<`*[T](x, y: ref T): bool {.magic: "LtPtr", noSideEffect.}: /system.
                                                             (line  459)
* proc `<`*[T](x, y: set[T]): bool {.magic: "LtSet", noSideEffect.}: /system.
                                                             (line  453)
* proc `<`*[T](x: Ordinal[T]): T {.magic: "UnaryLt", noSideEffect.}: /system.
                                                             (line  489)
* proc `= destroy`*(s: SharedString):    /pure/collections/sharedstrings.
                                                             (line   18)
* proc `==`*(a, b: Color): bool {.borrow.}: /pure/colors.    (line   14)
* proc `==`*(a, b: JsonNode): bool:      /pure/json.         (line  205)
* proc `==`*(a, b: NimIdent): bool {.magic: "EqIdent", noSideEffect.}: /core/macros.
                                                             (line   70)
* proc `==`*(a, b: NimNode): bool {.magic: "EqNimrodNode", noSideEffect.}: /core/macros.
                                                             (line   75)
* proc `==`*(a, b: Option): bool:        /pure/options.      (line   64)
* proc `==`*(a, b: Port): bool {.borrow.}: /pure/nativesockets.
                                                             (line   32)
* proc `==`*(a, b: Port): bool {.borrow.} <1>: /deprecated/pure/sockets.
                                                             (line   33)
* proc `==`*(a, b: Regex): bool:         /impure/nre.        (line   64)
* proc `==`*(a, b: RegexMatch): bool:    /impure/nre.        (line   67)
* proc `==`*(a, b: Rune): bool:          /pure/unicode.      (line   20)
* proc `==`*(a, b: SecureHash): bool:    /pure/securehash.   (line   24)
* proc `==`*(a, b: Time): bool {.rtl, extern: "ntEqTime", tags: [], raises: [].}: /pure/times.
                                                             (line  103)
* proc `==`*(D1, D2: MD5Digest): bool:   /pure/md5.          (line   48)
* proc `==`*(err1, err2: OSErrorCode): bool {.borrow.}: /pure/os.
                                                             (line   86)
* proc `==`*(lhs, rhs: IpAddress): bool: /pure/net.          (line  457)
* proc `==`*(oid1: Oid; oid2: Oid): bool: /pure/oids.        (line   19)
* proc `==`*(protocol: tuple[orig: string, major, minor: int]; ver: HttpVersion): bool: /pure/asynchttpserver.
                                                             (line   13)
* proc `==`*(s, t: SharedString): bool:  /pure/collections/sharedstrings.
                                                             (line   57)
* proc `==`*(s: SharedString; t: string): bool: /pure/collections/sharedstrings.
                                                             (line   54)
* proc `==`*(x, y: bool): bool {.magic: "EqB", noSideEffect.}: /system.
                                                             (line  395)
* proc `==`*(x, y: char): bool {.magic: "EqCh", noSideEffect.}: /system.
                                                             (line  390)
* proc `==`*(x, y: Complex): bool:       /pure/complex.      (line   19)
* proc `==`*(x, y: cstring): bool {.magic: "EqCString", noSideEffect.}: /system.
                                                             (line  385)
* proc `==`*(x, y: float): bool {.magic: "EqF64", noSideEffect.}: /system.
                                                             (line 1154)
* proc `==`*(x, y: float32): bool {.magic: "EqF64", noSideEffect.}: /system.
                                                             (line 1145)
* proc `==`*(x, y: int): bool {.magic: "EqI", noSideEffect.}: /system.
                                                             (line  914)
* proc `==`*(x, y: int16): bool {.magic: "EqI", noSideEffect.}: /system.
                                                             (line  920)
* proc `==`*(x, y: int32): bool {.magic: "EqI", noSideEffect.}: /system.
                                                             (line  923)
* proc `==`*(x, y: int64): bool {.magic: "EqI", noSideEffect.}: /system.
                                                             (line  926)
* proc `==`*(x, y: int8): bool {.magic: "EqI", noSideEffect.}: /system.
                                                             (line  917)
* proc `==`*(x, y: pointer): bool {.magic: "EqRef", noSideEffect.}: /system.
                                                             (line  372)
* proc `==`*(x, y: Rational): bool:      /pure/rationals.    (line  190)
* proc `==`*(x, y: SocketHandle): bool {.borrow.}: /windows/winlean.
                                                             (line  349)
* proc `==`*(x, y: SocketHandle): bool {.borrow.} <1>: /posix/posix.
                                                             (line 1570)
* proc `==`*(x, y: string): bool {.magic: "EqStr", noSideEffect.}: /system.
                                                             (line  380)
* proc `==`*(x: AsyncFD; y: AsyncFD): bool {.borrow.}: /pure/asyncdispatch.
                                                             (line  141)
* proc `==`*[A, B](s, t: TableRef[A, B]): bool: /pure/collections/tables.
                                                             (line  193)
* proc `==`*[A, B](s, t: Table[A, B]): bool: /pure/collections/tables.
                                                             (line  123)
* proc `==`*[A](s, t: HashSet[A]): bool: /pure/collections/sets.
                                                             (line  339)
* proc `==`*[A](s, t: OrderedSet[A]): bool: /pure/collections/sets.
                                                             (line  501)
* proc `==`*[Enum: enum](x, y: Enum): bool {.magic: "EqEnum", noSideEffect.}: /system.
                                                             (line  356)
* proc `==`*[I, T](x, y: array[I, T]): bool: /system.        (line 1866)
* proc `==`*[T: proc](x, y: T): bool {.magic: "EqProc", noSideEffect.}: /system.
                                                             (line  418)
* proc `==`*[T: SomeUnsignedInt](x, y: T): bool {.magic: "EqI", noSideEffect.}: /system.
                                                             (line 1063)
* proc `==`*[T: tuple |:                 /system.            (line 1920)
* proc `==`*[T](x, y: ptr T): bool {.magic: "EqRef", noSideEffect.}: /system.
                                                             (line  413)
* proc `==`*[T](x, y: ref T): bool {.magic: "EqRef", noSideEffect.}: /system.
                                                             (line  408)
* proc `==`*[T](x, y: seq[T]): bool {.noSideEffect.}: /system.
                                                             (line 1896)
* proc `==`*[T](x, y: set[T]): bool {.magic: "EqSet", noSideEffect.}: /system.
                                                             (line  400)
* proc `=`*[T](dest: var T; src: T) {.noSideEffect, magic: "Asgn".}: /system.
                                                             (line  340)
* proc `=~`*(m1, m2: Matrix2d): bool:    /pure/basic2d.      (line  157)
* proc `=~`*(m1, m2: Matrix3d): bool:    /pure/basic3d.      (line  168)
* proc `=~`*(p1, p2: Point2d): bool {.inline.}: /pure/basic2d.
                                                             (line  431)
* proc `=~`*(p1, p2: Point3d): bool {.inline.}: /pure/basic3d.
                                                             (line  415)
* proc `=~`*(v1, v2: Vector2d): bool:    /pure/basic2d.      (line  328)
* proc `=~`*(v1, v2: Vector3d): bool:    /pure/basic3d.      (line  326)
* proc `=~`*(x, y: Complex): bool:       /pure/complex.      (line   24)
* proc `?`*(a: Peg): Peg {.nosideEffect, rtl, extern: "npegsOptional".}: /pure/pegs.
                                                             (line   69)
* proc `@`*[IDX, T](a: array[IDX, T]): seq[T] {.magic: "ArrToSeq", nosideeffect.}: /system.
                                                             (line 1240)
* proc `@`*[T](a: openArray[T]): seq[T]: /system.            (line 1869)
* proc `addr`*[T](x: var T): ptr T {.magic: "Addr", noSideEffect.}: /system.
                                                             (line  229)
* proc `and`*(x, y: bool): bool {.magic: "And", noSideEffect.}: /system.
                                                             (line  258)
* proc `and`*(x, y: int): int {.magic: "BitandI", noSideEffect.}: /system.
                                                             (line  860)
* proc `and`*(x, y: int16): int16 {.magic: "BitandI", noSideEffect.}: /system.
                                                             (line  866)
* proc `and`*(x, y: int32): int32 {.magic: "BitandI", noSideEffect.}: /system.
                                                             (line  869)
* proc `and`*(x, y: int64): int64 {.magic: "BitandI", noSideEffect.}: /system.
                                                             (line  872)
* proc `and`*(x, y: int8): int8 {.magic: "BitandI", noSideEffect.}: /system.
                                                             (line  863)
* proc `and`*[T, Y](fut1: Future[T]; fut2: Future[Y]): Future[void]: /pure/asyncdispatch.
                                                             (line  129)
* proc `and`*[T: SomeUnsignedInt](x, y: T): T {.magic: "BitandI", noSideEffect.}: /system.
                                                             (line 1048)
* proc `attrs =`*(n: XmlNode; attr: XmlAttributes) {.inline.}: /pure/xmltree.
                                                             (line  127)
* proc `basename =`*(a: NimNode; val: string) {.compileTime.}: /core/macros.
                                                             (line  577)
* proc `body =`*(someProc: NimNode; val: NimNode) {.compileTime.}: /core/macros.
                                                             (line  551)
* proc `callback =`*(future: FutureBase; cb: proc () {.closure, gcsafe.}): /pure/asyncdispatch.
                                                             (line   63)
* proc `callback =`*[T](future: Future[T];: /pure/asyncdispatch.
                                                             (line   74)
* proc `clientData =`*(n: XmlNode; data: int) {.inline.}: /pure/xmltree.
                                                             (line  143)
* proc `div`*(x, y: int): int {.magic: "DivI", noSideEffect.}: /system.
                                                             (line  782)
* proc `div`*(x, y: int16): int16 {.magic: "DivI", noSideEffect.}: /system.
                                                             (line  788)
* proc `div`*(x, y: int32): int32 {.magic: "DivI", noSideEffect.}: /system.
                                                             (line  791)
* proc `div`*(x, y: int64): int64 {.magic: "DivI", noSideEffect.}: /system.
                                                             (line  801)
* proc `div`*(x, y: int8): int8 {.magic: "DivI", noSideEffect.}: /system.
                                                             (line  785)
* proc `div`*[T: SomeUnsignedInt](x, y: T): T {.magic: "DivU", noSideEffect.}: /system.
                                                             (line 1083)
* proc `floatVal =`*(n: NimNode; val: BiggestFloat) {.magic: "NSetFloatVal", noSideEffect.}: /core/macros.
                                                             (line  158)
* proc `ident =`*(n: NimNode; val: NimIdent) {.magic: "NSetIdent", noSideEffect.}: /core/macros.
                                                             (line  164)
* proc `intVal =`*(n: NimNode; val: BiggestInt) {.magic: "NSetIntVal", noSideEffect.}: /core/macros.
                                                             (line  155)
* proc `is`*[T, S](x: T; y: S): bool {.magic: "Is", noSideEffect.}: /system.
                                                             (line 1205)
* proc `len =`*(v: var Vector2d; newlen: float) {.noInit.}: /pure/basic2d.
                                                             (line  194)
* proc `len =`*(v: var Vector3d; newlen: float) {.noInit.}: /pure/basic3d.
                                                             (line  213)
* proc `miliseconds =`*(t: var TimeInterval; milliseconds: int) {.deprecated.}: /pure/times.
                                                             (line  185)
* proc `mod`*(p, q: Poly): Poly:         /pure/poly.         (line  130)
* proc `mod`*(x, y: float): float:       /pure/math.         (line  259)
* proc `mod`*(x, y: int): int {.magic: "ModI", noSideEffect.}: /system.
                                                             (line  804)
* proc `mod`*(x, y: int16): int16 {.magic: "ModI", noSideEffect.}: /system.
                                                             (line  810)
* proc `mod`*(x, y: int32): int32 {.magic: "ModI", noSideEffect.}: /system.
                                                             (line  813)
* proc `mod`*(x, y: int64): int64 {.magic: "ModI", noSideEffect.}: /system.
                                                             (line  820)
* proc `mod`*(x, y: int8): int8 {.magic: "ModI", noSideEffect.}: /system.
                                                             (line  807)
* proc `mod`*[T: SomeUnsignedInt](x, y: T): T {.magic: "ModU", noSideEffect.}: /system.
                                                             (line 1090)
* proc `name =`*(someProc: NimNode; val: NimNode) {.compileTime.}: /core/macros.
                                                             (line  529)
* proc `namespaceURI =`*(n: PNode; value: string): /pure/xmldom.
                                                             (line  134)
* proc `not`*(x: bool): bool {.magic: "Not", noSideEffect.}: /system.
                                                             (line  253)
* proc `not`*(x: int): int {.magic: "BitnotI", noSideEffect.}: /system.
                                                             (line  714)
* proc `not`*(x: int16): int16 {.magic: "BitnotI", noSideEffect.}: /system.
                                                             (line  720)
* proc `not`*(x: int32): int32 {.magic: "BitnotI", noSideEffect.}: /system.
                                                             (line  723)
* proc `not`*(x: int64): int64 {.magic: "BitnotI", noSideEffect.}: /system.
                                                             (line  728)
* proc `not`*(x: int8): int8 {.magic: "BitnotI", noSideEffect.}: /system.
                                                             (line  717)
* proc `not`*[T: SomeUnsignedInt](x: T): T {.magic: "BitnotI", noSideEffect.}: /system.
                                                             (line 1033)
* proc `of`*[T, S](x: T; y: S): bool {.magic: "Of", noSideEffect.}: /system.
                                                             (line 1218)
* proc `or`*(x, y: bool): bool {.magic: "Or", noSideEffect.}: /system.
                                                             (line  264)
* proc `or`*(x, y: int): int {.magic: "BitorI", noSideEffect.}: /system.
                                                             (line  878)
* proc `or`*(x, y: int16): int16 {.magic: "BitorI", noSideEffect.}: /system.
                                                             (line  884)
* proc `or`*(x, y: int32): int32 {.magic: "BitorI", noSideEffect.}: /system.
                                                             (line  887)
* proc `or`*(x, y: int64): int64 {.magic: "BitorI", noSideEffect.}: /system.
                                                             (line  890)
* proc `or`*(x, y: int8): int8 {.magic: "BitorI", noSideEffect.}: /system.
                                                             (line  881)
* proc `or`*[T, Y](fut1: Future[T]; fut2: Future[Y]): Future[void]: /pure/asyncdispatch.
                                                             (line  135)
* proc `or`*[T: SomeUnsignedInt](x, y: T): T {.magic: "BitorI", noSideEffect.}: /system.
                                                             (line 1053)
* proc `params =`*(someProc: NimNode; params: NimNode) {.compileTime.}: /core/macros.
                                                             (line  535)
* proc `pragma =`*(someProc: NimNode; val: NimNode) {.compileTime.}: /core/macros.
                                                             (line  543)
* proc `prefix =`*(n: PNode; value: string): /pure/xmldom.   (line  167)
* proc `raise`*(a1: cint): cint {.importc, header: "<signal.h>".}: /posix/posix.
                                                             (line 1317)
* proc `shl`*(x, y: int): int {.magic: "ShlI", noSideEffect.}: /system.
                                                             (line  841)
* proc `shl`*(x, y: int16): int16 {.magic: "ShlI", noSideEffect.}: /system.
                                                             (line  847)
* proc `shl`*(x, y: int32): int32 {.magic: "ShlI", noSideEffect.}: /system.
                                                             (line  850)
* proc `shl`*(x, y: int64): int64 {.magic: "ShlI", noSideEffect.}: /system.
                                                             (line  853)
* proc `shl`*(x, y: int8): int8 {.magic: "ShlI", noSideEffect.}: /system.
                                                             (line  844)
* proc `shl`*[T: SomeUnsignedInt](x, y: T): T {.magic: "ShlI", noSideEffect.}: /system.
                                                             (line 1043)
* proc `shr`*(x, y: int): int {.magic: "ShrI", noSideEffect.}: /system.
                                                             (line  823)
* proc `shr`*(x, y: int16): int16 {.magic: "ShrI", noSideEffect.}: /system.
                                                             (line  829)
* proc `shr`*(x, y: int32): int32 {.magic: "ShrI", noSideEffect.}: /system.
                                                             (line  832)
* proc `shr`*(x, y: int64): int64 {.magic: "ShrI", noSideEffect.}: /system.
                                                             (line  835)
* proc `shr`*(x, y: int8): int8 {.magic: "ShrI", noSideEffect.}: /system.
                                                             (line  826)
* proc `shr`*[T: SomeUnsignedInt](x, y: T): T {.magic: "ShrI", noSideEffect.}: /system.
                                                             (line 1038)
* proc `strVal =`*(n: NimNode; val: string) {.magic: "NSetStrVal", noSideEffect.}: /core/macros.
                                                             (line  167)
* proc `symbol =`*(n: NimNode; val: NimSym) {.magic: "NSetSymbol", noSideEffect.}: /core/macros.
                                                             (line  161)
* proc `tag =`*(n: XmlNode; tag: string) {.inline.}: /pure/xmltree.
                                                             (line   75)
* proc `text =`*(n: XmlNode; text: string) {.inline.}: /pure/xmltree.
                                                             (line   45)
* proc `type`*(x: expr): typeDesc {.magic: "TypeOf", noSideEffect, compileTime.}: /system.
                                                             (line  247)
* proc `xor`*(x, y: bool): bool {.magic: "Xor", noSideEffect.}: /system.
                                                             (line  270)
* proc `xor`*(x, y: int): int {.magic: "BitxorI", noSideEffect.}: /system.
                                                             (line  896)
* proc `xor`*(x, y: int16): int16 {.magic: "BitxorI", noSideEffect.}: /system.
                                                             (line  902)
* proc `xor`*(x, y: int32): int32 {.magic: "BitxorI", noSideEffect.}: /system.
                                                             (line  905)
* proc `xor`*(x, y: int64): int64 {.magic: "BitxorI", noSideEffect.}: /system.
                                                             (line  908)
* proc `xor`*(x, y: int8): int8 {.magic: "BitxorI", noSideEffect.}: /system.
                                                             (line  899)
* proc `xor`*[T: SomeUnsignedInt](x, y: T): T {.magic: "BitxorI", noSideEffect.}: /system.
                                                             (line 1058)
* proc `[]=`*(n: NimNode; i: int; child: NimNode) {.magic: "NSetChild", noSideEffect.}: /core/macros.
                                                             (line   50)
* proc `[]=`*(obj: JsonNode; key: string; val: JsonNode) {.inline.}: /pure/json.
                                                             (line  255)
* proc `[]=`*(p: var MultipartData; name, content: string): /pure/httpclient.
                                                             (line  113)
* proc `[]=`*(p: var MultipartData; name: string;: /pure/httpclient.
                                                             (line  120)
* proc `[]=`*(p: var Poly; idx: int; v: float): /pure/poly.  (line   34)
* proc `[]=`*(s: var SharedString; i: Natural; value: char): /pure/collections/sharedstrings.
                                                             (line   27)
* proc `[]=`*(s: var string; x: Slice[int]; b: string): /system.
                                                             (line 2441)
* proc `[]=`*(t: StringTableRef; key, val: string) {.rtl, extern: "nstPut".}: /pure/strtabs.
                                                             (line   57)
* proc `[]=`*(x, y: Any):                /core/typeinfo.     (line  117)
* proc `[]=`*(x: Any; fieldName: string; value: Any): /core/typeinfo.
                                                             (line  102)
* proc `[]=`*(x: Any; i: int; y: Any):   /core/typeinfo.     (line   68)
* proc `[]=`*[A, B](t: OrderedTableRef[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line  332)
* proc `[]=`*[A, B](t: TableRef[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line  164)
* proc `[]=`*[A, B](t: var OrderedTable[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line  239)
* proc `[]=`*[A, B](t: var SharedTable[A, B]; key: A; val: B): /pure/collections/sharedtables.
                                                             (line   39)
* proc `[]=`*[A, B](t: var Table[A, B]; key: A; val: B): /pure/collections/tables.
                                                             (line   82)
* proc `[]=`*[A](t: CountTableRef[A]; key: A; val: int): /pure/collections/tables.
                                                             (line  489)
* proc `[]=`*[A](t: var CountTable[A]; key: A; val: int): /pure/collections/tables.
                                                             (line  409)
* proc `[]=`*[I: Ordinal, T, S](a: T; i: I; x: S) {.noSideEffect, magic: "ArrPut".}: /system.
                                                             (line  337)
* proc `[]=`*[Idx, T](a: var array[Idx, T]; x: Slice[Idx]; b: openArray[T]): /system.
                                                             (line 2465)
* proc `[]=`*[Idx, T](a: var array[Idx, T]; x: Slice[int]; b: openArray[T]): /system.
                                                             (line 2455)
* proc `[]=`*[T](c: var CritBitTree[T]; key: string; val: T): /pure/collections/critbits.
                                                             (line   56)
* proc `[]=`*[T](s: var seq[T]; x: Slice[int]; b: openArray[T]): /system.
                                                             (line 2475)
* proc `[]=`*[T](tbl: PGenTable[T]; key: string; val: T): /pure/gentabs.
                                                             (line   36)
* proc `[]`*(n: NimNode; i: int): NimNode {.magic: "NChild", noSideEffect.}: /core/macros.
                                                             (line   45)
* proc `[]`*(n: var XmlNode; i: int): var XmlNode {.inline.}: /pure/xmltree.
                                                             (line  110)
* proc `[]`*(n: XmlNode; i: int): XmlNode {.inline.}: /pure/xmltree.
                                                             (line  100)
* proc `[]`*(node: JsonNode; index: int): JsonNode {.inline.}: /pure/json.
                                                             (line  227)
* proc `[]`*(node: JsonNode; name: string): JsonNode {.inline.}: /pure/json.
                                                             (line  221)
* proc `[]`*(p: Poly; idx: int): float:  /pure/poly.         (line   27)
* proc `[]`*(pattern: CaptureBounds; i: int): Option[Slice[int]]: /impure/nre.
                                                             (line   29)
* proc `[]`*(pattern: CaptureBounds; name: string): Option[Slice[int]]: /impure/nre.
                                                             (line   41)
* proc `[]`*(pattern: Captures; i: int): string: /impure/nre.
                                                             (line   32)
* proc `[]`*(pattern: Captures; name: string): string: /impure/nre.
                                                             (line   44)
* proc `[]`*(r: Rope; i: int): char {.rtl, extern: "nroCharAt".}: /pure/ropes.
                                                             (line   68)
* proc `[]`*(row: InstantRow; col: int): string {.inline.}: /impure/db_odbc.
                                                             (line   37)
* proc `[]`*(row: InstantRow; col: int): string {.inline.} <1>: /impure/db_mysql.
                                                             (line   41)
* proc `[]`*(row: InstantRow; col: int32): string {.inline.}: /impure/db_postgres.
                                                             (line   54)
* proc `[]`*(row: InstantRow; col: int32): string {.inline.} <1>: /impure/db_sqlite.
                                                             (line   37)
* proc `[]`*(s: Selector; fd: SocketHandle): SelectorKey: /pure/selectors.
                                                             (line   67)
* proc `[]`*(s: SharedString; ab: Slice[int]): SharedString: /pure/collections/sharedstrings.
                                                             (line   30)
* proc `[]`*(s: SharedString; i: Natural): char: /pure/collections/sharedstrings.
                                                             (line   24)
* proc `[]`*(s: string; x: Slice[int]): string {.inline.}: /system.
                                                             (line 2436)
* proc `[]`*(t: StringTableRef; key: string): var string {.rtl, extern: "nstTake",: /pure/strtabs.
                                                             (line   35)
* proc `[]`*(x: Any): Any:               /core/typeinfo.     (line  112)
* proc `[]`*(x: Any; fieldName: string): Any: /core/typeinfo.
                                                             (line  107)
* proc `[]`*(x: Any; i: int): Any:       /core/typeinfo.     (line   63)
* proc `[]`*[A, B](t: OrderedTableRef[A, B]; key: A): var B: /pure/collections/tables.
                                                             (line  294)
* proc `[]`*[A, B](t: OrderedTable[A, B]; key: A): B {.deprecatedGet.}: /pure/collections/tables.
                                                             (line  206)
* proc `[]`*[A, B](t: TableRef[A, B]; key: A): var B {.deprecatedGet.}: /pure/collections/tables.
                                                             (line  131)
* proc `[]`*[A, B](t: Table[A, B]; key: A): B {.deprecatedGet.}: /pure/collections/tables.
                                                             (line   33)
* proc `[]`*[A, B](t: var OrderedTable[A, B]; key: A): var B {.deprecatedGet.}: /pure/collections/tables.
                                                             (line  213)
* proc `[]`*[A, B](t: var Table[A, B]; key: A): var B {.deprecatedGet.}: /pure/collections/tables.
                                                             (line   40)
* proc `[]`*[A](s: var HashSet[A]; key: A): var A: /pure/collections/sets.
                                                             (line   78)
* proc `[]`*[A](t: CountTableRef[A]; key: A): var int {.deprecatedGet.}: /pure/collections/tables.
                                                             (line  463)
* proc `[]`*[A](t: CountTable[A]; key: A): int {.deprecatedGet.}: /pure/collections/tables.
                                                             (line  376)
* proc `[]`*[A](t: var CountTable[A]; key: A): var int {.deprecatedGet.}: /pure/collections/tables.
                                                             (line  383)
* proc `[]`*[I: Ordinal, T](a: T; i: I): T {.noSideEffect, magic: "ArrGet".}: /system.
                                                             (line  334)
* proc `[]`*[Idx, T](a: array[Idx, T]; x: Slice[Idx]): seq[T]: /system.
                                                             (line 2460)
* proc `[]`*[Idx, T](a: array[Idx, T]; x: Slice[int]): seq[T]: /system.
                                                             (line 2450)
* proc `[]`*[T](c: CritBitTree[T]; key: string): T {.inline, deprecatedGet.}: /pure/collections/critbits.
                                                             (line   61)
* proc `[]`*[T](c: var CritBitTree[T]; key: string): var T {.inline, deprecatedGet.}: /pure/collections/critbits.
                                                             (line   68)
* proc `[]`*[T](s: seq[T]; x: Slice[int]): seq[T]: /system.  (line 2470)
* proc `[]`*[T](tbl: PGenTable[T]; key: string): T: /pure/gentabs.
                                                             (line   29)
* proc `^`*(x: int): int {.noSideEffect, magic: "Roof".}: /system.
                                                             (line 2694)
* proc `^`*[T](f: ptr Channel[T]): T:    /deprecated/pure/actors.
                                                             (line   78)
* proc `^`*[T](fv: FlowVar[ref T]): ref T: /pure/concurrency/threadpool.
                                                             (line   39)
* proc `^`*[T](fv: FlowVar[T]): T:       /pure/concurrency/threadpool.
                                                             (line   44)
* proc `^`*[T](x, y: T): T:              /pure/math.         (line  277)
* proc `^`*[T](x: int; y: openArray[T]): int {.noSideEffect, magic: "Roof".}: /system.
                                                             (line 2691)
* proc `{}=`*(node: JsonNode; keys: varargs[string]; value: JsonNode): /pure/json.
                                                             (line  267)
* proc `{}`*(node: JsonNode; keys: varargs[string]): JsonNode: /pure/json.
                                                             (line  260)
* template accumulateResult*(iter: expr): /system.           (line 2771)
* template ACS_PICK*(w, n: expr): expr:  /wrappers/pdcurses. (line 1806)
* template allIt*(seq1, pred: expr): bool {.immediate.}: /pure/collections/sequtils.
                                                             (line  272)
* template anyIt*(seq1, pred: expr): bool {.immediate.}: /pure/collections/sequtils.
                                                             (line  282)
* template applyIt*(varSeq, op: expr):   /pure/collections/sequtils.
                                                             (line  391)
* template assert*(cond: bool; msg = ""): /system.           (line 2790)
* template attrKey*(my: XmlParser): string: /pure/parsexml.  (line  113)
* template attrValue*(my: XmlParser): string: /pure/parsexml.
                                                             (line  118)
* template BUTTON_CHANGED*(x: expr): expr: /wrappers/pdcurses.
                                                             (line 1800)
* template BUTTON_STATUS*(x: expr): expr: /wrappers/pdcurses.
                                                             (line 1803)
* template cceq*(val, c: expr): expr:    /posix/termios.     (line  104)
* template charData*(my: XmlParser): string: /pure/parsexml. (line   96)
* template COLOR_PAIR*(n: expr): expr:   /wrappers/pdcurses. (line 1812)
* template currentSourcePath*(): string: /system.            (line 2785)
* template cursorBackward*(count = 1):   /pure/terminal.     (line  160)
* template cursorDown*(count = 1):       /pure/terminal.     (line  154)
* template cursorForward*(count = 1):    /pure/terminal.     (line  157)
* template cursorUp*(count = 1):         /pure/terminal.     (line  151)
* template debug*(args: varargs[string, `$`]): /pure/logging.
                                                             (line  111)
* template digits*(): expr:              /pure/pegs.         (line  365)
* template digits*(T: typedesc[float32]): int: /pure/fenv.   (line  113)
* template digits*(T: typedesc[float64]): int: /pure/fenv.   (line  165)
* template doAssert*(cond: bool; msg = ""): /system.         (line 2801)
* template elementName*(my: XmlParser): string: /pure/parsexml.
                                                             (line  102)
* template emit*(e: static[string]): stmt: /core/macros.     (line  633)
* template entityName*(my: XmlParser): string: /pure/parsexml.
                                                             (line  108)
* template epsilon*(T: typedesc[float32]): float32: /pure/fenv.
                                                             (line  153)
* template epsilon*(T: typedesc[float64]): float64: /pure/fenv.
                                                             (line  205)
* template eraseLine*():                 /pure/terminal.     (line  163)
* template eraseScreen*():               /pure/terminal.     (line  166)
* template error*(args: varargs[string, `$`]): /pure/logging.
                                                             (line  126)
* template excl*[T](s: var set[T]; flags: set[T]): /system.  (line 2735)
* template fail*():                      /pure/unittest.     (line   71)
* template fastRuneAt*(s: string; i: int; result: expr; doInc = true): /pure/unicode.
                                                             (line  148)
* template fatal*(args: varargs[string, `$`]): /pure/logging.
                                                             (line  131)
* template fence*():                     /system/atomics.    (line  255)
* template filterIt*(seq1, pred: expr): expr: /pure/collections/sequtils.
                                                             (line  244)
* template findChild*(n: NimNode; cond: expr): NimNode {.immediate, dirty.}: /core/macros.
                                                             (line  626)
* template foldl*(sequence, operation: expr): expr: /pure/collections/sequtils.
                                                             (line  305)
* template foldr*(sequence, operation: expr): expr: /pure/collections/sequtils.
                                                             (line  333)
* template formatStr*(howExpr, namegetter, idgetter: expr): expr: /impure/nre/private/util.
                                                             (line   12)
* template fpRadix*(): int:              /pure/fenv.         (line  101)
* template getbegyx*(w, y, x: expr): expr: /wrappers/pdcurses.
                                                             (line 1824)
* template getch*(): expr:               /wrappers/pdcurses. (line 1818)
* template getmaxyx*(w, y, x: expr): expr: /wrappers/pdcurses.
                                                             (line 1827)
* template getmouse*(x: expr): expr:     /wrappers/pdcurses. (line 1839)
* template getparyx*(w, y, x: expr): expr: /wrappers/pdcurses.
                                                             (line 1830)
* template getsyx*(y, x: expr): stmt:    /wrappers/pdcurses. (line 1836)
* template getyx*(w, y, x: expr): expr:  /wrappers/pdcurses. (line 1833)
* template htonl*(x: int32): expr:       /pure/nativesockets.
                                                             (line  216)
* template htons*(x: int16): expr:       /pure/nativesockets.
                                                             (line  224)
* template ident*(): expr:               /pure/pegs.         (line  385)
* template identChars*(): expr:          /pure/pegs.         (line  375)
* template identStartChars*(): expr:     /pure/pegs.         (line  380)
* template incl*[T](s: var set[T]; flags: set[T]): /system.  (line 2730)
* template info*(args: varargs[string, `$`]): /pure/logging. (line  116)
* template keepItIf*(varSeq: seq; pred: expr): /pure/collections/sequtils.
                                                             (line  260)
* template KEY_F*(n: expr): expr:        /wrappers/pdcurses. (line 1809)
* template letters*(): expr:             /pure/pegs.         (line  360)
* template log*(level: Level; args: varargs[string, `$`]): /pure/logging.
                                                             (line  106)
* template mantissaDigits*(T: typedesc[float32]): int: /pure/fenv.
                                                             (line  107)
* template mantissaDigits*(T: typedesc[float64]): int: /pure/fenv.
                                                             (line  159)
* template mapIt*(seq1, op: expr): expr: /pure/collections/sequtils.
                                                             (line  379)
* template mapIt*(seq1, typ, op: expr): expr {.deprecated.}: /pure/collections/sequtils.
                                                             (line  361)
* template max10Exponent*(T: typedesc[float32]): int: /pure/fenv.
                                                             (line  135)
* template max10Exponent*(T: typedesc[float64]): int: /pure/fenv.
                                                             (line  187)
* template maxExponent*(T: typedesc[float32]): int: /pure/fenv.
                                                             (line  124)
* template maxExponent*(T: typedesc[float64]): int: /pure/fenv.
                                                             (line  176)
* template maximumPositiveValue*(T: typedesc[float32]): float32: /pure/fenv.
                                                             (line  147)
* template maximumPositiveValue*(T: typedesc[float64]): float64: /pure/fenv.
                                                             (line  199)
* template min10Exponent*(T: typedesc[float32]): int: /pure/fenv.
                                                             (line  129)
* template min10Exponent*(T: typedesc[float64]): int: /pure/fenv.
                                                             (line  181)
* template minExponent*(T: typedesc[float32]): int: /pure/fenv.
                                                             (line  119)
* template minExponent*(T: typedesc[float64]): int: /pure/fenv.
                                                             (line  171)
* template minimumPositiveValue*(T: typedesc[float32]): float32: /pure/fenv.
                                                             (line  141)
* template minimumPositiveValue*(T: typedesc[float64]): float64: /pure/fenv.
                                                             (line  193)
* template mix*(a, b: Color; fn: expr): expr: /pure/colors.  (line   68)
* template natural*(): expr:             /pure/pegs.         (line  390)
* template newException*(exceptn: typedesc; message: string): expr: /system.
                                                             (line 2776)
* template newRawSocket*(domain, sockType, protocol: cint): expr: /deprecated/pure/rawsockets.
                                                             (line    6)
* template newRawSocket*(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;: /deprecated/pure/rawsockets.
                                                             (line    9)
* template newSeqWith*(len: int; init: expr): expr: /pure/collections/sequtils.
                                                             (line  404)
* template onFailedAssert*(msg: expr; code: stmt): stmt {.dirty, immediate.}: /system.
                                                             (line 2807)
* template PAIR_NUMBER*(n: expr): expr:  /wrappers/pdcurses. (line 1815)
* template piName*(my: XmlParser): string: /pure/parsexml.   (line  123)
* template piRest*(my: XmlParser): string: /pure/parsexml.   (line  128)
* template require*(conditions: stmt): stmt {.immediate.}: /pure/unittest.
                                                             (line   85)
* template setBackgroundColor*(bg: BackgroundColor; bright = false): /pure/terminal.
                                                             (line  175)
* template setCursorPos*(x, y: int):     /pure/terminal.     (line  145)
* template setCursorXPos*(x: int):       /pure/terminal.     (line  148)
* template setForegroundColor*(fg: ForegroundColor; bright = false): /pure/terminal.
                                                             (line  172)
* template setStyle*(style: set[Style]): /pure/terminal.     (line  169)
* template sortedByIt*(seq1, op: expr): expr: /pure/algorithm.
                                                             (line  147)
* template spaces*(n: Natural): string:  /pure/strutils.     (line  816)
* template spawnX*(call: expr): expr:    /pure/concurrency/threadpool.
                                                             (line  118)
* template spawnX*(call: stmt):          /system/sysspawn.   (line   52)
* template sql*(query: string): SqlQuery: /pure/db_common.   (line   20)
* template stdmsg*(): File:              /system.            (line 2782)
* template styledEcho*(args: varargs[expr]): expr: /pure/terminal.
                                                             (line  140)
* template suite*(name: expr; body: stmt): stmt {.immediate, dirty.}: /pure/unittest.
                                                             (line   33)
* template task*(name: untyped; description: string; body: untyped): untyped: /system/nimscript.
                                                             (line  223)
* template test*(name: expr; body: stmt): stmt {.immediate, dirty.}: /pure/unittest.
                                                             (line   60)
* template toSeq*(iter: expr): expr {.immediate.}: /pure/collections/sequtils.
                                                             (line  292)
* template ungetch*(ch: expr): expr:     /wrappers/pdcurses. (line 1821)
* template warn*(args: varargs[string, `$`]): /pure/logging. (line  121)
* template whitespace*(): expr:          /pure/pegs.         (line  370)
* template withDir*(dir: string; body: untyped): untyped: /system/nimscript.
                                                             (line  212)
* template WSAIORW*(x, y): expr:         /windows/winlean.   (line  621)
* template `!=`*(x, y: expr): expr {.immediate.}: /system.   (line 2715)
* template `--`*(key, val: untyped):     /system/nimscript.  (line  202)
* template `--`*(key: untyped):          /system/nimscript.  (line  207)
* template `..<`*(a, b: expr): expr:     /system.            (line 2826)
* template `..^`*(a, b: expr): expr:     /system.            (line 2820)
* template `=~`*(s: string; pattern: Peg): bool: /pure/pegs. (line  395)
* template `=~`*(s: string; pattern: Regex): expr: /impure/re.
                                                             (line  178)
* template `>%`*(x, y: expr): expr {.immediate.}: /system.   (line 2765)
* template `>=%`*(x, y: expr): expr {.immediate.}: /system.  (line 2759)
* template `>=`*(x, y: expr): expr {.immediate.}: /system.   (line 2720)
* template `>`*(x, y: expr): expr {.immediate.}: /system.    (line 2725)
* template `in`*(x, y: expr): expr {.immediate, dirty.}: /system.
                                                             (line 2740)
* template `isnot`*(x, y: expr): expr {.immediate.}: /system.
                                                             (line 2754)
* template `notin`*(x, y: expr): expr {.immediate, dirty.}: /system.
                                                             (line 2747)


File: nim-ref-0.13.0.info,  Node: Variable Index,  Prev: Command and Function Index,  Up: Top

Variable index
**************

This is not a complete index of variables and faces, only the ones that
are mentioned in the manual.  For a more complete list, use 'M-x
org-customize <RET>' and then click yourself through the tree.

 [index ]
* Menu:

* ACS_SSSS* = ACS_PLUS:                  /wrappers/pdcurses.  (line  12)
* ActorPool*[In, Out] = object {.pure, final.}: /deprecated/pure/actors.
                                                              (line  11)
* AF_INET6* = 23:                        /windows/winlean.    (line  33)
* AllChars* = {'\0' .. '\xFF'}:          /pure/strutils.      (line   6)
* ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP* = 10: /wrappers/mysql.   (line  39)
* appType* {.magic: "AppType".}: string = "": /system.        (line  11)
* AsyncFD* = distinct int:               /pure/asyncdispatch. (line  12)
* AsyncFile* = ref object:               /pure/asyncfile.     (line   6)
* AsyncHttpClient* = ref object:         /pure/httpclient.    (line  50)
* AsyncScgiState* = ref AsyncScgiStateObj: /pure/scgi.        (line  11)
* AsyncSmtp* = ref object:               /pure/smtp.          (line   6)
* AsyncSocket* = ref AsyncSocketDesc:    /pure/asyncnet.      (line   6)
* ATOMIC_ACQUIRE* {.importc: "__ATOMIC_ACQUIRE", nodecl.}: AtomMemModel: /system/atomics.
                                                              (line  17)
* ATOMIC_ACQ_REL* {.importc: "__ATOMIC_ACQ_REL", nodecl.}: AtomMemModel: /system/atomics.
                                                              (line  29)
* ATOMIC_CONSUME* {.importc: "__ATOMIC_CONSUME", nodecl.}: AtomMemModel: /system/atomics.
                                                              (line  11)
* ATOMIC_RELAXED* {.importc: "__ATOMIC_RELAXED", nodecl.}: AtomMemModel: /system/atomics.
                                                              (line   6)
* ATOMIC_RELEASE* {.importc: "__ATOMIC_RELEASE", nodecl.}: AtomMemModel: /system/atomics.
                                                              (line  23)
* ATOMIC_SEQ_CST* {.importc: "__ATOMIC_SEQ_CST", nodecl.}: AtomMemModel: /system/atomics.
                                                              (line  35)
* AtomMemModel* = distinct cint:         /system/atomics.     (line  44)
* AtomType* = SomeNumber | pointer | ptr | char | bool: /system/atomics.
                                                              (line  47)
* BackgroundColor* = enum:               /pure/terminal.      (line  21)
* Barrier* {.compilerProc.} = object:    /system/sysspawn.    (line   6)
* BaseLexer* = object of RootObj:        /pure/lexbase.       (line  12)
* BiggestFloat* = float64:               /system.             (line 135)
* BindSymRule* = enum:                   /core/macros.        (line  25)
* bool* {.magic: Bool.} = enum:          /system.             (line  85)
* Breakpoint* = object:                  /system/debugger.    (line  12)
* BufferSize*: int = 4000:               /pure/net.           (line   6)
* BufferSize*: int = 4000 <1>:           /deprecated/pure/sockets.
                                                              (line   6)
* BUTTON_ALT* = BUTTON_MODIFIER_ALT:     /wrappers/pdcurses.  (line   9)
* BY_HANDLE_FILE_INFORMATION* {.final, pure.} = object: /windows/winlean.
                                                              (line  51)
* CallNodes* = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit,: /core/macros.
                                                              (line   9)
* CalloutBlock* = object:                /wrappers/pcre.      (line  72)
* Captures* = object:                    /pure/pegs.          (line  20)
* CfgParser* = object of BaseLexer:      /pure/parsecfg.      (line   6)
* Cflag* = cuint:                        /posix/termios.      (line  36)
* Channel* {.gcsafe.}[TMsg] = RawChannel: /system/channels.   (line   6)
* CharSet* {.deprecated.} = set[char]:   /pure/strutils.      (line  21)
* CLIENT_NET_WRITE_TIMEOUT* = 365 * 24 * 3600: /wrappers/mysql.
                                                              (line  33)
* CLONE_STOPPED* = 0x02000000:           /posix/linux.        (line   6)
* CMDSTATUS_LEN* = 40:                   /wrappers/postgres.  (line   6)
* Collation_needed_func* = proc (para1: pointer; para2: PSqlite3; eTextRep: int32;: /wrappers/sqlite3.
                                                              (line  15)
* Color* = distinct int:                 /pure/colors.        (line   6)
* commonAttr* = coreAttr & eventAttr:    /pure/htmlgen.       (line   6)
* CompletionCallback* = proc (a2: cstring; a3: ptr Completions) {.cdecl.}: /wrappers/linenoise/linenoise.
                                                              (line   6)
* Complex* = tuple[re, im: float]:       /pure/complex.       (line   6)
* COMP_HEADER_SIZE* = 3:                 /wrappers/mysql.     (line  24)
* Cond* = SysCond:                       /core/locks.         (line   6)
* CONFIG_PARENS_LIMIT* = 13:             /wrappers/pcre.      (line  36)
* constIUP_VERSION_DATE* = "2009/07/18": /wrappers/iup.       (line   6)
* CountTableRef*[A] = ref CountTable[A]: /pure/collections/tables.
                                                              (line  12)
* COUNT_ERROR* = not (my_ulonglong(0)):  /wrappers/mysql.     (line  36)
* CREATE_NO_WINDOW* = 0x08000000'i32:    /windows/winlean.    (line   9)
* CritBitTree*[T] = object:              /pure/collections/critbits.
                                                              (line   6)
* CRTSCTS* = 0o000000000000020000000000'i64: /posix/termios.  (line  18)
* CsvError* = object of IOError:         /pure/parsecsv.      (line   6)
* cuint* = cint:                         /wrappers/mysql.     (line  54)
* cuint32* {.importc: "unsigned int", nodecl.} = int: /pure/os.
                                                              (line  38)
* culong* {.importc: "unsigned long", nodecl.} = uint32: /system.
                                                              (line 142)
* DATA_TRUNCATED* = 101:                 /wrappers/mysql.     (line  48)
* DbColumns* = seq[DbColumn]:            /pure/db_common.     (line   6)
* dbgWatchpointHook*: proc (watchpointName: cstring) {.nimcall.}: /system/debugger.
                                                              (line   6)
* defUserAgent* = "Nim httpclient/" & NimVersion: /pure/httpclient.
                                                              (line   6)
* des_key_schedule* = array[1 .. 16, des_ks_struct]: /wrappers/openssl.
                                                              (line  12)
* DFA_RESTART* = 0x00020000:             /wrappers/pcre.      (line  15)
* DFA_SHORTEST* = 0x00010000:            /wrappers/pcre.      (line  12)
* DIR* {.importc: "DIR", header: "<dirent.h>", incompleteStruct.} = object: /posix/posix.
                                                              (line  68)
* DoublyLinkedRing*[T] = object:         /pure/collections/lists.
                                                              (line   6)
* DT_WHT* = 14:                          /posix/posix.        (line   6)
* DynlibFormat* = "lib$1.so":            /pure/ospaths.       (line   6)
* EncodingConverter* = ptr ConverterObj: /pure/encodings.     (line   6)
* EncodingError* = object of ValueError: /pure/encodings.     (line  11)
* Endianness* = enum:                    /system.             (line 122)
* Enum_field_types* = enum:              /wrappers/mysql.     (line  77)
* Enum_mysql_set_option* = enum:         /wrappers/mysql.     (line  92)
* Enum_server_command* = enum:           /wrappers/mysql.     (line  57)
* Enum_stmt_attr_type* = enum:           /wrappers/mysql.     (line 130)
* EParseError* = object of ValueError:   /packages/docutils/rst.
                                                              (line   9)
* EPOLLET* = 1 shl 31:                   /posix/epoll.        (line   6)
* EPOLL_CTL_MOD* = 3:                    /posix/epoll.        (line   9)
* epoll_event* {.importc: "struct epoll_event", header: "<sys/epoll.h>", pure, final.} = object: /posix/epoll.
                                                              (line  15)
* ErrorFunc* = proc (opaque: pointer; msg: cstring) {.cdecl.}: /wrappers/tinyc.
                                                              (line  14)
* errorMessageWriter*: (proc (msg: string) {.tags: [WriteIOEffect], benign.}): /system/excpt.
                                                              (line   6)
* ERROR_HANDLE_EOF* = 38:                /windows/winlean.    (line  24)
* ERROR_NETNAME_DELETED* = 64:           /windows/winlean.    (line  27)
* ERROR_UNSET* = - 33:                   /wrappers/pcre.      (line  21)
* EventError* = object of ValueError:    /pure/events.        (line  11)
* EventHandler* = tuple[name: string, handlers: seq[proc (e: EventArgs) {.closure.}]]: /pure/events.
                                                              (line   6)
* EVFILT_VM* = - 12:                     /posix/kqueue.       (line   6)
* EV_DISABLE* = 0x00000008:              /posix/kqueue.       (line   9)
* EV_DISPATCH* = 0x00000080:             /posix/kqueue.       (line  14)
* EV_ERROR* = 0x00004000:                /posix/kqueue.       (line  19)
* EWrongDocumentErr* = object of EDOMException: /pure/xmldom. (line   6)
* EXTPROC* = 0o000000200000:             /posix/termios.      (line  21)
* ExtraData* = object:                   /wrappers/pcre.      (line  51)
* EXTRA_EXECUTABLE_JIT* = 0x00000040:    /wrappers/pcre.      (line  42)
* ExtSep* = '.':                         /pure/ospaths.       (line  12)
* FE_DFL_ENV* {.importc, header: "<fenv.h>".}: cint: /pure/fenv.
                                                              (line   6)
* FIELD_OFFSET* = cuint:                 /wrappers/mysql.     (line 103)
* FileHandle* = cint:                    /system.             (line 182)
* FileId* = int64:                       /pure/os.            (line  41)
* FileInfo* = object:                    /pure/os.            (line  44)
* FilePermission* = enum:                /pure/os.            (line   6)
* FileStreamObj* = object of Stream:     /pure/streams.       (line  43)
* FILE_WRITE_DATA* = 0x00000002:         /windows/winlean.    (line  21)
* FindFileHandler* = proc (filename: string): string {.nimcall.}: /packages/docutils/rst.
                                                              (line   6)
* float64* {.magic: Float.}:             /system.             (line  80)
* FloatClass* = enum:                    /pure/math.          (line   6)
* FloatFormatMode* = enum:               /pure/strutils.      (line  24)
* FormatFlag* = enum:                    /pure/strtabs.       (line  11)
* FTPError* = object of IOError:         /deprecated/pure/ftpclient.
                                                              (line   6)
* FutureError* = object of Exception:    /pure/asyncdispatch. (line   6)
* GC_Strategy* = enum:                   /system.             (line 152)
* GetoptResult* = tuple[kind: CmdLineKind, key, val: TaintedString]: /pure/parseopt2.
                                                              (line  23)
* guarded* {.magic: "Guarded".}:         /system.             (line 115)
* GUID* {.final, pure.} = object:        /windows/winlean.    (line 101)
* Hash* = int:                           /pure/hashes.        (line   6)
* HashSet* {.myShallow.}[A] = object:    /pure/collections/sets.
                                                              (line   6)
* Hostent* = object:                     /pure/nativesockets. (line  12)
* HtmlTag* = enum:                       /pure/htmlparser.    (line   6)
* HttpMethod* = enum:                    /pure/httpclient.    (line  18)
* HttpParserSettings* {.pure, final, importc: "http_parser_settings",: /wrappers/joyent_http_parser.
                                                              (line   6)
* HttpRequestError* = object of IOError: /pure/httpclient.    (line  12)
* HttpVersion* = enum:                   /pure/asynchttpserver.
                                                              (line   6)
* Icallback* = proc (arg: PIhandle): cint {.cdecl.}: /wrappers/iup.
                                                              (line  30)
* in6addr_loopback* {.importc, header: "<netinet/in.h>".}: In6Addr: /posix/posix.
                                                              (line  62)
* IndexExt* = ".idx":                    /packages/docutils/rstgen.
                                                              (line   6)
* INFO_MATCH_EMPTY* = 25:                /wrappers/pcre.      (line  33)
* InotifyEvent* {.pure, final, importc: "struct inotify_event",: /posix/inotify.
                                                              (line  25)
* InstantRow* = object:                  /impure/db_mysql.    (line   6)
* InstantRow* = Pstmt:                   /impure/db_sqlite.   (line   6)
* InstantRow* = tuple[row: seq[string], len: int]: /impure/db_odbc.
                                                              (line   6)
* InterpolatedKind* = enum:              /pure/parseutils.    (line   6)
* IntSet* = object:                      /pure/collections/intsets.
                                                              (line   6)
* invalidSocket*: Socket = nil:          /deprecated/pure/sockets.
                                                              (line  14)
* INVALID_SOCKET* = SocketHandle(- 1):   /posix/posix.        (line  15)
* IN_ALL_EVENTS* = (IN_ACCESS or IN_MODIFY or IN_ATTRIB or IN_CLOSE_WRITE or: /posix/inotify.
                                                              (line  15)
* IN_IGNORED* = 0x00008000:              /posix/inotify.      (line   9)
* IN_MOVE_SELF* = 0x00000800:            /posix/inotify.      (line   6)
* IN_ONESHOT* = 0x0000000080000000'i64:  /posix/inotify.      (line  12)
* IOC_INOUT* = IOC_IN or IOC_OUT:        /windows/winlean.    (line  30)
* IpAddress* = object:                   /pure/net.           (line  23)
* Iparamcb* = proc (dialog: PIhandle; paramIndex: cint; userData: pointer): cint {.cdecl.}: /wrappers/iup.
                                                              (line  33)
* IUP_BUTTON5* = cint(ord('5')):         /wrappers/iup.       (line   9)
* IUP_MASK_UINT* = "/d+":                /wrappers/iup.       (line  12)
* IUP_SECONDARY* = - 2:                  /wrappers/iup.       (line  24)
* IUTF8* = 40000:                        /posix/termios.      (line  12)
* JitCallback* = proc (a: pointer): ptr JitStack {.cdecl.}: /wrappers/pcre.
                                                              (line 102)
* JitStack32* = object:                  /wrappers/pcre.      (line  48)
* JsonParser* = object of BaseLexer:     /pure/json.          (line   6)
* JsonParsingError* = object of ValueError: /pure/json.       (line  20)
* KEvent* {.importc: "struct kevent", header: "<sys/event.h>", pure, final.} = object: /posix/kqueue.
                                                              (line  27)
* KEY_EVENT* = 1:                        /impure/rdstdin.     (line   6)
* KEY_MODIFIER_NUMLOCK* = 8:             /wrappers/pdcurses.  (line   6)
* K_CR* = cint(13):                      /wrappers/iup.       (line  18)
* K_tilde* = cint(ord('~')):             /wrappers/iup.       (line  15)
* K_yAsterisk* = iUPyxCODE(K_asterisk):  /wrappers/iup.       (line  21)
* lc*: ListComprehension:                /pure/future.        (line   6)
* Level* = enum:                         /pure/logging.       (line  12)
* LibHandle* = pointer:                  /pure/dynlib.        (line   6)
* LIBSVM_VERSION* = 312:                 /wrappers/libsvm.    (line   6)
* LIO_WRITE* {.importc, header: "<aio.h>".}: cint: /posix/posix.
                                                              (line  24)
* LOCAL_HOST_NAMEDPIPE* = '.':           /wrappers/mysql.     (line   6)
* LOCAL_INFILE_ERROR_LEN* = 512:         /wrappers/mysql.     (line  45)
* LONG_DATA_HEADER* = 6:                 /wrappers/mysql.     (line  30)
* magicIdentSeparatorRuneByteWidth* = 3: /pure/etcpriv.       (line   6)
* MANAGER_INTERNAL_ERR* = 500:           /wrappers/mysql.     (line  42)
* MAP_POPULATE* {.importc, header: "<sys/mman.h>".}: cint: /posix/posix.
                                                              (line  46)
* MaxDistinguishedThread* = 32:          /pure/concurrency/threadpool.
                                                              (line   6)
* MAXIMUM_WAIT_OBJECTS* = 0x00000040:    /windows/winlean.    (line  18)
* MaxSubpatterns* = 20:                  /impure/re.          (line   6)
* MaxSubpatterns* = 20 <1>:              /pure/pegs.          (line   6)
* MAX_BLOB_WIDTH* = 8192:                /wrappers/mysql.     (line  15)
* MAX_PATH* = 260:                       /windows/winlean.    (line  12)
* MD5Context* {.final.} = object:        /pure/md5.           (line   6)
* MD5_CTX* = object:                     /wrappers/openssl.   (line  18)
* MD5_DIGEST_LENGTH* = 16:               /wrappers/openssl.   (line   6)
* MD5_LONG* = cuint:                     /wrappers/openssl.   (line  15)
* MemFile* = object:                     /pure/memfiles.      (line   6)
* MemProfilerHook* = proc (st: StackTrace; requestedSize: int) {.nimcall, benign.}: /system/profiler.
                                                              (line  26)
* MemSlice* = object:                    /pure/memfiles.      (line  31)
* MersenneTwister* = object:             /pure/mersenne.      (line   6)
* MimeDB* = object:                      /pure/mimetypes.     (line 482)
* mimes* = {"ez": "application/andrew-inset", "anx": "application/annodex",: /pure/mimetypes.
                                                              (line   6)
* MM_NOCON* {.importc, header: "<fmtmsg.h>".}: cint: /posix/posix.
                                                              (line  35)
* mode*: ScriptMode:                     /system/nimscript.   (line   6)
* Model* {.pure, final.} = object:       /wrappers/libsvm.    (line  39)
* MonitorEvent* = object:                /pure/fsmonitor.     (line   6)
* MSG_NOSIGNAL* = 0'i32:                 /posix/posix.        (line   9)
* MSG_OOB* {.importc, header: "<sys/socket.h>".}: cint: /posix/posix.
                                                              (line  41)
* NCCS* = 32:                            /posix/termios.      (line   6)
* NewLines* = {'\x0D', '\x0A'}:          /pure/lexbase.       (line   6)
* NimNode* {.magic: "PNimrodNode".} = ref NimNodeObj: /system.
                                                              (line 188)
* NimSym* = ref NimSymObj:               /core/macros.        (line  19)
* NimVersion*: string = $ NimMajor & "." & $ NimMinor & "." & $ NimPatch: /system.
                                                              (line  29)
* nimvm* {.magic: "Nimvm".}: bool = false: /system.           (line  37)
* nnkCallKinds* = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit}: /core/macros.
                                                              (line   6)
* NoFakeVars* = defined(nimscript):      /system.             (line  17)
* NULL_LENGTH*: int = int(not (0)):      /wrappers/mysql.     (line  27)
* off* = false:                          /system.             (line   6)
* Oid* = int32:                          /wrappers/postgres.  (line  12)
* Oid* = object:                         /pure/oids.          (line   6)
* OneVarFunction* = proc (x: float): float: /pure/numeric.    (line   6)
* ONLY_KILL_QUERY* = 1:                  /wrappers/mysql.     (line  12)
* Option* = enum:                        /wrappers/mysql.     (line 115)
* OptParser* = object of RootObj:        /pure/parseopt2.     (line   6)
* OptParser* = object of RootObj <1>:    /pure/parseopt.      (line   6)
* OrderedSet* {.myShallow.}[A] = object: /pure/collections/sets.
                                                              (line  18)
* OrderedTableRef*[A, B] = ref OrderedTable[A, B]: /pure/collections/tables.
                                                              (line   9)
* OSErrorCode* = distinct int32:         /pure/ospaths.       (line  21)
* osInvalidSocket* = winlean.INVALID_SOCKET: /pure/nativesockets.
                                                              (line   6)
* OsPlatform* {.pure.} = enum:           /system/platforms.   (line  40)
* outOfMemHook*: proc () {.nimcall, tags: [], benign.}: /system.
                                                              (line  53)
* OutputFormatCoff*: cint = 2:           /wrappers/tinyc.     (line   6)
* OutputLevel* = enum:                   /pure/unittest.      (line   6)
* packet_error* = - 1:                   /wrappers/mysql.     (line  18)
* PActor*[In, Out] = ptr Actor[In, Out]: /deprecated/pure/actors.
                                                              (line   6)
* PANEL* {.pure, final.} = object:       /wrappers/pdcurses.  (line  27)
* Parameter* {.pure, final.} = object:   /wrappers/libsvm.    (line  15)
* PAresChannel* = pointer:               /wrappers/libuv.     (line   6)
* PARTIAL* = 0x00008000:                 /wrappers/pcre.      (line   9)
* PathComponent* = enum:                 /pure/os.            (line  26)
* PathComponent* = enum <1>:             /pure/oswalkdir.     (line   6)
* PCRE_DATE* = "2014-09-26":             /wrappers/pcre.      (line   6)
* Peg* = Node:                           /pure/pegs.          (line  15)
* PGenTable*[T] = ref GenTable[T]:       /pure/gentabs.       (line   6)
* PInt32* = ptr int32:                   /system.             (line 147)
* PJitStack* {.deprecated.} = ptr JitStack: /wrappers/pcre.   (line 105)
* PMEM_ROOT* = ptr MEM_ROOT:             /wrappers/mysql.     (line 112)
* Pmy_ulonglong* = ptr my_ulonglong:     /wrappers/mysql.     (line 106)
* PNET* = ptr NET:                       /wrappers/mysql.     (line  74)
* pointer* {.magic: Pointer.}:           /system.             (line  91)
* POLLNVAL* {.importc, header: "<poll.h>".}: cshort: /posix/posix.
                                                              (line  54)
* Poly* = object:                        /pure/poly.          (line   6)
* POSIX_FADV_NOREUSE* {.importc, header: "<fcntl.h>".}: cint: /posix/posix.
                                                              (line  29)
* POSIX_SPAWN_SETSIGMASK* {.importc, header: "<spawn.h>".}: cint: /posix/posix.
                                                              (line  59)
* POSIX_SPAWN_USEVFORK* = cint(0x00000040): /posix/posix.     (line  12)
* poUseShell* {.deprecated.} = poUsePath: /pure/osproc.       (line   6)
* PQArgBlock* {.pure, final.} = object:  /wrappers/postgres.  (line  15)
* Process* = ref ProcessObj:             /pure/osproc.        (line  14)
* ProfilerHook* = proc (st: StackTrace) {.nimcall.}: /system/profiler.
                                                              (line  23)
* profilerHook*: MemProfilerHook:        /system/profiler.    (line  13)
* profilingRequestedHook*: proc (): bool {.nimcall, benign.}: /system/profiler.
                                                              (line   6)
* programResult* {.exportc: "nim_program_result".}: int: /system.
                                                              (line  46)
* ProgressChangedProc* = proc (total, progress: BiggestInt; speed: float): Future[void] {.: /pure/asyncftpclient.
                                                              (line   6)
* PSQLHANDLE* = ptr SqlHandle:           /wrappers/odbcsql.   (line  30)
* PSQL_TIMESTAMP_STRUCT* = ptr SQL_TIMESTAMP_STRUCT: /wrappers/odbcsql.
                                                              (line  33)
* PUDF_INIT* = ptr UDF_INIT:             /wrappers/mysql.     (line 100)
* PWOHandleArray* = ptr WOHandleArray:   /windows/winlean.    (line  98)
* Queue*[T] = object:                    /pure/collections/queues.
                                                              (line   6)
* quick_edit* {.importc: "pdc_quick_edit", dynlib: pdcursesdll.}: DWORD: /wrappers/pdcurses.
                                                              (line  21)
* QuitFailure* = 1:                      /system.             (line  23)
* Rational*[T] = object:                 /pure/rationals.     (line   6)
* ReadyInfo* = tuple[key: SelectorKey, events: set[Event]]: /pure/selectors.
                                                              (line   6)
* RegexError* = object of ValueError:    /impure/re.          (line  21)
* RequestMethod* = enum:                 /pure/cgi.           (line   6)
* requiresData*: seq[string] = @ []:     /system/nimscript.   (line  11)
* reURL* {.deprecated.} = r"\b(http(s)?|ftp|gopher|telnet|file|notes|ms-help)" &: /impure/re.
                                                              (line  12)
* RollingFileLogger* = ref object of FileLogger: /pure/logging.
                                                              (line  28)
* RomanNumeralDigits* = {'I', 'i', 'V', 'v', 'X', 'x', 'L', 'l', 'C', 'c', 'D', 'd', 'M', 'm'}: /pure/romans.
                                                              (line   6)
* ROW_OFFSET* = ROWS:                    /wrappers/mysql.     (line 109)
* RstNode* {.acyclic, final.} = object:  /packages/docutils/rstast.
                                                              (line   6)
* Rune16* = distinct int16:              /pure/unicode.       (line   6)
* RunningRegress* = object:              /pure/stats.         (line   6)
* ScgiError* = object of IOError:        /pure/scgi.          (line   6)
* screen* {.importc, nodecl.}: Screen:   /js/dom.             (line   6)
* SCREEN* {.pure, final.} = object:      /wrappers/pdcurses.  (line  43)
* ScriptMode* {.pure.} = enum:           /system/nimscript.   (line  19)
* SecureHash* = distinct Sha1Digest:     /pure/securehash.    (line   6)
* SecureSocket* = object:                /impure/ssl.         (line   6)
* Selector* = ref object:                /pure/selectors.     (line   9)
* SERVICENAME* = "MySQL":                /wrappers/mysql.     (line   9)
* set* {.magic: "Set".}[T]:              /system.             (line 102)
* SharedList*[A] = object:               /pure/collections/sharedlist.
                                                              (line   6)
* SharedString* = object:                /pure/collections/sharedstrings.
                                                              (line   6)
* SharedTable*[A, B] = object:           /pure/collections/sharedtables.
                                                              (line   6)
* SHUTDOWN_KILLABLE_UPDATE* = chr(1 shl 3): /wrappers/mysql.  (line  21)
* Slice*[T] = object:                    /system.             (line 107)
* Sockaddr* {.final.} = object:          /wrappers/mysql.     (line  97)
* SocketFlag* {.pure.} = enum:           /pure/net.           (line  18)
* SocketHandle* = distinct cint:         /posix/posix.        (line  75)
* SocketHandle* = distinct int:          /windows/winlean.    (line  92)
* SocketStatus* = enum:                  /deprecated/pure/asyncio.
                                                              (line   6)
* SockLen* = cuint:                      /windows/winlean.    (line  95)
* SomeNumber* = SomeInteger | SomeReal:  /system.             (line  97)
* SortOrder* = enum:                     /pure/algorithm.     (line   6)
* SourceLanguage* = enum:                /packages/docutils/highlite.
                                                              (line   6)
* SO_ERROR* {.importc, header: "winsock2.h".}: cint: /windows/winlean.
                                                              (line  39)
* SO_NOSIGPIPE* {.importc, header: "<sys/socket.h>".}: cint: /posix/posix.
                                                              (line  51)
* splitter*: string = "<wbr />":         /packages/docutils/rstgen.
                                                              (line  12)
* SQLITE_DETERMINISTIC* = 0x00000800:    /wrappers/sqlite3.   (line   6)
* SQLITE_TRANSIENT* = cast[pointer](- 1): /wrappers/sqlite3.  (line   9)
* SqlLexer* = object of BaseLexer:       /pure/parsesql.      (line   6)
* SqlNodeKind* = enum:                   /pure/parsesql.      (line  14)
* SqlParser* = object of SqlLexer:       /pure/parsesql.      (line  38)
* SqlPrepared* = distinct string:        /impure/db_postgres. (line   6)
* SQL_COLUMN_ALIAS* = 87:                /wrappers/odbcsql.   (line  24)
* SQL_GUID* = - 11:                      /wrappers/odbcsql.   (line   6)
* SQL_INTERVAL_MINUTE_TO_SECOND* = 100 + SQL_CODE_MINUTE_TO_SECOND: /wrappers/odbcsql.
                                                              (line   9)
* SQL_NO_TOTAL* = - 4:                   /wrappers/odbcsql.   (line  21)
* SQL_TYPE_MAX* = SQL_VARCHAR:           /wrappers/odbcsql.   (line  18)
* SQL_TYPE_NULL* = 0:                    /wrappers/odbcsql.   (line  15)
* SQL_UNICODE_CHAR* = SQL_UNICODE:       /wrappers/odbcsql.   (line  12)
* SSLAcceptResult* = enum:               /deprecated/pure/sockets.
                                                              (line  22)
* SslHandshakeType* = enum:              /pure/net.           (line  14)
* stderr* {.importc: "stderr", header: "<stdio.h>".}: File: /system.
                                                              (line  72)
* StreamObj* = object of RootObj:        /pure/streams.       (line   6)
* StringStreamObj* = object of StreamObj: /pure/streams.      (line  36)
* StringTableRef* = ref StringTableObj:  /pure/strtabs.       (line   6)
* StudyError* = ref object of RegexError: /impure/nre.        (line   6)
* STUDY_EXTRA_NEEDED* = 0x00000008:      /wrappers/pcre.      (line  39)
* Style* = enum:                         /pure/terminal.      (line   6)
* Subex* = distinct string:              /pure/subexes.       (line  11)
* SubexError* = object of ValueError:    /pure/subexes.       (line   6)
* svmdll* = "libsvm.dll":                /wrappers/libsvm.    (line   9)
* TableRef*[A, B] = ref Table[A, B]:     /pure/collections/tables.
                                                              (line   6)
* TaintedString* = distinct string:      /system.             (line 128)
* Taiocb* {.importc: "struct aiocb", header: "<aio.h>", final, pure.} = object: /posix/posix.
                                                              (line  97)
* TApplet* {.importc, deprecated.} = object of RootObj: /js/dom.
                                                              (line  15)
* targetCPU* = when defined(i386): CpuPlatform.i386: /system/platforms.
                                                              (line   6)
* TCIOFLUSH* = 2:                        /posix/termios.      (line  27)
* TCION* = 3:                            /posix/termios.      (line  24)
* TCSAFLUSH* = 2:                        /posix/termios.      (line  30)
* TerminalCmd* = enum:                   /pure/terminal.      (line  36)
* Termios* {.importc: "struct termios", header: "<termios.h>".} = object: /posix/termios.
                                                              (line  39)
* Tfexcept* {.importc: "fexcept_t", header: "<fenv.h>", final, pure.} = object: /pure/fenv.
                                                              (line  16)
* TFrame* {.importc, nodecl, final.} = object: /system.       (line 164)
* ThreadId* = range[0 .. MaxDistinguishedThread - 1]: /pure/concurrency/threadpool.
                                                              (line  14)
* ThreadId*[TArg] = ptr Thread[TArg]:    /system/threads.     (line   6)
* ThreadPoolState* = object:             /pure/concurrency/cpuload.
                                                              (line   6)
* TimeInterval* = object:                /pure/times.         (line  12)
* TimeoutError* = object of Exception:   /deprecated/pure/sockets.
                                                              (line  27)
* timezone* {.importc, header: "<time.h>".}: int: /posix/posix.
                                                              (line  21)
* TInterval* {.importc.} = object of RootObj: /js/dom.        (line  12)
* Tnfds* {.importc: "nfds_t", header: "<poll.h>".} = cint: /posix/posix.
                                                              (line 120)
* TNimSymKinds* {.deprecated.} = set[NimSymKind]: /core/macros.
                                                              (line  16)
* Tposix_spawn_file_actions* {.importc: "posix_spawn_file_actions_t",: /posix/posix.
                                                              (line 115)
* TResult* {.deprecated.} = enum:        /system.             (line 118)
* ttytype* {.importc: "ttytype", dynlib: pdcursesdll.}: cstring: /wrappers/pdcurses.
                                                              (line  18)
* TWSABuf* {.importc: "WSABUF", header: "winsock2.h".} = object: /windows/winlean.
                                                              (line 110)
* Ucontext* {.importc: "ucontext_t", header: "<ucontext.h>", final, pure.} = object: /posix/posix.
                                                              (line  78)
* UCP* = 0x20000000:                     /wrappers/pcre.      (line  18)
* UncheckedArray* {.unchecked.}[T] = array[0 .. 100000000, T]: /pure/collections/rtarrays.
                                                              (line   6)
* UnpackError* = ref object of ValueError: /pure/options.     (line   6)
* Uri* = object:                         /pure/uri.           (line   6)
* Url* = tuple[scheme, username, password, hostname, port, path, query, anchor: string]: /deprecated/pure/parseurl.
                                                              (line   6)
* useWinUnicode* = not defined(useWinAnsi): /windows/winlean. (line   6)
* UTF16_ERR4* = 4:                       /wrappers/pcre.      (line  27)
* UTF32_ERR3* = 3:                       /wrappers/pcre.      (line  30)
* UTF8_ERR22* = 22:                      /wrappers/pcre.      (line  24)
* Vector2d* = object:                    /pure/basic2d.       (line  14)
* Vector3d* = object:                    /pure/basic3d.       (line  14)
* VEOL2* = 16:                           /posix/termios.      (line   9)
* verboseFmtStr* = "$levelid, [$datetime] -- $appname: ": /pure/logging.
                                                              (line   6)
* WeekDay* = enum:                       /pure/times.         (line   6)
* WideCString* = ref array[0 .. 1000000, Utf16Char]: /system/widestrs.
                                                              (line   6)
* WIN32_FIND_DATA* {.pure.} = object:    /windows/winlean.    (line  73)
* WinChar* = Utf16Char:                  /windows/winlean.    (line  70)
* WSAEINPROGRESS* = 10036:               /windows/winlean.    (line  15)
* WSAID_GETACCEPTEXSOCKADDRS*: GUID = GUID(D1: 0xB5367DF2'i32, D2: 0xCBAC'i16,: /windows/winlean.
                                                              (line  42)
* XmlError* = object of ValueError:      /pure/xmlparser.     (line   6)
* xmlHeader* = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\x0A": /pure/xmltree.
                                                              (line   6)
* XmlParser* = object of BaseLexer:      /pure/parsexml.      (line   6)
* XTABS* = 14000:                        /posix/termios.      (line  15)
* YAXIS*: Vector2d = vector2d(0.0'f64, 1.0'f64): /pure/basic2d.
                                                              (line   6)
* ZAXIS*: Vector3d = vector3d(0.0'f64, 0.0'f64, 1.0'f64): /pure/basic3d.
                                                              (line   6)



Tag Table:
Node: Top89
Node: /system4057
Node: /prelude108356
Node: /nimrtl108444
Node: /impure/nre108536
Node: /impure/rdstdin113917
Node: /impure/re115847
Node: /impure/db_postgres123069
Node: /impure/osinfo_posix130802
Node: /impure/db_odbc130922
Node: /impure/osinfo_win136788
Node: /impure/db_mysql136903
Node: /impure/ssl141906
Node: /impure/db_sqlite142838
Node: /impure/nre/private/util148242
Node: /packages/docutils/rstast148587
Node: /packages/docutils/highlite150272
Node: /packages/docutils/rst151148
Node: /packages/docutils/rstgen152840
Node: /pure/future162140
Node: /pure/fsmonitor163299
Node: /pure/httpclient165539
Node: /pure/marshal178571
Node: /pure/pegs179146
Node: /pure/parsesql193192
Node: /pure/uri195598
Node: /pure/complex198404
Node: /pure/os204395
Node: /pure/stats230227
Node: /pure/typetraits235166
Node: /pure/parsexml235870
Node: /pure/unittest239643
Node: /pure/nimprof243490
Node: /pure/oswalkdir244012
Node: /pure/asyncnet245015
Node: /pure/xmldom252259
Node: /pure/unicode265608
Node: /pure/colors270025
Node: /pure/md5271966
Node: /pure/basic3d273180
Node: /pure/oids287121
Node: /pure/math288041
Node: /pure/securehash296977
Node: /pure/terminal297535
Node: /pure/parseopt2303012
Node: /pure/xmlparser305615
Node: /pure/fenv306889
Node: /pure/strutils313758
Node: /pure/asyncdispatch346191
Node: /pure/net355366
Node: /pure/dynlib372051
Node: /pure/romans373266
Node: /pure/options373897
Node: /pure/encodings375828
Node: /pure/etcpriv377224
Node: /pure/parsecsv377609
Node: /pure/coro379356
Node: /pure/numeric380342
Node: /pure/parsecfg381249
Node: /pure/times383255
Node: /pure/events401517
Node: /pure/basic2d403361
Node: /pure/strtabs418091
Node: /pure/db_common422185
Node: /pure/lexbase422923
Node: /pure/ropes425269
Node: /pure/asyncftpclient428408
Node: /pure/base64432436
Node: /pure/smtp433279
Node: /pure/xmltree436130
Node: /pure/mimetypes442700
Node: /pure/rationals477511
Node: /pure/selectors481971
Node: /pure/mersenne484262
Node: /pure/browsers484739
Node: /pure/parseopt485342
Node: /pure/memfiles487494
Node: /pure/asyncfile492872
Node: /pure/osproc494643
Node: /pure/endians504869
Node: /pure/nativesockets506000
Node: /pure/subexes513408
Node: /pure/json515111
Node: /pure/httpserver524607
Node: /pure/cgi526286
Node: /pure/htmlgen534684
Node: /pure/ospaths542879
Node: /pure/asynchttpserver551561
Node: /pure/streams553183
Node: /pure/htmlparser562571
Node: /pure/gentabs578069
Node: /pure/cookies579246
Node: /pure/poly580201
Node: /pure/matchers584881
Node: /pure/parseutils585759
Node: /pure/scgi593256
Node: /pure/hashes595610
Node: /pure/logging599016
Node: /pure/xmldomparser604403
Node: /pure/algorithm605034
Node: /pure/concurrency/cpuinfo610676
Node: /pure/concurrency/threadpool611035
Node: /pure/concurrency/cpuload615290
Node: /pure/unidecode/unidecode615880
Node: /pure/collections/sequtils616623
Node: /pure/collections/sharedtables631092
Node: /pure/collections/rtarrays633095
Node: /pure/collections/tables633548
Node: /pure/collections/sharedstrings654473
Node: /pure/collections/critbits655966
Node: /pure/collections/intsets661156
Node: /pure/collections/tableimpl662842
Node: /pure/collections/queues662984
Node: /pure/collections/sets664219
Node: /pure/collections/sharedlist680345
Node: /pure/collections/lists681089
Node: /deprecated/pure/rawsockets688202
Node: /deprecated/pure/sockets688687
Node: /deprecated/pure/parseurl711581
Node: /deprecated/pure/actors712172
Node: /deprecated/pure/asyncio715619
Node: /deprecated/pure/ftpclient723710
Node: /deprecated/core/unsigned728513
Node: /wrappers/libsvm728646
Node: /wrappers/pcre734046
Node: /wrappers/pdcurses742433
Node: /wrappers/tinyc824350
Node: /wrappers/iup828834
Node: /wrappers/sqlite3858744
Node: /wrappers/odbcsql881132
Node: /wrappers/libuv901117
Node: /wrappers/joyent_http_parser919777
Node: /wrappers/openssl922518
Node: /wrappers/postgres934565
Node: /wrappers/mysql954023
Node: /wrappers/linenoise/linenoise989741
Node: /windows/winlean991285
Node: /js/dom1020998
Node: /posix/inotify1028604
Node: /posix/linux1030716
Node: /posix/posix1031229
Node: /posix/termios1100309
Node: /posix/epoll1103330
Node: /posix/kqueue1106155
Node: /core/macros1108174
Node: /core/typeinfo1130412
Node: /core/locks1138506
Node: /system/avltree1139728
Node: /system/excpt1139833
Node: /system/gc_common1140433
Node: /system/assign1141168
Node: /system/sysspawn1141281
Node: /system/gc_ms1143006
Node: /system/cgprocs1143202
Node: /system/inclrtl1143311
Node: /system/repr1143419
Node: /system/gc1143522
Node: /system/dyncalls1144111
Node: /system/syslocks1144219
Node: /system/atomics1144332
Node: /system/sysio1155490
Node: /system/gc21155595
Node: /system/jssys1156183
Node: /system/reprjs1156937
Node: /system/profiler1157046
Node: /system/nimscript1157868
Node: /system/sysstr1163664
Node: /system/timers1163775
Node: /system/deepcopy1163885
Node: /system/embedded1163997
Node: /system/cellsets1164111
Node: /system/arithm1164223
Node: /system/debugger1164335
Node: /system/widestrs1166376
Node: /system/sets1167180
Node: /system/endb1167286
Node: /system/hti1167387
Node: /system/mmdisp1167490
Node: /system/channels1167597
Node: /system/platforms1169099
Node: /system/chcks1171329
Node: /system/threads1171440
Node: /system/ansi_c1172875
Node: /system/alloc1172983
Node: Command and Function Index1173289
Node: Variable Index1927346

End Tag Table
