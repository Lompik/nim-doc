@documentencoding UTF-8
@settitle The Nim Reference Manual
@ifnottex
@node Top
@top Nim info Manual
@end ifnottex
@defindex it

@menu

* /system::
* /deprecated/pure/parseurl::
* /deprecated/pure/ftpclient::
* /deprecated/pure/actors::
* /deprecated/pure/asyncio::
* /deprecated/pure/rawsockets::
* /deprecated/pure/sockets::
* /wrappers/pdcurses::
* /wrappers/odbcsql::
* /wrappers/openssl::
* /wrappers/iup::
* /wrappers/postgres::
* /wrappers/tinyc::
* /wrappers/pcre::
* /wrappers/sqlite3::
* /wrappers/mysql::
* /wrappers/joyent_http_parser::
* /wrappers/libuv::
* /wrappers/libsvm::
* /wrappers/linenoise/linenoise::
* /system/sysspawn::
* /system/threads::
* /system/gc::
* /system/profiler::
* /system/alloc::
* /system/gc2::
* /system/channels::
* /system/debugger::
* /system/atomics::
* /system/nimscript::
* /system/jssys::
* /system/excpt::
* /system/platforms::
* /system/gc_ms::
* /system/gc_common::
* /system/widestrs::
* /js/dom::
* /core/locks::
* /core/typeinfo::
* /core/macros::
* /windows/winlean::
* /posix/epoll::
* /posix/posix::
* /posix/inotify::
* /posix/termios::
* /posix/kqueue::
* /posix/linux::
* /packages/docutils/rstast::
* /packages/docutils/highlite::
* /packages/docutils/rst::
* /packages/docutils/rstgen::
* /pure/asyncnet::
* /pure/nimprof::
* /pure/future::
* /pure/parsecsv::
* /pure/options::
* /pure/asyncfile::
* /pure/htmlparser::
* /pure/basic3d::
* /pure/smtp::
* /pure/selectors::
* /pure/scgi::
* /pure/parsexml::
* /pure/lexbase::
* /pure/browsers::
* /pure/memfiles::
* /pure/parsecfg::
* /pure/base64::
* /pure/cgi::
* /pure/logging::
* /pure/subexes::
* /pure/mimetypes::
* /pure/poly::
* /pure/events::
* /pure/fenv::
* /pure/httpclient::
* /pure/asyncftpclient::
* /pure/parsesql::
* /pure/strutils::
* /pure/marshal::
* /pure/unittest::
* /pure/uri::
* /pure/parseopt2::
* /pure/romans::
* /pure/streams::
* /pure/basic2d::
* /pure/unicode::
* /pure/net::
* /pure/xmldomparser::
* /pure/securehash::
* /pure/md5::
* /pure/stats::
* /pure/times::
* /pure/typetraits::
* /pure/oswalkdir::
* /pure/osproc::
* /pure/dynlib::
* /pure/gentabs::
* /pure/numeric::
* /pure/hashes::
* /pure/nativesockets::
* /pure/xmldom::
* /pure/coro::
* /pure/db_common::
* /pure/xmltree::
* /pure/strtabs::
* /pure/algorithm::
* /pure/httpserver::
* /pure/etcpriv::
* /pure/math::
* /pure/complex::
* /pure/json::
* /pure/parseutils::
* /pure/terminal::
* /pure/oids::
* /pure/colors::
* /pure/ospaths::
* /pure/asynchttpserver::
* /pure/asyncdispatch::
* /pure/xmlparser::
* /pure/cookies::
* /pure/matchers::
* /pure/os::
* /pure/rationals::
* /pure/pegs::
* /pure/encodings::
* /pure/mersenne::
* /pure/htmlgen::
* /pure/endians::
* /pure/parseopt::
* /pure/ropes::
* /pure/fsmonitor::
* /pure/collections/queues::
* /pure/collections/LockFreeHash::
* /pure/collections/sequtils::
* /pure/collections/sharedtables::
* /pure/collections/lists::
* /pure/collections/sharedstrings::
* /pure/collections/critbits::
* /pure/collections/intsets::
* /pure/collections/sets::
* /pure/collections/rtarrays::
* /pure/collections/tables::
* /pure/collections/sharedlist::
* /pure/concurrency/cpuinfo::
* /pure/concurrency/cpuload::
* /pure/concurrency/threadpool::
* /pure/unidecode/unidecode::
* /impure/db_postgres::
* /impure/rdstdin::
* /impure/db_odbc::
* /impure/nre::
* /impure/ssl::
* /impure/db_sqlite::
* /impure/re::
* /impure/db_mysql::
* /impure/nre/private/util::


* Variable Index:: Variables
* Type Index:: Types
* Procedures Index:: Procedures, Macros and Templates
* Iterator Index:: Iterators
@end menu

hello!


@node /system, /deprecated/pure/parseurl , Top, Top
@chapter Constant variables

@itemize


@item off
  @vindex off* = false
@example
off* = false
@end example
  alias for @code{false}

@item appType
  @vindex appType* @{.magic꞉ "AppType".@}꞉ string = ""
@example
appType* @{.magic꞉ "AppType".@}꞉ string = ""
@end example
  a string that describes the application type. Possible values: "console", "gui", "lib".

@item NoFakeVars
  @vindex NoFakeVars* = defined(nimscript)
@example
NoFakeVars* = defined(nimscript)
@end example
  true if the backend doesn't support 
"fake variables" like 'var EBADF @{.importc.@}: cint'.

@item QuitFailure
  @vindex QuitFailure* = 1
@example
QuitFailure* = 1
@end example
  is the value that should be passed to @uref{#quit, quit} to indicate failure.

@item NimVersion
  @vindex NimVersion*꞉ string = $ NimMajor & "." & $ NimMinor & "." & $ NimPatch
@example
NimVersion*꞉ string = $ NimMajor & "." & $ NimMinor & "." & $ NimPatch
@end example
  is the version of Nim as a string.
@end itemize

@chapter Let variable

@itemize


@item nimvm
  @vindex nimvm* @{.magic꞉ "Nimvm".@}꞉ bool = false
@example
nimvm* @{.magic꞉ "Nimvm".@}꞉ bool = false
@end example
  may be used only in "when" expression. It is true in Nim VM context and false otherwise
@end itemize

@chapter Variables

@itemize


@item programResult
  @vindex programResult* @{.exportc꞉ "nim_program_result".@}꞉ int
@example
programResult* @{.exportc꞉ "nim_program_result".@}꞉ int
@end example
  modify this variable to specify the exit code of the program under normal circumstances. When the program is terminated prematurely using @code{quit}, this value is ignored.

@item outOfMemHook
  @vindex outOfMemHook*꞉ proc () @{.nimcall, tags꞉ [], benign.@}
@example
outOfMemHook*꞉ proc () @{.nimcall, tags꞉ [], benign.@}
@end example
  set this variable to provide a procedure that should be called in case of an  event. The standard handler writes an error message and terminates the program. @emph{outOfMemHook} can be used to raise an exception in case of OOM like so:
@example

var gOutOfMem: ref EOutOfMemory
new(gOutOfMem) # need to be allocated *before* OOM really happened!
gOutOfMem.msg = "out of memory"

proc handleOOM() =
  raise gOutOfMem

system.outOfMemHook = handleOOM
@end example
If the handler does not raise an exception, ordinary control flow continues and the program is terminated.

@item stderr
  @vindex stderr* @{.importc꞉ "stderr", header꞉ "<stdio.h>".@}꞉ File
@example
stderr* @{.importc꞉ "stderr", header꞉ "<stdio.h>".@}꞉ File
@end example
  The standard error stream.
@end itemize

@chapter Types

@itemize


@item float64
  @tindex float64* @{.magic꞉ Float.@}
@example
float64* @{.magic꞉ Float.@}
@end example
  64 bit floating point type

@item bool
  @tindex bool* @{.magic꞉ Bool.@} = enumfalse = 0, true = 1
@example
bool* @{.magic꞉ Bool.@} = enumfalse = 0, true = 1
@end example
  built-in boolean type

@item pointer
  @tindex pointer* @{.magic꞉ Pointer.@}
@example
pointer* @{.magic꞉ Pointer.@}
@end example
  built-in pointer type, use the @code{addr} operator to get a pointer to a variable

@item SomeNumber
  @tindex SomeNumber* = SomeInteger | SomeReal
@example
SomeNumber* = SomeInteger | SomeReal
@end example
  type class matching all number types

@item set
  @tindex set* @{.magic꞉ "Set".@}[T]
@example
set* @{.magic꞉ "Set".@}[T]
@end example
  Generic type to construct bit sets.

@item Slice
  @tindex Slice*[T] = objecta*, b*꞉ T                     ## the bounds
@example
Slice*[T] = objecta*, b*꞉ T                     ## the bounds
@end example
  builtin slice type

@item guarded
  @tindex guarded* @{.magic꞉ "Guarded".@}
@example
guarded* @{.magic꞉ "Guarded".@}
@end example
  

@item TResult
  @tindex TResult* @{.deprecated.@} = enumFailure, Success
@example
TResult* @{.deprecated.@} = enumFailure, Success
@end example
  

@item Endianness
  @tindex Endianness* = enumlittleEndian, bigEndian
@example
Endianness* = enumlittleEndian, bigEndian
@end example
  is a type describing the endianness of a processor.

@item TaintedString
  @tindex TaintedString* = distinct string
@example
TaintedString* = distinct string
@end example
  a distinct string type that is . It is an alias for @code{string} if the taint mode is not turned on. Use the @code{-d:taintMode} command line switch to turn the taint mode on.

@item BiggestFloat
  @tindex BiggestFloat* = float64
@example
BiggestFloat* = float64
@end example
  is an alias for the biggest floating point type the Nim compiler supports. Currently this is @code{float64}, but it is platform-dependant in general.

@item culong
  @tindex culong* @{.importc꞉ "unsigned long", nodecl.@} = uint32
@example
culong* @{.importc꞉ "unsigned long", nodecl.@} = uint32
@end example
  This is the same as the type @code{unsigned long} in @emph{C}.

@item PInt32
  @tindex PInt32* = ptr int32
@example
PInt32* = ptr int32
@end example
  an alias for @code{ptr int32}

@item GC_Strategy
  @tindex GC_Strategy* = enum
  gcThroughput,               ## optimize for throughput
  gcResponsiveness,           ## optimize for responsiveness (default)
  gcOptimizeTime,             ## optimize for speed
  gcOptimizeSpace             ## optimize for memory footprint
@example
GC_Strategy* = enum
  gcThroughput,               ## optimize for throughput
  gcResponsiveness,           ## optimize for responsiveness (default)
  gcOptimizeTime,             ## optimize for speed
  gcOptimizeSpace             ## optimize for memory footprint
@end example
  the strategy the GC should use for the application

@item TFrame
  @tindex TFrame* @{.importc, nodecl, final.@} = object
  prev*: PFrame                ## previous frame; used for chaining the call stack
  procname*: cstring           ## name of the proc that is currently executing
  line*: int                   ## line number of the proc that is currently executing
  filename*: cstring           ## filename of the proc that is currently executing
  len*: int16                  ## length of the inspectable slots
  calldepth*: int16            ## used for max call depth checking
  
@example
TFrame* @{.importc, nodecl, final.@} = object
  prev*: PFrame                ## previous frame; used for chaining the call stack
  procname*: cstring           ## name of the proc that is currently executing
  line*: int                   ## line number of the proc that is currently executing
  filename*: cstring           ## filename of the proc that is currently executing
  len*: int16                  ## length of the inspectable slots
  calldepth*: int16            ## used for max call depth checking
  
@end example
  the frame itself

@item FileHandle
  @tindex FileHandle* = cint
@example
FileHandle* = cint
@end example
  type that represents an OS file handle; this is useful for low-level file access

@item NimNode
  @tindex NimNode* @{.magic꞉ "PNimrodNode".@} = ref NimNodeObj
@example
NimNode* @{.magic꞉ "PNimrodNode".@} = ref NimNodeObj
@end example
  represents a Nim AST node. Macros operate on this type.
@end itemize

@chapter Procedures

@itemize


@item defined
  @findex proc defined*(x꞉ expr)꞉ bool @{.magic꞉ "Defined", noSideEffect, compileTime.@}
@example
proc defined*(x꞉ expr)꞉ bool @{.magic꞉ "Defined", noSideEffect, compileTime.@}
@end example
  Special compile-time procedure that checks whether @emph{x} is defined. @emph{x} is an external symbol introduced through the compiler's @uref{nimc.html#compile-time-symbols, -d:x switch} to enable build time conditionals:
@example
when not defined(release):
  # Do here programmer friendly expensive sanity checks.
# Put here the normal code
@end example

@item declared
  @findex proc declared*(x꞉ expr)꞉ bool @{.magic꞉ "Defined", noSideEffect, compileTime.@}
@example
proc declared*(x꞉ expr)꞉ bool @{.magic꞉ "Defined", noSideEffect, compileTime.@}
@end example
  Special compile-time procedure that checks whether @emph{x} is declared. @emph{x} has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:
@example
when not declared(strutils.toUpper):
  # provide our own toUpper proc here, because strutils is
  # missing it.
@end example

@item definedInScope
  @findex proc definedInScope*(x꞉ expr)꞉ bool @{.magic꞉ "DefinedInScope", noSideEffect,deprecated, compileTime.@}
@example
proc definedInScope*(x꞉ expr)꞉ bool @{.magic꞉ "DefinedInScope", noSideEffect,deprecated, compileTime.@}
@end example
  @strong{Deprecated since version 0.9.6}: Use @code{declaredInScope} instead.

@item declaredInScope
  @findex proc declaredInScope*(x꞉ expr)꞉ bool @{.magic꞉ "DefinedInScope", noSideEffect,compileTime.@}
@example
proc declaredInScope*(x꞉ expr)꞉ bool @{.magic꞉ "DefinedInScope", noSideEffect,compileTime.@}
@end example
  Special compile-time procedure that checks whether @emph{x} is declared in the current scope. @emph{x} has to be an identifier.

@item `addr`
  @findex proc `addr`*[T](x꞉ var T)꞉ ptr T @{.magic꞉ "Addr", noSideEffect.@}
@example
proc `addr`*[T](x꞉ var T)꞉ ptr T @{.magic꞉ "Addr", noSideEffect.@}
@end example
  Builtin 'addr' operator for taking the address of a memory location. Cannot be overloaded.
@example
var
  buf: seq[char] = @@['a','b','c']
  p: pointer = buf[1].addr
echo cast[ptr char](p)[]    # b
@end example

@item unsafeAddr
  @findex proc unsafeAddr*[T](x꞉ var T)꞉ ptr T @{.magic꞉ "Addr", noSideEffect.@}
@example
proc unsafeAddr*[T](x꞉ var T)꞉ ptr T @{.magic꞉ "Addr", noSideEffect.@}
@end example
  Builtin 'addr' operator for taking the address of a memory location. This works even for @code{let} variables or parameters for better interop with C and so it is considered even more unsafe than the ordinary @code{addr}. Cannot be overloaded.

@item `type`
  @findex proc `type`*(x꞉ expr)꞉ typeDesc @{.magic꞉ "TypeOf", noSideEffect, compileTime.@}
@example
proc `type`*(x꞉ expr)꞉ typeDesc @{.magic꞉ "TypeOf", noSideEffect, compileTime.@}
@end example
  Builtin 'type' operator for accessing the type of an expression. Cannot be overloaded.

@item `not`
  @findex proc `not`*(x꞉ bool)꞉ bool @{.magic꞉ "Not", noSideEffect.@}
@example
proc `not`*(x꞉ bool)꞉ bool @{.magic꞉ "Not", noSideEffect.@}
@end example
  Boolean not; returns true iff @code{x == false}.

@item `and`
  @findex proc `and`*(x, y꞉ bool)꞉ bool @{.magic꞉ "And", noSideEffect.@}
@example
proc `and`*(x, y꞉ bool)꞉ bool @{.magic꞉ "And", noSideEffect.@}
@end example
  Boolean @code{and}; returns true iff @code{x == y == true}. Evaluation is lazy: if @code{x} is false, @code{y} will not even be evaluated.

@item `or`
  @findex proc `or`*(x, y꞉ bool)꞉ bool @{.magic꞉ "Or", noSideEffect.@}
@example
proc `or`*(x, y꞉ bool)꞉ bool @{.magic꞉ "Or", noSideEffect.@}
@end example
  Boolean @code{or}; returns true iff @code{not (not x and not y)}. Evaluation is lazy: if @code{x} is true, @code{y} will not even be evaluated.

@item `xor`
  @findex proc `xor`*(x, y꞉ bool)꞉ bool @{.magic꞉ "Xor", noSideEffect.@}
@example
proc `xor`*(x, y꞉ bool)꞉ bool @{.magic꞉ "Xor", noSideEffect.@}
@end example
  Boolean @emph{exclusive or}; returns true iff @code{x != y}.

@item new
  @findex proc new*[T](a꞉ var ref T) @{.magic꞉ "New", noSideEffect.@}
@example
proc new*[T](a꞉ var ref T) @{.magic꞉ "New", noSideEffect.@}
@end example
  creates a new object of type @code{T} and returns a safe (traced) reference to it in @code{a}.

@item new
  @findex proc new*(T꞉ typedesc)꞉ auto
@example
proc new*(T꞉ typedesc)꞉ auto
@end example
  creates a new object of type @code{T} and returns a safe (traced) reference to it as result value.

When @code{T} is a ref type then the resulting type will be @code{T}, otherwise it will be @code{ref T}.

@item internalNew
  @findex proc internalNew*[T](a꞉ var ref T) @{.magic꞉ "New", noSideEffect.@}
@example
proc internalNew*[T](a꞉ var ref T) @{.magic꞉ "New", noSideEffect.@}
@end example
  leaked implementation detail. Do not use.

@item new
  @findex proc new*[T](a꞉ var ref T; finalizer꞉ proc (x꞉ ref T) @{.nimcall.@}) @{.magic꞉ "NewFinalize",noSideEffect.@}
@example
proc new*[T](a꞉ var ref T; finalizer꞉ proc (x꞉ ref T) @{.nimcall.@}) @{.magic꞉ "NewFinalize",noSideEffect.@}
@end example
  creates a new object of type @code{T} and returns a safe (traced) reference to it in @code{a}. When the garbage collector frees the object, @emph{finalizer} is called. The @emph{finalizer} may not keep a reference to the object pointed to by @emph{x}. The @emph{finalizer} cannot prevent the GC from freeing the object. Note: The @emph{finalizer} refers to the type @emph{T}, not to the object! This means that for each object of type @emph{T} the finalizer will be called!

@item reset
  @findex proc reset*[T](obj꞉ var T) @{.magic꞉ "Reset", noSideEffect.@}
@example
proc reset*[T](obj꞉ var T) @{.magic꞉ "Reset", noSideEffect.@}
@end example
  resets an object @emph{obj} to its initial (binary zero) value. This needs to be called before any possible .

@item high
  @findex proc high*[T](x꞉ T)꞉ T @{.magic꞉ "High", noSideEffect.@}
@example
proc high*[T](x꞉ T)꞉ T @{.magic꞉ "High", noSideEffect.@}
@end example
  returns the highest possible index of an array, a sequence, a string or the highest possible value of an ordinal value @emph{x}. As a special semantic rule, @emph{x} may also be a type identifier. @code{high(int)} is Nim's way of writing  or .
@example
var arr = [1,2,3,4,5,6,7]
high(arr) #=> 6
high(2) #=> 9223372036854775807
@end example

@item low
  @findex proc low*[T](x꞉ T)꞉ T @{.magic꞉ "Low", noSideEffect.@}
@example
proc low*[T](x꞉ T)꞉ T @{.magic꞉ "Low", noSideEffect.@}
@end example
  returns the lowest possible index of an array, a sequence, a string or the lowest possible value of an ordinal value @emph{x}. As a special semantic rule, @emph{x} may also be a type identifier.
@example
var arr = [1,2,3,4,5,6,7]
low(arr) #=> 0
low(2) #=> -9223372036854775808
@end example

@item `[]`
  @findex proc `[]`*[I꞉ Ordinal, T](a꞉ T; i꞉ I)꞉ T @{.noSideEffect, magic꞉ "ArrGet".@}
@example
proc `[]`*[I꞉ Ordinal, T](a꞉ T; i꞉ I)꞉ T @{.noSideEffect, magic꞉ "ArrGet".@}
@end example
  

@item `[]=`
  @findex proc `[]=`*[I꞉ Ordinal, T, S](a꞉ T; i꞉ I; x꞉ S) @{.noSideEffect, magic꞉ "ArrPut".@}
@example
proc `[]=`*[I꞉ Ordinal, T, S](a꞉ T; i꞉ I; x꞉ S) @{.noSideEffect, magic꞉ "ArrPut".@}
@end example
  

@item `=`
  @findex proc `=`*[T](dest꞉ var T; src꞉ T) @{.noSideEffect, magic꞉ "Asgn".@}
@example
proc `=`*[T](dest꞉ var T; src꞉ T) @{.noSideEffect, magic꞉ "Asgn".@}
@end example
  

@item `..`
  @findex proc `..`*[T](a, b꞉ T)꞉ Slice[T] @{.noSideEffect, inline, magic꞉ "DotDot".@}
@example
proc `..`*[T](a, b꞉ T)꞉ Slice[T] @{.noSideEffect, inline, magic꞉ "DotDot".@}
@end example
  operator that constructs an interval @code{[a, b]}, both @emph{a} and @emph{b} are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.

@item `..`
  @findex proc `..`*[T](b꞉ T)꞉ Slice[T] @{.noSideEffect, inline, magic꞉ "DotDot".@}
@example
proc `..`*[T](b꞉ T)꞉ Slice[T] @{.noSideEffect, inline, magic꞉ "DotDot".@}
@end example
  operator that constructs an interval @code{[default(T), b]}

@item `==`
  @findex proc `==`*[Enum꞉ enum](x, y꞉ Enum)꞉ bool @{.magic꞉ "EqEnum", noSideEffect.@}
@example
proc `==`*[Enum꞉ enum](x, y꞉ Enum)꞉ bool @{.magic꞉ "EqEnum", noSideEffect.@}
@end example
  Checks whether values within the @emph{same enum} have the same underlying value
@example
type
  Enum1 = enum
    Field1 = 3, Field2
  Enum2 = enum
    Place1, Place2 = 3
var
  e1 = Field1
  e2 = Enum1(Place2)
echo (e1 == e2) # true
echo (e1 == Place2) # raises error
@end example

@item `==`
  @findex proc `==`*(x, y꞉ pointer)꞉ bool @{.magic꞉ "EqRef", noSideEffect.@}
@example
proc `==`*(x, y꞉ pointer)꞉ bool @{.magic꞉ "EqRef", noSideEffect.@}
@end example
  @example
var # this is a wildly dangerous example
  a = cast[pointer](0)
  b = cast[pointer](nil)
echo (a == b) # true due to the special meaning of `nil`/0 as a pointer
@end example

@item `==`
  @findex proc `==`*(x, y꞉ string)꞉ bool @{.magic꞉ "EqStr", noSideEffect.@}
@example
proc `==`*(x, y꞉ string)꞉ bool @{.magic꞉ "EqStr", noSideEffect.@}
@end example
  Checks for equality between two @emph{string} variables

@item `==`
  @findex proc `==`*(x, y꞉ cstring)꞉ bool @{.magic꞉ "EqCString", noSideEffect.@}
@example
proc `==`*(x, y꞉ cstring)꞉ bool @{.magic꞉ "EqCString", noSideEffect.@}
@end example
  Checks for equality between two @emph{cstring} variables

@item `==`
  @findex proc `==`*(x, y꞉ char)꞉ bool @{.magic꞉ "EqCh", noSideEffect.@}
@example
proc `==`*(x, y꞉ char)꞉ bool @{.magic꞉ "EqCh", noSideEffect.@}
@end example
  Checks for equality between two @emph{char} variables

@item `==`
  @findex proc `==`*(x, y꞉ bool)꞉ bool @{.magic꞉ "EqB", noSideEffect.@}
@example
proc `==`*(x, y꞉ bool)꞉ bool @{.magic꞉ "EqB", noSideEffect.@}
@end example
  Checks for equality between two @emph{bool} variables

@item `==`
  @findex proc `==`*[T](x, y꞉ set[T])꞉ bool @{.magic꞉ "EqSet", noSideEffect.@}
@example
proc `==`*[T](x, y꞉ set[T])꞉ bool @{.magic꞉ "EqSet", noSideEffect.@}
@end example
  Checks for equality between two variables of type @emph{set}
@example
var a = @{1, 2, 2, 3@} # duplication in sets is ignored
var b = @{1, 2, 3@}
echo (a == b) # true
@end example

@item `==`
  @findex proc `==`*[T](x, y꞉ ref T)꞉ bool @{.magic꞉ "EqRef", noSideEffect.@}
@example
proc `==`*[T](x, y꞉ ref T)꞉ bool @{.magic꞉ "EqRef", noSideEffect.@}
@end example
  Checks that two @emph{ref} variables refer to the same item

@item `==`
  @findex proc `==`*[T](x, y꞉ ptr T)꞉ bool @{.magic꞉ "EqRef", noSideEffect.@}
@example
proc `==`*[T](x, y꞉ ptr T)꞉ bool @{.magic꞉ "EqRef", noSideEffect.@}
@end example
  Checks that two @emph{ptr} variables refer to the same item

@item `==`
  @findex proc `==`*[T꞉ proc](x, y꞉ T)꞉ bool @{.magic꞉ "EqProc", noSideEffect.@}
@example
proc `==`*[T꞉ proc](x, y꞉ T)꞉ bool @{.magic꞉ "EqProc", noSideEffect.@}
@end example
  Checks that two @emph{proc} variables refer to the same procedure

@item `<=`
  @findex proc `<=`*[Enum꞉ enum](x, y꞉ Enum)꞉ bool @{.magic꞉ "LeEnum", noSideEffect.@}
@example
proc `<=`*[Enum꞉ enum](x, y꞉ Enum)꞉ bool @{.magic꞉ "LeEnum", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ string)꞉ bool @{.magic꞉ "LeStr", noSideEffect.@}
@example
proc `<=`*(x, y꞉ string)꞉ bool @{.magic꞉ "LeStr", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ char)꞉ bool @{.magic꞉ "LeCh", noSideEffect.@}
@example
proc `<=`*(x, y꞉ char)꞉ bool @{.magic꞉ "LeCh", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*[T](x, y꞉ set[T])꞉ bool @{.magic꞉ "LeSet", noSideEffect.@}
@example
proc `<=`*[T](x, y꞉ set[T])꞉ bool @{.magic꞉ "LeSet", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ bool)꞉ bool @{.magic꞉ "LeB", noSideEffect.@}
@example
proc `<=`*(x, y꞉ bool)꞉ bool @{.magic꞉ "LeB", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*[T](x, y꞉ ref T)꞉ bool @{.magic꞉ "LePtr", noSideEffect.@}
@example
proc `<=`*[T](x, y꞉ ref T)꞉ bool @{.magic꞉ "LePtr", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ pointer)꞉ bool @{.magic꞉ "LePtr", noSideEffect.@}
@example
proc `<=`*(x, y꞉ pointer)꞉ bool @{.magic꞉ "LePtr", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*[Enum꞉ enum](x, y꞉ Enum)꞉ bool @{.magic꞉ "LtEnum", noSideEffect.@}
@example
proc `<`*[Enum꞉ enum](x, y꞉ Enum)꞉ bool @{.magic꞉ "LtEnum", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ string)꞉ bool @{.magic꞉ "LtStr", noSideEffect.@}
@example
proc `<`*(x, y꞉ string)꞉ bool @{.magic꞉ "LtStr", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ char)꞉ bool @{.magic꞉ "LtCh", noSideEffect.@}
@example
proc `<`*(x, y꞉ char)꞉ bool @{.magic꞉ "LtCh", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*[T](x, y꞉ set[T])꞉ bool @{.magic꞉ "LtSet", noSideEffect.@}
@example
proc `<`*[T](x, y꞉ set[T])꞉ bool @{.magic꞉ "LtSet", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ bool)꞉ bool @{.magic꞉ "LtB", noSideEffect.@}
@example
proc `<`*(x, y꞉ bool)꞉ bool @{.magic꞉ "LtB", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*[T](x, y꞉ ref T)꞉ bool @{.magic꞉ "LtPtr", noSideEffect.@}
@example
proc `<`*[T](x, y꞉ ref T)꞉ bool @{.magic꞉ "LtPtr", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*[T](x, y꞉ ptr T)꞉ bool @{.magic꞉ "LtPtr", noSideEffect.@}
@example
proc `<`*[T](x, y꞉ ptr T)꞉ bool @{.magic꞉ "LtPtr", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ pointer)꞉ bool @{.magic꞉ "LtPtr", noSideEffect.@}
@example
proc `<`*(x, y꞉ pointer)꞉ bool @{.magic꞉ "LtPtr", noSideEffect.@}
@end example
  

@item unsafeNew
  @findex proc unsafeNew*[T](a꞉ var ref T; size꞉ Natural) @{.magic꞉ "New", noSideEffect.@}
@example
proc unsafeNew*[T](a꞉ var ref T; size꞉ Natural) @{.magic꞉ "New", noSideEffect.@}
@end example
  creates a new object of type @code{T} and returns a safe (traced) reference to it in @code{a}. This is @strong{unsafe} as it allocates an object of the passed @code{size}. This should only be used for optimization purposes when you know what you're doing!

@item sizeof
  @findex proc sizeof*[T](x꞉ T)꞉ int @{.magic꞉ "SizeOf", noSideEffect.@}
@example
proc sizeof*[T](x꞉ T)꞉ int @{.magic꞉ "SizeOf", noSideEffect.@}
@end example
  returns the size of @code{x} in bytes. Since this is a low-level proc, its usage is discouraged - using @code{new} for the most cases suffices that one never needs to know @code{x}'s size. As a special semantic rule, @code{x} may also be a type identifier (@code{sizeof(int)} is valid).
@example
sizeof('A') #=> 1
sizeof(2) #=> 8
@end example

@item sizeof
  @findex proc sizeof*(x꞉ typedesc)꞉ int @{.magic꞉ "SizeOf", noSideEffect.@}
@example
proc sizeof*(x꞉ typedesc)꞉ int @{.magic꞉ "SizeOf", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*[T](x꞉ Ordinal[T])꞉ T @{.magic꞉ "UnaryLt", noSideEffect.@}
@example
proc `<`*[T](x꞉ Ordinal[T])꞉ T @{.magic꞉ "UnaryLt", noSideEffect.@}
@end example
  unary @code{<} that can be used for nice looking excluding ranges:
@example
for i in 0 .. <10: echo i
@end example
Semantically this is the same as @code{pred}.

@item succ
  @findex proc succ*[T](x꞉ Ordinal[T]; y = 1)꞉ T @{.magic꞉ "Succ", noSideEffect.@}
@example
proc succ*[T](x꞉ Ordinal[T]; y = 1)꞉ T @{.magic꞉ "Succ", noSideEffect.@}
@end example
  returns the @code{y}-th successor of the value @code{x}. @code{T} has to be an ordinal type. If such a value does not exist, @code{EOutOfRange} is raised or a compile time error occurs.

@item pred
  @findex proc pred*[T](x꞉ Ordinal[T]; y = 1)꞉ T @{.magic꞉ "Pred", noSideEffect.@}
@example
proc pred*[T](x꞉ Ordinal[T]; y = 1)꞉ T @{.magic꞉ "Pred", noSideEffect.@}
@end example
  returns the @code{y}-th predecessor of the value @code{x}. @code{T} has to be an ordinal type. If such a value does not exist, @code{EOutOfRange} is raised or a compile time error occurs.

@item inc
  @findex proc inc*[T꞉ Ordinal | uint | uint64](x꞉ var T; y = 1) @{.magic꞉ "Inc", noSideEffect.@}
@example
proc inc*[T꞉ Ordinal | uint | uint64](x꞉ var T; y = 1) @{.magic꞉ "Inc", noSideEffect.@}
@end example
  increments the ordinal @code{x} by @code{y}. If such a value does not exist, @code{EOutOfRange} is raised or a compile time error occurs. This is a short notation for: @code{x = succ(x, y)}.
@example
var i = 2
inc(i) #=> 3
inc(i, 3) #=> 6
@end example

@item dec
  @findex proc dec*[T꞉ Ordinal | uint | uint64](x꞉ var T; y = 1) @{.magic꞉ "Dec", noSideEffect.@}
@example
proc dec*[T꞉ Ordinal | uint | uint64](x꞉ var T; y = 1) @{.magic꞉ "Dec", noSideEffect.@}
@end example
  decrements the ordinal @code{x} by @code{y}. If such a value does not exist, @code{EOutOfRange} is raised or a compile time error occurs. This is a short notation for: @code{x = pred(x, y)}.
@example
var i = 2
dec(i) #=> 1
dec(i, 3) #=> -2
@end example

@item newSeq
  @findex proc newSeq*[T](s꞉ var seq[T]; len꞉ Natural) @{.magic꞉ "NewSeq", noSideEffect.@}
@example
proc newSeq*[T](s꞉ var seq[T]; len꞉ Natural) @{.magic꞉ "NewSeq", noSideEffect.@}
@end example
  creates a new sequence of type @code{seq[T]} with length @code{len}. This is equivalent to @code{s = @@[]; setlen(s, len)}, but more efficient since no reallocation is needed.

Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be @code{nil}. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:


@example
var inputStrings : seq[string]
newSeq(inputStrings, 3)
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"
@end example

@item newSeq
  @findex proc newSeq*[T](len = 0.Natural)꞉ seq[T]
@example
proc newSeq*[T](len = 0.Natural)꞉ seq[T]
@end example
  creates a new sequence of type @code{seq[T]} with length @code{len}.

Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be @code{nil}. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:


@example
var inputStrings = newSeq[string](3)
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"
@end example

@item len
  @findex proc len*[TOpenArray꞉ openArray | varargs](x꞉ TOpenArray)꞉ int @{.magic꞉ "LengthOpenArray", noSideEffect.@}
@example
proc len*[TOpenArray꞉ openArray | varargs](x꞉ TOpenArray)꞉ int @{.magic꞉ "LengthOpenArray", noSideEffect.@}
@end example
  

@item len
  @findex proc len*(x꞉ string)꞉ int @{.magic꞉ "LengthStr", noSideEffect.@}
@example
proc len*(x꞉ string)꞉ int @{.magic꞉ "LengthStr", noSideEffect.@}
@end example
  

@item len
  @findex proc len*(x꞉ cstring)꞉ int @{.magic꞉ "LengthStr", noSideEffect.@}
@example
proc len*(x꞉ cstring)꞉ int @{.magic꞉ "LengthStr", noSideEffect.@}
@end example
  

@item len
  @findex proc len*[I, T](x꞉ array[I, T])꞉ int @{.magic꞉ "LengthArray", noSideEffect.@}
@example
proc len*[I, T](x꞉ array[I, T])꞉ int @{.magic꞉ "LengthArray", noSideEffect.@}
@end example
  

@item len
  @findex proc len*[T](x꞉ seq[T])꞉ int @{.magic꞉ "LengthSeq", noSideEffect.@}
@example
proc len*[T](x꞉ seq[T])꞉ int @{.magic꞉ "LengthSeq", noSideEffect.@}
@end example
  returns the length of an array, an openarray, a sequence or a string. This is roughly the same as @code{high(T)-low(T)+1}, but its resulting type is always an int.
@example
var arr = [1,1,1,1,1]
len(arr) #=> 5
for i in 0..<arr.len:
  echo arr[i] #=> 1,1,1,1,1
@end example

@item incl
  @findex proc incl*[T](x꞉ var set[T]; y꞉ T) @{.magic꞉ "Incl", noSideEffect.@}
@example
proc incl*[T](x꞉ var set[T]; y꞉ T) @{.magic꞉ "Incl", noSideEffect.@}
@end example
  includes element @code{y} to the set @code{x}. This is the same as @code{x = x + @{y@}}, but it might be more efficient.
@example
var a = initSet[int](4)
a.incl(2) #=> @{2@}
a.incl(3) #=> @{2, 3@}
@end example

@item excl
  @findex proc excl*[T](x꞉ var set[T]; y꞉ T) @{.magic꞉ "Excl", noSideEffect.@}
@example
proc excl*[T](x꞉ var set[T]; y꞉ T) @{.magic꞉ "Excl", noSideEffect.@}
@end example
  excludes element @code{y} to the set @code{x}. This is the same as @code{x = x - @{y@}}, but it might be more efficient.
@example
var b = @{2,3,5,6,12,545@}
b.excl(5)  #=> @{2,3,6,12,545@}
@end example

@item card
  @findex proc card*[T](x꞉ set[T])꞉ int @{.magic꞉ "Card", noSideEffect.@}
@example
proc card*[T](x꞉ set[T])꞉ int @{.magic꞉ "Card", noSideEffect.@}
@end example
  returns the cardinality of the set @code{x}, i.e. the number of elements in the set.
@example
var i = @{1,2,3,4@}
card(i) #=> 4
@end example

@item ord
  @findex proc ord*[T](x꞉ T)꞉ int @{.magic꞉ "Ord", noSideEffect.@}
@example
proc ord*[T](x꞉ T)꞉ int @{.magic꞉ "Ord", noSideEffect.@}
@end example
  returns the internal int value of an ordinal value @code{x}.
@example
ord('A') #=> 65
@end example

@item chr
  @findex proc chr*(u꞉ range[0 .. 255])꞉ char @{.magic꞉ "Chr", noSideEffect.@}
@example
proc chr*(u꞉ range[0 .. 255])꞉ char @{.magic꞉ "Chr", noSideEffect.@}
@end example
  converts an int in the range 0..255 to a character.
@example
chr(65) #=> A
@end example

@item ze
  @findex proc ze*(x꞉ int8)꞉ int @{.magic꞉ "Ze8ToI", noSideEffect.@}
@example
proc ze*(x꞉ int8)꞉ int @{.magic꞉ "Ze8ToI", noSideEffect.@}
@end example
  zero extends a smaller integer type to @code{int}. This treats @emph{x} as unsigned.

@item ze
  @findex proc ze*(x꞉ int16)꞉ int @{.magic꞉ "Ze16ToI", noSideEffect.@}
@example
proc ze*(x꞉ int16)꞉ int @{.magic꞉ "Ze16ToI", noSideEffect.@}
@end example
  zero extends a smaller integer type to @code{int}. This treats @emph{x} as unsigned.

@item ze64
  @findex proc ze64*(x꞉ int8)꞉ int64 @{.magic꞉ "Ze8ToI64", noSideEffect.@}
@example
proc ze64*(x꞉ int8)꞉ int64 @{.magic꞉ "Ze8ToI64", noSideEffect.@}
@end example
  zero extends a smaller integer type to @code{int64}. This treats @emph{x} as unsigned.

@item ze64
  @findex proc ze64*(x꞉ int16)꞉ int64 @{.magic꞉ "Ze16ToI64", noSideEffect.@}
@example
proc ze64*(x꞉ int16)꞉ int64 @{.magic꞉ "Ze16ToI64", noSideEffect.@}
@end example
  zero extends a smaller integer type to @code{int64}. This treats @emph{x} as unsigned.

@item ze64
  @findex proc ze64*(x꞉ int32)꞉ int64 @{.magic꞉ "Ze32ToI64", noSideEffect.@}
@example
proc ze64*(x꞉ int32)꞉ int64 @{.magic꞉ "Ze32ToI64", noSideEffect.@}
@end example
  zero extends a smaller integer type to @code{int64}. This treats @emph{x} as unsigned.

@item ze64
  @findex proc ze64*(x꞉ int)꞉ int64 @{.magic꞉ "ZeIToI64", noSideEffect.@}
@example
proc ze64*(x꞉ int)꞉ int64 @{.magic꞉ "ZeIToI64", noSideEffect.@}
@end example
  zero extends a smaller integer type to @code{int64}. This treats @emph{x} as unsigned. Does nothing if the size of an @code{int} is the same as @code{int64}. (This is the case on 64 bit processors.)

@item toU8
  @findex proc toU8*(x꞉ int)꞉ int8 @{.magic꞉ "ToU8", noSideEffect.@}
@example
proc toU8*(x꞉ int)꞉ int8 @{.magic꞉ "ToU8", noSideEffect.@}
@end example
  treats @emph{x} as unsigned and converts it to a byte by taking the last 8 bits from @emph{x}.

@item toU16
  @findex proc toU16*(x꞉ int)꞉ int16 @{.magic꞉ "ToU16", noSideEffect.@}
@example
proc toU16*(x꞉ int)꞉ int16 @{.magic꞉ "ToU16", noSideEffect.@}
@end example
  treats @emph{x} as unsigned and converts it to an @code{int16} by taking the last 16 bits from @emph{x}.

@item toU32
  @findex proc toU32*(x꞉ int64)꞉ int32 @{.magic꞉ "ToU32", noSideEffect.@}
@example
proc toU32*(x꞉ int64)꞉ int32 @{.magic꞉ "ToU32", noSideEffect.@}
@end example
  treats @emph{x} as unsigned and converts it to an @code{int32} by taking the last 32 bits from @emph{x}.

@item `+`
  @findex proc `+`*(x꞉ int)꞉ int @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@example
proc `+`*(x꞉ int)꞉ int @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x꞉ int8)꞉ int8 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@example
proc `+`*(x꞉ int8)꞉ int8 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x꞉ int16)꞉ int16 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@example
proc `+`*(x꞉ int16)꞉ int16 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x꞉ int32)꞉ int32 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@example
proc `+`*(x꞉ int32)꞉ int32 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x꞉ int64)꞉ int64 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@example
proc `+`*(x꞉ int64)꞉ int64 @{.magic꞉ "UnaryPlusI", noSideEffect.@}
@end example
  Unary @emph{+} operator for an integer. Has no effect.

@item `-`
  @findex proc `-`*(x꞉ int)꞉ int @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@example
proc `-`*(x꞉ int)꞉ int @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x꞉ int8)꞉ int8 @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@example
proc `-`*(x꞉ int8)꞉ int8 @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x꞉ int16)꞉ int16 @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@example
proc `-`*(x꞉ int16)꞉ int16 @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x꞉ int32)꞉ int32 @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@example
proc `-`*(x꞉ int32)꞉ int32 @{.magic꞉ "UnaryMinusI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x꞉ int64)꞉ int64 @{.magic꞉ "UnaryMinusI64", noSideEffect.@}
@example
proc `-`*(x꞉ int64)꞉ int64 @{.magic꞉ "UnaryMinusI64", noSideEffect.@}
@end example
  Unary @emph{-} operator for an integer. Negates @emph{x}.

@item `not`
  @findex proc `not`*(x꞉ int)꞉ int @{.magic꞉ "BitnotI", noSideEffect.@}
@example
proc `not`*(x꞉ int)꞉ int @{.magic꞉ "BitnotI", noSideEffect.@}
@end example
  

@item `not`
  @findex proc `not`*(x꞉ int8)꞉ int8 @{.magic꞉ "BitnotI", noSideEffect.@}
@example
proc `not`*(x꞉ int8)꞉ int8 @{.magic꞉ "BitnotI", noSideEffect.@}
@end example
  

@item `not`
  @findex proc `not`*(x꞉ int16)꞉ int16 @{.magic꞉ "BitnotI", noSideEffect.@}
@example
proc `not`*(x꞉ int16)꞉ int16 @{.magic꞉ "BitnotI", noSideEffect.@}
@end example
  

@item `not`
  @findex proc `not`*(x꞉ int32)꞉ int32 @{.magic꞉ "BitnotI", noSideEffect.@}
@example
proc `not`*(x꞉ int32)꞉ int32 @{.magic꞉ "BitnotI", noSideEffect.@}
@end example
  computes the @emph{bitwise complement} of the integer @emph{x}.

@item `not`
  @findex proc `not`*(x꞉ int64)꞉ int64 @{.magic꞉ "BitnotI", noSideEffect.@}
@example
proc `not`*(x꞉ int64)꞉ int64 @{.magic꞉ "BitnotI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x, y꞉ int)꞉ int @{.magic꞉ "AddI", noSideEffect.@}
@example
proc `+`*(x, y꞉ int)꞉ int @{.magic꞉ "AddI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "AddI", noSideEffect.@}
@example
proc `+`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "AddI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "AddI", noSideEffect.@}
@example
proc `+`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "AddI", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "AddI", noSideEffect.@}
@example
proc `+`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "AddI", noSideEffect.@}
@end example
  Binary @emph{+} operator for an integer.

@item `+`
  @findex proc `+`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "AddI", noSideEffect.@}
@example
proc `+`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "AddI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x, y꞉ int)꞉ int @{.magic꞉ "SubI", noSideEffect.@}
@example
proc `-`*(x, y꞉ int)꞉ int @{.magic꞉ "SubI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "SubI", noSideEffect.@}
@example
proc `-`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "SubI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "SubI", noSideEffect.@}
@example
proc `-`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "SubI", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "SubI", noSideEffect.@}
@example
proc `-`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "SubI", noSideEffect.@}
@end example
  Binary @emph{-} operator for an integer.

@item `-`
  @findex proc `-`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "SubI", noSideEffect.@}
@example
proc `-`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "SubI", noSideEffect.@}
@end example
  

@item `*`
  @findex proc `*`*(x, y꞉ int)꞉ int @{.magic꞉ "MulI", noSideEffect.@}
@example
proc `*`*(x, y꞉ int)꞉ int @{.magic꞉ "MulI", noSideEffect.@}
@end example
  

@item `*`
  @findex proc `*`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "MulI", noSideEffect.@}
@example
proc `*`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "MulI", noSideEffect.@}
@end example
  

@item `*`
  @findex proc `*`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "MulI", noSideEffect.@}
@example
proc `*`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "MulI", noSideEffect.@}
@end example
  

@item `*`
  @findex proc `*`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "MulI", noSideEffect.@}
@example
proc `*`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "MulI", noSideEffect.@}
@end example
  Binary @emph{*} operator for an integer.

@item `*`
  @findex proc `*`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MulI", noSideEffect.@}
@example
proc `*`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MulI", noSideEffect.@}
@end example
  

@item `div`
  @findex proc `div`*(x, y꞉ int)꞉ int @{.magic꞉ "DivI", noSideEffect.@}
@example
proc `div`*(x, y꞉ int)꞉ int @{.magic꞉ "DivI", noSideEffect.@}
@end example
  

@item `div`
  @findex proc `div`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "DivI", noSideEffect.@}
@example
proc `div`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "DivI", noSideEffect.@}
@end example
  

@item `div`
  @findex proc `div`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "DivI", noSideEffect.@}
@example
proc `div`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "DivI", noSideEffect.@}
@end example
  

@item `div`
  @findex proc `div`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "DivI", noSideEffect.@}
@example
proc `div`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "DivI", noSideEffect.@}
@end example
  computes the integer division. This is roughly the same as @code{floor(x/y)}.
@example
1 div 2 == 0
2 div 2 == 1
3 div 2 == 1
7 div 5 == 1
@end example

@item `div`
  @findex proc `div`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "DivI", noSideEffect.@}
@example
proc `div`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "DivI", noSideEffect.@}
@end example
  

@item `mod`
  @findex proc `mod`*(x, y꞉ int)꞉ int @{.magic꞉ "ModI", noSideEffect.@}
@example
proc `mod`*(x, y꞉ int)꞉ int @{.magic꞉ "ModI", noSideEffect.@}
@end example
  

@item `mod`
  @findex proc `mod`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "ModI", noSideEffect.@}
@example
proc `mod`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "ModI", noSideEffect.@}
@end example
  

@item `mod`
  @findex proc `mod`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "ModI", noSideEffect.@}
@example
proc `mod`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "ModI", noSideEffect.@}
@end example
  

@item `mod`
  @findex proc `mod`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "ModI", noSideEffect.@}
@example
proc `mod`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "ModI", noSideEffect.@}
@end example
  computes the integer modulo operation (remainder). This is the same as @code{x - (x div y) * y}.
@example
(7 mod 5) == 2
@end example

@item `mod`
  @findex proc `mod`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ModI", noSideEffect.@}
@example
proc `mod`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ModI", noSideEffect.@}
@end example
  

@item `shr`
  @findex proc `shr`*(x, y꞉ int)꞉ int @{.magic꞉ "ShrI", noSideEffect.@}
@example
proc `shr`*(x, y꞉ int)꞉ int @{.magic꞉ "ShrI", noSideEffect.@}
@end example
  

@item `shr`
  @findex proc `shr`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "ShrI", noSideEffect.@}
@example
proc `shr`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "ShrI", noSideEffect.@}
@end example
  

@item `shr`
  @findex proc `shr`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "ShrI", noSideEffect.@}
@example
proc `shr`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "ShrI", noSideEffect.@}
@end example
  

@item `shr`
  @findex proc `shr`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "ShrI", noSideEffect.@}
@example
proc `shr`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "ShrI", noSideEffect.@}
@end example
  

@item `shr`
  @findex proc `shr`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ShrI", noSideEffect.@}
@example
proc `shr`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ShrI", noSideEffect.@}
@end example
  computes the @emph{shift right} operation of @emph{x} and @emph{y}, filling vacant bit positions with zeros.
@example
0b0001_0000'i8 shr 2 == 0b0000_0100'i8
0b1000_0000'i8 shr 8 == 0b0000_0000'i8
0b0000_0001'i8 shr 1 == 0b0000_0000'i8
@end example

@item `shl`
  @findex proc `shl`*(x, y꞉ int)꞉ int @{.magic꞉ "ShlI", noSideEffect.@}
@example
proc `shl`*(x, y꞉ int)꞉ int @{.magic꞉ "ShlI", noSideEffect.@}
@end example
  

@item `shl`
  @findex proc `shl`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "ShlI", noSideEffect.@}
@example
proc `shl`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "ShlI", noSideEffect.@}
@end example
  

@item `shl`
  @findex proc `shl`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "ShlI", noSideEffect.@}
@example
proc `shl`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "ShlI", noSideEffect.@}
@end example
  

@item `shl`
  @findex proc `shl`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "ShlI", noSideEffect.@}
@example
proc `shl`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "ShlI", noSideEffect.@}
@end example
  

@item `shl`
  @findex proc `shl`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ShlI", noSideEffect.@}
@example
proc `shl`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ShlI", noSideEffect.@}
@end example
  computes the @emph{shift left} operation of @emph{x} and @emph{y}.
@example
1'i32 shl 4  == 0x0000_0010
1'i64 shl 4  == 0x0000_0000_0000_0010
@end example

@item `and`
  @findex proc `and`*(x, y꞉ int)꞉ int @{.magic꞉ "BitandI", noSideEffect.@}
@example
proc `and`*(x, y꞉ int)꞉ int @{.magic꞉ "BitandI", noSideEffect.@}
@end example
  

@item `and`
  @findex proc `and`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "BitandI", noSideEffect.@}
@example
proc `and`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "BitandI", noSideEffect.@}
@end example
  

@item `and`
  @findex proc `and`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "BitandI", noSideEffect.@}
@example
proc `and`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "BitandI", noSideEffect.@}
@end example
  

@item `and`
  @findex proc `and`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "BitandI", noSideEffect.@}
@example
proc `and`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "BitandI", noSideEffect.@}
@end example
  

@item `and`
  @findex proc `and`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "BitandI", noSideEffect.@}
@example
proc `and`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "BitandI", noSideEffect.@}
@end example
  computes the @emph{bitwise and} of numbers @emph{x} and @emph{y}.
@example
(0xffff'i16 and 0x0010'i16) == 0x0010
@end example

@item `or`
  @findex proc `or`*(x, y꞉ int)꞉ int @{.magic꞉ "BitorI", noSideEffect.@}
@example
proc `or`*(x, y꞉ int)꞉ int @{.magic꞉ "BitorI", noSideEffect.@}
@end example
  

@item `or`
  @findex proc `or`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "BitorI", noSideEffect.@}
@example
proc `or`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "BitorI", noSideEffect.@}
@end example
  

@item `or`
  @findex proc `or`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "BitorI", noSideEffect.@}
@example
proc `or`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "BitorI", noSideEffect.@}
@end example
  

@item `or`
  @findex proc `or`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "BitorI", noSideEffect.@}
@example
proc `or`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "BitorI", noSideEffect.@}
@end example
  

@item `or`
  @findex proc `or`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "BitorI", noSideEffect.@}
@example
proc `or`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "BitorI", noSideEffect.@}
@end example
  computes the @emph{bitwise or} of numbers @emph{x} and @emph{y}.
@example
(0x0005'i16 or 0x0010'i16) == 0x0015
@end example

@item `xor`
  @findex proc `xor`*(x, y꞉ int)꞉ int @{.magic꞉ "BitxorI", noSideEffect.@}
@example
proc `xor`*(x, y꞉ int)꞉ int @{.magic꞉ "BitxorI", noSideEffect.@}
@end example
  

@item `xor`
  @findex proc `xor`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "BitxorI", noSideEffect.@}
@example
proc `xor`*(x, y꞉ int8)꞉ int8 @{.magic꞉ "BitxorI", noSideEffect.@}
@end example
  

@item `xor`
  @findex proc `xor`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "BitxorI", noSideEffect.@}
@example
proc `xor`*(x, y꞉ int16)꞉ int16 @{.magic꞉ "BitxorI", noSideEffect.@}
@end example
  

@item `xor`
  @findex proc `xor`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "BitxorI", noSideEffect.@}
@example
proc `xor`*(x, y꞉ int32)꞉ int32 @{.magic꞉ "BitxorI", noSideEffect.@}
@end example
  

@item `xor`
  @findex proc `xor`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "BitxorI", noSideEffect.@}
@example
proc `xor`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "BitxorI", noSideEffect.@}
@end example
  computes the @emph{bitwise xor} of numbers @emph{x} and @emph{y}.
@example
(0x1011'i16 xor 0x0101'i16) == 0x1110
@end example

@item `==`
  @findex proc `==`*(x, y꞉ int)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@example
proc `==`*(x, y꞉ int)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ int8)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@example
proc `==`*(x, y꞉ int8)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ int16)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@example
proc `==`*(x, y꞉ int16)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ int32)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@example
proc `==`*(x, y꞉ int32)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ int64)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@example
proc `==`*(x, y꞉ int64)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@end example
  Compares two integers for equality.

@item `<=`
  @findex proc `<=`*(x, y꞉ int)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@example
proc `<=`*(x, y꞉ int)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ int8)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@example
proc `<=`*(x, y꞉ int8)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ int16)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@example
proc `<=`*(x, y꞉ int16)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ int32)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@example
proc `<=`*(x, y꞉ int32)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@example
proc `<=`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LeI", noSideEffect.@}
@end example
  Returns true iff @emph{x} is less than or equal to @emph{y}.

@item `<`
  @findex proc `<`*(x, y꞉ int)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@example
proc `<`*(x, y꞉ int)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ int8)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@example
proc `<`*(x, y꞉ int8)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ int16)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@example
proc `<`*(x, y꞉ int16)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ int32)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@example
proc `<`*(x, y꞉ int32)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@example
proc `<`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LtI", noSideEffect.@}
@end example
  Returns true iff @emph{x} is less than @emph{y}.

@item `+%`
  @findex proc `+%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "AddU", noSideEffect.@}
@example
proc `+%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "AddU", noSideEffect.@}
@end example
  

@item `+%`
  @findex proc `+%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "AddU", noSideEffect.@}
@example
proc `+%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "AddU", noSideEffect.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and adds them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.

@item `-%`
  @findex proc `-%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "SubU", noSideEffect.@}
@example
proc `-%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "SubU", noSideEffect.@}
@end example
  

@item `-%`
  @findex proc `-%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "SubU", noSideEffect.@}
@example
proc `-%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "SubU", noSideEffect.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and subtracts them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.

@item `*%`
  @findex proc `*%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "MulU", noSideEffect.@}
@example
proc `*%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "MulU", noSideEffect.@}
@end example
  

@item `*%`
  @findex proc `*%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MulU", noSideEffect.@}
@example
proc `*%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MulU", noSideEffect.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and multiplies them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.

@item `/%`
  @findex proc `/%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "DivU", noSideEffect.@}
@example
proc `/%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "DivU", noSideEffect.@}
@end example
  

@item `/%`
  @findex proc `/%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "DivU", noSideEffect.@}
@example
proc `/%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "DivU", noSideEffect.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and divides them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.

@item `%%`
  @findex proc `%%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "ModU", noSideEffect.@}
@example
proc `%%`*(x, y꞉ IntMax32)꞉ IntMax32 @{.magic꞉ "ModU", noSideEffect.@}
@end example
  

@item `%%`
  @findex proc `%%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ModU", noSideEffect.@}
@example
proc `%%`*(x, y꞉ int64)꞉ int64 @{.magic꞉ "ModU", noSideEffect.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and compute the modulo of @emph{x} and @emph{y}. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.

@item `<=%`
  @findex proc `<=%`*(x, y꞉ IntMax32)꞉ bool @{.magic꞉ "LeU", noSideEffect.@}
@example
proc `<=%`*(x, y꞉ IntMax32)꞉ bool @{.magic꞉ "LeU", noSideEffect.@}
@end example
  

@item `<=%`
  @findex proc `<=%`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LeU64", noSideEffect.@}
@example
proc `<=%`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LeU64", noSideEffect.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and compares them. Returns true iff @code{unsigned(x) <= unsigned(y)}.

@item `<%`
  @findex proc `<%`*(x, y꞉ IntMax32)꞉ bool @{.magic꞉ "LtU", noSideEffect.@}
@example
proc `<%`*(x, y꞉ IntMax32)꞉ bool @{.magic꞉ "LtU", noSideEffect.@}
@end example
  

@item `<%`
  @findex proc `<%`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LtU64", noSideEffect.@}
@example
proc `<%`*(x, y꞉ int64)꞉ bool @{.magic꞉ "LtU64", noSideEffect.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and compares them. Returns true iff @code{unsigned(x) < unsigned(y)}.

@item `not`
  @findex proc `not`*[T꞉ SomeUnsignedInt](x꞉ T)꞉ T @{.magic꞉ "BitnotI", noSideEffect.@}
@example
proc `not`*[T꞉ SomeUnsignedInt](x꞉ T)꞉ T @{.magic꞉ "BitnotI", noSideEffect.@}
@end example
  computes the @emph{bitwise complement} of the integer @emph{x}.

@item `shr`
  @findex proc `shr`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "ShrI", noSideEffect.@}
@example
proc `shr`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "ShrI", noSideEffect.@}
@end example
  computes the @emph{shift right} operation of @emph{x} and @emph{y}.

@item `shl`
  @findex proc `shl`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "ShlI", noSideEffect.@}
@example
proc `shl`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "ShlI", noSideEffect.@}
@end example
  computes the @emph{shift left} operation of @emph{x} and @emph{y}.

@item `and`
  @findex proc `and`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "BitandI", noSideEffect.@}
@example
proc `and`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "BitandI", noSideEffect.@}
@end example
  computes the @emph{bitwise and} of numbers @emph{x} and @emph{y}.

@item `or`
  @findex proc `or`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "BitorI", noSideEffect.@}
@example
proc `or`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "BitorI", noSideEffect.@}
@end example
  computes the @emph{bitwise or} of numbers @emph{x} and @emph{y}.

@item `xor`
  @findex proc `xor`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "BitxorI", noSideEffect.@}
@example
proc `xor`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "BitxorI", noSideEffect.@}
@end example
  computes the @emph{bitwise xor} of numbers @emph{x} and @emph{y}.

@item `==`
  @findex proc `==`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@example
proc `==`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ bool @{.magic꞉ "EqI", noSideEffect.@}
@end example
  Compares two unsigned integers for equality.

@item `+`
  @findex proc `+`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "AddU", noSideEffect.@}
@example
proc `+`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "AddU", noSideEffect.@}
@end example
  Binary @emph{+} operator for unsigned integers.

@item `-`
  @findex proc `-`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "SubU", noSideEffect.@}
@example
proc `-`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "SubU", noSideEffect.@}
@end example
  Binary @emph{-} operator for unsigned integers.

@item `*`
  @findex proc `*`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "MulU", noSideEffect.@}
@example
proc `*`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "MulU", noSideEffect.@}
@end example
  Binary @emph{*} operator for unsigned integers.

@item `div`
  @findex proc `div`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "DivU", noSideEffect.@}
@example
proc `div`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "DivU", noSideEffect.@}
@end example
  computes the integer division. This is roughly the same as @code{floor(x/y)}.
@example
(7 div 5) == 2
@end example

@item `mod`
  @findex proc `mod`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "ModU", noSideEffect.@}
@example
proc `mod`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ T @{.magic꞉ "ModU", noSideEffect.@}
@end example
  computes the integer modulo operation (remainder). This is the same as @code{x - (x div y) * y}.
@example
(7 mod 5) == 2
@end example

@item `<=`
  @findex proc `<=`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ bool @{.magic꞉ "LeU", noSideEffect.@}
@example
proc `<=`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ bool @{.magic꞉ "LeU", noSideEffect.@}
@end example
  Returns true iff @code{x <= y}.

@item `<`
  @findex proc `<`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ bool @{.magic꞉ "LtU", noSideEffect.@}
@example
proc `<`*[T꞉ SomeUnsignedInt](x, y꞉ T)꞉ bool @{.magic꞉ "LtU", noSideEffect.@}
@end example
  Returns true iff @code{unsigned(x) < unsigned(y)}.

@item `+`
  @findex proc `+`*(x꞉ float32)꞉ float32 @{.magic꞉ "UnaryPlusF64", noSideEffect.@}
@example
proc `+`*(x꞉ float32)꞉ float32 @{.magic꞉ "UnaryPlusF64", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x꞉ float32)꞉ float32 @{.magic꞉ "UnaryMinusF64", noSideEffect.@}
@example
proc `-`*(x꞉ float32)꞉ float32 @{.magic꞉ "UnaryMinusF64", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "AddF64", noSideEffect.@}
@example
proc `+`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "AddF64", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "SubF64", noSideEffect.@}
@example
proc `-`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "SubF64", noSideEffect.@}
@end example
  

@item `*`
  @findex proc `*`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "MulF64", noSideEffect.@}
@example
proc `*`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "MulF64", noSideEffect.@}
@end example
  

@item `/`
  @findex proc `/`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "DivF64", noSideEffect.@}
@example
proc `/`*(x, y꞉ float32)꞉ float32 @{.magic꞉ "DivF64", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x꞉ float)꞉ float @{.magic꞉ "UnaryPlusF64", noSideEffect.@}
@example
proc `+`*(x꞉ float)꞉ float @{.magic꞉ "UnaryPlusF64", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x꞉ float)꞉ float @{.magic꞉ "UnaryMinusF64", noSideEffect.@}
@example
proc `-`*(x꞉ float)꞉ float @{.magic꞉ "UnaryMinusF64", noSideEffect.@}
@end example
  

@item `+`
  @findex proc `+`*(x, y꞉ float)꞉ float @{.magic꞉ "AddF64", noSideEffect.@}
@example
proc `+`*(x, y꞉ float)꞉ float @{.magic꞉ "AddF64", noSideEffect.@}
@end example
  

@item `-`
  @findex proc `-`*(x, y꞉ float)꞉ float @{.magic꞉ "SubF64", noSideEffect.@}
@example
proc `-`*(x, y꞉ float)꞉ float @{.magic꞉ "SubF64", noSideEffect.@}
@end example
  

@item `*`
  @findex proc `*`*(x, y꞉ float)꞉ float @{.magic꞉ "MulF64", noSideEffect.@}
@example
proc `*`*(x, y꞉ float)꞉ float @{.magic꞉ "MulF64", noSideEffect.@}
@end example
  

@item `/`
  @findex proc `/`*(x, y꞉ float)꞉ float @{.magic꞉ "DivF64", noSideEffect.@}
@example
proc `/`*(x, y꞉ float)꞉ float @{.magic꞉ "DivF64", noSideEffect.@}
@end example
  computes the floating point division

@item `==`
  @findex proc `==`*(x, y꞉ float32)꞉ bool @{.magic꞉ "EqF64", noSideEffect.@}
@example
proc `==`*(x, y꞉ float32)꞉ bool @{.magic꞉ "EqF64", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ float32)꞉ bool @{.magic꞉ "LeF64", noSideEffect.@}
@example
proc `<=`*(x, y꞉ float32)꞉ bool @{.magic꞉ "LeF64", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ float32)꞉ bool @{.magic꞉ "LtF64", noSideEffect.@}
@example
proc `<`*(x, y꞉ float32)꞉ bool @{.magic꞉ "LtF64", noSideEffect.@}
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ float)꞉ bool @{.magic꞉ "EqF64", noSideEffect.@}
@example
proc `==`*(x, y꞉ float)꞉ bool @{.magic꞉ "EqF64", noSideEffect.@}
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ float)꞉ bool @{.magic꞉ "LeF64", noSideEffect.@}
@example
proc `<=`*(x, y꞉ float)꞉ bool @{.magic꞉ "LeF64", noSideEffect.@}
@end example
  

@item `<`
  @findex proc `<`*(x, y꞉ float)꞉ bool @{.magic꞉ "LtF64", noSideEffect.@}
@example
proc `<`*(x, y꞉ float)꞉ bool @{.magic꞉ "LtF64", noSideEffect.@}
@end example
  

@item `*`
  @findex proc `*`*[T](x, y꞉ set[T])꞉ set[T] @{.magic꞉ "MulSet", noSideEffect.@}
@example
proc `*`*[T](x, y꞉ set[T])꞉ set[T] @{.magic꞉ "MulSet", noSideEffect.@}
@end example
  This operator computes the intersection of two sets.

@item `+`
  @findex proc `+`*[T](x, y꞉ set[T])꞉ set[T] @{.magic꞉ "PlusSet", noSideEffect.@}
@example
proc `+`*[T](x, y꞉ set[T])꞉ set[T] @{.magic꞉ "PlusSet", noSideEffect.@}
@end example
  This operator computes the union of two sets.

@item `-`
  @findex proc `-`*[T](x, y꞉ set[T])꞉ set[T] @{.magic꞉ "MinusSet", noSideEffect.@}
@example
proc `-`*[T](x, y꞉ set[T])꞉ set[T] @{.magic꞉ "MinusSet", noSideEffect.@}
@end example
  This operator computes the difference of two sets.

@item contains
  @findex proc contains*[T](x꞉ set[T]; y꞉ T)꞉ bool @{.magic꞉ "InSet", noSideEffect.@}
@example
proc contains*[T](x꞉ set[T]; y꞉ T)꞉ bool @{.magic꞉ "InSet", noSideEffect.@}
@end example
  One should overload this proc if one wants to overload the @code{in} operator. The parameters are in reverse order! @code{a in b} is a template for @code{contains(b, a)}. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the @code{in} operator that would be the wrong direction for this piece of code:
@example
var s: set[range['a'..'z']] = @{'a'..'c'@}
writeLine(stdout, 'b' in s)
@end example
If @code{in} had been declared as @code{[T](elem: T, s: set[T])} then @code{T} would have been bound to @code{char}. But @code{s} is not compatible to type @code{set[char]}! The solution is to bind @code{T} to @code{range['a'..'z']}. This is achieved by reversing the parameters for @code{contains}; @code{in} then passes its arguments in reverse order.

@item contains
  @findex proc contains*[T](s꞉ Slice[T]; value꞉ T)꞉ bool @{.noSideEffect, inline.@}
@example
proc contains*[T](s꞉ Slice[T]; value꞉ T)꞉ bool @{.noSideEffect, inline.@}
@end example
  Checks if @emph{value} is within the range of @emph{s}; returns true iff @emph{value >= s.a and value <= s.b}
@example
assert((1..3).contains(1) == true)
assert((1..3).contains(2) == true)
assert((1..3).contains(4) == false)
@end example

@item `is`
  @findex proc `is`*[T, S](x꞉ T; y꞉ S)꞉ bool @{.magic꞉ "Is", noSideEffect.@}
@example
proc `is`*[T, S](x꞉ T; y꞉ S)꞉ bool @{.magic꞉ "Is", noSideEffect.@}
@end example
  Checks if T is of the same type as S
@example
proc test[T](a: T): int =
  when (T is int):
    return a
  else:
    return 0

assert(test[int](3) == 3)
assert(test[string]("xyz") == 0)
@end example

@item `of`
  @findex proc `of`*[T, S](x꞉ T; y꞉ S)꞉ bool @{.magic꞉ "Of", noSideEffect.@}
@example
proc `of`*[T, S](x꞉ T; y꞉ S)꞉ bool @{.magic꞉ "Of", noSideEffect.@}
@end example
  Checks if @emph{x} has a type of @emph{y}
@example
assert(FloatingPointError of Exception)
assert(DivByZeroError of Exception)
@end example

@item cmp
  @findex proc cmp*[T](x, y꞉ T)꞉ int @{.procvar.@}
@example
proc cmp*[T](x, y꞉ T)꞉ int @{.procvar.@}
@end example
  Generic compare proc. Returns a value < 0 iff x < y, a value > 0 iff x > y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the @emph{==} and @emph{<} operators.
@example
import algorithm
echo sorted(@@[4,2,6,5,8,7], cmp[int])
@end example

@item cmp
  @findex proc cmp*(x, y꞉ string)꞉ int @{.noSideEffect, procvar.@}
@example
proc cmp*(x, y꞉ string)꞉ int @{.noSideEffect, procvar.@}
@end example
  Compare proc for strings. More efficient than the generic version.

@item `@@@@`
  @findex proc `@@`*[IDX, T](a꞉ array[IDX, T])꞉ seq[T] @{.magic꞉ "ArrToSeq", nosideeffect.@}
@example
proc `@@`*[IDX, T](a꞉ array[IDX, T])꞉ seq[T] @{.magic꞉ "ArrToSeq", nosideeffect.@}
@end example
  turns an array into a sequence. This most often useful for constructing sequences with the array constructor: @code{@@[1, 2, 3]} has the type @code{seq[int]}, while @code{[1, 2, 3]} has the type @code{array[0..2, int]}.

@item setLen
  @findex proc setLen*[T](s꞉ var seq[T]; newlen꞉ Natural) @{.magic꞉ "SetLengthSeq", noSideEffect.@}
@example
proc setLen*[T](s꞉ var seq[T]; newlen꞉ Natural) @{.magic꞉ "SetLengthSeq", noSideEffect.@}
@end example
  sets the length of @emph{s} to @emph{newlen}. @code{T} may be any sequence type. If the current length is greater than the new length, @code{s} will be truncated. @emph{s} cannot be nil! To initialize a sequence with a size, use @code{newSeq} instead.

@item setLen
  @findex proc setLen*(s꞉ var string; newlen꞉ Natural) @{.magic꞉ "SetLengthStr", noSideEffect.@}
@example
proc setLen*(s꞉ var string; newlen꞉ Natural) @{.magic꞉ "SetLengthStr", noSideEffect.@}
@end example
  sets the length of @emph{s} to @emph{newlen}. If the current length is greater than the new length, @code{s} will be truncated. @emph{s} cannot be nil! To initialize a string with a size, use @code{newString} instead.
@example
var myS = "Nim is great!!"
myS.setLen(3)
echo myS, " is fantastic!!"
@end example

@item newString
  @findex proc newString*(len꞉ Natural)꞉ string @{.magic꞉ "NewString", importc꞉ "mnewString",noSideEffect.@}
@example
proc newString*(len꞉ Natural)꞉ string @{.magic꞉ "NewString", importc꞉ "mnewString",noSideEffect.@}
@end example
  returns a new string of length @code{len} but with uninitialized content. One needs to fill the string character after character with the index operator @code{s[i]}. This procedure exists only for optimization purposes; the same effect can be achieved with the @code{&} operator or with @code{add}.

@item newStringOfCap
  @findex proc newStringOfCap*(cap꞉ Natural)꞉ string @{.magic꞉ "NewStringOfCap",importc꞉ "rawNewString", noSideEffect.@}
@example
proc newStringOfCap*(cap꞉ Natural)꞉ string @{.magic꞉ "NewStringOfCap",importc꞉ "rawNewString", noSideEffect.@}
@end example
  returns a new string of length @code{0} but with capacity @emph{cap}.This procedure exists only for optimization purposes; the same effect can be achieved with the @code{&} operator or with @code{add}.

@item `&`
  @findex proc `&`*(x꞉ string; y꞉ char)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@example
proc `&`*(x꞉ string; y꞉ char)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@end example
  Concatenates @emph{x} with @emph{y}
@example
assert("ab" & 'c' == "abc")
@end example

@item `&`
  @findex proc `&`*(x, y꞉ char)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@example
proc `&`*(x, y꞉ char)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@end example
  Concatenates @emph{x} and @emph{y} into a string
@example
assert('a' & 'b' == "ab")
@end example

@item `&`
  @findex proc `&`*(x, y꞉ string)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@example
proc `&`*(x, y꞉ string)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@end example
  Concatenates @emph{x} and @emph{y}
@example
assert("ab" & "cd" == "abcd")
@end example

@item `&`
  @findex proc `&`*(x꞉ char; y꞉ string)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@example
proc `&`*(x꞉ char; y꞉ string)꞉ string @{.magic꞉ "ConStrStr", noSideEffect, merge.@}
@end example
  Concatenates @emph{x} with @emph{y}
@example
assert('a' & "bc" == "abc")
@end example

@item add
  @findex proc add*(x꞉ var string; y꞉ char) @{.magic꞉ "AppendStrCh", noSideEffect.@}
@example
proc add*(x꞉ var string; y꞉ char) @{.magic꞉ "AppendStrCh", noSideEffect.@}
@end example
  Appends @emph{y} to @emph{x} in place
@example
var tmp = ""
tmp.add('a')
tmp.add('b')
assert(tmp == "ab")
@end example

@item add
  @findex proc add*(x꞉ var string; y꞉ string) @{.magic꞉ "AppendStrStr", noSideEffect.@}
@example
proc add*(x꞉ var string; y꞉ string) @{.magic꞉ "AppendStrStr", noSideEffect.@}
@end example
  Concatenates @emph{x} and @emph{y} in place
@example
var tmp = ""
tmp.add("ab")
tmp.add("cd")
assert(tmp == "abcd")
@end example

@item compileOption
  @findex proc compileOption*(option꞉ string)꞉ bool @{.magic꞉ "CompileOption", noSideEffect.@}
@example
proc compileOption*(option꞉ string)꞉ bool @{.magic꞉ "CompileOption", noSideEffect.@}
@end example
  can be used to determine an on|off compile-time option. Example:
@example
when compileOption("floatchecks"):
  echo "compiled with floating point NaN and Inf checks"
@end example

@item compileOption
  @findex proc compileOption*(option, arg꞉ string)꞉ bool @{.magic꞉ "CompileOptionArg",noSideEffect.@}
@example
proc compileOption*(option, arg꞉ string)꞉ bool @{.magic꞉ "CompileOptionArg",noSideEffect.@}
@end example
  can be used to determine an enum compile-time option. Example:
@example
when compileOption("opt", "size") and compileOption("gc", "boehm"):
  echo "compiled with optimization for size and uses Boehm's GC"
@end example

@item len
  @findex proc len*(s꞉ TaintedString)꞉ int @{.borrow.@}
@example
proc len*(s꞉ TaintedString)꞉ int @{.borrow.@}
@end example
  

@item quit
  @findex proc quit*(errorcode꞉ int = QuitSuccess) @{.magic꞉ "Exit", importc꞉ "exit",header꞉ "<stdlib.h>", noreturn.@}
@example
proc quit*(errorcode꞉ int = QuitSuccess) @{.magic꞉ "Exit", importc꞉ "exit",header꞉ "<stdlib.h>", noreturn.@}
@end example
  Stops the program immediately with an exit code.

Before stopping the program the "quit procedures" are called in the opposite order they were added with @uref{#addQuitProc, addQuitProc}. @code{quit} never returns and ignores any exception that may have been raised by the quit procedures.  It does @emph{not} call the garbage collector to free all the memory, unless a quit procedure calls @uref{#GC_fullCollect, GC_fullCollect}.

The proc @code{quit(QuitSuccess)} is called implicitly when your nim program finishes without incident. A raised unhandled exception is equivalent to calling @code{quit(QuitFailure)}.

Note that this is a @emph{runtime} call and using @code{quit} inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the @uref{manual.html#error-pragma, error} or @uref{manual.html#fatal-pragma, fatal} pragmas.

@item add
  @findex proc add*[T](x꞉ var seq[T]; y꞉ T) @{.magic꞉ "AppendSeqElem", noSideEffect.@}
@example
proc add*[T](x꞉ var seq[T]; y꞉ T) @{.magic꞉ "AppendSeqElem", noSideEffect.@}
@end example
  

@item add
  @findex proc add*[T](x꞉ var seq[T]; y꞉ openArray[T]) @{.noSideEffect.@}
@example
proc add*[T](x꞉ var seq[T]; y꞉ openArray[T]) @{.noSideEffect.@}
@end example
  Generic proc for adding a data item @emph{y} to a container @emph{x}. For containers that have an order, @emph{add} means @emph{append}. New generic containers should also call their adding proc @emph{add} for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.
@example
var s: seq[string] = @@["test2","test2"]
s.add("test") #=> @@[test2, test2, test]
@end example

@item shallowCopy
  @findex proc shallowCopy*[T](x꞉ var T; y꞉ T) @{.noSideEffect, magic꞉ "ShallowCopy".@}
@example
proc shallowCopy*[T](x꞉ var T; y꞉ T) @{.noSideEffect, magic꞉ "ShallowCopy".@}
@end example
  use this instead of @emph{=} for a . The shallow copy only changes the semantics for sequences and strings (and types which contain those). Be careful with the changed semantics though! There is a reason why the default assignment does a deep copy of sequences and strings.

@item del
  @findex proc del*[T](x꞉ var seq[T]; i꞉ Natural) @{.noSideEffect.@}
@example
proc del*[T](x꞉ var seq[T]; i꞉ Natural) @{.noSideEffect.@}
@end example
  deletes the item at index @emph{i} by putting @code{x[high(x)]} into position @emph{i}. This is an O(1) operation.
@example
var i = @@[1,2,3,4,5]
i.del(2) #=> @@[1, 2, 5, 4]
@end example

@item delete
  @findex proc delete*[T](x꞉ var seq[T]; i꞉ Natural) @{.noSideEffect.@}
@example
proc delete*[T](x꞉ var seq[T]; i꞉ Natural) @{.noSideEffect.@}
@end example
  deletes the item at index @emph{i} by moving @code{x[i+1..]} by one position. This is an O(n) operation.
@example
var i = @@[1,2,3,4,5]
i.delete(2) #=> @@[1, 2, 4, 5]
@end example

@item insert
  @findex proc insert*[T](x꞉ var seq[T]; item꞉ T; i = 0.Natural) @{.noSideEffect.@}
@example
proc insert*[T](x꞉ var seq[T]; item꞉ T; i = 0.Natural) @{.noSideEffect.@}
@end example
  inserts @emph{item} into @emph{x} at position @emph{i}.
@example
var i = @@[1,2,3,4,5]
i.insert(2,4) #=> @@[1, 2, 3, 4, 2, 5]
@end example

@item repr
  @findex proc repr*[T](x꞉ T)꞉ string @{.magic꞉ "Repr", noSideEffect.@}
@example
proc repr*[T](x꞉ T)꞉ string @{.magic꞉ "Repr", noSideEffect.@}
@end example
  takes any Nim variable and returns its string representation. It works even for complex data graphs with cycles. This is a great debugging tool.
@example
var s: seq[string] = @@["test2","test2"]
var i = @@[1,2,3,4,5]
repr(s) #=> 0x1055eb050[0x1055ec050"test2", 0x1055ec078"test2"]
repr(i) #=> 0x1055ed050[1, 2, 3, 4, 5]
@end example

@item toFloat
  @findex proc toFloat*(i꞉ int)꞉ float @{.magic꞉ "ToFloat", noSideEffect, importc꞉ "toFloat".@}
@example
proc toFloat*(i꞉ int)꞉ float @{.magic꞉ "ToFloat", noSideEffect, importc꞉ "toFloat".@}
@end example
  converts an integer @emph{i} into a @code{float}. If the conversion fails, @emph{EInvalidValue} is raised. However, on most platforms the conversion cannot fail.

@item toBiggestFloat
  @findex proc toBiggestFloat*(i꞉ BiggestInt)꞉ BiggestFloat @{.magic꞉ "ToBiggestFloat",noSideEffect, importc꞉ "toBiggestFloat".@}
@example
proc toBiggestFloat*(i꞉ BiggestInt)꞉ BiggestFloat @{.magic꞉ "ToBiggestFloat",noSideEffect, importc꞉ "toBiggestFloat".@}
@end example
  converts an biggestint @emph{i} into a @code{biggestfloat}. If the conversion fails, @emph{EInvalidValue} is raised. However, on most platforms the conversion cannot fail.

@item toInt
  @findex proc toInt*(f꞉ float)꞉ int @{.magic꞉ "ToInt", noSideEffect, importc꞉ "toInt".@}
@example
proc toInt*(f꞉ float)꞉ int @{.magic꞉ "ToInt", noSideEffect, importc꞉ "toInt".@}
@end example
  converts a floating point number @emph{f} into an @code{int}. Conversion rounds @emph{f} if it does not contain an integer value. If the conversion fails (because @emph{f} is infinite for example), @emph{EInvalidValue} is raised.

@item toBiggestInt
  @findex proc toBiggestInt*(f꞉ BiggestFloat)꞉ BiggestInt @{.magic꞉ "ToBiggestInt", noSideEffect,importc꞉ "toBiggestInt".@}
@example
proc toBiggestInt*(f꞉ BiggestFloat)꞉ BiggestInt @{.magic꞉ "ToBiggestInt", noSideEffect,importc꞉ "toBiggestInt".@}
@end example
  converts a biggestfloat @emph{f} into a @code{biggestint}. Conversion rounds @emph{f} if it does not contain an integer value. If the conversion fails (because @emph{f} is infinite for example), @emph{EInvalidValue} is raised.

@item addQuitProc
  @findex proc addQuitProc*(QuitProc꞉ proc () @{.noconv.@}) @{.importc꞉ "atexit",header꞉ "<stdlib.h>".@}
@example
proc addQuitProc*(QuitProc꞉ proc () @{.noconv.@}) @{.importc꞉ "atexit",header꞉ "<stdlib.h>".@}
@end example
  Adds/registers a quit procedure.

Each call to @code{addQuitProc} registers another quit procedure. Up to 30 procedures can be registered. They are executed on a last-in, first-out basis (that is, the last function registered is the first to be executed). @code{addQuitProc} raises an EOutOfIndex exception if @code{QuitProc} cannot be registered.

@item copy
  @findex proc copy*(s꞉ string; first = 0)꞉ string @{.magic꞉ "CopyStr", importc꞉ "copyStr",noSideEffect, deprecated.@}
@example
proc copy*(s꞉ string; first = 0)꞉ string @{.magic꞉ "CopyStr", importc꞉ "copyStr",noSideEffect, deprecated.@}
@end example
  

@item copy
  @findex proc copy*(s꞉ string; first, last꞉ int)꞉ string @{.magic꞉ "CopyStrLast",importc꞉ "copyStrLast", noSideEffect, deprecated.@}
@example
proc copy*(s꞉ string; first, last꞉ int)꞉ string @{.magic꞉ "CopyStrLast",importc꞉ "copyStrLast", noSideEffect, deprecated.@}
@end example
  copies a slice of @emph{s} into a new string and returns this new string. The bounds @emph{first} and @emph{last} denote the indices of the first and last characters that shall be copied. If @code{last} is omitted, it is treated as @code{high(s)}. @strong{Deprecated since version 0.8.12}: Use @code{substr} instead.

@item substr
  @findex proc substr*(s꞉ string; first = 0)꞉ string @{.magic꞉ "CopyStr", importc꞉ "copyStr",noSideEffect.@}
@example
proc substr*(s꞉ string; first = 0)꞉ string @{.magic꞉ "CopyStr", importc꞉ "copyStr",noSideEffect.@}
@end example
  

@item substr
  @findex proc substr*(s꞉ string; first, last꞉ int)꞉ string @{.magic꞉ "CopyStrLast",importc꞉ "copyStrLast", noSideEffect.@}
@example
proc substr*(s꞉ string; first, last꞉ int)꞉ string @{.magic꞉ "CopyStrLast",importc꞉ "copyStrLast", noSideEffect.@}
@end example
  copies a slice of @emph{s} into a new string and returns this new string. The bounds @emph{first} and @emph{last} denote the indices of the first and last characters that shall be copied. If @code{last} is omitted, it is treated as @code{high(s)}. If @code{last >= s.len}, @code{s.len} is used instead: This means @code{substr} can also be used to  or  a string's length.

@item zeroMem
  @findex proc zeroMem*(p꞉ pointer; size꞉ Natural) @{.importc, noDecl, benign.@}
@example
proc zeroMem*(p꞉ pointer; size꞉ Natural) @{.importc, noDecl, benign.@}
@end example
  overwrites the contents of the memory at @code{p} with the value 0. Exactly @code{size} bytes will be overwritten. Like any procedure dealing with raw memory this is @emph{unsafe}.

@item copyMem
  @findex proc copyMem*(dest, source꞉ pointer; size꞉ Natural) @{.importc꞉ "memcpy",header꞉ "<string.h>", benign.@}
@example
proc copyMem*(dest, source꞉ pointer; size꞉ Natural) @{.importc꞉ "memcpy",header꞉ "<string.h>", benign.@}
@end example
  copies the contents from the memory at @code{source} to the memory at @code{dest}. Exactly @code{size} bytes will be copied. The memory regions may not overlap. Like any procedure dealing with raw memory this is @emph{unsafe}.

@item moveMem
  @findex proc moveMem*(dest, source꞉ pointer; size꞉ Natural) @{.importc꞉ "memmove",header꞉ "<string.h>", benign.@}
@example
proc moveMem*(dest, source꞉ pointer; size꞉ Natural) @{.importc꞉ "memmove",header꞉ "<string.h>", benign.@}
@end example
  copies the contents from the memory at @code{source} to the memory at @code{dest}. Exactly @code{size} bytes will be copied. The memory regions may overlap, @code{moveMem} handles this case appropriately and is thus somewhat more safe than @code{copyMem}. Like any procedure dealing with raw memory this is still @emph{unsafe}, though.

@item equalMem
  @findex proc equalMem*(a, b꞉ pointer; size꞉ Natural)꞉ bool @{.importc꞉ "equalMem", noDecl,noSideEffect.@}
@example
proc equalMem*(a, b꞉ pointer; size꞉ Natural)꞉ bool @{.importc꞉ "equalMem", noDecl,noSideEffect.@}
@end example
  compares the memory blocks @code{a} and @code{b}. @code{size} bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is @emph{unsafe}.

@item alloc
  @findex proc alloc*(size꞉ Natural)꞉ pointer @{.noconv, rtl, tags꞉ [], benign.@}
@example
proc alloc*(size꞉ Natural)꞉ pointer @{.noconv, rtl, tags꞉ [], benign.@}
@end example
  allocates a new memory block with at least @code{size} bytes. The block has to be freed with @code{realloc(block, 0)} or @code{dealloc(block)}. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use @emph{allocShared} to allocate from a shared heap.

@item createU
  @findex proc createU*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline, benign.@}
@example
proc createU*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline, benign.@}
@end example
  allocates a new memory block with at least @code{T.sizeof * size} bytes. The block has to be freed with @code{resize(block, 0)} or @code{free(block)}. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use @emph{createSharedU} to allocate from a shared heap.

@item alloc0
  @findex proc alloc0*(size꞉ Natural)꞉ pointer @{.noconv, rtl, tags꞉ [], benign.@}
@example
proc alloc0*(size꞉ Natural)꞉ pointer @{.noconv, rtl, tags꞉ [], benign.@}
@end example
  allocates a new memory block with at least @code{size} bytes. The block has to be freed with @code{realloc(block, 0)} or @code{dealloc(block)}. The block is initialized with all bytes containing zero, so it is somewhat safer than @code{alloc}. The allocated memory belongs to its allocating thread! Use @emph{allocShared0} to allocate from a shared heap.

@item create
  @findex proc create*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline, benign.@}
@example
proc create*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline, benign.@}
@end example
  allocates a new memory block with at least @code{T.sizeof * size} bytes. The block has to be freed with @code{resize(block, 0)} or @code{free(block)}. The block is initialized with all bytes containing zero, so it is somewhat safer than @code{createU}. The allocated memory belongs to its allocating thread! Use @emph{createShared} to allocate from a shared heap.

@item realloc
  @findex proc realloc*(p꞉ pointer; newSize꞉ Natural)꞉ pointer @{.noconv, rtl, tags꞉ [], benign.@}
@example
proc realloc*(p꞉ pointer; newSize꞉ Natural)꞉ pointer @{.noconv, rtl, tags꞉ [], benign.@}
@end example
  grows or shrinks a given memory block. If p is @strong{nil} then a new memory block is returned. In either way the block has at least @code{newSize} bytes. If @code{newSize == 0} and p is not @strong{nil} @code{realloc} calls @code{dealloc(p)}. In other cases the block has to be freed with @code{dealloc}. The allocated memory belongs to its allocating thread! Use @emph{reallocShared} to reallocate from a shared heap.

@item resize
  @findex proc resize*[T](p꞉ ptr T; newSize꞉ Natural)꞉ ptr T @{.inline, benign.@}
@example
proc resize*[T](p꞉ ptr T; newSize꞉ Natural)꞉ ptr T @{.inline, benign.@}
@end example
  grows or shrinks a given memory block. If p is @strong{nil} then a new memory block is returned. In either way the block has at least @code{T.sizeof * newSize} bytes. If @code{newSize == 0} and p is not @strong{nil} @code{resize} calls @code{free(p)}. In other cases the block has to be freed with @code{free}. The allocated memory belongs to its allocating thread! Use @emph{resizeShared} to reallocate from a shared heap.

@item dealloc
  @findex proc dealloc*(p꞉ pointer) @{.noconv, rtl, tags꞉ [], benign.@}
@example
proc dealloc*(p꞉ pointer) @{.noconv, rtl, tags꞉ [], benign.@}
@end example
  frees the memory allocated with @code{alloc}, @code{alloc0} or @code{realloc}. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted. The freed memory must belong to its allocating thread! Use @emph{deallocShared} to deallocate from a shared heap.

@item allocShared
  @findex proc allocShared*(size꞉ Natural)꞉ pointer @{.noconv, rtl, benign.@}
@example
proc allocShared*(size꞉ Natural)꞉ pointer @{.noconv, rtl, benign.@}
@end example
  allocates a new memory block on the shared heap with at least @code{size} bytes. The block has to be freed with @code{reallocShared(block, 0)} or @code{deallocShared(block)}. The block is not initialized, so reading from it before writing to it is undefined behaviour!

@item createSharedU
  @findex proc createSharedU*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline, benign.@}
@example
proc createSharedU*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline, benign.@}
@end example
  allocates a new memory block on the shared heap with at least @code{T.sizeof * size} bytes. The block has to be freed with @code{resizeShared(block, 0)} or @code{freeShared(block)}. The block is not initialized, so reading from it before writing to it is undefined behaviour!

@item allocShared0
  @findex proc allocShared0*(size꞉ Natural)꞉ pointer @{.noconv, rtl, benign.@}
@example
proc allocShared0*(size꞉ Natural)꞉ pointer @{.noconv, rtl, benign.@}
@end example
  allocates a new memory block on the shared heap with at least @code{size} bytes. The block has to be freed with @code{reallocShared(block, 0)} or @code{deallocShared(block)}. The block is initialized with all bytes containing zero, so it is somewhat safer than @code{allocShared}.

@item createShared
  @findex proc createShared*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline.@}
@example
proc createShared*(T꞉ typedesc; size = 1.Positive)꞉ ptr T @{.inline.@}
@end example
  allocates a new memory block on the shared heap with at least @code{T.sizeof * size} bytes. The block has to be freed with @code{resizeShared(block, 0)} or @code{freeShared(block)}. The block is initialized with all bytes containing zero, so it is somewhat safer than @code{createSharedU}.

@item reallocShared
  @findex proc reallocShared*(p꞉ pointer; newSize꞉ Natural)꞉ pointer @{.noconv, rtl, benign.@}
@example
proc reallocShared*(p꞉ pointer; newSize꞉ Natural)꞉ pointer @{.noconv, rtl, benign.@}
@end example
  grows or shrinks a given memory block on the heap. If p is @strong{nil} then a new memory block is returned. In either way the block has at least @code{newSize} bytes. If @code{newSize == 0} and p is not @strong{nil} @code{reallocShared} calls @code{deallocShared(p)}. In other cases the block has to be freed with @code{deallocShared}.

@item resizeShared
  @findex proc resizeShared*[T](p꞉ ptr T; newSize꞉ Natural)꞉ ptr T @{.inline.@}
@example
proc resizeShared*[T](p꞉ ptr T; newSize꞉ Natural)꞉ ptr T @{.inline.@}
@end example
  grows or shrinks a given memory block on the heap. If p is @strong{nil} then a new memory block is returned. In either way the block has at least @code{T.sizeof * newSize} bytes. If @code{newSize == 0} and p is not @strong{nil} @code{resizeShared} calls @code{freeShared(p)}. In other cases the block has to be freed with @code{freeShared}.

@item deallocShared
  @findex proc deallocShared*(p꞉ pointer) @{.noconv, rtl, benign.@}
@example
proc deallocShared*(p꞉ pointer) @{.noconv, rtl, benign.@}
@end example
  frees the memory allocated with @code{allocShared}, @code{allocShared0} or @code{reallocShared}. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.

@item freeShared
  @findex proc freeShared*[T](p꞉ ptr T) @{.inline, benign.@}
@example
proc freeShared*[T](p꞉ ptr T) @{.inline, benign.@}
@end example
  frees the memory allocated with @code{createShared}, @code{createSharedU} or @code{resizeShared}. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.

@item swap
  @findex proc swap*[T](a, b꞉ var T) @{.magic꞉ "Swap", noSideEffect.@}
@example
proc swap*[T](a, b꞉ var T) @{.magic꞉ "Swap", noSideEffect.@}
@end example
  swaps the values @emph{a} and @emph{b}. This is often more efficient than @code{tmp = a; a = b; b = tmp}. Particularly useful for sorting algorithms.

@item `$`
  @findex proc `$`*(x꞉ int)꞉ string @{.magic꞉ "IntToStr", noSideEffect.@}
@example
proc `$`*(x꞉ int)꞉ string @{.magic꞉ "IntToStr", noSideEffect.@}
@end example
  The stringify operator for an integer argument. Returns @emph{x} converted to a decimal string. @code{$} is Nim's general way of spelling .

@item `$`
  @findex proc `$`*(x꞉ int64)꞉ string @{.magic꞉ "Int64ToStr", noSideEffect.@}
@example
proc `$`*(x꞉ int64)꞉ string @{.magic꞉ "Int64ToStr", noSideEffect.@}
@end example
  The stringify operator for an integer argument. Returns @emph{x} converted to a decimal string.

@item `$`
  @findex proc `$`*(x꞉ uint64)꞉ string @{.noSideEffect.@}
@example
proc `$`*(x꞉ uint64)꞉ string @{.noSideEffect.@}
@end example
  The stringify operator for an unsigned integer argument. Returns @emph{x} converted to a decimal string.

@item `$`
  @findex proc `$`*(x꞉ float)꞉ string @{.magic꞉ "FloatToStr", noSideEffect.@}
@example
proc `$`*(x꞉ float)꞉ string @{.magic꞉ "FloatToStr", noSideEffect.@}
@end example
  The stringify operator for a float argument. Returns @emph{x} converted to a decimal string.

@item `$`
  @findex proc `$`*(x꞉ bool)꞉ string @{.magic꞉ "BoolToStr", noSideEffect.@}
@example
proc `$`*(x꞉ bool)꞉ string @{.magic꞉ "BoolToStr", noSideEffect.@}
@end example
  The stringify operator for a boolean argument. Returns @emph{x} converted to the string "false" or "true".

@item `$`
  @findex proc `$`*(x꞉ char)꞉ string @{.magic꞉ "CharToStr", noSideEffect.@}
@example
proc `$`*(x꞉ char)꞉ string @{.magic꞉ "CharToStr", noSideEffect.@}
@end example
  The stringify operator for a character argument. Returns @emph{x} converted to a string.

@item `$`
  @findex proc `$`*(x꞉ cstring)꞉ string @{.magic꞉ "CStrToStr", noSideEffect.@}
@example
proc `$`*(x꞉ cstring)꞉ string @{.magic꞉ "CStrToStr", noSideEffect.@}
@end example
  The stringify operator for a CString argument. Returns @emph{x} converted to a string.

@item `$`
  @findex proc `$`*(x꞉ string)꞉ string @{.magic꞉ "StrToStr", noSideEffect.@}
@example
proc `$`*(x꞉ string)꞉ string @{.magic꞉ "StrToStr", noSideEffect.@}
@end example
  The stringify operator for a string argument. Returns @emph{x} as it is. This operator is useful for generic code, so that @code{$expr} also works if @code{expr} is already a string.

@item `$`
  @findex proc `$`*[Enum꞉ enum](x꞉ Enum)꞉ string @{.magic꞉ "EnumToStr", noSideEffect.@}
@example
proc `$`*[Enum꞉ enum](x꞉ Enum)꞉ string @{.magic꞉ "EnumToStr", noSideEffect.@}
@end example
  The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a @code{$} operator for a concrete enumeration is provided, this is used instead. (In other words: @emph{Overwriting} is possible.)

@item getRefcount
  @findex proc getRefcount*[T](x꞉ ref T)꞉ int @{.importc꞉ "getRefcount", noSideEffect.@}
@example
proc getRefcount*[T](x꞉ ref T)꞉ int @{.importc꞉ "getRefcount", noSideEffect.@}
@end example
  

@item getRefcount
  @findex proc getRefcount*(x꞉ string)꞉ int @{.importc꞉ "getRefcount", noSideEffect.@}
@example
proc getRefcount*(x꞉ string)꞉ int @{.importc꞉ "getRefcount", noSideEffect.@}
@end example
  

@item getRefcount
  @findex proc getRefcount*[T](x꞉ seq[T])꞉ int @{.importc꞉ "getRefcount", noSideEffect.@}
@example
proc getRefcount*[T](x꞉ seq[T])꞉ int @{.importc꞉ "getRefcount", noSideEffect.@}
@end example
  retrieves the reference count of an heap-allocated object. The value is implementation-dependent.

@item getOccupiedMem
  @findex proc getOccupiedMem*()꞉ int @{.rtl.@}
@example
proc getOccupiedMem*()꞉ int @{.rtl.@}
@end example
  returns the number of bytes that are owned by the process and hold data.

@item getFreeMem
  @findex proc getFreeMem*()꞉ int @{.rtl.@}
@example
proc getFreeMem*()꞉ int @{.rtl.@}
@end example
  returns the number of bytes that are owned by the process, but do not hold any meaningful data.

@item getTotalMem
  @findex proc getTotalMem*()꞉ int @{.rtl.@}
@example
proc getTotalMem*()꞉ int @{.rtl.@}
@end example
  returns the number of bytes that are owned by the process.

@item getOccupiedSharedMem
  @findex proc getOccupiedSharedMem*()꞉ int @{.rtl.@}
@example
proc getOccupiedSharedMem*()꞉ int @{.rtl.@}
@end example
  returns the number of bytes that are owned by the process on the shared heap and hold data. This is only available when threads are enabled.

@item getFreeSharedMem
  @findex proc getFreeSharedMem*()꞉ int @{.rtl.@}
@example
proc getFreeSharedMem*()꞉ int @{.rtl.@}
@end example
  returns the number of bytes that are owned by the process on the shared heap, but do not hold any meaningful data. This is only available when threads are enabled.

@item getTotalSharedMem
  @findex proc getTotalSharedMem*()꞉ int @{.rtl.@}
@example
proc getTotalSharedMem*()꞉ int @{.rtl.@}
@end example
  returns the number of bytes on the shared heap that are owned by the process. This is only available when threads are enabled.

@item min
  @findex proc min*(x, y꞉ int)꞉ int @{.magic꞉ "MinI", noSideEffect.@}
@example
proc min*(x, y꞉ int)꞉ int @{.magic꞉ "MinI", noSideEffect.@}
@end example
  

@item min
  @findex proc min*(x, y꞉ int8)꞉ int8 @{.magic꞉ "MinI", noSideEffect.@}
@example
proc min*(x, y꞉ int8)꞉ int8 @{.magic꞉ "MinI", noSideEffect.@}
@end example
  

@item min
  @findex proc min*(x, y꞉ int16)꞉ int16 @{.magic꞉ "MinI", noSideEffect.@}
@example
proc min*(x, y꞉ int16)꞉ int16 @{.magic꞉ "MinI", noSideEffect.@}
@end example
  

@item min
  @findex proc min*(x, y꞉ int32)꞉ int32 @{.magic꞉ "MinI", noSideEffect.@}
@example
proc min*(x, y꞉ int32)꞉ int32 @{.magic꞉ "MinI", noSideEffect.@}
@end example
  

@item min
  @findex proc min*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MinI", noSideEffect.@}
@example
proc min*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MinI", noSideEffect.@}
@end example
  The minimum value of two integers.

@item min
  @findex proc min*[T](x꞉ varargs[T])꞉ T
@example
proc min*[T](x꞉ varargs[T])꞉ T
@end example
  The minimum value of @emph{x}. @code{T} needs to have a @code{<} operator.

@item max
  @findex proc max*(x, y꞉ int)꞉ int @{.magic꞉ "MaxI", noSideEffect.@}
@example
proc max*(x, y꞉ int)꞉ int @{.magic꞉ "MaxI", noSideEffect.@}
@end example
  

@item max
  @findex proc max*(x, y꞉ int8)꞉ int8 @{.magic꞉ "MaxI", noSideEffect.@}
@example
proc max*(x, y꞉ int8)꞉ int8 @{.magic꞉ "MaxI", noSideEffect.@}
@end example
  

@item max
  @findex proc max*(x, y꞉ int16)꞉ int16 @{.magic꞉ "MaxI", noSideEffect.@}
@example
proc max*(x, y꞉ int16)꞉ int16 @{.magic꞉ "MaxI", noSideEffect.@}
@end example
  

@item max
  @findex proc max*(x, y꞉ int32)꞉ int32 @{.magic꞉ "MaxI", noSideEffect.@}
@example
proc max*(x, y꞉ int32)꞉ int32 @{.magic꞉ "MaxI", noSideEffect.@}
@end example
  

@item max
  @findex proc max*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MaxI", noSideEffect.@}
@example
proc max*(x, y꞉ int64)꞉ int64 @{.magic꞉ "MaxI", noSideEffect.@}
@end example
  The maximum value of two integers.

@item max
  @findex proc max*[T](x꞉ varargs[T])꞉ T
@example
proc max*[T](x꞉ varargs[T])꞉ T
@end example
  The maximum value of @emph{x}. @code{T} needs to have a @code{<} operator.

@item abs
  @findex proc abs*(x꞉ float)꞉ float @{.magic꞉ "AbsF64", noSideEffect.@}
@example
proc abs*(x꞉ float)꞉ float @{.magic꞉ "AbsF64", noSideEffect.@}
@end example
  

@item min
  @findex proc min*(x, y꞉ float)꞉ float @{.magic꞉ "MinF64", noSideEffect.@}
@example
proc min*(x, y꞉ float)꞉ float @{.magic꞉ "MinF64", noSideEffect.@}
@end example
  

@item max
  @findex proc max*(x, y꞉ float)꞉ float @{.magic꞉ "MaxF64", noSideEffect.@}
@example
proc max*(x, y꞉ float)꞉ float @{.magic꞉ "MaxF64", noSideEffect.@}
@end example
  

@item clamp
  @findex proc clamp*[T](x, a, b꞉ T)꞉ T
@example
proc clamp*[T](x, a, b꞉ T)꞉ T
@end example
  limits the value @code{x} within the interval [a, b]
@example
assert((1.4).clamp(0.0, 1.0) == 1.0)
assert((0.5).clamp(0.0, 1.0) == 0.5)
@end example

@item isNil
  @findex proc isNil*[T](x꞉ seq[T])꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@example
proc isNil*[T](x꞉ seq[T])꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@end example
  

@item isNil
  @findex proc isNil*[T](x꞉ ref T)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@example
proc isNil*[T](x꞉ ref T)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@end example
  

@item isNil
  @findex proc isNil*(x꞉ string)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@example
proc isNil*(x꞉ string)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@end example
  

@item isNil
  @findex proc isNil*[T](x꞉ ptr T)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@example
proc isNil*[T](x꞉ ptr T)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@end example
  

@item isNil
  @findex proc isNil*(x꞉ pointer)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@example
proc isNil*(x꞉ pointer)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@end example
  

@item isNil
  @findex proc isNil*(x꞉ cstring)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@example
proc isNil*(x꞉ cstring)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@end example
  

@item isNil
  @findex proc isNil*[T꞉ proc](x꞉ T)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@example
proc isNil*[T꞉ proc](x꞉ T)꞉ bool @{.noSideEffect, magic꞉ "IsNil".@}
@end example
  Fast check whether @emph{x} is nil. This is sometimes more efficient than @code{== nil}.

@item `==`
  @findex proc `==`*[I, T](x, y꞉ array[I, T])꞉ bool
@example
proc `==`*[I, T](x, y꞉ array[I, T])꞉ bool
@end example
  

@item `@@@@`
  @findex proc `@@`*[T](a꞉ openArray[T])꞉ seq[T]
@example
proc `@@`*[T](a꞉ openArray[T])꞉ seq[T]
@end example
  turns an openarray into a sequence. This is not as efficient as turning a fixed length array into a sequence as it always copies every element of @emph{a}.

@item `&`
  @findex proc `&`*[T](x, y꞉ seq[T])꞉ seq[T] @{.noSideEffect.@}
@example
proc `&`*[T](x, y꞉ seq[T])꞉ seq[T] @{.noSideEffect.@}
@end example
  Concatenates two sequences. Requires copying of the sequences.
@example
assert(@@[1, 2, 3, 4] & @@[5, 6] == @@[1, 2, 3, 4, 5, 6])
@end example

@item `&`
  @findex proc `&`*[T](x꞉ seq[T]; y꞉ T)꞉ seq[T] @{.noSideEffect.@}
@example
proc `&`*[T](x꞉ seq[T]; y꞉ T)꞉ seq[T] @{.noSideEffect.@}
@end example
  Appends element y to the end of the sequence. Requires copying of the sequence
@example
assert(@@[1, 2, 3] & 4 == @@[1, 2, 3, 4])
@end example

@item `&`
  @findex proc `&`*[T](x꞉ T; y꞉ seq[T])꞉ seq[T] @{.noSideEffect.@}
@example
proc `&`*[T](x꞉ T; y꞉ seq[T])꞉ seq[T] @{.noSideEffect.@}
@end example
  Prepends the element x to the beginning of the sequence. Requires copying of the sequence
@example
assert(1 & @@[2, 3, 4] == @@[1, 2, 3, 4])
@end example

@item `==`
  @findex proc `==`*[T](x, y꞉ seq[T])꞉ bool @{.noSideEffect.@}
@example
proc `==`*[T](x, y꞉ seq[T])꞉ bool @{.noSideEffect.@}
@end example
  Generic equals operator for sequences: relies on a equals operator for the element type @emph{T}.

@item find
  @findex proc find*[T, S](a꞉ T; item꞉ S)꞉ int @{.inline.@}
@example
proc find*[T, S](a꞉ T; item꞉ S)꞉ int @{.inline.@}
@end example
  Returns the first index of @emph{item} in @emph{a} or -1 if not found. This requires appropriate @emph{items} and @emph{==} operations to work.

@item contains
  @findex proc contains*[T](a꞉ openArray[T]; item꞉ T)꞉ bool @{.inline.@}
@example
proc contains*[T](a꞉ openArray[T]; item꞉ T)꞉ bool @{.inline.@}
@end example
  Returns true if @emph{item} is in @emph{a} or false if not found. This is a shortcut for @code{find(a, item) >= 0}.

@item pop
  @findex proc pop*[T](s꞉ var seq[T])꞉ T @{.inline, noSideEffect.@}
@example
proc pop*[T](s꞉ var seq[T])꞉ T @{.inline, noSideEffect.@}
@end example
  returns the last item of @emph{s} and decreases @code{s.len} by one. This treats @emph{s} as a stack and implements the common @emph{pop} operation.

@item `==`
  @findex proc `==`*[T꞉ tuple |object](x, y꞉ T)꞉ bool
@example
proc `==`*[T꞉ tuple |object](x, y꞉ T)꞉ bool
@end example
  generic @code{==} operator for tuples that is lifted from the components of @emph{x} and @emph{y}.

@item `<=`
  @findex proc `<=`*[T꞉ tuple](x, y꞉ T)꞉ bool
@example
proc `<=`*[T꞉ tuple](x, y꞉ T)꞉ bool
@end example
  generic @code{<=} operator for tuples that is lifted from the components of @emph{x} and @emph{y}. This implementation uses @emph{cmp}.

@item `<`
  @findex proc `<`*[T꞉ tuple](x, y꞉ T)꞉ bool
@example
proc `<`*[T꞉ tuple](x, y꞉ T)꞉ bool
@end example
  generic @code{<} operator for tuples that is lifted from the components of @emph{x} and @emph{y}. This implementation uses @emph{cmp}.

@item `$`
  @findex proc `$`*[T꞉ tuple |object](x꞉ T)꞉ string
@example
proc `$`*[T꞉ tuple |object](x꞉ T)꞉ string
@end example
  generic @code{$} operator for tuples that is lifted from the components of @emph{x}. Example:
@example
$(23, 45) == "(23, 45)"
$() == "()"
@end example

@item `$`
  @findex proc `$`*[T](x꞉ set[T])꞉ string
@example
proc `$`*[T](x꞉ set[T])꞉ string
@end example
  generic @code{$} operator for sets that is lifted from the components of @emph{x}. Example:
@example
$@{23, 45@} == "@{23, 45@}"
@end example

@item `$`
  @findex proc `$`*[T](x꞉ seq[T])꞉ string
@example
proc `$`*[T](x꞉ seq[T])꞉ string
@end example
  generic @code{$} operator for seqs that is lifted from the components of @emph{x}. Example:
@example
$(@@[23, 45]) == "@@[23, 45]"
@end example

@item GC_disable
  @findex proc GC_disable*() @{.rtl, inl, benign.@}
@example
proc GC_disable*() @{.rtl, inl, benign.@}
@end example
  disables the GC. If called n-times, n calls to @emph{GC_enable} are needed to reactivate the GC. Note that in most circumstances one should only disable the mark and sweep phase with @emph{GC_disableMarkAndSweep}.

@item GC_enable
  @findex proc GC_enable*() @{.rtl, inl, benign.@}
@example
proc GC_enable*() @{.rtl, inl, benign.@}
@end example
  enables the GC again.

@item GC_fullCollect
  @findex proc GC_fullCollect*() @{.rtl, benign.@}
@example
proc GC_fullCollect*() @{.rtl, benign.@}
@end example
  forces a full garbage collection pass. Ordinary code does not need to call this (and should not).

@item GC_setStrategy
  @findex proc GC_setStrategy*(strategy꞉ GC_Strategy) @{.rtl, deprecated, benign.@}
@example
proc GC_setStrategy*(strategy꞉ GC_Strategy) @{.rtl, deprecated, benign.@}
@end example
  tells the GC the desired strategy for the application. @strong{Deprecated} since version 0.8.14. This has always been a nop.

@item GC_enableMarkAndSweep
  @findex proc GC_enableMarkAndSweep*() @{.rtl, benign.@}
@example
proc GC_enableMarkAndSweep*() @{.rtl, benign.@}
@end example
  

@item GC_disableMarkAndSweep
  @findex proc GC_disableMarkAndSweep*() @{.rtl, benign.@}
@example
proc GC_disableMarkAndSweep*() @{.rtl, benign.@}
@end example
  the current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC.

@item GC_getStatistics
  @findex proc GC_getStatistics*()꞉ string @{.rtl, benign.@}
@example
proc GC_getStatistics*()꞉ string @{.rtl, benign.@}
@end example
  returns an informative string about the GC's activity. This may be useful for tweaking.

@item GC_ref
  @findex proc GC_ref*[T](x꞉ ref T) @{.magic꞉ "GCref", benign.@}
@example
proc GC_ref*[T](x꞉ ref T) @{.magic꞉ "GCref", benign.@}
@end example
  

@item GC_ref
  @findex proc GC_ref*[T](x꞉ seq[T]) @{.magic꞉ "GCref", benign.@}
@example
proc GC_ref*[T](x꞉ seq[T]) @{.magic꞉ "GCref", benign.@}
@end example
  

@item GC_ref
  @findex proc GC_ref*(x꞉ string) @{.magic꞉ "GCref", benign.@}
@example
proc GC_ref*(x꞉ string) @{.magic꞉ "GCref", benign.@}
@end example
  marks the object @emph{x} as referenced, so that it will not be freed until it is unmarked via @emph{GC_unref}. If called n-times for the same object @emph{x}, n calls to @emph{GC_unref} are needed to unmark @emph{x}.

@item GC_unref
  @findex proc GC_unref*[T](x꞉ ref T) @{.magic꞉ "GCunref", benign.@}
@example
proc GC_unref*[T](x꞉ ref T) @{.magic꞉ "GCunref", benign.@}
@end example
  

@item GC_unref
  @findex proc GC_unref*[T](x꞉ seq[T]) @{.magic꞉ "GCunref", benign.@}
@example
proc GC_unref*[T](x꞉ seq[T]) @{.magic꞉ "GCunref", benign.@}
@end example
  

@item GC_unref
  @findex proc GC_unref*(x꞉ string) @{.magic꞉ "GCunref", benign.@}
@example
proc GC_unref*(x꞉ string) @{.magic꞉ "GCunref", benign.@}
@end example
  see the documentation of @emph{GC_ref}.

@item add
  @findex proc add*(x꞉ var string; y꞉ cstring) @{.asmNoStackFrame.@}
@example
proc add*(x꞉ var string; y꞉ cstring) @{.asmNoStackFrame.@}
@end example
  

@item add
  @findex proc add*(x꞉ var cstring; y꞉ cstring) @{.magic꞉ "AppendStrStr".@}
@example
proc add*(x꞉ var cstring; y꞉ cstring) @{.magic꞉ "AppendStrStr".@}
@end example
  

@item echo
  @findex proc echo*(x꞉ varargs[typed, `$`]) @{.magic꞉ "Echo", tags꞉ [WriteIOEffect], benign,sideEffect.@}
@example
proc echo*(x꞉ varargs[typed, `$`]) @{.magic꞉ "Echo", tags꞉ [WriteIOEffect], benign,sideEffect.@}
@end example
  Writes and flushes the parameters to the standard output.

Special built-in that takes a variable number of arguments. Each argument is converted to a string via @code{$}, so it works for user-defined types that have an overloaded @code{$} operator. It is roughly equivalent to @code{writeLine(stdout, x); flushFile(stdout)}, but available for the JavaScript target too.

Unlike other IO operations this is guaranteed to be thread-safe as @code{echo} is very often used for debugging convenience. If you want to use @code{echo} inside a @uref{manual.html#pragmas-nosideeffect-pragma, proc without side effects} you can use @uref{#debugEcho, debugEcho} instead.

@item debugEcho
  @findex proc debugEcho*(x꞉ varargs[typed, `$`]) @{.magic꞉ "Echo", noSideEffect, tags꞉ [],raises꞉ [].@}
@example
proc debugEcho*(x꞉ varargs[typed, `$`]) @{.magic꞉ "Echo", noSideEffect, tags꞉ [],raises꞉ [].@}
@end example
  Same as @uref{#echo, echo}, but as a special semantic rule, @code{debugEcho} pretends to be free of side effects, so that it can be used for debugging routines marked as @uref{manual.html#pragmas-nosideeffect-pragma, noSideEffect}.

@item getTypeInfo
  @findex proc getTypeInfo*[T](x꞉ T)꞉ pointer @{.magic꞉ "GetTypeInfo", benign.@}
@example
proc getTypeInfo*[T](x꞉ T)꞉ pointer @{.magic꞉ "GetTypeInfo", benign.@}
@end example
  get type information for @emph{x}. Ordinary code should not use this, but the @emph{typeinfo} module instead.

@item abs
  @findex proc abs*(x꞉ int)꞉ int @{.magic꞉ "AbsI", noSideEffect.@}
@example
proc abs*(x꞉ int)꞉ int @{.magic꞉ "AbsI", noSideEffect.@}
@end example
  

@item abs
  @findex proc abs*(x꞉ int8)꞉ int8 @{.magic꞉ "AbsI", noSideEffect.@}
@example
proc abs*(x꞉ int8)꞉ int8 @{.magic꞉ "AbsI", noSideEffect.@}
@end example
  

@item abs
  @findex proc abs*(x꞉ int16)꞉ int16 @{.magic꞉ "AbsI", noSideEffect.@}
@example
proc abs*(x꞉ int16)꞉ int16 @{.magic꞉ "AbsI", noSideEffect.@}
@end example
  

@item abs
  @findex proc abs*(x꞉ int32)꞉ int32 @{.magic꞉ "AbsI", noSideEffect.@}
@example
proc abs*(x꞉ int32)꞉ int32 @{.magic꞉ "AbsI", noSideEffect.@}
@end example
  

@item abs
  @findex proc abs*(x꞉ int64)꞉ int64 @{.magic꞉ "AbsI", noSideEffect.@}
@example
proc abs*(x꞉ int64)꞉ int64 @{.magic꞉ "AbsI", noSideEffect.@}
@end example
  returns the absolute value of @emph{x}. If @emph{x} is @code{low(x)} (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on).

@item open
  @findex proc open*(f꞉ var File; filename꞉ string; mode꞉ FileMode = fmRead; bufSize꞉ int = - 1)꞉ bool @{.tags꞉ [], benign.@}
@example
proc open*(f꞉ var File; filename꞉ string; mode꞉ FileMode = fmRead; bufSize꞉ int = - 1)꞉ bool @{.tags꞉ [], benign.@}
@end example
  Opens a file named @emph{filename} with given @emph{mode}.

Default mode is readonly. Returns true iff the file could be opened. This throws no exception if the file could not be opened.

@item open
  @findex proc open*(f꞉ var File; filehandle꞉ FileHandle; mode꞉ FileMode = fmRead)꞉ bool @{.tags꞉ [],benign.@}
@example
proc open*(f꞉ var File; filehandle꞉ FileHandle; mode꞉ FileMode = fmRead)꞉ bool @{.tags꞉ [],benign.@}
@end example
  Creates a @code{File} from a @emph{filehandle} with given @emph{mode}.

Default mode is readonly. Returns true iff the file could be opened.

@item open
  @findex proc open*(filename꞉ string; mode꞉ FileMode = fmRead; bufSize꞉ int = - 1)꞉ File
@example
proc open*(filename꞉ string; mode꞉ FileMode = fmRead; bufSize꞉ int = - 1)꞉ File
@end example
  Opens a file named @emph{filename} with given @emph{mode}.

Default mode is readonly. Raises an @code{IO} exception if the file could not be opened.

@item reopen
  @findex proc reopen*(f꞉ File; filename꞉ string; mode꞉ FileMode = fmRead)꞉ bool @{.tags꞉ [], benign.@}
@example
proc reopen*(f꞉ File; filename꞉ string; mode꞉ FileMode = fmRead)꞉ bool @{.tags꞉ [], benign.@}
@end example
  reopens the file @emph{f} with given @emph{filename} and @emph{mode}. This is often used to redirect the @emph{stdin}, @emph{stdout} or @emph{stderr} file variables.

Default mode is readonly. Returns true iff the file could be reopened.

@item close
  @findex proc close*(f꞉ File) @{.importc꞉ "fclose", header꞉ "<stdio.h>", tags꞉ [].@}
@example
proc close*(f꞉ File) @{.importc꞉ "fclose", header꞉ "<stdio.h>", tags꞉ [].@}
@end example
  Closes the file.

@item endOfFile
  @findex proc endOfFile*(f꞉ File)꞉ bool @{.tags꞉ [], benign.@}
@example
proc endOfFile*(f꞉ File)꞉ bool @{.tags꞉ [], benign.@}
@end example
  Returns true iff @emph{f} is at the end.

@item readChar
  @findex proc readChar*(f꞉ File)꞉ char @{.importc꞉ "fgetc", header꞉ "<stdio.h>",tags꞉ [ReadIOEffect].@}
@example
proc readChar*(f꞉ File)꞉ char @{.importc꞉ "fgetc", header꞉ "<stdio.h>",tags꞉ [ReadIOEffect].@}
@end example
  Reads a single character from the stream @emph{f}.

@item flushFile
  @findex proc flushFile*(f꞉ File) @{.importc꞉ "fflush", header꞉ "<stdio.h>",tags꞉ [WriteIOEffect].@}
@example
proc flushFile*(f꞉ File) @{.importc꞉ "fflush", header꞉ "<stdio.h>",tags꞉ [WriteIOEffect].@}
@end example
  Flushes @emph{f}'s buffer.

@item readAll
  @findex proc readAll*(file꞉ File)꞉ TaintedString @{.tags꞉ [ReadIOEffect], benign.@}
@example
proc readAll*(file꞉ File)꞉ TaintedString @{.tags꞉ [ReadIOEffect], benign.@}
@end example
  Reads all data from the stream @emph{file}.

Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.

@item readFile
  @findex proc readFile*(filename꞉ string)꞉ TaintedString @{.tags꞉ [ReadIOEffect], benign.@}
@example
proc readFile*(filename꞉ string)꞉ TaintedString @{.tags꞉ [ReadIOEffect], benign.@}
@end example
  Opens a file named @emph{filename} for reading.

Then calls @uref{#readAll, readAll} and closes the file afterwards. Returns the string.  Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use @uref{#staticRead, staticRead}.

@item writeFile
  @findex proc writeFile*(filename, content꞉ string) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc writeFile*(filename, content꞉ string) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  Opens a file named @emph{filename} for writing. Then writes the @emph{content} completely to the file and closes the file afterwards. Raises an IO exception in case of an error.

@item write
  @findex proc write*(f꞉ File; r꞉ float32) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; r꞉ float32) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; i꞉ int) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; i꞉ int) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; i꞉ BiggestInt) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; i꞉ BiggestInt) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; r꞉ BiggestFloat) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; r꞉ BiggestFloat) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; s꞉ string) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; s꞉ string) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; b꞉ bool) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; b꞉ bool) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; c꞉ char) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; c꞉ char) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; c꞉ cstring) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; c꞉ cstring) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  

@item write
  @findex proc write*(f꞉ File; a꞉ varargs[string, `$`]) @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc write*(f꞉ File; a꞉ varargs[string, `$`]) @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  Writes a value to the file @emph{f}. May throw an IO exception.

@item readLine
  @findex proc readLine*(f꞉ File)꞉ TaintedString @{.tags꞉ [ReadIOEffect], benign.@}
@example
proc readLine*(f꞉ File)꞉ TaintedString @{.tags꞉ [ReadIOEffect], benign.@}
@end example
  reads a line of text from the file @emph{f}. May throw an IO exception. A line of text may be delimited by @code{LF} or @code{CRLF}. The newline character(s) are not part of the returned string.

@item readLine
  @findex proc readLine*(f꞉ File; line꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect], benign.@}
@example
proc readLine*(f꞉ File; line꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect], benign.@}
@end example
  reads a line of text from the file @emph{f} into @emph{line}. @emph{line} must not be @code{nil}! May throw an IO exception. A line of text may be delimited by @code{LF} or @code{CRLF}. The newline character(s) are not part of the returned string. Returns @code{false} if the end of the file has been reached, @code{true} otherwise. If @code{false} is returned @emph{line} contains no new data.

@item writeLn
  @findex proc writeLn*[Ty](f꞉ File; x꞉ varargs[Ty, `$`]) @{.inline, tags꞉ [WriteIOEffect], benign,deprecated.@}
@example
proc writeLn*[Ty](f꞉ File; x꞉ varargs[Ty, `$`]) @{.inline, tags꞉ [WriteIOEffect], benign,deprecated.@}
@end example
  @strong{Deprecated since version 0.11.4:} Use @strong{writeLine} instead.

@item writeLine
  @findex proc writeLine*[Ty](f꞉ File; x꞉ varargs[Ty, `$`]) @{.inline, tags꞉ [WriteIOEffect], benign.@}
@example
proc writeLine*[Ty](f꞉ File; x꞉ varargs[Ty, `$`]) @{.inline, tags꞉ [WriteIOEffect], benign.@}
@end example
  writes the values @emph{x} to @emph{f} and then writes "n". May throw an IO exception.

@item getFileSize
  @findex proc getFileSize*(f꞉ File)꞉ int64 @{.tags꞉ [ReadIOEffect], benign.@}
@example
proc getFileSize*(f꞉ File)꞉ int64 @{.tags꞉ [ReadIOEffect], benign.@}
@end example
  retrieves the file size (in bytes) of @emph{f}.

@item readBytes
  @findex proc readBytes*(f꞉ File; a꞉ var openArray[int8 | uint8]; start, len꞉ Natural)꞉ int @{.tags꞉ [ReadIOEffect], benign.@}
@example
proc readBytes*(f꞉ File; a꞉ var openArray[int8 | uint8]; start, len꞉ Natural)꞉ int @{.tags꞉ [ReadIOEffect], benign.@}
@end example
  reads @emph{len} bytes into the buffer @emph{a} starting at @code{a[start]}. Returns the actual number of bytes that have been read which may be less than @emph{len} (if not as many bytes are remaining), but not greater.

@item readChars
  @findex proc readChars*(f꞉ File; a꞉ var openArray[char]; start, len꞉ Natural)꞉ int @{.tags꞉ [ReadIOEffect], benign.@}
@example
proc readChars*(f꞉ File; a꞉ var openArray[char]; start, len꞉ Natural)꞉ int @{.tags꞉ [ReadIOEffect], benign.@}
@end example
  reads @emph{len} bytes into the buffer @emph{a} starting at @code{a[start]}. Returns the actual number of bytes that have been read which may be less than @emph{len} (if not as many bytes are remaining), but not greater.

@item readBuffer
  @findex proc readBuffer*(f꞉ File; buffer꞉ pointer; len꞉ Natural)꞉ int @{.tags꞉ [ReadIOEffect],benign.@}
@example
proc readBuffer*(f꞉ File; buffer꞉ pointer; len꞉ Natural)꞉ int @{.tags꞉ [ReadIOEffect],benign.@}
@end example
  reads @emph{len} bytes into the buffer pointed to by @emph{buffer}. Returns the actual number of bytes that have been read which may be less than @emph{len} (if not as many bytes are remaining), but not greater.

@item writeBytes
  @findex proc writeBytes*(f꞉ File; a꞉ openArray[int8 | uint8]; start, len꞉ Natural)꞉ int @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc writeBytes*(f꞉ File; a꞉ openArray[int8 | uint8]; start, len꞉ Natural)꞉ int @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  writes the bytes of @code{a[start..start+len-1]} to the file @emph{f}. Returns the number of actual written bytes, which may be less than @emph{len} in case of an error.

@item writeChars
  @findex proc writeChars*(f꞉ File; a꞉ openArray[char]; start, len꞉ Natural)꞉ int @{.tags꞉ [WriteIOEffect], benign.@}
@example
proc writeChars*(f꞉ File; a꞉ openArray[char]; start, len꞉ Natural)꞉ int @{.tags꞉ [WriteIOEffect], benign.@}
@end example
  writes the bytes of @code{a[start..start+len-1]} to the file @emph{f}. Returns the number of actual written bytes, which may be less than @emph{len} in case of an error.

@item writeBuffer
  @findex proc writeBuffer*(f꞉ File; buffer꞉ pointer; len꞉ Natural)꞉ int @{.tags꞉ [WriteIOEffect],benign.@}
@example
proc writeBuffer*(f꞉ File; buffer꞉ pointer; len꞉ Natural)꞉ int @{.tags꞉ [WriteIOEffect],benign.@}
@end example
  writes the bytes of buffer pointed to by the parameter @emph{buffer} to the file @emph{f}. Returns the number of actual written bytes, which may be less than @emph{len} in case of an error.

@item setFilePos
  @findex proc setFilePos*(f꞉ File; pos꞉ int64) @{.benign.@}
@example
proc setFilePos*(f꞉ File; pos꞉ int64) @{.benign.@}
@end example
  sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero.

@item getFilePos
  @findex proc getFilePos*(f꞉ File)꞉ int64 @{.benign.@}
@example
proc getFilePos*(f꞉ File)꞉ int64 @{.benign.@}
@end example
  retrieves the current position of the file pointer that is used to read from the file @emph{f}. The file's first byte has the index zero.

@item getFileHandle
  @findex proc getFileHandle*(f꞉ File)꞉ FileHandle @{.importc꞉ "fileno", header꞉ "<stdio.h>".@}
@example
proc getFileHandle*(f꞉ File)꞉ FileHandle @{.importc꞉ "fileno", header꞉ "<stdio.h>".@}
@end example
  returns the OS file handle of the file @code{f}. This is only useful for platform specific programming.

@item cstringArrayToSeq
  @findex proc cstringArrayToSeq*(a꞉ cstringArray; len꞉ Natural)꞉ seq[string]
@example
proc cstringArrayToSeq*(a꞉ cstringArray; len꞉ Natural)꞉ seq[string]
@end example
  converts a @code{cstringArray} to a @code{seq[string]}. @emph{a} is supposed to be of length @code{len}.

@item cstringArrayToSeq
  @findex proc cstringArrayToSeq*(a꞉ cstringArray)꞉ seq[string]
@example
proc cstringArrayToSeq*(a꞉ cstringArray)꞉ seq[string]
@end example
  converts a @code{cstringArray} to a @code{seq[string]}. @emph{a} is supposed to be terminated by @code{nil}.

@item allocCStringArray
  @findex proc allocCStringArray*(a꞉ openArray[string])꞉ cstringArray
@example
proc allocCStringArray*(a꞉ openArray[string])꞉ cstringArray
@end example
  creates a NULL terminated cstringArray from @emph{a}. The result has to be freed with @emph{deallocCStringArray} after it's not needed anymore.

@item deallocCStringArray
  @findex proc deallocCStringArray*(a꞉ cstringArray)
@example
proc deallocCStringArray*(a꞉ cstringArray)
@end example
  frees a NULL terminated cstringArray.

@item atomicInc
  @findex proc atomicInc*(memLoc꞉ var int; x꞉ int = 1)꞉ int @{.inline, discardable, benign.@}
@example
proc atomicInc*(memLoc꞉ var int; x꞉ int = 1)꞉ int @{.inline, discardable, benign.@}
@end example
  atomic increment of @emph{memLoc}. Returns the value after the operation.

@item atomicDec
  @findex proc atomicDec*(memLoc꞉ var int; x꞉ int = 1)꞉ int @{.inline, discardable, benign.@}
@example
proc atomicDec*(memLoc꞉ var int; x꞉ int = 1)꞉ int @{.inline, discardable, benign.@}
@end example
  atomic decrement of @emph{memLoc}. Returns the value after the operation.

@item setControlCHook
  @findex proc setControlCHook*(hook꞉ proc () @{.noconv.@} not nil)
@example
proc setControlCHook*(hook꞉ proc () @{.noconv.@} not nil)
@end example
  allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.

@item writeStackTrace
  @findex proc writeStackTrace*() @{.tags꞉ [WriteIOEffect].@}
@example
proc writeStackTrace*() @{.tags꞉ [WriteIOEffect].@}
@end example
  writes the current stack trace to @code{stderr}. This is only works for debug builds.

@item getStackTrace
  @findex proc getStackTrace*()꞉ string
@example
proc getStackTrace*()꞉ string
@end example
  gets the current stack trace. This only works for debug builds.

@item getStackTrace
  @findex proc getStackTrace*(e꞉ ref Exception)꞉ string
@example
proc getStackTrace*(e꞉ ref Exception)꞉ string
@end example
  gets the stack trace associated with @emph{e}, which is the stack that lead to the @code{raise} statement. This only works for debug builds.

@item getCurrentException
  @findex proc getCurrentException*()꞉ ref Exception @{.compilerRtl, inl, benign.@}
@example
proc getCurrentException*()꞉ ref Exception @{.compilerRtl, inl, benign.@}
@end example
  retrieves the current exception; if there is none, nil is returned.

@item getCurrentExceptionMsg
  @findex proc getCurrentExceptionMsg*()꞉ string @{.inline, benign.@}
@example
proc getCurrentExceptionMsg*()꞉ string @{.inline, benign.@}
@end example
  retrieves the error message that was attached to the current exception; if there is none, "" is returned.

@item onRaise
  @findex proc onRaise*(action꞉ proc (e꞉ ref Exception)꞉ bool @{.closure.@})
@example
proc onRaise*(action꞉ proc (e꞉ ref Exception)꞉ bool @{.closure.@})
@end example
  can be used in a @code{try} statement to setup a Lisp-like : This prevents the 'raise' statement to raise an exception but instead calls @code{action}. If @code{action} returns false, the exception has been handled and does not propagate further through the call stack.

@item setCurrentException
  @findex proc setCurrentException*(exc꞉ ref Exception) @{.inline, benign.@}
@example
proc setCurrentException*(exc꞉ ref Exception) @{.inline, benign.@}
@end example
  sets the current exception.

@strong{Warning}: Only use this if you know what you are doing.

@item likely
  @findex proc likely*(val꞉ bool)꞉ bool @{.importc꞉ "likely", nodecl, nosideeffect.@}
@example
proc likely*(val꞉ bool)꞉ bool @{.importc꞉ "likely", nodecl, nosideeffect.@}
@end example
  Hints the optimizer that @emph{val} is likely going to be true.

You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:


@example
for value in inputValues:
  if likely(value <= 100):
    process(value)
  else:
    echo "Value too big!"
@end example

@item unlikely
  @findex proc unlikely*(val꞉ bool)꞉ bool @{.importc꞉ "unlikely", nodecl, nosideeffect.@}
@example
proc unlikely*(val꞉ bool)꞉ bool @{.importc꞉ "unlikely", nodecl, nosideeffect.@}
@end example
  Hints the optimizer that @emph{val} is likely going to be false.

You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:


@example
for value in inputValues:
  if unlikely(value > 100):
    echo "Value too big!"
  else:
    process(value)
@end example

@item rawProc
  @findex proc rawProc*[T꞉ proc](x꞉ T)꞉ pointer @{.noSideEffect, inline.@}
@example
proc rawProc*[T꞉ proc](x꞉ T)꞉ pointer @{.noSideEffect, inline.@}
@end example
  retrieves the raw proc pointer of the closure @emph{x}. This is useful for interfacing closures with C.

@item rawEnv
  @findex proc rawEnv*[T꞉ proc](x꞉ T)꞉ pointer @{.noSideEffect, inline.@}
@example
proc rawEnv*[T꞉ proc](x꞉ T)꞉ pointer @{.noSideEffect, inline.@}
@end example
  retrieves the raw environment pointer of the closure @emph{x}. This is useful for interfacing closures with C.

@item finished
  @findex proc finished*[T꞉ proc](x꞉ T)꞉ bool @{.noSideEffect, inline.@}
@example
proc finished*[T꞉ proc](x꞉ T)꞉ bool @{.noSideEffect, inline.@}
@end example
  can be used to determine if a first class iterator has finished.

@item quit
  @findex proc quit*(errormsg꞉ string; errorcode = QuitFailure) @{.noReturn.@}
@example
proc quit*(errormsg꞉ string; errorcode = QuitFailure) @{.noReturn.@}
@end example
  a shorthand for @code{echo(errormsg); quit(errorcode)}.

@item `/`
  @findex proc `/`*(x, y꞉ int)꞉ float @{.inline, noSideEffect.@}
@example
proc `/`*(x, y꞉ int)꞉ float @{.inline, noSideEffect.@}
@end example
  integer division that results in a float.

@item `[]`
  @findex proc `[]`*(s꞉ string; x꞉ Slice[int])꞉ string @{.inline.@}
@example
proc `[]`*(s꞉ string; x꞉ Slice[int])꞉ string @{.inline.@}
@end example
  slice operation for strings.

@item `[]=`
  @findex proc `[]=`*(s꞉ var string; x꞉ Slice[int]; b꞉ string)
@example
proc `[]=`*(s꞉ var string; x꞉ Slice[int]; b꞉ string)
@end example
  slice assignment for strings. If @code{b.len} is not exactly the number of elements that are referred to by @emph{x}, a  is performed:
@example
var s = "abcdef"
s[1 .. ^2] = "xyz"
assert s == "axyzf"
@end example

@item `[]`
  @findex proc `[]`*[Idx, T](a꞉ array[Idx, T]; x꞉ Slice[int])꞉ seq[T]
@example
proc `[]`*[Idx, T](a꞉ array[Idx, T]; x꞉ Slice[int])꞉ seq[T]
@end example
  slice operation for arrays.

@item `[]=`
  @findex proc `[]=`*[Idx, T](a꞉ var array[Idx, T]; x꞉ Slice[int]; b꞉ openArray[T])
@example
proc `[]=`*[Idx, T](a꞉ var array[Idx, T]; x꞉ Slice[int]; b꞉ openArray[T])
@end example
  slice assignment for arrays.

@item `[]`
  @findex proc `[]`*[Idx, T](a꞉ array[Idx, T]; x꞉ Slice[Idx])꞉ seq[T]
@example
proc `[]`*[Idx, T](a꞉ array[Idx, T]; x꞉ Slice[Idx])꞉ seq[T]
@end example
  slice operation for arrays.

@item `[]=`
  @findex proc `[]=`*[Idx, T](a꞉ var array[Idx, T]; x꞉ Slice[Idx]; b꞉ openArray[T])
@example
proc `[]=`*[Idx, T](a꞉ var array[Idx, T]; x꞉ Slice[Idx]; b꞉ openArray[T])
@end example
  slice assignment for arrays.

@item `[]`
  @findex proc `[]`*[T](s꞉ seq[T]; x꞉ Slice[int])꞉ seq[T]
@example
proc `[]`*[T](s꞉ seq[T]; x꞉ Slice[int])꞉ seq[T]
@end example
  slice operation for sequences.

@item `[]=`
  @findex proc `[]=`*[T](s꞉ var seq[T]; x꞉ Slice[int]; b꞉ openArray[T])
@example
proc `[]=`*[T](s꞉ var seq[T]; x꞉ Slice[int]; b꞉ openArray[T])
@end example
  slice assignment for sequences. If @code{b.len} is not exactly the number of elements that are referred to by @emph{x}, a  is performed.

@item slurp
  @findex proc slurp*(filename꞉ string)꞉ string @{.magic꞉ "Slurp".@}
@example
proc slurp*(filename꞉ string)꞉ string @{.magic꞉ "Slurp".@}
@end example
  This is an alias for @uref{#staticRead, staticRead}.

@item staticRead
  @findex proc staticRead*(filename꞉ string)꞉ string @{.magic꞉ "Slurp".@}
@example
proc staticRead*(filename꞉ string)꞉ string @{.magic꞉ "Slurp".@}
@end example
  Compile-time @uref{#readFile, readFile} proc for easy  embedding:
@example
const myResource = staticRead"mydatafile.bin"
@end example
@uref{#slurp, slurp} is an alias for @code{staticRead}.

@item gorge
  @findex proc gorge*(command꞉ string; input = ""; cache = "")꞉ string @{.magic꞉ "StaticExec".@}
@example
proc gorge*(command꞉ string; input = ""; cache = "")꞉ string @{.magic꞉ "StaticExec".@}
@end example
  This is an alias for @uref{#staticExec, staticExec}.

@item staticExec
  @findex proc staticExec*(command꞉ string; input = ""; cache = "")꞉ string @{.magic꞉ "StaticExec".@}
@example
proc staticExec*(command꞉ string; input = ""; cache = "")꞉ string @{.magic꞉ "StaticExec".@}
@end example
  Executes an external process at compile-time. if @emph{input} is not an empty string, it will be passed as a standard input to the executed program.
@example
const buildInfo = "Revision " & staticExec("git rev-parse HEAD") &
                  "\nCompiled on " & staticExec("uname -v")
@end example
@uref{#gorge, gorge} is an alias for @code{staticExec}. Note that you can use this proc inside a pragma like @uref{nimc.html#passc-pragma, passC} or @uref{nimc.html#passl-pragma, passL}.

If @code{cache} is not empty, the results of @code{staticExec} are cached within the @code{nimcache} directory. Use @code{--forceBuild} to get rid of this caching behaviour then. @code{command & input & cache} (the concatenated string) is used to determine wether the entry in the cache is still valid. You can use versioning information for @code{cache}:


@example
const stateMachine = staticExec("dfaoptimizer", "input", "0.8.0")
@end example

@item `+=`
  @findex proc `+=`*[T꞉ SomeOrdinal | uint | uint64](x꞉ var T; y꞉ T) @{.magic꞉ "Inc", noSideEffect.@}
@example
proc `+=`*[T꞉ SomeOrdinal | uint | uint64](x꞉ var T; y꞉ T) @{.magic꞉ "Inc", noSideEffect.@}
@end example
  Increments an ordinal

@item `-=`
  @findex proc `-=`*[T꞉ SomeOrdinal | uint | uint64](x꞉ var T; y꞉ T) @{.magic꞉ "Dec", noSideEffect.@}
@example
proc `-=`*[T꞉ SomeOrdinal | uint | uint64](x꞉ var T; y꞉ T) @{.magic꞉ "Dec", noSideEffect.@}
@end example
  Decrements an ordinal

@item `*=`
  @findex proc `*=`*[T꞉ SomeOrdinal | uint | uint64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@example
proc `*=`*[T꞉ SomeOrdinal | uint | uint64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@end example
  Binary @emph{*=} operator for ordinals

@item `+=`
  @findex proc `+=`*[T꞉ float | float32 | float64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@example
proc `+=`*[T꞉ float | float32 | float64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@end example
  Increments in placee a floating point number

@item `-=`
  @findex proc `-=`*[T꞉ float | float32 | float64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@example
proc `-=`*[T꞉ float | float32 | float64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@end example
  Decrements in place a floating point number

@item `*=`
  @findex proc `*=`*[T꞉ float | float32 | float64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@example
proc `*=`*[T꞉ float | float32 | float64](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@end example
  Multiplies in place a floating point number

@item `/=`
  @findex proc `/=`*(x꞉ var float64; y꞉ float64) @{.inline, noSideEffect.@}
@example
proc `/=`*(x꞉ var float64; y꞉ float64) @{.inline, noSideEffect.@}
@end example
  Divides in place a floating point number

@item `/=`
  @findex proc `/=`*[T꞉ float | float32](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@example
proc `/=`*[T꞉ float | float32](x꞉ var T; y꞉ T) @{.inline, noSideEffect.@}
@end example
  Divides in place a floating point number

@item `&=`
  @findex proc `&=`*(x꞉ var string; y꞉ string) @{.magic꞉ "AppendStrStr", noSideEffect.@}
@example
proc `&=`*(x꞉ var string; y꞉ string) @{.magic꞉ "AppendStrStr", noSideEffect.@}
@end example
  

@item astToStr
  @findex proc astToStr*[T](x꞉ T)꞉ string @{.magic꞉ "AstToStr", noSideEffect.@}
@example
proc astToStr*[T](x꞉ T)꞉ string @{.magic꞉ "AstToStr", noSideEffect.@}
@end example
  converts the AST of @emph{x} into a string representation. This is very useful for debugging.

@item instantiationInfo
  @findex proc instantiationInfo*(index = - 1; fullPaths = false)꞉ tuple[filename꞉ string, line꞉ int] @{.magic꞉ "InstantiationInfo", noSideEffect.@}
@example
proc instantiationInfo*(index = - 1; fullPaths = false)꞉ tuple[filename꞉ string, line꞉ int] @{.magic꞉ "InstantiationInfo", noSideEffect.@}
@end example
  provides access to the compiler's instantiation stack line information.

This proc is mostly useful for meta programming (eg. @code{assert} template) to retrieve information about the current filename and line number. Example:


@example
import strutils

template testException(exception, code: expr): stmt =
  try:
    let pos = instantiationInfo()
    discard(code)
    echo "Test failure at $1:$2 with '$3'" % [pos.filename,
      $pos.line, astToStr(code)]
    assert false, "A test expecting failure succeeded?"
  except exception:
    discard

proc tester(pos: int): int =
  let
    a = @@[1, 2, 3]
  result = a[pos]

when isMainModule:
  testException(IndexError, tester(30))
  testException(IndexError, tester(1))
  # --> Test failure at example.nim:20 with 'tester(1)'
@end example

@item raiseAssert
  @findex proc raiseAssert*(msg꞉ string) @{.noinline.@}
@example
proc raiseAssert*(msg꞉ string) @{.noinline.@}
@end example
  

@item failedAssertImpl
  @findex proc failedAssertImpl*(msg꞉ string) @{.raises꞉ [], tags꞉ [].@}
@example
proc failedAssertImpl*(msg꞉ string) @{.raises꞉ [], tags꞉ [].@}
@end example
  

@item shallow
  @findex proc shallow*[T](s꞉ var seq[T]) @{.noSideEffect, inline.@}
@example
proc shallow*[T](s꞉ var seq[T]) @{.noSideEffect, inline.@}
@end example
  marks a sequence @emph{s} as . Subsequent assignments will not perform deep copies of @emph{s}. This is only useful for optimization purposes.

@item shallow
  @findex proc shallow*(s꞉ var string) @{.noSideEffect, inline.@}
@example
proc shallow*(s꞉ var string) @{.noSideEffect, inline.@}
@end example
  marks a string @emph{s} as . Subsequent assignments will not perform deep copies of @emph{s}. This is only useful for optimization purposes.

@item insert
  @findex proc insert*(x꞉ var string; item꞉ string; i = 0.Natural) @{.noSideEffect.@}
@example
proc insert*(x꞉ var string; item꞉ string; i = 0.Natural) @{.noSideEffect.@}
@end example
  inserts @emph{item} into @emph{x} at position @emph{i}.

@item compiles
  @findex proc compiles*(x꞉ expr)꞉ bool @{.magic꞉ "Compiles", noSideEffect, compileTime.@}
@example
proc compiles*(x꞉ expr)꞉ bool @{.magic꞉ "Compiles", noSideEffect, compileTime.@}
@end example
  Special compile-time procedure that checks whether @emph{x} can be compiled without any semantic error. This can be used to check whether a type supports some operation:
@example
when not compiles(3 + 4):
  echo "'+' for integers is available"
@end example

@item safeAdd
  @findex proc safeAdd*[T](x꞉ var seq[T]; y꞉ T) @{.noSideEffect.@}
@example
proc safeAdd*[T](x꞉ var seq[T]; y꞉ T) @{.noSideEffect.@}
@end example
  Adds @code{y} to @code{x} unless @code{x} is not yet initialized; in that case, @code{x} becomes @code{@@[y]}

@item safeAdd
  @findex proc safeAdd*(x꞉ var string; y꞉ char)
@example
proc safeAdd*(x꞉ var string; y꞉ char)
@end example
  Adds @code{y} to @code{x}. If @code{x} is @code{nil} it is initialized to @code{""}

@item safeAdd
  @findex proc safeAdd*(x꞉ var string; y꞉ string)
@example
proc safeAdd*(x꞉ var string; y꞉ string)
@end example
  Adds @code{y} to @code{x} unless @code{x} is not yet initalized; in that case, @code{x} becomes @code{y}

@item locals
  @findex proc locals*()꞉ RootObj @{.magic꞉ "Plugin", noSideEffect.@}
@example
proc locals*()꞉ RootObj @{.magic꞉ "Plugin", noSideEffect.@}
@end example
  generates a tuple constructor expression listing all the local variables in the current scope. This is quite fast as it does not rely on any debug or runtime information. Note that in constrast to what the official signature says, the return type is not @code{RootObj} but a tuple of a structure that depends on the current scope. Example:
@example
proc testLocals() =
  var
    a = "something"
    b = 4
    c = locals()
    d = "super!"
  
  b = 1
  for name, value in fieldPairs(c):
    echo "name ", name, " with value ", value
  echo "B is ", b
# -> name a with value something
# -> name b with value 4
# -> B is 1
@end example

@item deepCopy
  @findex proc deepCopy*[T](x꞉ var T; y꞉ T) @{.noSideEffect, magic꞉ "DeepCopy".@}
@example
proc deepCopy*[T](x꞉ var T; y꞉ T) @{.noSideEffect, magic꞉ "DeepCopy".@}
@end example
  performs a deep copy of @emph{x}. This is also used by the code generator for the implementation of @code{spawn}.

@item procCall
  @findex proc procCall*(x꞉ expr) @{.magic꞉ "ProcCall", compileTime.@}
@example
proc procCall*(x꞉ expr) @{.magic꞉ "ProcCall", compileTime.@}
@end example
  special magic to prohibit dynamic binding for  calls. This is similar to  in ordinary OO languages.
@example
# 'someMethod' will be resolved fully statically:
procCall someMethod(a, b)
@end example

@item `^`
  @findex proc `^`*[T](x꞉ int; y꞉ openArray[T])꞉ int @{.noSideEffect, magic꞉ "Roof".@}
@example
proc `^`*[T](x꞉ int; y꞉ openArray[T])꞉ int @{.noSideEffect, magic꞉ "Roof".@}
@end example
  

@item `^`
  @findex proc `^`*(x꞉ int)꞉ int @{.noSideEffect, magic꞉ "Roof".@}
@example
proc `^`*(x꞉ int)꞉ int @{.noSideEffect, magic꞉ "Roof".@}
@end example
  builtin  operator that can be used for convenient array access. @code{a[^x]} is rewritten to @code{a[a.len-x]}. However currently the @code{a} expression must not have side effects for this to compile. Note that since this is a builtin, it automatically works for all kinds of overloaded @code{[]} or @code{[]=} accessors.

@item xlen
  @findex proc xlen*(x꞉ string)꞉ int @{.magic꞉ "XLenStr", noSideEffect.@}
@example
proc xlen*(x꞉ string)꞉ int @{.magic꞉ "XLenStr", noSideEffect.@}
@end example
  

@item xlen
  @findex proc xlen*[T](x꞉ seq[T])꞉ int @{.magic꞉ "XLenSeq", noSideEffect.@}
@example
proc xlen*[T](x꞉ seq[T])꞉ int @{.magic꞉ "XLenSeq", noSideEffect.@}
@end example
  returns the length of a sequence or a string without testing for 'nil'. This is an optimization that rarely makes sense.
@end itemize

@chapter Templates

@itemize


@item `!=`
  @findex template `!=`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@example
template `!=`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@end example
  unequals operator. This is a shorthand for @code{not (x == y)}.

@item `>=`
  @findex template `>=`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@example
template `>=`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@end example
  "is greater or equals" operator. This is the same as @code{y <= x}.

@item `>`
  @findex template `>`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@example
template `>`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@end example
  "is greater" operator. This is the same as @code{y < x}.

@item incl
  @findex template incl*[T](s꞉ var set[T]; flags꞉ set[T])
@example
template incl*[T](s꞉ var set[T]; flags꞉ set[T])
@end example
  includes the set of flags to the set @code{x}.

@item excl
  @findex template excl*[T](s꞉ var set[T]; flags꞉ set[T])
@example
template excl*[T](s꞉ var set[T]; flags꞉ set[T])
@end example
  excludes the set of flags to @code{x}.

@item `in`
  @findex template `in`*(x, y꞉ expr)꞉ expr @{.immediate, dirty.@}
@example
template `in`*(x, y꞉ expr)꞉ expr @{.immediate, dirty.@}
@end example
  Sugar for contains
@example
assert(1 in (1..3) == true)
assert(5 in (1..3) == false)
@end example

@item `notin`
  @findex template `notin`*(x, y꞉ expr)꞉ expr @{.immediate, dirty.@}
@example
template `notin`*(x, y꞉ expr)꞉ expr @{.immediate, dirty.@}
@end example
  Sugar for not containing
@example
assert(1 notin (1..3) == false)
assert(5 notin (1..3) == true)
@end example

@item `isnot`
  @findex template `isnot`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@example
template `isnot`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@end example
  Negated version of @emph{is}. Equivalent to @code{not(x is y)}.

@item `>=%`
  @findex template `>=%`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@example
template `>=%`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and compares them. Returns true iff @code{unsigned(x) >= unsigned(y)}.

@item `>%`
  @findex template `>%`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@example
template `>%`*(x, y꞉ expr)꞉ expr @{.immediate.@}
@end example
  treats @emph{x} and @emph{y} as unsigned and compares them. Returns true iff @code{unsigned(x) > unsigned(y)}.

@item accumulateResult
  @findex template accumulateResult*(iter꞉ expr)
@example
template accumulateResult*(iter꞉ expr)
@end example
  helps to convert an iterator to a proc.

@item newException
  @findex template newException*(exceptn꞉ typedesc; message꞉ string)꞉ expr
@example
template newException*(exceptn꞉ typedesc; message꞉ string)꞉ expr
@end example
  creates an exception object of type @code{exceptn} and sets its @code{msg} field to @emph{message}. Returns the new exception object.

@item stdmsg
  @findex template stdmsg*()꞉ File
@example
template stdmsg*()꞉ File
@end example
  

@item currentSourcePath
  @findex template currentSourcePath*()꞉ string
@example
template currentSourcePath*()꞉ string
@end example
  returns the full file-system path of the current source

@item assert
  @findex template assert*(cond꞉ bool; msg = "")
@example
template assert*(cond꞉ bool; msg = "")
@end example
  Raises @code{AssertionError} with @emph{msg} if @emph{cond} is false. Note that @code{AssertionError} is hidden from the effect system, so it doesn't produce @code{@{.raises: [AssertionError].@}}. This exception is only supposed to be caught by unit testing frameworks. The compiler may not generate any code at all for @code{assert} if it is advised to do so through the @code{-d:release} or @code{--assertions:off} @uref{nimc.html#command-line-switches, command line switches}.

@item doAssert
  @findex template doAssert*(cond꞉ bool; msg = "")
@example
template doAssert*(cond꞉ bool; msg = "")
@end example
  same as @emph{assert} but is always turned on and not affected by the @code{--assertions} command line switch.

@item onFailedAssert
  @findex template onFailedAssert*(msg꞉ expr; code꞉ stmt)꞉ stmt @{.dirty, immediate.@}
@example
template onFailedAssert*(msg꞉ expr; code꞉ stmt)꞉ stmt @{.dirty, immediate.@}
@end example
  Sets an assertion failure handler that will intercept any assert statements following @emph{onFailedAssert} in the current module scope.
@example
# module-wide policy to change the failed assert
# exception type in order to include a lineinfo
onFailedAssert(msg):
  var e = new(TMyError)
  e.msg = msg
  e.lineinfo = instantiationInfo(-2)
  raise e
@end example

@item `..^`
  @findex template `..^`*(a, b꞉ expr)꞉ expr
@example
template `..^`*(a, b꞉ expr)꞉ expr
@end example
  a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.

@item `..<`
  @findex template `..<`*(a, b꞉ expr)꞉ expr
@example
template `..<`*(a, b꞉ expr)꞉ expr
@end example
  a shortcut for '.. <' to avoid the common gotcha that a space between '..' and '<' is required.
@end itemize




@chapter Iterators

@itemize


@item countdown
  @itindex iterator countdown*[T](a, b꞉ T; step = 1)꞉ T @{.inline.@}
@example
iterator countdown*[T](a, b꞉ T; step = 1)꞉ T @{.inline.@}
@end example
  Counts from ordinal value @emph{a} down to @emph{b} (inclusive) with the given step count. @emph{T} may be any ordinal type, @emph{step} may only be positive. @strong{Note}: This fails to count to @code{low(int)} if T = int for efficiency reasons.

@item countup
  @itindex iterator countup*[S, T](a꞉ S; b꞉ T; step = 1)꞉ T @{.inline.@}
@example
iterator countup*[S, T](a꞉ S; b꞉ T; step = 1)꞉ T @{.inline.@}
@end example
  Counts from ordinal value @emph{a} up to @emph{b} (inclusive) with the given step count. @emph{S}, @emph{T} may be any ordinal type, @emph{step} may only be positive. @strong{Note}: This fails to count to @code{high(int)} if T = int for efficiency reasons.

@item `..`
  @itindex iterator `..`*[S, T](a꞉ S; b꞉ T)꞉ T @{.inline.@}
@example
iterator `..`*[S, T](a꞉ S; b꞉ T)꞉ T @{.inline.@}
@end example
  An alias for @emph{countup}.

@item `||`
  @itindex iterator `||`*[S, T](a꞉ S; b꞉ T; annotation = "")꞉ T @{.inline, magic꞉ "OmpParFor", sideEffect.@}
@example
iterator `||`*[S, T](a꞉ S; b꞉ T; annotation = "")꞉ T @{.inline, magic꞉ "OmpParFor", sideEffect.@}
@end example
  parallel loop iterator. Same as @emph{..} but the loop may run in parallel. @emph{annotation} is an additional annotation for the code generator to use. Note that the compiler maps that to the @code{#pragma omp parallel for} construct of  and as such isn't aware of the parallelism in your code! Be careful! Later versions of @code{||} will get proper support by Nim's code generator and GC.

@item items
  @itindex iterator items*[T](a꞉ openArray[T])꞉ T @{.inline.@}
@example
iterator items*[T](a꞉ openArray[T])꞉ T @{.inline.@}
@end example
  iterates over each item of @emph{a}.

@item mitems
  @itindex iterator mitems*[T](a꞉ var openArray[T])꞉ var T @{.inline.@}
@example
iterator mitems*[T](a꞉ var openArray[T])꞉ var T @{.inline.@}
@end example
  iterates over each item of @emph{a} so that you can modify the yielded value.

@item items
  @itindex iterator items*[IX, T](a꞉ array[IX, T])꞉ T @{.inline.@}
@example
iterator items*[IX, T](a꞉ array[IX, T])꞉ T @{.inline.@}
@end example
  iterates over each item of @emph{a}.

@item mitems
  @itindex iterator mitems*[IX, T](a꞉ var array[IX, T])꞉ var T @{.inline.@}
@example
iterator mitems*[IX, T](a꞉ var array[IX, T])꞉ var T @{.inline.@}
@end example
  iterates over each item of @emph{a} so that you can modify the yielded value.

@item items
  @itindex iterator items*[T](a꞉ set[T])꞉ T @{.inline.@}
@example
iterator items*[T](a꞉ set[T])꞉ T @{.inline.@}
@end example
  iterates over each element of @emph{a}. @emph{items} iterates only over the elements that are really in the set (and not over the ones the set is able to hold).

@item items
  @itindex iterator items*(a꞉ cstring)꞉ char @{.inline.@}
@example
iterator items*(a꞉ cstring)꞉ char @{.inline.@}
@end example
  iterates over each item of @emph{a}.

@item mitems
  @itindex iterator mitems*(a꞉ var cstring)꞉ var char @{.inline.@}
@example
iterator mitems*(a꞉ var cstring)꞉ var char @{.inline.@}
@end example
  iterates over each item of @emph{a} so that you can modify the yielded value.

@item items
  @itindex iterator items*(E꞉ typedesc[enum])꞉ E
@example
iterator items*(E꞉ typedesc[enum])꞉ E
@end example
  iterates over the values of the enum @code{E}.

@item items
  @itindex iterator items*[T](s꞉ Slice[T])꞉ T
@example
iterator items*[T](s꞉ Slice[T])꞉ T
@end example
  iterates over the slice @emph{s}, yielding each value between @emph{s.a} and @emph{s.b} (inclusively).

@item pairs
  @itindex iterator pairs*[T](a꞉ openArray[T])꞉ tuple[key꞉ int, val꞉ T] @{.inline.@}
@example
iterator pairs*[T](a꞉ openArray[T])꞉ tuple[key꞉ int, val꞉ T] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs.

@item mpairs
  @itindex iterator mpairs*[T](a꞉ var openArray[T])꞉ tuple[key꞉ int, val꞉ var T] @{.inline.@}
@example
iterator mpairs*[T](a꞉ var openArray[T])꞉ tuple[key꞉ int, val꞉ var T] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs. @code{a[index]} can be modified.

@item pairs
  @itindex iterator pairs*[IX, T](a꞉ array[IX, T])꞉ tuple[key꞉ IX, val꞉ T] @{.inline.@}
@example
iterator pairs*[IX, T](a꞉ array[IX, T])꞉ tuple[key꞉ IX, val꞉ T] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs.

@item mpairs
  @itindex iterator mpairs*[IX, T](a꞉ var array[IX, T])꞉ tuple[key꞉ IX, val꞉ var T] @{.inline.@}
@example
iterator mpairs*[IX, T](a꞉ var array[IX, T])꞉ tuple[key꞉ IX, val꞉ var T] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs. @code{a[index]} can be modified.

@item pairs
  @itindex iterator pairs*[T](a꞉ seq[T])꞉ tuple[key꞉ int, val꞉ T] @{.inline.@}
@example
iterator pairs*[T](a꞉ seq[T])꞉ tuple[key꞉ int, val꞉ T] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs.

@item mpairs
  @itindex iterator mpairs*[T](a꞉ var seq[T])꞉ tuple[key꞉ int, val꞉ var T] @{.inline.@}
@example
iterator mpairs*[T](a꞉ var seq[T])꞉ tuple[key꞉ int, val꞉ var T] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs. @code{a[index]} can be modified.

@item pairs
  @itindex iterator pairs*(a꞉ string)꞉ tuple[key꞉ int, val꞉ char] @{.inline.@}
@example
iterator pairs*(a꞉ string)꞉ tuple[key꞉ int, val꞉ char] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs.

@item mpairs
  @itindex iterator mpairs*(a꞉ var string)꞉ tuple[key꞉ int, val꞉ var char] @{.inline.@}
@example
iterator mpairs*(a꞉ var string)꞉ tuple[key꞉ int, val꞉ var char] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs. @code{a[index]} can be modified.

@item pairs
  @itindex iterator pairs*(a꞉ cstring)꞉ tuple[key꞉ int, val꞉ char] @{.inline.@}
@example
iterator pairs*(a꞉ cstring)꞉ tuple[key꞉ int, val꞉ char] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs.

@item mpairs
  @itindex iterator mpairs*(a꞉ var cstring)꞉ tuple[key꞉ int, val꞉ var char] @{.inline.@}
@example
iterator mpairs*(a꞉ var cstring)꞉ tuple[key꞉ int, val꞉ var char] @{.inline.@}
@end example
  iterates over each item of @emph{a}. Yields @code{(index, a[index])} pairs. @code{a[index]} can be modified.

@item fields
  @itindex iterator fields*[T꞉ tuple |object](x꞉ T)꞉ RootObj @{.magic꞉ "Fields", noSideEffect.@}
@example
iterator fields*[T꞉ tuple |object](x꞉ T)꞉ RootObj @{.magic꞉ "Fields", noSideEffect.@}
@end example
  iterates over every field of @emph{x}. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.

@item fields
  @itindex iterator fields*[S꞉ tuple |object, T꞉ tuple |object](x꞉ S; y꞉ T)꞉ tuple[a, b꞉ expr] @{.magic꞉ "Fields", noSideEffect.@}
@example
iterator fields*[S꞉ tuple |object, T꞉ tuple |object](x꞉ S; y꞉ T)꞉ tuple[a, b꞉ expr] @{.magic꞉ "Fields", noSideEffect.@}
@end example
  iterates over every field of @emph{x} and @emph{y}. Warning: This is really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.

@item fieldPairs
  @itindex iterator fieldPairs*[T꞉ tuple |object](x꞉ T)꞉ RootObj @{.magic꞉ "FieldPairs", noSideEffect.@}
@example
iterator fieldPairs*[T꞉ tuple |object](x꞉ T)꞉ RootObj @{.magic꞉ "FieldPairs", noSideEffect.@}
@end example
  Iterates over every field of @emph{x} returning their name and value.

When you iterate over objects with different field types you have to use the compile time @code{when} instead of a runtime @code{if} to select the code you want to run for each type. To perform the comparison use the @uref{manual.html#is-operator, is operator}. Example:


@example

type
  Custom = object
    foo: string
    bar: bool

proc `$`(x: Custom): string =
  result = "Custom:"
  for name, value in x.fieldPairs:
    when value is bool:
      result.add("\n\t" & name & " is " & $value)
    else:
      if value.isNil:
        result.add("\n\t" & name & " (nil)")
      else:
        result.add("\n\t" & name & " '" & value & "'")
@end example
Another way to do the same without @code{when} is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the @emph{value} to.

Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.

@item fieldPairs
  @itindex iterator fieldPairs*[S꞉ tuple |object, T꞉ tuple |object](x꞉ S; y꞉ T)꞉ tuple[a, b꞉ expr] @{.magic꞉ "FieldPairs", noSideEffect.@}
@example
iterator fieldPairs*[S꞉ tuple |object, T꞉ tuple |object](x꞉ S; y꞉ T)꞉ tuple[a, b꞉ expr] @{.magic꞉ "FieldPairs", noSideEffect.@}
@end example
  iterates over every field of @emph{x} and @emph{y}. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.

@item lines
  @itindex iterator lines*(filename꞉ string)꞉ TaintedString @{.tags꞉ [ReadIOEffect].@}
@example
iterator lines*(filename꞉ string)꞉ TaintedString @{.tags꞉ [ReadIOEffect].@}
@end example
  Iterates over any line in the file named @emph{filename}.

If the file does not exist @emph{EIO} is raised. The trailing newline character(s) are removed from the iterated lines. Example:


@example
import strutils

proc transformLetters(filename: string) =
  var buffer = ""
  for line in filename.lines:
    buffer.add(line.replace("a", "0") & '\x0A')
  writeFile(filename, buffer)
@end example

@item lines
  @itindex iterator lines*(f꞉ File)꞉ TaintedString @{.tags꞉ [ReadIOEffect].@}
@example
iterator lines*(f꞉ File)꞉ TaintedString @{.tags꞉ [ReadIOEffect].@}
@end example
  Iterate over any line in the file @emph{f}.

The trailing newline character(s) are removed from the iterated lines. Example:


@example
proc countZeros(filename: File): tuple[lines, zeros: int] =
  for line in filename.lines:
    for letter in line:
      if letter == '0':
        result.zeros += 1
    result.lines += 1
@end example

@item items
  @itindex iterator items*[T](a꞉ seq[T])꞉ T @{.inline.@}
@example
iterator items*[T](a꞉ seq[T])꞉ T @{.inline.@}
@end example
  iterates over each item of @emph{a}.

@item mitems
  @itindex iterator mitems*[T](a꞉ var seq[T])꞉ var T @{.inline.@}
@example
iterator mitems*[T](a꞉ var seq[T])꞉ var T @{.inline.@}
@end example
  iterates over each item of @emph{a} so that you can modify the yielded value.

@item items
  @itindex iterator items*(a꞉ string)꞉ char @{.inline.@}
@example
iterator items*(a꞉ string)꞉ char @{.inline.@}
@end example
  iterates over each item of @emph{a}.

@item mitems
  @itindex iterator mitems*(a꞉ var string)꞉ var char @{.inline.@}
@example
iterator mitems*(a꞉ var string)꞉ var char @{.inline.@}
@end example
  iterates over each item of @emph{a} so that you can modify the yielded value.
@end itemize

@node /deprecated/pure/parseurl, /deprecated/pure/ftpclient , /system, Top



@chapter Types

@itemize


@item Url
  @tindex Url* = tuple[scheme, username, password, hostname, port, path, query, anchor꞉ string]
@example
Url* = tuple[scheme, username, password, hostname, port, path, query, anchor꞉ string]
@end example
  represents a @emph{Uniform Resource Locator} (URL) any optional component is "" if it does not exist
@end itemize

@chapter Procedures

@itemize


@item parseUrl
  @findex proc parseUrl*(url꞉ string)꞉ Url @{.deprecated.@}
@example
proc parseUrl*(url꞉ string)꞉ Url @{.deprecated.@}
@end example
  

@item `$`
  @findex proc `$`*(u꞉ Url)꞉ string @{.deprecated.@}
@example
proc `$`*(u꞉ Url)꞉ string @{.deprecated.@}
@end example
  turns the URL @emph{u} into its string representation.
@end itemize






@node /deprecated/pure/ftpclient, /deprecated/pure/actors , /deprecated/pure/parseurl, Top



@chapter Types

@itemize


@item FTPError
  @tindex FTPError* = object of IOError
@example
FTPError* = object of IOError
@end example
  
@end itemize

@chapter Procedures

@itemize


@item ftpClient
  @findex proc ftpClient*(address꞉ string; port = Port(21); user, pass = "")꞉ FtpClient
@example
proc ftpClient*(address꞉ string; port = Port(21); user, pass = "")꞉ FtpClient
@end example
  Create a @code{FtpClient} object.

@item send
  @findex proc send*[T](ftp꞉ FtpBase[T]; m꞉ string)꞉ TaintedString
@example
proc send*[T](ftp꞉ FtpBase[T]; m꞉ string)꞉ TaintedString
@end example
  Send a message to the server, and wait for a primary reply. @code{\c\L} is added for you.

@strong{Note:} The server may return multiple lines of coded replies.

@item connect
  @findex proc connect*[T](ftp꞉ FtpBase[T])
@example
proc connect*[T](ftp꞉ FtpBase[T])
@end example
  Connect to the FTP server specified by @code{ftp}.

@item pwd
  @findex proc pwd*[T](ftp꞉ FtpBase[T])꞉ string
@example
proc pwd*[T](ftp꞉ FtpBase[T])꞉ string
@end example
  Returns the current working directory.

@item cd
  @findex proc cd*[T](ftp꞉ FtpBase[T]; dir꞉ string)
@example
proc cd*[T](ftp꞉ FtpBase[T]; dir꞉ string)
@end example
  Changes the current directory on the remote FTP server to @code{dir}.

@item cdup
  @findex proc cdup*[T](ftp꞉ FtpBase[T])
@example
proc cdup*[T](ftp꞉ FtpBase[T])
@end example
  Changes the current directory to the parent of the current directory.

@item listDirs
  @findex proc listDirs*[T](ftp꞉ FtpBase[T]; dir꞉ string = ""; async = false)꞉ seq[string]
@example
proc listDirs*[T](ftp꞉ FtpBase[T]; dir꞉ string = ""; async = false)꞉ seq[string]
@end example
  Returns a list of filenames in the given directory. If @code{dir} is "", the current directory is used. If @code{async} is true, this function will return immediately and it will be your job to use asyncio's @code{poll} to progress this operation.

@item fileExists
  @findex proc fileExists*(ftp꞉ FtpClient; file꞉ string)꞉ bool @{.deprecated.@}
@example
proc fileExists*(ftp꞉ FtpClient; file꞉ string)꞉ bool @{.deprecated.@}
@end example
  @strong{Deprecated since version 0.9.0:} Please use @code{existsFile}.

Determines whether @code{file} exists.

Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.

@item existsFile
  @findex proc existsFile*(ftp꞉ FtpClient; file꞉ string)꞉ bool
@example
proc existsFile*(ftp꞉ FtpClient; file꞉ string)꞉ bool
@end example
  Determines whether @code{file} exists.

Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.

@item createDir
  @findex proc createDir*[T](ftp꞉ FtpBase[T]; dir꞉ string; recursive꞉ bool = false)
@example
proc createDir*[T](ftp꞉ FtpBase[T]; dir꞉ string; recursive꞉ bool = false)
@end example
  Creates a directory @code{dir}. If @code{recursive} is true, the topmost subdirectory of @code{dir} will be created first, following the secondmost... etc. this allows you to give a full path as the @code{dir} without worrying about subdirectories not existing.

@item chmod
  @findex proc chmod*[T](ftp꞉ FtpBase[T]; path꞉ string; permissions꞉ set[FilePermission])
@example
proc chmod*[T](ftp꞉ FtpBase[T]; path꞉ string; permissions꞉ set[FilePermission])
@end example
  Changes permission of @code{path} to @code{permissions}.

@item list
  @findex proc list*[T](ftp꞉ FtpBase[T]; dir꞉ string = ""; async = false)꞉ string
@example
proc list*[T](ftp꞉ FtpBase[T]; dir꞉ string = ""; async = false)꞉ string
@end example
  Lists all files in @code{dir}. If @code{dir} is @code{""}, uses the current working directory. If @code{async} is true, this function will return immediately and it will be your job to call asyncio's @code{poll} to progress this operation.

@item retrText
  @findex proc retrText*[T](ftp꞉ FtpBase[T]; file꞉ string; async = false)꞉ string
@example
proc retrText*[T](ftp꞉ FtpBase[T]; file꞉ string; async = false)꞉ string
@end example
  Retrieves @code{file}. File must be ASCII text. If @code{async} is true, this function will return immediately and it will be your job to call asyncio's @code{poll} to progress this operation.

@item retrFile
  @findex proc retrFile*[T](ftp꞉ FtpBase[T]; file, dest꞉ string; async = false)
@example
proc retrFile*[T](ftp꞉ FtpBase[T]; file, dest꞉ string; async = false)
@end example
  Downloads @code{file} and saves it to @code{dest}. Usage of this function asynchronously is recommended to view the progress of the download. The @code{EvRetr} event is passed to the specified @code{handleEvent} function when the download is finished, and the @code{filename} field will be equal to @code{file}.

@item store
  @findex proc store*[T](ftp꞉ FtpBase[T]; file, dest꞉ string; async = false)
@example
proc store*[T](ftp꞉ FtpBase[T]; file, dest꞉ string; async = false)
@end example
  Uploads @code{file} to @code{dest} on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The @code{EvStore} event is passed to the specified @code{handleEvent} function when the upload is finished, and the @code{filename} field will be equal to @code{file}.

@item close
  @findex proc close*[T](ftp꞉ FtpBase[T])
@example
proc close*[T](ftp꞉ FtpBase[T])
@end example
  Terminates the connection to the server.

@item asyncFTPClient
  @findex proc asyncFTPClient*(address: string; port = Port(21); user, pass = ""; handleEvent: proc (
    ftp: AsyncFTPClient; ev: FTPEvent) @{.closure, gcsafe.@} = (proc (ftp: AsyncFTPClient;
    ev: FTPEvent) =
  discard )): AsyncFTPClient
@example
proc asyncFTPClient*(address: string; port = Port(21); user, pass = ""; handleEvent: proc (
    ftp: AsyncFTPClient; ev: FTPEvent) @{.closure, gcsafe.@} = (proc (ftp: AsyncFTPClient;
    ev: FTPEvent) =
  discard )): AsyncFTPClient
@end example
  Create a @code{AsyncFTPClient} object.

Use this if you want to use asyncio's dispatcher.

@item register
  @findex proc register*(d꞉ Dispatcher; ftp꞉ AsyncFTPClient)꞉ Delegate @{.discardable.@}
@example
proc register*(d꞉ Dispatcher; ftp꞉ AsyncFTPClient)꞉ Delegate @{.discardable.@}
@end example
  Registers @code{ftp} with dispatcher @code{d}.
@end itemize






@node /deprecated/pure/actors, /deprecated/pure/asyncio , /deprecated/pure/ftpclient, Top



@chapter Types

@itemize


@item PActor
  @tindex PActor*[In, Out] = ptr Actor[In, Out]
@example
PActor*[In, Out] = ptr Actor[In, Out]
@end example
  an actor

@item ActorPool
  @tindex ActorPool*[In, Out] = object @{.pure, final.@}
  actors: seq[PActor[In, Out]]
  when Out isnot void:
      outputs: Channel[Out]

  
@example
ActorPool*[In, Out] = object @{.pure, final.@}
  actors: seq[PActor[In, Out]]
  when Out isnot void:
      outputs: Channel[Out]

  
@end example
  an actor pool
@end itemize

@chapter Procedures

@itemize


@item spawn
  @findex proc spawn*[In, Out](action꞉ proc (self꞉ PActor[In, Out]) @{.thread.@})꞉ PActor[In, Out]
@example
proc spawn*[In, Out](action꞉ proc (self꞉ PActor[In, Out]) @{.thread.@})꞉ PActor[In, Out]
@end example
  creates an actor; that is a thread with an inbox. The caller MUST call @code{join} because that also frees the actor's associated resources.

@item inbox
  @findex proc inbox*[In, Out](self꞉ PActor[In, Out])꞉ ptr Channel[In]
@example
proc inbox*[In, Out](self꞉ PActor[In, Out])꞉ ptr Channel[In]
@end example
  gets a pointer to the associated inbox of the actor @emph{self}.

@item running
  @findex proc running*[In, Out](a꞉ PActor[In, Out])꞉ bool
@example
proc running*[In, Out](a꞉ PActor[In, Out])꞉ bool
@end example
  returns true if the actor @emph{a} is running.

@item ready
  @findex proc ready*[In, Out](a꞉ PActor[In, Out])꞉ bool
@example
proc ready*[In, Out](a꞉ PActor[In, Out])꞉ bool
@end example
  returns true if the actor @emph{a} is ready to process new messages.

@item join
  @findex proc join*[In, Out](a꞉ PActor[In, Out])
@example
proc join*[In, Out](a꞉ PActor[In, Out])
@end example
  joins an actor.

@item recv
  @findex proc recv*[In, Out](a꞉ PActor[In, Out])꞉ Task[In, Out]
@example
proc recv*[In, Out](a꞉ PActor[In, Out])꞉ Task[In, Out]
@end example
  receives a task from @emph{a}'s inbox.

@item send
  @findex proc send*[In, Out, X, Y](receiver꞉ PActor[In, Out]; msg꞉ In; sender꞉ PActor[X, Y])
@example
proc send*[In, Out, X, Y](receiver꞉ PActor[In, Out]; msg꞉ In; sender꞉ PActor[X, Y])
@end example
  sends a message to @emph{a}'s inbox.

@item send
  @findex proc send*[In, Out](receiver꞉ PActor[In, Out]; msg꞉ In; sender꞉ ptr Channel[Out] = nil)
@example
proc send*[In, Out](receiver꞉ PActor[In, Out]; msg꞉ In; sender꞉ ptr Channel[Out] = nil)
@end example
  sends a message to @emph{receiver}'s inbox.

@item sendShutdown
  @findex proc sendShutdown*[In, Out](receiver꞉ PActor[In, Out])
@example
proc sendShutdown*[In, Out](receiver꞉ PActor[In, Out])
@end example
  send a shutdown message to @emph{receiver}.

@item reply
  @findex proc reply*[In, Out](t꞉ Task[In, Out]; m꞉ Out)
@example
proc reply*[In, Out](t꞉ Task[In, Out]; m꞉ Out)
@end example
  sends a message to io's output message box.

@item `^`
  @findex proc `^`*[T](f꞉ ptr Channel[T])꞉ T
@example
proc `^`*[T](f꞉ ptr Channel[T])꞉ T
@end example
  alias for 'recv'.

@item createActorPool
  @findex proc createActorPool*[In, Out](a꞉ var ActorPool[In, Out]; poolSize = 4)
@example
proc createActorPool*[In, Out](a꞉ var ActorPool[In, Out]; poolSize = 4)
@end example
  creates an actor pool.

@item sync
  @findex proc sync*[In, Out](a꞉ var ActorPool[In, Out]; polling = 50)
@example
proc sync*[In, Out](a꞉ var ActorPool[In, Out]; polling = 50)
@end example
  waits for every actor of @emph{a} to finish with its work. Currently this is implemented as polling every @emph{polling} ms and has a slight chance of failing since we check for every actor to be in @emph{ready} state and not for messages still in ether. This will change in a later version, however.

@item terminate
  @findex proc terminate*[In, Out](a꞉ var ActorPool[In, Out])
@example
proc terminate*[In, Out](a꞉ var ActorPool[In, Out])
@end example
  terminates each actor in the actor pool @emph{a} and frees the resources attached to @emph{a}.

@item join
  @findex proc join*[In, Out](a꞉ var ActorPool[In, Out])
@example
proc join*[In, Out](a꞉ var ActorPool[In, Out])
@end example
  short-cut for @emph{sync} and then @emph{terminate}.

@item spawn
  @findex proc spawn*[In, Out](p꞉ var ActorPool[In, Out]; input꞉ In;action꞉ proc (input꞉ In)꞉ Out @{.thread.@})꞉ ptr Channel[Out]
@example
proc spawn*[In, Out](p꞉ var ActorPool[In, Out]; input꞉ In;action꞉ proc (input꞉ In)꞉ Out @{.thread.@})꞉ ptr Channel[Out]
@end example
  uses the actor pool to run @code{action(input)} concurrently. @emph{spawn} is guaranteed to not block.

@item spawn
  @findex proc spawn*[In](p꞉ var ActorPool[In, void]; input꞉ In;action꞉ proc (input꞉ In) @{.thread.@})
@example
proc spawn*[In](p꞉ var ActorPool[In, void]; input꞉ In;action꞉ proc (input꞉ In) @{.thread.@})
@end example
  uses the actor pool to run @code{action(input)} concurrently. @emph{spawn} is guaranteed to not block.
@end itemize






@node /deprecated/pure/asyncio, /deprecated/pure/rawsockets , /deprecated/pure/actors, Top



@chapter Types

@itemize


@item SocketStatus
  @tindex SocketStatus* = enumSockIdle, SockConnecting, SockConnected, SockListening, SockClosed, SockUDPBound
@example
SocketStatus* = enumSockIdle, SockConnecting, SockConnected, SockListening, SockClosed, SockUDPBound
@end example
  
@end itemize

@chapter Procedures

@itemize


@item newDelegate
  @findex proc newDelegate*()꞉ Delegate
@example
proc newDelegate*()꞉ Delegate
@end example
  Creates a new delegate.

@item asyncSocket
  @findex proc asyncSocket*(domain꞉ Domain = AF_INET; typ꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ AsyncSocket
@example
proc asyncSocket*(domain꞉ Domain = AF_INET; typ꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ AsyncSocket
@end example
  Initialises an AsyncSocket object. If a socket cannot be initialised EOS is raised.

@item toAsyncSocket
  @findex proc toAsyncSocket*(sock꞉ Socket; state꞉ SocketStatus = SockConnected)꞉ AsyncSocket
@example
proc toAsyncSocket*(sock꞉ Socket; state꞉ SocketStatus = SockConnected)꞉ AsyncSocket
@end example
  Wraps an already initialized @code{Socket} into a AsyncSocket. This is useful if you want to use an already connected Socket as an asynchronous AsyncSocket in asyncio's event loop.

@code{state} may be overriden, i.e. if @code{sock} is not connected it should be adjusted properly. By default it will be assumed that the socket is connected. Please note this is only applicable to TCP client sockets, if @code{sock} is a different type of socket @code{state} needs to be adjusted!!!


@multitable @columnfractions  0.5 0.5
@item @b{Value}
@tab @b{Meaning}
@item SockIdle
@tab Socket has only just been initialised, not connected or closed.
@item SockConnected
@tab Socket is connected to a server.
@item SockConnecting
@tab Socket is in the process of connecting to a server.
@item SockListening
@tab Socket is a server socket and is listening for connections.
@item SockClosed
@tab Socket has been closed.
@item SockUDPBound
@tab Socket is a UDP socket which is listening for data.


@end multitable
@strong{Warning}: If @code{state} is set incorrectly the resulting @code{AsyncSocket} object may not work properly.

@strong{Note}: This will set @code{sock} to be non-blocking.

@item close
  @findex proc close*(sock꞉ AsyncSocket) @{.gcsafe.@}
@example
proc close*(sock꞉ AsyncSocket) @{.gcsafe.@}
@end example
  

@item connect
  @findex proc connect*(sock꞉ AsyncSocket; name꞉ string; port = Port(0); af꞉ Domain = AF_INET)
@example
proc connect*(sock꞉ AsyncSocket; name꞉ string; port = Port(0); af꞉ Domain = AF_INET)
@end example
  Begins connecting @code{sock} to @code{name}:@code{port}.

@item close
  @findex proc close*(sock꞉ AsyncSocket)
@example
proc close*(sock꞉ AsyncSocket)
@end example
  Closes @code{sock}. Terminates any current connections.

@item bindAddr
  @findex proc bindAddr*(sock꞉ AsyncSocket; port = Port(0); address = "")
@example
proc bindAddr*(sock꞉ AsyncSocket; port = Port(0); address = "")
@end example
  Equivalent to @code{sockets.bindAddr}.

@item listen
  @findex proc listen*(sock꞉ AsyncSocket)
@example
proc listen*(sock꞉ AsyncSocket)
@end example
  Equivalent to @code{sockets.listen}.

@item acceptAddr
  @findex proc acceptAddr*(server꞉ AsyncSocket; client꞉ var AsyncSocket; address꞉ var string)
@example
proc acceptAddr*(server꞉ AsyncSocket; client꞉ var AsyncSocket; address꞉ var string)
@end example
  Equivalent to @code{sockets.acceptAddr}. This procedure should be called in a @code{handleAccept} event handler @strong{only} once.

@strong{Note}: @code{client} needs to be initialised.

@item accept
  @findex proc accept*(server꞉ AsyncSocket; client꞉ var AsyncSocket)
@example
proc accept*(server꞉ AsyncSocket; client꞉ var AsyncSocket)
@end example
  Equivalent to @code{sockets.accept}.

@item acceptAddr
  @findex proc acceptAddr*(server꞉ AsyncSocket)꞉ tuple[sock꞉ AsyncSocket, address꞉ string] @{.deprecated.@}
@example
proc acceptAddr*(server꞉ AsyncSocket)꞉ tuple[sock꞉ AsyncSocket, address꞉ string] @{.deprecated.@}
@end example
  Equivalent to @code{sockets.acceptAddr}.

@strong{Deprecated since version 0.9.0:} Please use the function above.

@item accept
  @findex proc accept*(server꞉ AsyncSocket)꞉ AsyncSocket @{.deprecated.@}
@example
proc accept*(server꞉ AsyncSocket)꞉ AsyncSocket @{.deprecated.@}
@end example
  Equivalent to @code{sockets.accept}.

@strong{Deprecated since version 0.9.0:} Please use the function above.

@item newDispatcher
  @findex proc newDispatcher*()꞉ Dispatcher
@example
proc newDispatcher*()꞉ Dispatcher
@end example
  

@item register
  @findex proc register*(d꞉ Dispatcher; deleg꞉ Delegate)
@example
proc register*(d꞉ Dispatcher; deleg꞉ Delegate)
@end example
  Registers delegate @code{deleg} with dispatcher @code{d}.

@item register
  @findex proc register*(d꞉ Dispatcher; sock꞉ AsyncSocket)꞉ Delegate @{.discardable.@}
@example
proc register*(d꞉ Dispatcher; sock꞉ AsyncSocket)꞉ Delegate @{.discardable.@}
@end example
  Registers async socket @code{sock} with dispatcher @code{d}.

@item unregister
  @findex proc unregister*(d꞉ Dispatcher; deleg꞉ Delegate)
@example
proc unregister*(d꞉ Dispatcher; deleg꞉ Delegate)
@end example
  Unregisters deleg @code{deleg} from dispatcher @code{d}.

@item isWriteable
  @findex proc isWriteable*(s꞉ AsyncSocket)꞉ bool
@example
proc isWriteable*(s꞉ AsyncSocket)꞉ bool
@end example
  Determines whether socket @code{s} is ready to be written to.

@item isConnected
  @findex proc isConnected*(s꞉ AsyncSocket)꞉ bool
@example
proc isConnected*(s꞉ AsyncSocket)꞉ bool
@end example
  Determines whether @code{s} is connected.

@item isListening
  @findex proc isListening*(s꞉ AsyncSocket)꞉ bool
@example
proc isListening*(s꞉ AsyncSocket)꞉ bool
@end example
  Determines whether @code{s} is listening for incoming connections.

@item isConnecting
  @findex proc isConnecting*(s꞉ AsyncSocket)꞉ bool
@example
proc isConnecting*(s꞉ AsyncSocket)꞉ bool
@end example
  Determines whether @code{s} is connecting.

@item isClosed
  @findex proc isClosed*(s꞉ AsyncSocket)꞉ bool
@example
proc isClosed*(s꞉ AsyncSocket)꞉ bool
@end example
  Determines whether @code{s} has been closed.

@item isSendDataBuffered
  @findex proc isSendDataBuffered*(s꞉ AsyncSocket)꞉ bool
@example
proc isSendDataBuffered*(s꞉ AsyncSocket)꞉ bool
@end example
  Determines whether @code{s} has data waiting to be sent, i.e. whether this socket's sendBuffer contains data.

@item setHandleWrite
  @findex proc setHandleWrite*(s꞉ AsyncSocket;handleWrite꞉ proc (s꞉ AsyncSocket) @{.closure, gcsafe.@})
@example
proc setHandleWrite*(s꞉ AsyncSocket;handleWrite꞉ proc (s꞉ AsyncSocket) @{.closure, gcsafe.@})
@end example
  Setter for the @code{handleWrite} event.

To remove this event you should use the @code{delHandleWrite} function. It is advised to use that function instead of just setting the event to @code{proc (s: AsyncSocket) = nil} as that would mean that that function would be called constantly.

@item delHandleWrite
  @findex proc delHandleWrite*(s꞉ AsyncSocket)
@example
proc delHandleWrite*(s꞉ AsyncSocket)
@end example
  Removes the @code{handleWrite} event handler on @code{s}.

@item recvLine
  @findex proc recvLine*(s꞉ AsyncSocket; line꞉ var TaintedString)꞉ bool @{.deprecated.@}
@example
proc recvLine*(s꞉ AsyncSocket; line꞉ var TaintedString)꞉ bool @{.deprecated.@}
@end example
  Behaves similar to @code{sockets.recvLine}, however it handles non-blocking sockets properly. This function guarantees that @code{line} is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved.

Unlike @code{sockets.recvLine} this function will raise an EOS or ESSL exception if an error occurs.

@strong{Deprecated since version 0.9.2}: This function has been deprecated in favour of readLine.

@item readLine
  @findex proc readLine*(s꞉ AsyncSocket; line꞉ var TaintedString)꞉ bool
@example
proc readLine*(s꞉ AsyncSocket; line꞉ var TaintedString)꞉ bool
@end example
  Behaves similar to @code{sockets.readLine}, however it handles non-blocking sockets properly. This function guarantees that @code{line} is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved, when this happens False will be returned. True will only be returned if a full line has been retrieved or the socket has been disconnected in which case @code{line} will be set to "".

This function will raise an EOS exception when a socket error occurs.

@item send
  @findex proc send*(sock꞉ AsyncSocket; data꞉ string)
@example
proc send*(sock꞉ AsyncSocket; data꞉ string)
@end example
  Sends @code{data} to socket @code{sock}. This is basically a nicer implementation of @code{sockets.sendAsync}.

If @code{data} cannot be sent immediately it will be buffered and sent when @code{sock} becomes writeable (during the @code{handleWrite} event). It's possible that only a part of @code{data} will be sent immediately, while the rest of it will be buffered and sent later.

@item poll
  @findex proc poll*(d꞉ Dispatcher; timeout꞉ int = 500)꞉ bool
@example
proc poll*(d꞉ Dispatcher; timeout꞉ int = 500)꞉ bool
@end example
  This function checks for events on all the delegates in the @emph{PDispatcher}. It then proceeds to call the correct event handler.

This function returns @code{True} if there are file descriptors that are still open, otherwise @code{False}. File descriptors that have been closed are immediately removed from the dispatcher automatically.

@strong{Note:} Each delegate has a task associated with it. This gets called after each select() call, if you set timeout to @code{-1} the tasks will only be executed after one or more file descriptors becomes readable or writeable.

@item len
  @findex proc len*(disp꞉ Dispatcher)꞉ int
@example
proc len*(disp꞉ Dispatcher)꞉ int
@end example
  Retrieves the amount of delegates in @code{disp}.
@end itemize



@chapter Converter

@itemize


@item getSocket
  @findex converter getSocket*(s꞉ AsyncSocket)꞉ Socket
@example
converter getSocket*(s꞉ AsyncSocket)꞉ Socket
@end example
  
@end itemize



@node /deprecated/pure/rawsockets, /deprecated/pure/sockets , /deprecated/pure/asyncio, Top





@chapter Templates

@itemize


@item newRawSocket
  @findex template newRawSocket*(domain, sockType, protocol꞉ cint)꞉ expr
@example
template newRawSocket*(domain, sockType, protocol꞉ cint)꞉ expr
@end example
  

@item newRawSocket
  @findex template newRawSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP)꞉ expr
@example
template newRawSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP)꞉ expr
@end example
  
@end itemize





@node /deprecated/pure/sockets, /wrappers/pdcurses , /deprecated/pure/rawsockets, Top
@chapter Constant variables

@itemize


@item BufferSize
  @vindex BufferSize*꞉ int = 4000
@example
BufferSize*꞉ int = 4000
@end example
  size of a buffered socket's buffer
@end itemize

@chapter Let variable

@itemize


@item invalidSocket
  @vindex invalidSocket*꞉ Socket = nil
@example
invalidSocket*꞉ Socket = nil
@end example
  invalid socket
@end itemize


@chapter Types

@itemize


@item SSLAcceptResult
  @tindex SSLAcceptResult* = enumAcceptNoClient = 0, AcceptNoHandshake, AcceptSuccess
@example
SSLAcceptResult* = enumAcceptNoClient = 0, AcceptNoHandshake, AcceptSuccess
@end example
  

@item TimeoutError
  @tindex TimeoutError* = object of Exception
@example
TimeoutError* = object of Exception
@end example
  
@end itemize

@chapter Procedures

@itemize


@item `==`
  @findex proc `==`*(a, b꞉ Port)꞉ bool @{.borrow.@}
@example
proc `==`*(a, b꞉ Port)꞉ bool @{.borrow.@}
@end example
  @code{==} for ports.

@item `$`
  @findex proc `$`*(p꞉ Port)꞉ string @{.borrow.@}
@example
proc `$`*(p꞉ Port)꞉ string @{.borrow.@}
@end example
  returns the port number as a string

@item ntohl
  @findex proc ntohl*(x꞉ int32)꞉ int32
@example
proc ntohl*(x꞉ int32)꞉ int32
@end example
  Converts 32-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.

@item ntohs
  @findex proc ntohs*(x꞉ int16)꞉ int16
@example
proc ntohs*(x꞉ int16)꞉ int16
@end example
  Converts 16-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.

@item htonl
  @findex proc htonl*(x꞉ int32)꞉ int32
@example
proc htonl*(x꞉ int32)꞉ int32
@end example
  Converts 32-bit integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.

@item htons
  @findex proc htons*(x꞉ int16)꞉ int16
@example
proc htons*(x꞉ int16)꞉ int16
@end example
  Converts 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.

@item socket
  @findex proc socket*(domain꞉ Domain = AF_INET; typ꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ Socket
@example
proc socket*(domain꞉ Domain = AF_INET; typ꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ Socket
@end example
  Creates a new socket; returns @emph{InvalidSocket} if an error occurs.

@item newContext
  @findex proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";keyFile = "")꞉ SSLContext
@example
proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";keyFile = "")꞉ SSLContext
@end example
  Creates an SSL context.

Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are are available with the addition of @code{ProtSSLv23} which allows for compatibility with all of them.

There are currently only two options for verify mode; one is @code{CVerifyNone} and with it certificates will not be verified the other is @code{CVerifyPeer} and certificates will be verified for it, @code{CVerifyPeer} is the safest choice.

The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: @code{openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem}.

@item wrapSocket
  @findex proc wrapSocket*(ctx꞉ SSLContext; socket꞉ Socket)
@example
proc wrapSocket*(ctx꞉ SSLContext; socket꞉ Socket)
@end example
  Wraps a socket in an SSL context. This function effectively turns @code{socket} into an SSL socket.

@strong{Disclaimer}: This code is not well tested, may be very unsafe and prone to security vulnerabilities.

@item raiseSocketError
  @findex proc raiseSocketError*(socket꞉ Socket; err꞉ int = - 1; async = false)
@example
proc raiseSocketError*(socket꞉ Socket; err꞉ int = - 1; async = false)
@end example
  Raises proper errors based on return values of @code{recv} functions.

If @code{async} is @code{True} no error will be thrown in the case when the error was caused by no data being available to be read.

If @code{err} is not lower than 0 no exception will be raised.

@item listen
  @findex proc listen*(socket꞉ Socket; backlog = SOMAXCONN) @{.tags꞉ [ReadIOEffect].@}
@example
proc listen*(socket꞉ Socket; backlog = SOMAXCONN) @{.tags꞉ [ReadIOEffect].@}
@end example
  Marks @code{socket} as accepting connections. @code{Backlog} specifies the maximum length of the queue of pending connections.

@item parseIp4
  @findex proc parseIp4*(s꞉ string)꞉ BiggestInt
@example
proc parseIp4*(s꞉ string)꞉ BiggestInt
@end example
  parses an IP version 4 in dotted decimal form like "a.b.c.d".

This is equivalent to .

Raises EInvalidValue in case of an error.

@item bindAddr
  @findex proc bindAddr*(socket꞉ Socket; port = Port(0); address = "") @{.tags꞉ [ReadIOEffect].@}
@example
proc bindAddr*(socket꞉ Socket; port = Port(0); address = "") @{.tags꞉ [ReadIOEffect].@}
@end example
  binds an address/port number to a socket. Use address string in dotted decimal form like "a.b.c.d" or leave "" for any address.

@item getSockName
  @findex proc getSockName*(socket꞉ Socket)꞉ Port
@example
proc getSockName*(socket꞉ Socket)꞉ Port
@end example
  returns the socket's associated port number.

@item acceptAddr
  @findex proc acceptAddr*(server꞉ Socket; client꞉ var Socket; address꞉ var string) @{.tags꞉ [ReadIOEffect].@}
@example
proc acceptAddr*(server꞉ Socket; client꞉ var Socket; address꞉ var string) @{.tags꞉ [ReadIOEffect].@}
@end example
  Blocks until a connection is being made from a client. When a connection is made sets @code{client} to the client socket and @code{address} to the address of the connecting client. If @code{server} is non-blocking then this function returns immediately, and if there are no connections queued the returned socket will be @code{InvalidSocket}. This function will raise EOS if an error occurs.

The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.

@strong{Note}: @code{client} must be initialised (with @code{new}), this function makes no effort to initialise the @code{client} variable.

@strong{Warning:} When using SSL with non-blocking sockets, it is best to use the acceptAddrSSL procedure as this procedure will most likely block.

@item setBlocking
  @findex proc setBlocking*(s꞉ Socket; blocking꞉ bool) @{.tags꞉ [], gcsafe.@}
@example
proc setBlocking*(s꞉ Socket; blocking꞉ bool) @{.tags꞉ [], gcsafe.@}
@end example
  Sets blocking mode on socket

@item acceptAddrSSL
  @findex proc acceptAddrSSL*(server꞉ Socket; client꞉ var Socket; address꞉ var string)꞉ SSLAcceptResult @{.tags꞉ [ReadIOEffect].@}
@example
proc acceptAddrSSL*(server꞉ Socket; client꞉ var Socket; address꞉ var string)꞉ SSLAcceptResult @{.tags꞉ [ReadIOEffect].@}
@end example
  This procedure should only be used for non-blocking @strong{SSL} sockets. It will immediately return with one of the following values:

@code{AcceptSuccess} will be returned when a client has been successfully accepted and the handshake has been successfully performed between @code{server} and the newly connected client.

@code{AcceptNoHandshake} will be returned when a client has been accepted but no handshake could be performed. This can happen when the client connects but does not yet initiate a handshake. In this case @code{acceptAddrSSL} should be called again with the same parameters.

@code{AcceptNoClient} will be returned when no client is currently attempting to connect.

@item accept
  @findex proc accept*(server꞉ Socket; client꞉ var Socket) @{.tags꞉ [ReadIOEffect].@}
@example
proc accept*(server꞉ Socket; client꞉ var Socket) @{.tags꞉ [ReadIOEffect].@}
@end example
  Equivalent to @code{acceptAddr} but doesn't return the address, only the socket.

@strong{Note}: @code{client} must be initialised (with @code{new}), this function makes no effort to initialise the @code{client} variable.

@item acceptAddr
  @findex proc acceptAddr*(server꞉ Socket)꞉ tuple[client꞉ Socket, address꞉ string] @{.deprecated,tags꞉ [ReadIOEffect].@}
@example
proc acceptAddr*(server꞉ Socket)꞉ tuple[client꞉ Socket, address꞉ string] @{.deprecated,tags꞉ [ReadIOEffect].@}
@end example
  Slightly different version of @code{acceptAddr}.

@strong{Deprecated since version 0.9.0:} Please use the function above.

@item accept
  @findex proc accept*(server꞉ Socket)꞉ Socket @{.deprecated, tags꞉ [ReadIOEffect].@}
@example
proc accept*(server꞉ Socket)꞉ Socket @{.deprecated, tags꞉ [ReadIOEffect].@}
@end example
  @strong{Deprecated since version 0.9.0:} Please use the function above.

@item close
  @findex proc close*(socket꞉ Socket)
@example
proc close*(socket꞉ Socket)
@end example
  closes a socket.

@item getServByName
  @findex proc getServByName*(name, proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@example
proc getServByName*(name, proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@end example
  Searches the database from the beginning and finds the first entry for which the service name specified by @code{name} matches the s_name member and the protocol name specified by @code{proto} matches the s_proto member.

On posix this will search through the @code{/etc/services} file.

@item getServByPort
  @findex proc getServByPort*(port꞉ Port; proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@example
proc getServByPort*(port꞉ Port; proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@end example
  Searches the database from the beginning and finds the first entry for which the port specified by @code{port} matches the s_port member and the protocol name specified by @code{proto} matches the s_proto member.

On posix this will search through the @code{/etc/services} file.

@item getHostByAddr
  @findex proc getHostByAddr*(ip꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@example
proc getHostByAddr*(ip꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@end example
  This function will lookup the hostname of an IP Address.

@item getHostByName
  @findex proc getHostByName*(name꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@example
proc getHostByName*(name꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@end example
  This function will lookup the IP address of a hostname.

@item getSockOptInt
  @findex proc getSockOptInt*(socket꞉ Socket; level, optname꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc getSockOptInt*(socket꞉ Socket; level, optname꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  getsockopt for integer options.

@item setSockOptInt
  @findex proc setSockOptInt*(socket꞉ Socket; level, optname, optval꞉ int) @{.tags꞉ [WriteIOEffect].@}
@example
proc setSockOptInt*(socket꞉ Socket; level, optname, optval꞉ int) @{.tags꞉ [WriteIOEffect].@}
@end example
  setsockopt for integer options.

@item getSockOpt
  @findex proc getSockOpt*(socket꞉ Socket; opt꞉ SOBool; level = SOL_SOCKET)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@example
proc getSockOpt*(socket꞉ Socket; opt꞉ SOBool; level = SOL_SOCKET)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@end example
  Retrieves option @code{opt} as a boolean value.

@item setSockOpt
  @findex proc setSockOpt*(socket꞉ Socket; opt꞉ SOBool; value꞉ bool; level = SOL_SOCKET) @{.tags꞉ [WriteIOEffect].@}
@example
proc setSockOpt*(socket꞉ Socket; opt꞉ SOBool; value꞉ bool; level = SOL_SOCKET) @{.tags꞉ [WriteIOEffect].@}
@end example
  Sets option @code{opt} to a boolean value specified by @code{value}.

@item connect
  @findex proc connect*(socket꞉ Socket; address꞉ string; port = Port(0); af꞉ Domain = AF_INET) @{.tags꞉ [ReadIOEffect].@}
@example
proc connect*(socket꞉ Socket; address꞉ string; port = Port(0); af꞉ Domain = AF_INET) @{.tags꞉ [ReadIOEffect].@}
@end example
  Connects socket to @code{address}:@code{port}. @code{Address} can be an IP address or a host name. If @code{address} is a host name, this function will try each IP of that host name. @code{htons} is already performed on @code{port} so you must not do it.

If @code{socket} is an SSL socket a handshake will be automatically performed.

@item connectAsync
  @findex proc connectAsync*(socket꞉ Socket; name꞉ string; port = Port(0); af꞉ Domain = AF_INET) @{.tags꞉ [ReadIOEffect].@}
@example
proc connectAsync*(socket꞉ Socket; name꞉ string; port = Port(0); af꞉ Domain = AF_INET) @{.tags꞉ [ReadIOEffect].@}
@end example
  A variant of @code{connect} for non-blocking sockets.

This procedure will immediately return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using @code{select}) whether the socket is writeable.

@strong{Note}: For SSL sockets, the @code{handshake} procedure must be called whenever the socket successfully connects to a server.

@item handshake
  @findex proc handshake*(socket꞉ Socket)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc handshake*(socket꞉ Socket)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  This proc needs to be called on a socket after it connects. This is only applicable when using @code{connectAsync}. This proc performs the SSL handshake.

Returns @code{False} whenever the socket is not yet ready for a handshake, @code{True} whenever handshake completed successfully.

A ESSL error is raised on any other errors.

@item gotHandshake
  @findex proc gotHandshake*(socket꞉ Socket)꞉ bool
@example
proc gotHandshake*(socket꞉ Socket)꞉ bool
@end example
  Determines whether a handshake has occurred between a client (@code{socket}) and the server that @code{socket} is connected to.

Throws ESSL if @code{socket} is not an SSL socket.

@item hasDataBuffered
  @findex proc hasDataBuffered*(s꞉ Socket)꞉ bool
@example
proc hasDataBuffered*(s꞉ Socket)꞉ bool
@end example
  Determines whether a socket has data buffered.

@item select
  @findex proc select*(readfds, writefds, exceptfds꞉ var seq[Socket]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc select*(readfds, writefds, exceptfds꞉ var seq[Socket]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. @code{Timeout} is in milliseconds and -1 can be specified for no timeout.

Sockets which are @strong{not} ready for reading, writing or which don't have errors waiting on them are removed from the @code{readfds}, @code{writefds}, @code{exceptfds} sequences respectively.

@item select
  @findex proc select*(readfds, writefds꞉ var seq[Socket]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc select*(readfds, writefds꞉ var seq[Socket]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  Variant of select with only a read and write list.

@item selectWrite
  @findex proc selectWrite*(writefds꞉ var seq[Socket]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc selectWrite*(writefds꞉ var seq[Socket]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  When a socket in @code{writefds} is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which @strong{cannot} be written to will also be removed from @code{writefds}.

@code{timeout} is specified in milliseconds and @code{-1} can be specified for an unlimited time.

@item select
  @findex proc select*(readfds꞉ var seq[Socket]; timeout = 500)꞉ int
@example
proc select*(readfds꞉ var seq[Socket]; timeout = 500)꞉ int
@end example
  variant of select with a read list only

@item recv
  @findex proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  Receives data from a socket.

@strong{Note}: This is a low-level function, you may be interested in the higher level versions of this function which are also named @code{recv}.

@item recv
  @findex proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int; timeout꞉ int)꞉ int @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@example
proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int; timeout꞉ int)꞉ int @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@end example
  overload with a @code{timeout} parameter in milliseconds.

@item recv
  @findex proc recv*(socket꞉ Socket; data꞉ var string; size꞉ int; timeout = - 1)꞉ int
@example
proc recv*(socket꞉ Socket; data꞉ var string; size꞉ int; timeout = - 1)꞉ int
@end example
  Higher-level version of @code{recv}.

When 0 is returned the socket's connection has been closed.

This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.

A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.

@strong{Note}: @code{data} must be initialised.

@item recvAsync
  @findex proc recvAsync*(socket꞉ Socket; data꞉ var string; size꞉ int)꞉ int
@example
proc recvAsync*(socket꞉ Socket; data꞉ var string; size꞉ int)꞉ int
@end example
  Async version of @code{recv}.

When socket is non-blocking and no data is available on the socket, @code{-1} will be returned and @code{data} will be @code{""}.

@strong{Note}: @code{data} must be initialised.

@item recvLine
  @findex proc recvLine*(socket꞉ Socket; line꞉ var TaintedString; timeout = - 1)꞉ bool @{.tags꞉ [ReadIOEffect, TimeEffect], deprecated.@}
@example
proc recvLine*(socket꞉ Socket; line꞉ var TaintedString; timeout = - 1)꞉ bool @{.tags꞉ [ReadIOEffect, TimeEffect], deprecated.@}
@end example
  Receive a line of data from @code{socket}.

If a full line is received @code{\r\L} is not added to @code{line}, however if solely @code{\r\L} is received then @code{line} will be set to it.

@code{True} is returned if data is available. @code{False} suggests an error, EOS exceptions are not raised and @code{False} is simply returned instead.

If the socket is disconnected, @code{line} will be set to @code{""} and @code{True} will be returned.

A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.

@strong{Deprecated since version 0.9.2}: This function has been deprecated in favour of readLine.

@item readLine
  @findex proc readLine*(socket꞉ Socket; line꞉ var TaintedString; timeout = - 1) @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@example
proc readLine*(socket꞉ Socket; line꞉ var TaintedString; timeout = - 1) @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@end example
  Reads a line of data from @code{socket}.

If a full line is read @code{\r\L} is not added to @code{line}, however if solely @code{\r\L} is read then @code{line} will be set to it.

If the socket is disconnected, @code{line} will be set to @code{""}.

An EOS exception will be raised in the case of a socket error.

A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.

@item recvLineAsync
  @findex proc recvLineAsync*(socket꞉ Socket; line꞉ var TaintedString)꞉ RecvLineResult @{.tags꞉ [ReadIOEffect], deprecated.@}
@example
proc recvLineAsync*(socket꞉ Socket; line꞉ var TaintedString)꞉ RecvLineResult @{.tags꞉ [ReadIOEffect], deprecated.@}
@end example
  Similar to @code{recvLine} but designed for non-blocking sockets.

The values of the returned enum should be pretty self explanatory:


@quotation 
@itemize 
 @item If a full line has been retrieved; @code{RecvFullLine} is returned.
@item If some data has been retrieved; @code{RecvPartialLine} is returned.
@item If the socket has been disconnected; @code{RecvDisconnected} is returned.
@item If call to @code{recv} failed; @code{RecvFail} is returned.
 
@end itemize
 
@end quotation
@strong{Deprecated since version 0.9.2}: This function has been deprecated in favour of readLineAsync.

@item readLineAsync
  @findex proc readLineAsync*(socket꞉ Socket; line꞉ var TaintedString)꞉ ReadLineResult @{.tags꞉ [ReadIOEffect].@}
@example
proc readLineAsync*(socket꞉ Socket; line꞉ var TaintedString)꞉ ReadLineResult @{.tags꞉ [ReadIOEffect].@}
@end example
  Similar to @code{recvLine} but designed for non-blocking sockets.

The values of the returned enum should be pretty self explanatory:


@quotation 
@itemize 
 @item If a full line has been retrieved; @code{ReadFullLine} is returned.
@item If some data has been retrieved; @code{ReadPartialLine} is returned.
@item If the socket has been disconnected; @code{ReadDisconnected} is returned.
@item If no data could be retrieved; @code{ReadNone} is returned.
@item If call to @code{recv} failed; @strong{an EOS exception is raised.}
 
@end itemize
 
@end quotation

@item recv
  @findex proc recv*(socket꞉ Socket)꞉ TaintedString @{.tags꞉ [ReadIOEffect], deprecated.@}
@example
proc recv*(socket꞉ Socket)꞉ TaintedString @{.tags꞉ [ReadIOEffect], deprecated.@}
@end example
  receives all the available data from the socket. Socket errors will result in an @code{EOS} error. If socket is not a connectionless socket and socket is not connected @code{""} will be returned.

@strong{Deprecated since version 0.9.2}: This function is not safe for use.

@item recvTimeout
  @findex proc recvTimeout*(socket꞉ Socket; timeout꞉ int)꞉ TaintedString @{.tags꞉ [ReadIOEffect],deprecated.@}
@example
proc recvTimeout*(socket꞉ Socket; timeout꞉ int)꞉ TaintedString @{.tags꞉ [ReadIOEffect],deprecated.@}
@end example
  overloaded variant to support a @code{timeout} parameter, the @code{timeout} parameter specifies the amount of milliseconds to wait for data on the socket.

@strong{Deprecated since version 0.9.2}: This function is not safe for use.

@item recvAsync
  @findex proc recvAsync*(socket꞉ Socket; s꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect],deprecated.@}
@example
proc recvAsync*(socket꞉ Socket; s꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect],deprecated.@}
@end example
  receives all the data from a non-blocking socket. If socket is non-blocking and there are no messages available, @emph{False} will be returned. Other socket errors will result in an @code{EOS} error. If socket is not a connectionless socket and socket is not connected @code{s} will be set to @code{""}.

@strong{Deprecated since version 0.9.2}: This function is not safe for use.

@item recvFrom
  @findex proc recvFrom*(socket꞉ Socket; data꞉ var string; length꞉ int; address꞉ var string;port꞉ var Port; flags = 0'i32)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc recvFrom*(socket꞉ Socket; data꞉ var string; length꞉ int; address꞉ var string;port꞉ var Port; flags = 0'i32)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  Receives data from @code{socket}. This function should normally be used with connection-less sockets (UDP sockets).

If an error occurs the return value will be @code{-1}. Otherwise the return value will be the length of data received.

@strong{Warning:} This function does not yet have a buffered implementation, so when @code{socket} is buffered the non-buffered implementation will be used. Therefore if @code{socket} contains something in its buffer this function will make no effort to return it.

@item recvFromAsync
  @findex proc recvFromAsync*(socket꞉ Socket; data꞉ var string; length꞉ int; address꞉ var string;port꞉ var Port; flags = 0'i32)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@example
proc recvFromAsync*(socket꞉ Socket; data꞉ var string; length꞉ int; address꞉ var string;port꞉ var Port; flags = 0'i32)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@end example
  Variant of @code{recvFrom} for non-blocking sockets. Unlike @code{recvFrom}, this function will raise an EOS error whenever a socket error occurs.

If there is no data to be read from the socket @code{False} will be returned.

@item skip
  @findex proc skip*(socket꞉ Socket) @{.tags꞉ [ReadIOEffect], deprecated.@}
@example
proc skip*(socket꞉ Socket) @{.tags꞉ [ReadIOEffect], deprecated.@}
@end example
  skips all the data that is pending for the socket

@strong{Deprecated since version 0.9.2}: This function is not safe for use.

@item skip
  @findex proc skip*(socket꞉ Socket; size꞉ int; timeout = - 1)
@example
proc skip*(socket꞉ Socket; size꞉ int; timeout = - 1)
@end example
  Skips @code{size} amount of bytes.

An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.

Returns the number of skipped bytes.

@item send
  @findex proc send*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [WriteIOEffect].@}
@example
proc send*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [WriteIOEffect].@}
@end example
  sends data to a socket.

@item send
  @findex proc send*(socket꞉ Socket; data꞉ string) @{.tags꞉ [WriteIOEffect].@}
@example
proc send*(socket꞉ Socket; data꞉ string) @{.tags꞉ [WriteIOEffect].@}
@end example
  sends data to a socket.

@item sendAsync
  @findex proc sendAsync*(socket꞉ Socket; data꞉ string)꞉ int @{.tags꞉ [WriteIOEffect].@}
@example
proc sendAsync*(socket꞉ Socket; data꞉ string)꞉ int @{.tags꞉ [WriteIOEffect].@}
@end example
  sends data to a non-blocking socket. Returns @code{0} if no data could be sent, if data has been sent returns the amount of bytes of @code{data} that was successfully sent. This number may not always be the length of @code{data} but typically is.

An EOS (or ESSL if socket is an SSL socket) exception is raised if an error occurs.

@item trySend
  @findex proc trySend*(socket꞉ Socket; data꞉ string)꞉ bool @{.tags꞉ [WriteIOEffect].@}
@example
proc trySend*(socket꞉ Socket; data꞉ string)꞉ bool @{.tags꞉ [WriteIOEffect].@}
@end example
  safe alternative to @code{send}. Does not raise an EOS when an error occurs, and instead returns @code{false} on failure.

@item sendTo
  @findex proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ pointer; size꞉ int;af꞉ Domain = AF_INET; flags = 0'i32)꞉ int @{.tags꞉ [WriteIOEffect].@}
@example
proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ pointer; size꞉ int;af꞉ Domain = AF_INET; flags = 0'i32)꞉ int @{.tags꞉ [WriteIOEffect].@}
@end example
  low-level sendTo proc. This proc sends @code{data} to the specified @code{address}, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.

@strong{Note:} This proc is not available for SSL sockets.

@item sendTo
  @findex proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ string)꞉ int @{.tags꞉ [WriteIOEffect].@}
@example
proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ string)꞉ int @{.tags꞉ [WriteIOEffect].@}
@end example
  Friendlier version of the low-level @code{sendTo}.

@item connect
  @findex proc connect*(socket꞉ Socket; address꞉ string; port = Port(0); timeout꞉ int;af꞉ Domain = AF_INET) @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc connect*(socket꞉ Socket; address꞉ string; port = Port(0); timeout꞉ int;af꞉ Domain = AF_INET) @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  Connects to server as specified by @code{address} on port specified by @code{port}.

The @code{timeout} paremeter specifies the time in milliseconds to allow for the connection to the server to be made.

@item isSSL
  @findex proc isSSL*(socket꞉ Socket)꞉ bool
@example
proc isSSL*(socket꞉ Socket)꞉ bool
@end example
  Determines whether @code{socket} is a SSL socket.

@item getFD
  @findex proc getFD*(socket꞉ Socket)꞉ SocketHandle
@example
proc getFD*(socket꞉ Socket)꞉ SocketHandle
@end example
  Returns the socket's file descriptor

@item isBlocking
  @findex proc isBlocking*(socket꞉ Socket)꞉ bool
@example
proc isBlocking*(socket꞉ Socket)꞉ bool
@end example
  Determines whether @code{socket} is blocking.
@end itemize






@node /wrappers/pdcurses, /wrappers/odbcsql , /deprecated/pure/sockets, Top
@chapter Constant variables

@itemize


@item KEY_MODIFIER_NUMLOCK
  @vindex KEY_MODIFIER_NUMLOCK* = 8
@example
KEY_MODIFIER_NUMLOCK* = 8
@end example
  

@item BUTTON_ALT
  @vindex BUTTON_ALT* = BUTTON_MODIFIER_ALT
@example
BUTTON_ALT* = BUTTON_MODIFIER_ALT
@end example
  

@item ACS_SSSS
  @vindex ACS_SSSS* = ACS_PLUS
@example
ACS_SSSS* = ACS_PLUS
@end example
  
@end itemize


@chapter Variables

@itemize


@item ttytype
  @vindex ttytype* @{.importc꞉ "ttytype", dynlib꞉ pdcursesdll.@}꞉ cstring
@example
ttytype* @{.importc꞉ "ttytype", dynlib꞉ pdcursesdll.@}꞉ cstring
@end example
  

@item quick_edit
  @vindex quick_edit* @{.importc꞉ "pdc_quick_edit", dynlib꞉ pdcursesdll.@}꞉ DWORD
@example
quick_edit* @{.importc꞉ "pdc_quick_edit", dynlib꞉ pdcursesdll.@}꞉ DWORD
@end example
  
@end itemize

@chapter Types

@itemize


@item PANEL
  @tindex PANEL* @{.pure, final.@} = object
  win*: ptr WINDOW
  wstarty*: cint
  wendy*: cint
  wstartx*: cint
  wendx*: cint
  below*: ptr PANEL
  above*: ptr PANEL
  user*: pointer
  obscure*: ptr PANELOBS

@example
PANEL* @{.pure, final.@} = object
  win*: ptr WINDOW
  wstarty*: cint
  wendy*: cint
  wstartx*: cint
  wendx*: cint
  below*: ptr PANEL
  above*: ptr PANEL
  user*: pointer
  obscure*: ptr PANELOBS

@end example
  

@item SCREEN
  @tindex SCREEN* @{.pure, final.@} = object
  alive*: cunsignedchar
  autocr*: cunsignedchar
  cbreak*: cunsignedchar
  echo*: cunsignedchar
  raw_inp*: cunsignedchar
  raw_out*: cunsignedchar
  audible*: cunsignedchar
  mono*: cunsignedchar
  resized*: cunsignedchar
  orig_attr*: cunsignedchar
  orig_fore*: cshort
  orig_back*: cshort
  cursrow*: cint
  curscol*: cint
  visibility*: cint
  orig_cursor*: cint
  lines*: cint
  cols*: cint
  trap_mbe*: cunsignedlong
  map_mbe_to_key*: cunsignedlong
  mouse_wait*: cint
  slklines*: cint
  slk_winptr*: ptr WINDOW
  linesrippedoff*: cint
  linesrippedoffontop*: cint
  delaytenths*: cint
  preserve*: cunsignedchar
  restore*: cint
  save_key_modifiers*: cunsignedchar
  return_key_modifiers*: cunsignedchar
  key_code*: cunsignedchar
  XcurscrSize*: cint
  sb_on*: cunsignedchar
  sb_viewport_y*: cint
  sb_viewport_x*: cint
  sb_total_y*: cint
  sb_total_x*: cint
  sb_cur_y*: cint
  sb_cur_x*: cint
  line_color*: cshort

@example
SCREEN* @{.pure, final.@} = object
  alive*: cunsignedchar
  autocr*: cunsignedchar
  cbreak*: cunsignedchar
  echo*: cunsignedchar
  raw_inp*: cunsignedchar
  raw_out*: cunsignedchar
  audible*: cunsignedchar
  mono*: cunsignedchar
  resized*: cunsignedchar
  orig_attr*: cunsignedchar
  orig_fore*: cshort
  orig_back*: cshort
  cursrow*: cint
  curscol*: cint
  visibility*: cint
  orig_cursor*: cint
  lines*: cint
  cols*: cint
  trap_mbe*: cunsignedlong
  map_mbe_to_key*: cunsignedlong
  mouse_wait*: cint
  slklines*: cint
  slk_winptr*: ptr WINDOW
  linesrippedoff*: cint
  linesrippedoffontop*: cint
  delaytenths*: cint
  preserve*: cunsignedchar
  restore*: cint
  save_key_modifiers*: cunsignedchar
  return_key_modifiers*: cunsignedchar
  key_code*: cunsignedchar
  XcurscrSize*: cint
  sb_on*: cunsignedchar
  sb_viewport_y*: cint
  sb_viewport_x*: cint
  sb_total_y*: cint
  sb_total_x*: cint
  sb_cur_y*: cint
  sb_cur_x*: cint
  line_color*: cshort

@end example
  
@end itemize

@chapter Procedures

@itemize


@item addch
  @findex proc addch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "addch", dynlib꞉ pdcursesdll.@}
@example
proc addch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "addch", dynlib꞉ pdcursesdll.@}
@end example
  

@item addchnstr
  @findex proc addchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "addchnstr",dynlib꞉ pdcursesdll.@}
@example
proc addchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "addchnstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item addchstr
  @findex proc addchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "addchstr",dynlib꞉ pdcursesdll.@}
@example
proc addchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "addchstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item addnstr
  @findex proc addnstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "addnstr",dynlib꞉ pdcursesdll.@}
@example
proc addnstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "addnstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item addstr
  @findex proc addstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "addstr", dynlib꞉ pdcursesdll.@}
@example
proc addstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "addstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item attroff
  @findex proc attroff*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "attroff",dynlib꞉ pdcursesdll.@}
@example
proc attroff*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "attroff",dynlib꞉ pdcursesdll.@}
@end example
  

@item attron
  @findex proc attron*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "attron", dynlib꞉ pdcursesdll.@}
@example
proc attron*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "attron", dynlib꞉ pdcursesdll.@}
@end example
  

@item attrset
  @findex proc attrset*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "attrset",dynlib꞉ pdcursesdll.@}
@example
proc attrset*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "attrset",dynlib꞉ pdcursesdll.@}
@end example
  

@item attr_get
  @findex proc attr_get*(a2꞉ ptr cunsignedlong; a3꞉ ptr cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "attr_get", dynlib꞉ pdcursesdll.@}
@example
proc attr_get*(a2꞉ ptr cunsignedlong; a3꞉ ptr cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "attr_get", dynlib꞉ pdcursesdll.@}
@end example
  

@item attr_off
  @findex proc attr_off*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl, importc꞉ "attr_off",dynlib꞉ pdcursesdll.@}
@example
proc attr_off*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl, importc꞉ "attr_off",dynlib꞉ pdcursesdll.@}
@end example
  

@item attr_on
  @findex proc attr_on*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl, importc꞉ "attr_on",dynlib꞉ pdcursesdll.@}
@example
proc attr_on*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl, importc꞉ "attr_on",dynlib꞉ pdcursesdll.@}
@end example
  

@item attr_set
  @findex proc attr_set*(a2꞉ cunsignedlong; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "attr_set", dynlib꞉ pdcursesdll.@}
@example
proc attr_set*(a2꞉ cunsignedlong; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "attr_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item baudrate
  @findex proc baudrate*()꞉ cint @{.extdecl, importc꞉ "baudrate", dynlib꞉ pdcursesdll.@}
@example
proc baudrate*()꞉ cint @{.extdecl, importc꞉ "baudrate", dynlib꞉ pdcursesdll.@}
@end example
  

@item beep
  @findex proc beep*()꞉ cint @{.extdecl, importc꞉ "beep", dynlib꞉ pdcursesdll.@}
@example
proc beep*()꞉ cint @{.extdecl, importc꞉ "beep", dynlib꞉ pdcursesdll.@}
@end example
  

@item bkgd
  @findex proc bkgd*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "bkgd", dynlib꞉ pdcursesdll.@}
@example
proc bkgd*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "bkgd", dynlib꞉ pdcursesdll.@}
@end example
  

@item bkgdset
  @findex proc bkgdset*(a2꞉ cunsignedlong) @{.extdecl, importc꞉ "bkgdset", dynlib꞉ pdcursesdll.@}
@example
proc bkgdset*(a2꞉ cunsignedlong) @{.extdecl, importc꞉ "bkgdset", dynlib꞉ pdcursesdll.@}
@end example
  

@item border
  @findex proc border*(a2: cunsignedlong; a3: cunsignedlong; a4: cunsignedlong;
            a5: cunsignedlong; a6: cunsignedlong; a7: cunsignedlong;
            a8: cunsignedlong; a9: cunsignedlong): cint @{.extdecl, importc: "border",
    dynlib: pdcursesdll.@}
@example
proc border*(a2: cunsignedlong; a3: cunsignedlong; a4: cunsignedlong;
            a5: cunsignedlong; a6: cunsignedlong; a7: cunsignedlong;
            a8: cunsignedlong; a9: cunsignedlong): cint @{.extdecl, importc: "border",
    dynlib: pdcursesdll.@}
@end example
  

@item box
  @findex proc box*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "box", dynlib꞉ pdcursesdll.@}
@example
proc box*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "box", dynlib꞉ pdcursesdll.@}
@end example
  

@item can_change_color
  @findex proc can_change_color*()꞉ cunsignedchar @{.extdecl, importc꞉ "can_change_color",dynlib꞉ pdcursesdll.@}
@example
proc can_change_color*()꞉ cunsignedchar @{.extdecl, importc꞉ "can_change_color",dynlib꞉ pdcursesdll.@}
@end example
  

@item cbreak
  @findex proc cbreak*()꞉ cint @{.extdecl, importc꞉ "cbreak", dynlib꞉ pdcursesdll.@}
@example
proc cbreak*()꞉ cint @{.extdecl, importc꞉ "cbreak", dynlib꞉ pdcursesdll.@}
@end example
  

@item chgat
  @findex proc chgat*(a2꞉ cint; a3꞉ cunsignedlong; a4꞉ cshort; a5꞉ pointer)꞉ cint @{.extdecl,importc꞉ "chgat", dynlib꞉ pdcursesdll.@}
@example
proc chgat*(a2꞉ cint; a3꞉ cunsignedlong; a4꞉ cshort; a5꞉ pointer)꞉ cint @{.extdecl,importc꞉ "chgat", dynlib꞉ pdcursesdll.@}
@end example
  

@item clearok
  @findex proc clearok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "clearok",dynlib꞉ pdcursesdll.@}
@example
proc clearok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "clearok",dynlib꞉ pdcursesdll.@}
@end example
  

@item clear
  @findex proc clear*()꞉ cint @{.extdecl, importc꞉ "clear", dynlib꞉ pdcursesdll.@}
@example
proc clear*()꞉ cint @{.extdecl, importc꞉ "clear", dynlib꞉ pdcursesdll.@}
@end example
  

@item clrtobot
  @findex proc clrtobot*()꞉ cint @{.extdecl, importc꞉ "clrtobot", dynlib꞉ pdcursesdll.@}
@example
proc clrtobot*()꞉ cint @{.extdecl, importc꞉ "clrtobot", dynlib꞉ pdcursesdll.@}
@end example
  

@item clrtoeol
  @findex proc clrtoeol*()꞉ cint @{.extdecl, importc꞉ "clrtoeol", dynlib꞉ pdcursesdll.@}
@example
proc clrtoeol*()꞉ cint @{.extdecl, importc꞉ "clrtoeol", dynlib꞉ pdcursesdll.@}
@end example
  

@item color_content
  @findex proc color_content*(a2꞉ cshort; a3꞉ ptr cshort; a4꞉ ptr cshort; a5꞉ ptr cshort)꞉ cint @{.extdecl, importc꞉ "color_content", dynlib꞉ pdcursesdll.@}
@example
proc color_content*(a2꞉ cshort; a3꞉ ptr cshort; a4꞉ ptr cshort; a5꞉ ptr cshort)꞉ cint @{.extdecl, importc꞉ "color_content", dynlib꞉ pdcursesdll.@}
@end example
  

@item color_set
  @findex proc color_set*(a2꞉ cshort; a3꞉ pointer)꞉ cint @{.extdecl, importc꞉ "color_set",dynlib꞉ pdcursesdll.@}
@example
proc color_set*(a2꞉ cshort; a3꞉ pointer)꞉ cint @{.extdecl, importc꞉ "color_set",dynlib꞉ pdcursesdll.@}
@end example
  

@item copywin
  @findex proc copywin*(a2꞉ ptr WINDOW; a3꞉ ptr WINDOW; a4꞉ cint; a5꞉ cint; a6꞉ cint; a7꞉ cint; a8꞉ cint;a9꞉ cint; a10꞉ cint)꞉ cint @{.extdecl, importc꞉ "copywin",dynlib꞉ pdcursesdll.@}
@example
proc copywin*(a2꞉ ptr WINDOW; a3꞉ ptr WINDOW; a4꞉ cint; a5꞉ cint; a6꞉ cint; a7꞉ cint; a8꞉ cint;a9꞉ cint; a10꞉ cint)꞉ cint @{.extdecl, importc꞉ "copywin",dynlib꞉ pdcursesdll.@}
@end example
  

@item curs_set
  @findex proc curs_set*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "curs_set", dynlib꞉ pdcursesdll.@}
@example
proc curs_set*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "curs_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item def_prog_mode
  @findex proc def_prog_mode*()꞉ cint @{.extdecl, importc꞉ "def_prog_mode", dynlib꞉ pdcursesdll.@}
@example
proc def_prog_mode*()꞉ cint @{.extdecl, importc꞉ "def_prog_mode", dynlib꞉ pdcursesdll.@}
@end example
  

@item def_shell_mode
  @findex proc def_shell_mode*()꞉ cint @{.extdecl, importc꞉ "def_shell_mode", dynlib꞉ pdcursesdll.@}
@example
proc def_shell_mode*()꞉ cint @{.extdecl, importc꞉ "def_shell_mode", dynlib꞉ pdcursesdll.@}
@end example
  

@item delay_output
  @findex proc delay_output*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "delay_output",dynlib꞉ pdcursesdll.@}
@example
proc delay_output*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "delay_output",dynlib꞉ pdcursesdll.@}
@end example
  

@item delch
  @findex proc delch*()꞉ cint @{.extdecl, importc꞉ "delch", dynlib꞉ pdcursesdll.@}
@example
proc delch*()꞉ cint @{.extdecl, importc꞉ "delch", dynlib꞉ pdcursesdll.@}
@end example
  

@item deleteln
  @findex proc deleteln*()꞉ cint @{.extdecl, importc꞉ "deleteln", dynlib꞉ pdcursesdll.@}
@example
proc deleteln*()꞉ cint @{.extdecl, importc꞉ "deleteln", dynlib꞉ pdcursesdll.@}
@end example
  

@item delscreen
  @findex proc delscreen*(a2꞉ ptr SCREEN) @{.extdecl, importc꞉ "delscreen", dynlib꞉ pdcursesdll.@}
@example
proc delscreen*(a2꞉ ptr SCREEN) @{.extdecl, importc꞉ "delscreen", dynlib꞉ pdcursesdll.@}
@end example
  

@item delwin
  @findex proc delwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "delwin", dynlib꞉ pdcursesdll.@}
@example
proc delwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "delwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item derwin
  @findex proc derwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "derwin", dynlib꞉ pdcursesdll.@}
@example
proc derwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "derwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item doupdate
  @findex proc doupdate*()꞉ cint @{.extdecl, importc꞉ "doupdate", dynlib꞉ pdcursesdll.@}
@example
proc doupdate*()꞉ cint @{.extdecl, importc꞉ "doupdate", dynlib꞉ pdcursesdll.@}
@end example
  

@item dupwin
  @findex proc dupwin*(a2꞉ ptr WINDOW)꞉ ptr WINDOW @{.extdecl, importc꞉ "dupwin",dynlib꞉ pdcursesdll.@}
@example
proc dupwin*(a2꞉ ptr WINDOW)꞉ ptr WINDOW @{.extdecl, importc꞉ "dupwin",dynlib꞉ pdcursesdll.@}
@end example
  

@item echochar
  @findex proc echochar*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "echochar",dynlib꞉ pdcursesdll.@}
@example
proc echochar*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "echochar",dynlib꞉ pdcursesdll.@}
@end example
  

@item echo
  @findex proc echo*()꞉ cint @{.extdecl, importc꞉ "echo", dynlib꞉ pdcursesdll.@}
@example
proc echo*()꞉ cint @{.extdecl, importc꞉ "echo", dynlib꞉ pdcursesdll.@}
@end example
  

@item endwin
  @findex proc endwin*()꞉ cint @{.extdecl, importc꞉ "endwin", dynlib꞉ pdcursesdll.@}
@example
proc endwin*()꞉ cint @{.extdecl, importc꞉ "endwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item erasechar
  @findex proc erasechar*()꞉ char @{.extdecl, importc꞉ "erasechar", dynlib꞉ pdcursesdll.@}
@example
proc erasechar*()꞉ char @{.extdecl, importc꞉ "erasechar", dynlib꞉ pdcursesdll.@}
@end example
  

@item erase
  @findex proc erase*()꞉ cint @{.extdecl, importc꞉ "erase", dynlib꞉ pdcursesdll.@}
@example
proc erase*()꞉ cint @{.extdecl, importc꞉ "erase", dynlib꞉ pdcursesdll.@}
@end example
  

@item filter
  @findex proc filter*() @{.extdecl, importc꞉ "filter", dynlib꞉ pdcursesdll.@}
@example
proc filter*() @{.extdecl, importc꞉ "filter", dynlib꞉ pdcursesdll.@}
@end example
  

@item flash
  @findex proc flash*()꞉ cint @{.extdecl, importc꞉ "flash", dynlib꞉ pdcursesdll.@}
@example
proc flash*()꞉ cint @{.extdecl, importc꞉ "flash", dynlib꞉ pdcursesdll.@}
@end example
  

@item flushinp
  @findex proc flushinp*()꞉ cint @{.extdecl, importc꞉ "flushinp", dynlib꞉ pdcursesdll.@}
@example
proc flushinp*()꞉ cint @{.extdecl, importc꞉ "flushinp", dynlib꞉ pdcursesdll.@}
@end example
  

@item getbkgd
  @findex proc getbkgd*(a2꞉ ptr WINDOW)꞉ cunsignedlong @{.extdecl, importc꞉ "getbkgd",dynlib꞉ pdcursesdll.@}
@example
proc getbkgd*(a2꞉ ptr WINDOW)꞉ cunsignedlong @{.extdecl, importc꞉ "getbkgd",dynlib꞉ pdcursesdll.@}
@end example
  

@item getnstr
  @findex proc getnstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "getnstr",dynlib꞉ pdcursesdll.@}
@example
proc getnstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "getnstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item getstr
  @findex proc getstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "getstr", dynlib꞉ pdcursesdll.@}
@example
proc getstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "getstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item getwin
  @findex proc getwin*(a2꞉ File)꞉ ptr WINDOW @{.extdecl, importc꞉ "getwin", dynlib꞉ pdcursesdll.@}
@example
proc getwin*(a2꞉ File)꞉ ptr WINDOW @{.extdecl, importc꞉ "getwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item halfdelay
  @findex proc halfdelay*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "halfdelay", dynlib꞉ pdcursesdll.@}
@example
proc halfdelay*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "halfdelay", dynlib꞉ pdcursesdll.@}
@end example
  

@item has_colors
  @findex proc has_colors*()꞉ cunsignedchar @{.extdecl, importc꞉ "has_colors",dynlib꞉ pdcursesdll.@}
@example
proc has_colors*()꞉ cunsignedchar @{.extdecl, importc꞉ "has_colors",dynlib꞉ pdcursesdll.@}
@end example
  

@item has_ic
  @findex proc has_ic*()꞉ cunsignedchar @{.extdecl, importc꞉ "has_ic", dynlib꞉ pdcursesdll.@}
@example
proc has_ic*()꞉ cunsignedchar @{.extdecl, importc꞉ "has_ic", dynlib꞉ pdcursesdll.@}
@end example
  

@item has_il
  @findex proc has_il*()꞉ cunsignedchar @{.extdecl, importc꞉ "has_il", dynlib꞉ pdcursesdll.@}
@example
proc has_il*()꞉ cunsignedchar @{.extdecl, importc꞉ "has_il", dynlib꞉ pdcursesdll.@}
@end example
  

@item hline
  @findex proc hline*(a2꞉ cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "hline",dynlib꞉ pdcursesdll.@}
@example
proc hline*(a2꞉ cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "hline",dynlib꞉ pdcursesdll.@}
@end example
  

@item idcok
  @findex proc idcok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar) @{.extdecl, importc꞉ "idcok",dynlib꞉ pdcursesdll.@}
@example
proc idcok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar) @{.extdecl, importc꞉ "idcok",dynlib꞉ pdcursesdll.@}
@end example
  

@item idlok
  @findex proc idlok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "idlok",dynlib꞉ pdcursesdll.@}
@example
proc idlok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "idlok",dynlib꞉ pdcursesdll.@}
@end example
  

@item immedok
  @findex proc immedok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar) @{.extdecl, importc꞉ "immedok",dynlib꞉ pdcursesdll.@}
@example
proc immedok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar) @{.extdecl, importc꞉ "immedok",dynlib꞉ pdcursesdll.@}
@end example
  

@item inchnstr
  @findex proc inchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "inchnstr",dynlib꞉ pdcursesdll.@}
@example
proc inchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "inchnstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item inchstr
  @findex proc inchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "inchstr",dynlib꞉ pdcursesdll.@}
@example
proc inchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "inchstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item inch
  @findex proc inch*()꞉ cunsignedlong @{.extdecl, importc꞉ "inch", dynlib꞉ pdcursesdll.@}
@example
proc inch*()꞉ cunsignedlong @{.extdecl, importc꞉ "inch", dynlib꞉ pdcursesdll.@}
@end example
  

@item init_color
  @findex proc init_color*(a2꞉ cshort; a3꞉ cshort; a4꞉ cshort; a5꞉ cshort)꞉ cint @{.extdecl,importc꞉ "init_color", dynlib꞉ pdcursesdll.@}
@example
proc init_color*(a2꞉ cshort; a3꞉ cshort; a4꞉ cshort; a5꞉ cshort)꞉ cint @{.extdecl,importc꞉ "init_color", dynlib꞉ pdcursesdll.@}
@end example
  

@item init_pair
  @findex proc init_pair*(a2꞉ cshort; a3꞉ cshort; a4꞉ cshort)꞉ cint @{.extdecl,importc꞉ "init_pair", dynlib꞉ pdcursesdll.@}
@example
proc init_pair*(a2꞉ cshort; a3꞉ cshort; a4꞉ cshort)꞉ cint @{.extdecl,importc꞉ "init_pair", dynlib꞉ pdcursesdll.@}
@end example
  

@item initscr
  @findex proc initscr*()꞉ ptr WINDOW @{.extdecl, importc꞉ "initscr", dynlib꞉ pdcursesdll.@}
@example
proc initscr*()꞉ ptr WINDOW @{.extdecl, importc꞉ "initscr", dynlib꞉ pdcursesdll.@}
@end example
  

@item innstr
  @findex proc innstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "innstr",dynlib꞉ pdcursesdll.@}
@example
proc innstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "innstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item insch
  @findex proc insch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "insch", dynlib꞉ pdcursesdll.@}
@example
proc insch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "insch", dynlib꞉ pdcursesdll.@}
@end example
  

@item insdelln
  @findex proc insdelln*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "insdelln", dynlib꞉ pdcursesdll.@}
@example
proc insdelln*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "insdelln", dynlib꞉ pdcursesdll.@}
@end example
  

@item insertln
  @findex proc insertln*()꞉ cint @{.extdecl, importc꞉ "insertln", dynlib꞉ pdcursesdll.@}
@example
proc insertln*()꞉ cint @{.extdecl, importc꞉ "insertln", dynlib꞉ pdcursesdll.@}
@end example
  

@item insnstr
  @findex proc insnstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "insnstr",dynlib꞉ pdcursesdll.@}
@example
proc insnstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "insnstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item insstr
  @findex proc insstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "insstr", dynlib꞉ pdcursesdll.@}
@example
proc insstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "insstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item instr
  @findex proc instr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "instr", dynlib꞉ pdcursesdll.@}
@example
proc instr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "instr", dynlib꞉ pdcursesdll.@}
@end example
  

@item intrflush
  @findex proc intrflush*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "intrflush", dynlib꞉ pdcursesdll.@}
@example
proc intrflush*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "intrflush", dynlib꞉ pdcursesdll.@}
@end example
  

@item isendwin
  @findex proc isendwin*()꞉ cunsignedchar @{.extdecl, importc꞉ "isendwin", dynlib꞉ pdcursesdll.@}
@example
proc isendwin*()꞉ cunsignedchar @{.extdecl, importc꞉ "isendwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item is_linetouched
  @findex proc is_linetouched*(a2꞉ ptr WINDOW; a3꞉ cint)꞉ cunsignedchar @{.extdecl,importc꞉ "is_linetouched", dynlib꞉ pdcursesdll.@}
@example
proc is_linetouched*(a2꞉ ptr WINDOW; a3꞉ cint)꞉ cunsignedchar @{.extdecl,importc꞉ "is_linetouched", dynlib꞉ pdcursesdll.@}
@end example
  

@item is_wintouched
  @findex proc is_wintouched*(a2꞉ ptr WINDOW)꞉ cunsignedchar @{.extdecl,importc꞉ "is_wintouched", dynlib꞉ pdcursesdll.@}
@example
proc is_wintouched*(a2꞉ ptr WINDOW)꞉ cunsignedchar @{.extdecl,importc꞉ "is_wintouched", dynlib꞉ pdcursesdll.@}
@end example
  

@item keyname
  @findex proc keyname*(a2꞉ cint)꞉ cstring @{.extdecl, importc꞉ "keyname", dynlib꞉ pdcursesdll.@}
@example
proc keyname*(a2꞉ cint)꞉ cstring @{.extdecl, importc꞉ "keyname", dynlib꞉ pdcursesdll.@}
@end example
  

@item keypad
  @findex proc keypad*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "keypad",dynlib꞉ pdcursesdll.@}
@example
proc keypad*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "keypad",dynlib꞉ pdcursesdll.@}
@end example
  

@item killchar
  @findex proc killchar*()꞉ char @{.extdecl, importc꞉ "killchar", dynlib꞉ pdcursesdll.@}
@example
proc killchar*()꞉ char @{.extdecl, importc꞉ "killchar", dynlib꞉ pdcursesdll.@}
@end example
  

@item leaveok
  @findex proc leaveok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "leaveok",dynlib꞉ pdcursesdll.@}
@example
proc leaveok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "leaveok",dynlib꞉ pdcursesdll.@}
@end example
  

@item longname
  @findex proc longname*()꞉ cstring @{.extdecl, importc꞉ "longname", dynlib꞉ pdcursesdll.@}
@example
proc longname*()꞉ cstring @{.extdecl, importc꞉ "longname", dynlib꞉ pdcursesdll.@}
@end example
  

@item meta
  @findex proc meta*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "meta",dynlib꞉ pdcursesdll.@}
@example
proc meta*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "meta",dynlib꞉ pdcursesdll.@}
@end example
  

@item move
  @findex proc move*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "move", dynlib꞉ pdcursesdll.@}
@example
proc move*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "move", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddch
  @findex proc mvaddch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvaddch",dynlib꞉ pdcursesdll.@}
@example
proc mvaddch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvaddch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddchnstr
  @findex proc mvaddchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvaddchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvaddchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvaddchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddchstr
  @findex proc mvaddchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvaddchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvaddchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvaddchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddnstr
  @findex proc mvaddnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvaddnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvaddnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvaddnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddstr
  @findex proc mvaddstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvaddstr",dynlib꞉ pdcursesdll.@}
@example
proc mvaddstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvaddstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvchgat
  @findex proc mvchgat*(a2꞉ cint; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong; a6꞉ cshort; a7꞉ pointer)꞉ cint @{.extdecl, importc꞉ "mvchgat", dynlib꞉ pdcursesdll.@}
@example
proc mvchgat*(a2꞉ cint; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong; a6꞉ cshort; a7꞉ pointer)꞉ cint @{.extdecl, importc꞉ "mvchgat", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvcur
  @findex proc mvcur*(a2꞉ cint; a3꞉ cint; a4꞉ cint; a5꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvcur",dynlib꞉ pdcursesdll.@}
@example
proc mvcur*(a2꞉ cint; a3꞉ cint; a4꞉ cint; a5꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvcur",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvdelch
  @findex proc mvdelch*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvdelch",dynlib꞉ pdcursesdll.@}
@example
proc mvdelch*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvdelch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvderwin
  @findex proc mvderwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvderwin",dynlib꞉ pdcursesdll.@}
@example
proc mvderwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvderwin",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvgetch
  @findex proc mvgetch*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvgetch",dynlib꞉ pdcursesdll.@}
@example
proc mvgetch*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvgetch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvgetnstr
  @findex proc mvgetnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvgetnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvgetnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvgetnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvgetstr
  @findex proc mvgetstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvgetstr",dynlib꞉ pdcursesdll.@}
@example
proc mvgetstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvgetstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvhline
  @findex proc mvhline*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvhline", dynlib꞉ pdcursesdll.@}
@example
proc mvhline*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvhline", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinch
  @findex proc mvinch*(a2꞉ cint; a3꞉ cint)꞉ cunsignedlong @{.extdecl, importc꞉ "mvinch",dynlib꞉ pdcursesdll.@}
@example
proc mvinch*(a2꞉ cint; a3꞉ cint)꞉ cunsignedlong @{.extdecl, importc꞉ "mvinch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinchnstr
  @findex proc mvinchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvinchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinchstr
  @findex proc mvinchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvinchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvinchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvinchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinnstr
  @findex proc mvinnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvinnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinsch
  @findex proc mvinsch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvinsch",dynlib꞉ pdcursesdll.@}
@example
proc mvinsch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvinsch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinsnstr
  @findex proc mvinsnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinsnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvinsnstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinsnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinsstr
  @findex proc mvinsstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvinsstr",dynlib꞉ pdcursesdll.@}
@example
proc mvinsstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvinsstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinstr
  @findex proc mvinstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvinstr",dynlib꞉ pdcursesdll.@}
@example
proc mvinstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvinstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvprintw
  @findex proc mvprintw*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvprintw", dynlib꞉ pdcursesdll.@}
@example
proc mvprintw*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvprintw", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvscanw
  @findex proc mvscanw*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvscanw", dynlib꞉ pdcursesdll.@}
@example
proc mvscanw*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvscanw", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvvline
  @findex proc mvvline*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvvline", dynlib꞉ pdcursesdll.@}
@example
proc mvvline*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvvline", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddchnstr
  @findex proc mvwaddchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwaddchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwaddchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddchstr
  @findex proc mvwaddchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvwaddchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvwaddchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddch
  @findex proc mvwaddch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwaddch", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwaddch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddnstr
  @findex proc mvwaddnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwaddnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwaddnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddstr
  @findex proc mvwaddstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwaddstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwaddstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwchgat
  @findex proc mvwchgat*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cunsignedlong; a7꞉ cshort;a8꞉ pointer)꞉ cint @{.extdecl, importc꞉ "mvwchgat", dynlib꞉ pdcursesdll.@}
@example
proc mvwchgat*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cunsignedlong; a7꞉ cshort;a8꞉ pointer)꞉ cint @{.extdecl, importc꞉ "mvwchgat", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwdelch
  @findex proc mvwdelch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwdelch",dynlib꞉ pdcursesdll.@}
@example
proc mvwdelch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwdelch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwgetch
  @findex proc mvwgetch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwgetch",dynlib꞉ pdcursesdll.@}
@example
proc mvwgetch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwgetch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwgetnstr
  @findex proc mvwgetnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwgetnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwgetnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwgetnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwgetstr
  @findex proc mvwgetstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwgetstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwgetstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwgetstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwhline
  @findex proc mvwhline*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwhline", dynlib꞉ pdcursesdll.@}
@example
proc mvwhline*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwhline", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinchnstr
  @findex proc mvwinchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwinchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwinchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinchstr
  @findex proc mvwinchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwinchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwinchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinch
  @findex proc mvwinch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cunsignedlong @{.extdecl,importc꞉ "mvwinch", dynlib꞉ pdcursesdll.@}
@example
proc mvwinch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cunsignedlong @{.extdecl,importc꞉ "mvwinch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinnstr
  @findex proc mvwinnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinsch
  @findex proc mvwinsch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwinsch", dynlib꞉ pdcursesdll.@}
@example
proc mvwinsch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwinsch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinsnstr
  @findex proc mvwinsnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinsnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinsnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinsnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinsstr
  @findex proc mvwinsstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwinsstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinsstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwinsstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinstr
  @findex proc mvwinstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwinstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwinstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwin
  @findex proc mvwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwin",dynlib꞉ pdcursesdll.@}
@example
proc mvwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwin",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwprintw
  @findex proc mvwprintw*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvwprintw", dynlib꞉ pdcursesdll.@}
@example
proc mvwprintw*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvwprintw", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwscanw
  @findex proc mvwscanw*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvwscanw", dynlib꞉ pdcursesdll.@}
@example
proc mvwscanw*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.varargs, extdecl,importc꞉ "mvwscanw", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwvline
  @findex proc mvwvline*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwvline", dynlib꞉ pdcursesdll.@}
@example
proc mvwvline*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwvline", dynlib꞉ pdcursesdll.@}
@end example
  

@item napms
  @findex proc napms*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "napms", dynlib꞉ pdcursesdll.@}
@example
proc napms*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "napms", dynlib꞉ pdcursesdll.@}
@end example
  

@item newpad
  @findex proc newpad*(a2꞉ cint; a3꞉ cint)꞉ ptr WINDOW @{.extdecl, importc꞉ "newpad",dynlib꞉ pdcursesdll.@}
@example
proc newpad*(a2꞉ cint; a3꞉ cint)꞉ ptr WINDOW @{.extdecl, importc꞉ "newpad",dynlib꞉ pdcursesdll.@}
@end example
  

@item newterm
  @findex proc newterm*(a2꞉ cstring; a3꞉ File; a4꞉ File)꞉ ptr SCREEN @{.extdecl, importc꞉ "newterm",dynlib꞉ pdcursesdll.@}
@example
proc newterm*(a2꞉ cstring; a3꞉ File; a4꞉ File)꞉ ptr SCREEN @{.extdecl, importc꞉ "newterm",dynlib꞉ pdcursesdll.@}
@end example
  

@item newwin
  @findex proc newwin*(a2꞉ cint; a3꞉ cint; a4꞉ cint; a5꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "newwin", dynlib꞉ pdcursesdll.@}
@example
proc newwin*(a2꞉ cint; a3꞉ cint; a4꞉ cint; a5꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "newwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item nl
  @findex proc nl*()꞉ cint @{.extdecl, importc꞉ "nl", dynlib꞉ pdcursesdll.@}
@example
proc nl*()꞉ cint @{.extdecl, importc꞉ "nl", dynlib꞉ pdcursesdll.@}
@end example
  

@item nocbreak
  @findex proc nocbreak*()꞉ cint @{.extdecl, importc꞉ "nocbreak", dynlib꞉ pdcursesdll.@}
@example
proc nocbreak*()꞉ cint @{.extdecl, importc꞉ "nocbreak", dynlib꞉ pdcursesdll.@}
@end example
  

@item nodelay
  @findex proc nodelay*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "nodelay",dynlib꞉ pdcursesdll.@}
@example
proc nodelay*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "nodelay",dynlib꞉ pdcursesdll.@}
@end example
  

@item noecho
  @findex proc noecho*()꞉ cint @{.extdecl, importc꞉ "noecho", dynlib꞉ pdcursesdll.@}
@example
proc noecho*()꞉ cint @{.extdecl, importc꞉ "noecho", dynlib꞉ pdcursesdll.@}
@end example
  

@item nonl
  @findex proc nonl*()꞉ cint @{.extdecl, importc꞉ "nonl", dynlib꞉ pdcursesdll.@}
@example
proc nonl*()꞉ cint @{.extdecl, importc꞉ "nonl", dynlib꞉ pdcursesdll.@}
@end example
  

@item noqiflush
  @findex proc noqiflush*() @{.extdecl, importc꞉ "noqiflush", dynlib꞉ pdcursesdll.@}
@example
proc noqiflush*() @{.extdecl, importc꞉ "noqiflush", dynlib꞉ pdcursesdll.@}
@end example
  

@item noraw
  @findex proc noraw*()꞉ cint @{.extdecl, importc꞉ "noraw", dynlib꞉ pdcursesdll.@}
@example
proc noraw*()꞉ cint @{.extdecl, importc꞉ "noraw", dynlib꞉ pdcursesdll.@}
@end example
  

@item notimeout
  @findex proc notimeout*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "notimeout", dynlib꞉ pdcursesdll.@}
@example
proc notimeout*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "notimeout", dynlib꞉ pdcursesdll.@}
@end example
  

@item overlay
  @findex proc overlay*(a2꞉ ptr WINDOW; a3꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "overlay",dynlib꞉ pdcursesdll.@}
@example
proc overlay*(a2꞉ ptr WINDOW; a3꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "overlay",dynlib꞉ pdcursesdll.@}
@end example
  

@item overwrite
  @findex proc overwrite*(a2꞉ ptr WINDOW; a3꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "overwrite",dynlib꞉ pdcursesdll.@}
@example
proc overwrite*(a2꞉ ptr WINDOW; a3꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "overwrite",dynlib꞉ pdcursesdll.@}
@end example
  

@item pair_content
  @findex proc pair_content*(a2꞉ cshort; a3꞉ ptr cshort; a4꞉ ptr cshort)꞉ cint @{.extdecl,importc꞉ "pair_content", dynlib꞉ pdcursesdll.@}
@example
proc pair_content*(a2꞉ cshort; a3꞉ ptr cshort; a4꞉ ptr cshort)꞉ cint @{.extdecl,importc꞉ "pair_content", dynlib꞉ pdcursesdll.@}
@end example
  

@item pechochar
  @findex proc pechochar*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "pechochar", dynlib꞉ pdcursesdll.@}
@example
proc pechochar*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "pechochar", dynlib꞉ pdcursesdll.@}
@end example
  

@item pnoutrefresh
  @findex proc pnoutrefresh*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint; a7꞉ cint; a8꞉ cint)꞉ cint @{.extdecl, importc꞉ "pnoutrefresh", dynlib꞉ pdcursesdll.@}
@example
proc pnoutrefresh*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint; a7꞉ cint; a8꞉ cint)꞉ cint @{.extdecl, importc꞉ "pnoutrefresh", dynlib꞉ pdcursesdll.@}
@end example
  

@item prefresh
  @findex proc prefresh*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint; a7꞉ cint; a8꞉ cint)꞉ cint @{.extdecl, importc꞉ "prefresh", dynlib꞉ pdcursesdll.@}
@example
proc prefresh*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint; a7꞉ cint; a8꞉ cint)꞉ cint @{.extdecl, importc꞉ "prefresh", dynlib꞉ pdcursesdll.@}
@end example
  

@item printw
  @findex proc printw*(a2꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "printw",dynlib꞉ pdcursesdll.@}
@example
proc printw*(a2꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "printw",dynlib꞉ pdcursesdll.@}
@end example
  

@item putwin
  @findex proc putwin*(a2꞉ ptr WINDOW; a3꞉ File)꞉ cint @{.extdecl, importc꞉ "putwin",dynlib꞉ pdcursesdll.@}
@example
proc putwin*(a2꞉ ptr WINDOW; a3꞉ File)꞉ cint @{.extdecl, importc꞉ "putwin",dynlib꞉ pdcursesdll.@}
@end example
  

@item qiflush
  @findex proc qiflush*() @{.extdecl, importc꞉ "qiflush", dynlib꞉ pdcursesdll.@}
@example
proc qiflush*() @{.extdecl, importc꞉ "qiflush", dynlib꞉ pdcursesdll.@}
@end example
  

@item raw
  @findex proc raw*()꞉ cint @{.extdecl, importc꞉ "raw", dynlib꞉ pdcursesdll.@}
@example
proc raw*()꞉ cint @{.extdecl, importc꞉ "raw", dynlib꞉ pdcursesdll.@}
@end example
  

@item redrawwin
  @findex proc redrawwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "redrawwin",dynlib꞉ pdcursesdll.@}
@example
proc redrawwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "redrawwin",dynlib꞉ pdcursesdll.@}
@end example
  

@item refresh
  @findex proc refresh*()꞉ cint @{.extdecl, importc꞉ "refresh", dynlib꞉ pdcursesdll.@}
@example
proc refresh*()꞉ cint @{.extdecl, importc꞉ "refresh", dynlib꞉ pdcursesdll.@}
@end example
  

@item reset_prog_mode
  @findex proc reset_prog_mode*()꞉ cint @{.extdecl, importc꞉ "reset_prog_mode",dynlib꞉ pdcursesdll.@}
@example
proc reset_prog_mode*()꞉ cint @{.extdecl, importc꞉ "reset_prog_mode",dynlib꞉ pdcursesdll.@}
@end example
  

@item reset_shell_mode
  @findex proc reset_shell_mode*()꞉ cint @{.extdecl, importc꞉ "reset_shell_mode",dynlib꞉ pdcursesdll.@}
@example
proc reset_shell_mode*()꞉ cint @{.extdecl, importc꞉ "reset_shell_mode",dynlib꞉ pdcursesdll.@}
@end example
  

@item resetty
  @findex proc resetty*()꞉ cint @{.extdecl, importc꞉ "resetty", dynlib꞉ pdcursesdll.@}
@example
proc resetty*()꞉ cint @{.extdecl, importc꞉ "resetty", dynlib꞉ pdcursesdll.@}
@end example
  

@item savetty
  @findex proc savetty*()꞉ cint @{.extdecl, importc꞉ "savetty", dynlib꞉ pdcursesdll.@}
@example
proc savetty*()꞉ cint @{.extdecl, importc꞉ "savetty", dynlib꞉ pdcursesdll.@}
@end example
  

@item scanw
  @findex proc scanw*(a2꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "scanw", dynlib꞉ pdcursesdll.@}
@example
proc scanw*(a2꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "scanw", dynlib꞉ pdcursesdll.@}
@end example
  

@item scr_dump
  @findex proc scr_dump*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_dump", dynlib꞉ pdcursesdll.@}
@example
proc scr_dump*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_dump", dynlib꞉ pdcursesdll.@}
@end example
  

@item scr_init
  @findex proc scr_init*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_init", dynlib꞉ pdcursesdll.@}
@example
proc scr_init*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_init", dynlib꞉ pdcursesdll.@}
@end example
  

@item scr_restore
  @findex proc scr_restore*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_restore",dynlib꞉ pdcursesdll.@}
@example
proc scr_restore*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_restore",dynlib꞉ pdcursesdll.@}
@end example
  

@item scr_set
  @findex proc scr_set*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_set", dynlib꞉ pdcursesdll.@}
@example
proc scr_set*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "scr_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item scrl
  @findex proc scrl*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "scrl", dynlib꞉ pdcursesdll.@}
@example
proc scrl*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "scrl", dynlib꞉ pdcursesdll.@}
@end example
  

@item scroll
  @findex proc scroll*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "scroll", dynlib꞉ pdcursesdll.@}
@example
proc scroll*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "scroll", dynlib꞉ pdcursesdll.@}
@end example
  

@item scrollok
  @findex proc scrollok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "scrollok",dynlib꞉ pdcursesdll.@}
@example
proc scrollok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "scrollok",dynlib꞉ pdcursesdll.@}
@end example
  

@item set_term
  @findex proc set_term*(a2꞉ ptr SCREEN)꞉ ptr SCREEN @{.extdecl, importc꞉ "set_term",dynlib꞉ pdcursesdll.@}
@example
proc set_term*(a2꞉ ptr SCREEN)꞉ ptr SCREEN @{.extdecl, importc꞉ "set_term",dynlib꞉ pdcursesdll.@}
@end example
  

@item setscrreg
  @findex proc setscrreg*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "setscrreg",dynlib꞉ pdcursesdll.@}
@example
proc setscrreg*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "setscrreg",dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_attroff
  @findex proc slk_attroff*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "slk_attroff",dynlib꞉ pdcursesdll.@}
@example
proc slk_attroff*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "slk_attroff",dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_attr_off
  @findex proc slk_attr_off*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl,importc꞉ "slk_attr_off", dynlib꞉ pdcursesdll.@}
@example
proc slk_attr_off*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl,importc꞉ "slk_attr_off", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_attron
  @findex proc slk_attron*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "slk_attron",dynlib꞉ pdcursesdll.@}
@example
proc slk_attron*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "slk_attron",dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_attr_on
  @findex proc slk_attr_on*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl,importc꞉ "slk_attr_on", dynlib꞉ pdcursesdll.@}
@example
proc slk_attr_on*(a2꞉ cunsignedlong; a3꞉ pointer)꞉ cint @{.extdecl,importc꞉ "slk_attr_on", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_attrset
  @findex proc slk_attrset*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "slk_attrset",dynlib꞉ pdcursesdll.@}
@example
proc slk_attrset*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "slk_attrset",dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_attr_set
  @findex proc slk_attr_set*(a2꞉ cunsignedlong; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "slk_attr_set", dynlib꞉ pdcursesdll.@}
@example
proc slk_attr_set*(a2꞉ cunsignedlong; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "slk_attr_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_clear
  @findex proc slk_clear*()꞉ cint @{.extdecl, importc꞉ "slk_clear", dynlib꞉ pdcursesdll.@}
@example
proc slk_clear*()꞉ cint @{.extdecl, importc꞉ "slk_clear", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_color
  @findex proc slk_color*(a2꞉ cshort)꞉ cint @{.extdecl, importc꞉ "slk_color", dynlib꞉ pdcursesdll.@}
@example
proc slk_color*(a2꞉ cshort)꞉ cint @{.extdecl, importc꞉ "slk_color", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_init
  @findex proc slk_init*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "slk_init", dynlib꞉ pdcursesdll.@}
@example
proc slk_init*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "slk_init", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_label
  @findex proc slk_label*(a2꞉ cint)꞉ cstring @{.extdecl, importc꞉ "slk_label", dynlib꞉ pdcursesdll.@}
@example
proc slk_label*(a2꞉ cint)꞉ cstring @{.extdecl, importc꞉ "slk_label", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_noutrefresh
  @findex proc slk_noutrefresh*()꞉ cint @{.extdecl, importc꞉ "slk_noutrefresh",dynlib꞉ pdcursesdll.@}
@example
proc slk_noutrefresh*()꞉ cint @{.extdecl, importc꞉ "slk_noutrefresh",dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_refresh
  @findex proc slk_refresh*()꞉ cint @{.extdecl, importc꞉ "slk_refresh", dynlib꞉ pdcursesdll.@}
@example
proc slk_refresh*()꞉ cint @{.extdecl, importc꞉ "slk_refresh", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_restore
  @findex proc slk_restore*()꞉ cint @{.extdecl, importc꞉ "slk_restore", dynlib꞉ pdcursesdll.@}
@example
proc slk_restore*()꞉ cint @{.extdecl, importc꞉ "slk_restore", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_set
  @findex proc slk_set*(a2꞉ cint; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "slk_set",dynlib꞉ pdcursesdll.@}
@example
proc slk_set*(a2꞉ cint; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "slk_set",dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_touch
  @findex proc slk_touch*()꞉ cint @{.extdecl, importc꞉ "slk_touch", dynlib꞉ pdcursesdll.@}
@example
proc slk_touch*()꞉ cint @{.extdecl, importc꞉ "slk_touch", dynlib꞉ pdcursesdll.@}
@end example
  

@item standend
  @findex proc standend*()꞉ cint @{.extdecl, importc꞉ "standend", dynlib꞉ pdcursesdll.@}
@example
proc standend*()꞉ cint @{.extdecl, importc꞉ "standend", dynlib꞉ pdcursesdll.@}
@end example
  

@item standout
  @findex proc standout*()꞉ cint @{.extdecl, importc꞉ "standout", dynlib꞉ pdcursesdll.@}
@example
proc standout*()꞉ cint @{.extdecl, importc꞉ "standout", dynlib꞉ pdcursesdll.@}
@end example
  

@item start_color
  @findex proc start_color*()꞉ cint @{.extdecl, importc꞉ "start_color", dynlib꞉ pdcursesdll.@}
@example
proc start_color*()꞉ cint @{.extdecl, importc꞉ "start_color", dynlib꞉ pdcursesdll.@}
@end example
  

@item subpad
  @findex proc subpad*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "subpad", dynlib꞉ pdcursesdll.@}
@example
proc subpad*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "subpad", dynlib꞉ pdcursesdll.@}
@end example
  

@item subwin
  @findex proc subwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "subwin", dynlib꞉ pdcursesdll.@}
@example
proc subwin*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint; a6꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "subwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item syncok
  @findex proc syncok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "syncok",dynlib꞉ pdcursesdll.@}
@example
proc syncok*(a2꞉ ptr WINDOW; a3꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "syncok",dynlib꞉ pdcursesdll.@}
@end example
  

@item termattrs
  @findex proc termattrs*()꞉ cunsignedlong @{.extdecl, importc꞉ "termattrs", dynlib꞉ pdcursesdll.@}
@example
proc termattrs*()꞉ cunsignedlong @{.extdecl, importc꞉ "termattrs", dynlib꞉ pdcursesdll.@}
@end example
  

@item termattrs2
  @findex proc termattrs2*()꞉ cunsignedlong @{.extdecl, importc꞉ "term_attrs",dynlib꞉ pdcursesdll.@}
@example
proc termattrs2*()꞉ cunsignedlong @{.extdecl, importc꞉ "term_attrs",dynlib꞉ pdcursesdll.@}
@end example
  

@item termname
  @findex proc termname*()꞉ cstring @{.extdecl, importc꞉ "termname", dynlib꞉ pdcursesdll.@}
@example
proc termname*()꞉ cstring @{.extdecl, importc꞉ "termname", dynlib꞉ pdcursesdll.@}
@end example
  

@item timeout
  @findex proc timeout*(a2꞉ cint) @{.extdecl, importc꞉ "timeout", dynlib꞉ pdcursesdll.@}
@example
proc timeout*(a2꞉ cint) @{.extdecl, importc꞉ "timeout", dynlib꞉ pdcursesdll.@}
@end example
  

@item touchline
  @findex proc touchline*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "touchline",dynlib꞉ pdcursesdll.@}
@example
proc touchline*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "touchline",dynlib꞉ pdcursesdll.@}
@end example
  

@item touchwin
  @findex proc touchwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "touchwin", dynlib꞉ pdcursesdll.@}
@example
proc touchwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "touchwin", dynlib꞉ pdcursesdll.@}
@end example
  

@item typeahead
  @findex proc typeahead*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "typeahead", dynlib꞉ pdcursesdll.@}
@example
proc typeahead*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "typeahead", dynlib꞉ pdcursesdll.@}
@end example
  

@item untouchwin
  @findex proc untouchwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "untouchwin",dynlib꞉ pdcursesdll.@}
@example
proc untouchwin*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "untouchwin",dynlib꞉ pdcursesdll.@}
@end example
  

@item use_env
  @findex proc use_env*(a2꞉ cunsignedchar) @{.extdecl, importc꞉ "use_env", dynlib꞉ pdcursesdll.@}
@example
proc use_env*(a2꞉ cunsignedchar) @{.extdecl, importc꞉ "use_env", dynlib꞉ pdcursesdll.@}
@end example
  

@item vidattr
  @findex proc vidattr*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "vidattr",dynlib꞉ pdcursesdll.@}
@example
proc vidattr*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "vidattr",dynlib꞉ pdcursesdll.@}
@end example
  

@item vid_attr
  @findex proc vid_attr*(a2꞉ cunsignedlong; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "vid_attr", dynlib꞉ pdcursesdll.@}
@example
proc vid_attr*(a2꞉ cunsignedlong; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "vid_attr", dynlib꞉ pdcursesdll.@}
@end example
  

@item vline
  @findex proc vline*(a2꞉ cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "vline",dynlib꞉ pdcursesdll.@}
@example
proc vline*(a2꞉ cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "vline",dynlib꞉ pdcursesdll.@}
@end example
  

@item vwprintw
  @findex proc vwprintw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs,importc꞉ "vw_printw", dynlib꞉ pdcursesdll.@}
@example
proc vwprintw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs,importc꞉ "vw_printw", dynlib꞉ pdcursesdll.@}
@end example
  

@item vwprintw2
  @findex proc vwprintw2*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs,importc꞉ "vwprintw", dynlib꞉ pdcursesdll.@}
@example
proc vwprintw2*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs,importc꞉ "vwprintw", dynlib꞉ pdcursesdll.@}
@end example
  

@item vwscanw
  @findex proc vwscanw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs, importc꞉ "vw_scanw",dynlib꞉ pdcursesdll.@}
@example
proc vwscanw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs, importc꞉ "vw_scanw",dynlib꞉ pdcursesdll.@}
@end example
  

@item vwscanw2
  @findex proc vwscanw2*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs, importc꞉ "vwscanw",dynlib꞉ pdcursesdll.@}
@example
proc vwscanw2*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, varargs, importc꞉ "vwscanw",dynlib꞉ pdcursesdll.@}
@end example
  

@item waddchnstr
  @findex proc waddchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "waddchnstr", dynlib꞉ pdcursesdll.@}
@example
proc waddchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "waddchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item waddchstr
  @findex proc waddchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "waddchstr", dynlib꞉ pdcursesdll.@}
@example
proc waddchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "waddchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item waddch
  @findex proc waddch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "waddch",dynlib꞉ pdcursesdll.@}
@example
proc waddch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "waddch",dynlib꞉ pdcursesdll.@}
@end example
  

@item waddnstr
  @findex proc waddnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "waddnstr", dynlib꞉ pdcursesdll.@}
@example
proc waddnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "waddnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item waddstr
  @findex proc waddstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "waddstr",dynlib꞉ pdcursesdll.@}
@example
proc waddstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "waddstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item wattroff
  @findex proc wattroff*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wattroff",dynlib꞉ pdcursesdll.@}
@example
proc wattroff*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wattroff",dynlib꞉ pdcursesdll.@}
@end example
  

@item wattron
  @findex proc wattron*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wattron",dynlib꞉ pdcursesdll.@}
@example
proc wattron*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wattron",dynlib꞉ pdcursesdll.@}
@end example
  

@item wattrset
  @findex proc wattrset*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wattrset",dynlib꞉ pdcursesdll.@}
@example
proc wattrset*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wattrset",dynlib꞉ pdcursesdll.@}
@end example
  

@item wattr_get
  @findex proc wattr_get*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ ptr cshort; a5꞉ pointer)꞉ cint @{.extdecl, importc꞉ "wattr_get", dynlib꞉ pdcursesdll.@}
@example
proc wattr_get*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ ptr cshort; a5꞉ pointer)꞉ cint @{.extdecl, importc꞉ "wattr_get", dynlib꞉ pdcursesdll.@}
@end example
  

@item wattr_off
  @findex proc wattr_off*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "wattr_off", dynlib꞉ pdcursesdll.@}
@example
proc wattr_off*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "wattr_off", dynlib꞉ pdcursesdll.@}
@end example
  

@item wattr_on
  @findex proc wattr_on*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "wattr_on", dynlib꞉ pdcursesdll.@}
@example
proc wattr_on*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "wattr_on", dynlib꞉ pdcursesdll.@}
@end example
  

@item wattr_set
  @findex proc wattr_set*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cshort; a5꞉ pointer)꞉ cint @{.extdecl, importc꞉ "wattr_set", dynlib꞉ pdcursesdll.@}
@example
proc wattr_set*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cshort; a5꞉ pointer)꞉ cint @{.extdecl, importc꞉ "wattr_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item wbkgdset
  @findex proc wbkgdset*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong) @{.extdecl, importc꞉ "wbkgdset",dynlib꞉ pdcursesdll.@}
@example
proc wbkgdset*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong) @{.extdecl, importc꞉ "wbkgdset",dynlib꞉ pdcursesdll.@}
@end example
  

@item wbkgd
  @findex proc wbkgd*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wbkgd",dynlib꞉ pdcursesdll.@}
@example
proc wbkgd*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wbkgd",dynlib꞉ pdcursesdll.@}
@end example
  

@item wborder
  @findex proc wborder*(a2: ptr WINDOW; a3: cunsignedlong; a4: cunsignedlong; a5: cunsignedlong;
             a6: cunsignedlong; a7: cunsignedlong; a8: cunsignedlong;
             a9: cunsignedlong; a10: cunsignedlong): cint @{.extdecl,
    importc: "wborder", dynlib: pdcursesdll.@}
@example
proc wborder*(a2: ptr WINDOW; a3: cunsignedlong; a4: cunsignedlong; a5: cunsignedlong;
             a6: cunsignedlong; a7: cunsignedlong; a8: cunsignedlong;
             a9: cunsignedlong; a10: cunsignedlong): cint @{.extdecl,
    importc: "wborder", dynlib: pdcursesdll.@}
@end example
  

@item wchgat
  @findex proc wchgat*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cunsignedlong; a5꞉ cshort; a6꞉ pointer)꞉ cint @{.extdecl, importc꞉ "wchgat", dynlib꞉ pdcursesdll.@}
@example
proc wchgat*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cunsignedlong; a5꞉ cshort; a6꞉ pointer)꞉ cint @{.extdecl, importc꞉ "wchgat", dynlib꞉ pdcursesdll.@}
@end example
  

@item wclear
  @findex proc wclear*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wclear", dynlib꞉ pdcursesdll.@}
@example
proc wclear*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wclear", dynlib꞉ pdcursesdll.@}
@end example
  

@item wclrtobot
  @findex proc wclrtobot*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wclrtobot",dynlib꞉ pdcursesdll.@}
@example
proc wclrtobot*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wclrtobot",dynlib꞉ pdcursesdll.@}
@end example
  

@item wclrtoeol
  @findex proc wclrtoeol*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wclrtoeol",dynlib꞉ pdcursesdll.@}
@example
proc wclrtoeol*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wclrtoeol",dynlib꞉ pdcursesdll.@}
@end example
  

@item wcolor_set
  @findex proc wcolor_set*(a2꞉ ptr WINDOW; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "wcolor_set", dynlib꞉ pdcursesdll.@}
@example
proc wcolor_set*(a2꞉ ptr WINDOW; a3꞉ cshort; a4꞉ pointer)꞉ cint @{.extdecl,importc꞉ "wcolor_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item wcursyncup
  @findex proc wcursyncup*(a2꞉ ptr WINDOW) @{.extdecl, importc꞉ "wcursyncup", dynlib꞉ pdcursesdll.@}
@example
proc wcursyncup*(a2꞉ ptr WINDOW) @{.extdecl, importc꞉ "wcursyncup", dynlib꞉ pdcursesdll.@}
@end example
  

@item wdelch
  @findex proc wdelch*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wdelch", dynlib꞉ pdcursesdll.@}
@example
proc wdelch*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wdelch", dynlib꞉ pdcursesdll.@}
@end example
  

@item wdeleteln
  @findex proc wdeleteln*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wdeleteln",dynlib꞉ pdcursesdll.@}
@example
proc wdeleteln*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wdeleteln",dynlib꞉ pdcursesdll.@}
@end example
  

@item wechochar
  @findex proc wechochar*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wechochar", dynlib꞉ pdcursesdll.@}
@example
proc wechochar*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wechochar", dynlib꞉ pdcursesdll.@}
@end example
  

@item werase
  @findex proc werase*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "werase", dynlib꞉ pdcursesdll.@}
@example
proc werase*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "werase", dynlib꞉ pdcursesdll.@}
@end example
  

@item wgetch
  @findex proc wgetch*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wgetch", dynlib꞉ pdcursesdll.@}
@example
proc wgetch*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wgetch", dynlib꞉ pdcursesdll.@}
@end example
  

@item wgetnstr
  @findex proc wgetnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wgetnstr", dynlib꞉ pdcursesdll.@}
@example
proc wgetnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wgetnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item wgetstr
  @findex proc wgetstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "wgetstr",dynlib꞉ pdcursesdll.@}
@example
proc wgetstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "wgetstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item whline
  @findex proc whline*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "whline", dynlib꞉ pdcursesdll.@}
@example
proc whline*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "whline", dynlib꞉ pdcursesdll.@}
@end example
  

@item winchnstr
  @findex proc winchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "winchnstr", dynlib꞉ pdcursesdll.@}
@example
proc winchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "winchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item winchstr
  @findex proc winchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "winchstr", dynlib꞉ pdcursesdll.@}
@example
proc winchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "winchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item winch
  @findex proc winch*(a2꞉ ptr WINDOW)꞉ cunsignedlong @{.extdecl, importc꞉ "winch",dynlib꞉ pdcursesdll.@}
@example
proc winch*(a2꞉ ptr WINDOW)꞉ cunsignedlong @{.extdecl, importc꞉ "winch",dynlib꞉ pdcursesdll.@}
@end example
  

@item winnstr
  @findex proc winnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "winnstr",dynlib꞉ pdcursesdll.@}
@example
proc winnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "winnstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item winsch
  @findex proc winsch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "winsch",dynlib꞉ pdcursesdll.@}
@example
proc winsch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "winsch",dynlib꞉ pdcursesdll.@}
@end example
  

@item winsdelln
  @findex proc winsdelln*(a2꞉ ptr WINDOW; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "winsdelln",dynlib꞉ pdcursesdll.@}
@example
proc winsdelln*(a2꞉ ptr WINDOW; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "winsdelln",dynlib꞉ pdcursesdll.@}
@end example
  

@item winsertln
  @findex proc winsertln*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "winsertln",dynlib꞉ pdcursesdll.@}
@example
proc winsertln*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "winsertln",dynlib꞉ pdcursesdll.@}
@end example
  

@item winsnstr
  @findex proc winsnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "winsnstr", dynlib꞉ pdcursesdll.@}
@example
proc winsnstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "winsnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item winsstr
  @findex proc winsstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "winsstr",dynlib꞉ pdcursesdll.@}
@example
proc winsstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "winsstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item winstr
  @findex proc winstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "winstr",dynlib꞉ pdcursesdll.@}
@example
proc winstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "winstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item wmove
  @findex proc wmove*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "wmove",dynlib꞉ pdcursesdll.@}
@example
proc wmove*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "wmove",dynlib꞉ pdcursesdll.@}
@end example
  

@item wnoutrefresh
  @findex proc wnoutrefresh*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wnoutrefresh",dynlib꞉ pdcursesdll.@}
@example
proc wnoutrefresh*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wnoutrefresh",dynlib꞉ pdcursesdll.@}
@end example
  

@item wprintw
  @findex proc wprintw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "wprintw",dynlib꞉ pdcursesdll.@}
@example
proc wprintw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "wprintw",dynlib꞉ pdcursesdll.@}
@end example
  

@item wredrawln
  @findex proc wredrawln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "wredrawln",dynlib꞉ pdcursesdll.@}
@example
proc wredrawln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "wredrawln",dynlib꞉ pdcursesdll.@}
@end example
  

@item wrefresh
  @findex proc wrefresh*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wrefresh", dynlib꞉ pdcursesdll.@}
@example
proc wrefresh*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wrefresh", dynlib꞉ pdcursesdll.@}
@end example
  

@item wscanw
  @findex proc wscanw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "wscanw",dynlib꞉ pdcursesdll.@}
@example
proc wscanw*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.varargs, extdecl, importc꞉ "wscanw",dynlib꞉ pdcursesdll.@}
@end example
  

@item wscrl
  @findex proc wscrl*(a2꞉ ptr WINDOW; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "wscrl",dynlib꞉ pdcursesdll.@}
@example
proc wscrl*(a2꞉ ptr WINDOW; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "wscrl",dynlib꞉ pdcursesdll.@}
@end example
  

@item wsetscrreg
  @findex proc wsetscrreg*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wsetscrreg", dynlib꞉ pdcursesdll.@}
@example
proc wsetscrreg*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wsetscrreg", dynlib꞉ pdcursesdll.@}
@end example
  

@item wstandend
  @findex proc wstandend*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wstandend",dynlib꞉ pdcursesdll.@}
@example
proc wstandend*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wstandend",dynlib꞉ pdcursesdll.@}
@end example
  

@item wstandout
  @findex proc wstandout*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wstandout",dynlib꞉ pdcursesdll.@}
@example
proc wstandout*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "wstandout",dynlib꞉ pdcursesdll.@}
@end example
  

@item wsyncdown
  @findex proc wsyncdown*(a2꞉ ptr WINDOW) @{.extdecl, importc꞉ "wsyncdown", dynlib꞉ pdcursesdll.@}
@example
proc wsyncdown*(a2꞉ ptr WINDOW) @{.extdecl, importc꞉ "wsyncdown", dynlib꞉ pdcursesdll.@}
@end example
  

@item wsyncup
  @findex proc wsyncup*(a2꞉ ptr WINDOW) @{.extdecl, importc꞉ "wsyncup", dynlib꞉ pdcursesdll.@}
@example
proc wsyncup*(a2꞉ ptr WINDOW) @{.extdecl, importc꞉ "wsyncup", dynlib꞉ pdcursesdll.@}
@end example
  

@item wtimeout
  @findex proc wtimeout*(a2꞉ ptr WINDOW; a3꞉ cint) @{.extdecl, importc꞉ "wtimeout",dynlib꞉ pdcursesdll.@}
@example
proc wtimeout*(a2꞉ ptr WINDOW; a3꞉ cint) @{.extdecl, importc꞉ "wtimeout",dynlib꞉ pdcursesdll.@}
@end example
  

@item wtouchln
  @findex proc wtouchln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "wtouchln", dynlib꞉ pdcursesdll.@}
@example
proc wtouchln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "wtouchln", dynlib꞉ pdcursesdll.@}
@end example
  

@item wvline
  @findex proc wvline*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wvline", dynlib꞉ pdcursesdll.@}
@example
proc wvline*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wvline", dynlib꞉ pdcursesdll.@}
@end example
  

@item addnwstr
  @findex proc addnwstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "addnwstr",dynlib꞉ pdcursesdll.@}
@example
proc addnwstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "addnwstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item addwstr
  @findex proc addwstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "addwstr", dynlib꞉ pdcursesdll.@}
@example
proc addwstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "addwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item add_wch
  @findex proc add_wch*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "add_wch",dynlib꞉ pdcursesdll.@}
@example
proc add_wch*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "add_wch",dynlib꞉ pdcursesdll.@}
@end example
  

@item add_wchnstr
  @findex proc add_wchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl,importc꞉ "add_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc add_wchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl,importc꞉ "add_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item add_wchstr
  @findex proc add_wchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "add_wchstr",dynlib꞉ pdcursesdll.@}
@example
proc add_wchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "add_wchstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item border_set
  @findex proc border_set*(a2: ptr cunsignedlong; a3: ptr cunsignedlong; a4: ptr cunsignedlong;
                a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr cunsignedlong;
                a8: ptr cunsignedlong; a9: ptr cunsignedlong): cint @{.extdecl,
    importc: "border_set", dynlib: pdcursesdll.@}
@example
proc border_set*(a2: ptr cunsignedlong; a3: ptr cunsignedlong; a4: ptr cunsignedlong;
                a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr cunsignedlong;
                a8: ptr cunsignedlong; a9: ptr cunsignedlong): cint @{.extdecl,
    importc: "border_set", dynlib: pdcursesdll.@}
@end example
  

@item box_set
  @findex proc box_set*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "box_set", dynlib꞉ pdcursesdll.@}
@example
proc box_set*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "box_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item echo_wchar
  @findex proc echo_wchar*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "echo_wchar",dynlib꞉ pdcursesdll.@}
@example
proc echo_wchar*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "echo_wchar",dynlib꞉ pdcursesdll.@}
@end example
  

@item erasewchar
  @findex proc erasewchar*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "erasewchar",dynlib꞉ pdcursesdll.@}
@example
proc erasewchar*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "erasewchar",dynlib꞉ pdcursesdll.@}
@end example
  

@item getbkgrnd
  @findex proc getbkgrnd*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "getbkgrnd",dynlib꞉ pdcursesdll.@}
@example
proc getbkgrnd*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "getbkgrnd",dynlib꞉ pdcursesdll.@}
@end example
  

@item getcchar
  @findex proc getcchar*(a2꞉ ptr cunsignedlong; a3꞉ cstring; a4꞉ ptr cunsignedlong; a5꞉ ptr cshort;a6꞉ pointer)꞉ cint @{.extdecl, importc꞉ "getcchar", dynlib꞉ pdcursesdll.@}
@example
proc getcchar*(a2꞉ ptr cunsignedlong; a3꞉ cstring; a4꞉ ptr cunsignedlong; a5꞉ ptr cshort;a6꞉ pointer)꞉ cint @{.extdecl, importc꞉ "getcchar", dynlib꞉ pdcursesdll.@}
@end example
  

@item getn_wstr
  @findex proc getn_wstr*(a2꞉ ptr cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "getn_wstr",dynlib꞉ pdcursesdll.@}
@example
proc getn_wstr*(a2꞉ ptr cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "getn_wstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item get_wch
  @findex proc get_wch*(a2꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "get_wch", dynlib꞉ pdcursesdll.@}
@example
proc get_wch*(a2꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "get_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item get_wstr
  @findex proc get_wstr*(a2꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "get_wstr", dynlib꞉ pdcursesdll.@}
@example
proc get_wstr*(a2꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "get_wstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item hline_set
  @findex proc hline_set*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "hline_set",dynlib꞉ pdcursesdll.@}
@example
proc hline_set*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "hline_set",dynlib꞉ pdcursesdll.@}
@end example
  

@item innwstr
  @findex proc innwstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "innwstr",dynlib꞉ pdcursesdll.@}
@example
proc innwstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "innwstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item ins_nwstr
  @findex proc ins_nwstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "ins_nwstr",dynlib꞉ pdcursesdll.@}
@example
proc ins_nwstr*(a2꞉ cstring; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "ins_nwstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item ins_wch
  @findex proc ins_wch*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "ins_wch",dynlib꞉ pdcursesdll.@}
@example
proc ins_wch*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "ins_wch",dynlib꞉ pdcursesdll.@}
@end example
  

@item ins_wstr
  @findex proc ins_wstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "ins_wstr", dynlib꞉ pdcursesdll.@}
@example
proc ins_wstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "ins_wstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item inwstr
  @findex proc inwstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "inwstr", dynlib꞉ pdcursesdll.@}
@example
proc inwstr*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "inwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item in_wch
  @findex proc in_wch*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "in_wch",dynlib꞉ pdcursesdll.@}
@example
proc in_wch*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "in_wch",dynlib꞉ pdcursesdll.@}
@end example
  

@item in_wchnstr
  @findex proc in_wchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl,importc꞉ "in_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc in_wchnstr*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl,importc꞉ "in_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item in_wchstr
  @findex proc in_wchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "in_wchstr",dynlib꞉ pdcursesdll.@}
@example
proc in_wchstr*(a2꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "in_wchstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item key_name
  @findex proc key_name*(a2꞉ char)꞉ cstring @{.extdecl, importc꞉ "key_name", dynlib꞉ pdcursesdll.@}
@example
proc key_name*(a2꞉ char)꞉ cstring @{.extdecl, importc꞉ "key_name", dynlib꞉ pdcursesdll.@}
@end example
  

@item killwchar
  @findex proc killwchar*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "killwchar", dynlib꞉ pdcursesdll.@}
@example
proc killwchar*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "killwchar", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddnwstr
  @findex proc mvaddnwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvaddnwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvaddnwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvaddnwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddwstr
  @findex proc mvaddwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvaddwstr",dynlib꞉ pdcursesdll.@}
@example
proc mvaddwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvaddwstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvadd_wch
  @findex proc mvadd_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvadd_wch", dynlib꞉ pdcursesdll.@}
@example
proc mvadd_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvadd_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvadd_wchnstr
  @findex proc mvadd_wchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvadd_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvadd_wchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvadd_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvadd_wchstr
  @findex proc mvadd_wchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvadd_wchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvadd_wchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvadd_wchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvgetn_wstr
  @findex proc mvgetn_wstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cint; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvgetn_wstr", dynlib꞉ pdcursesdll.@}
@example
proc mvgetn_wstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cint; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvgetn_wstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvget_wch
  @findex proc mvget_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "mvget_wch",dynlib꞉ pdcursesdll.@}
@example
proc mvget_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "mvget_wch",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvget_wstr
  @findex proc mvget_wstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "mvget_wstr",dynlib꞉ pdcursesdll.@}
@example
proc mvget_wstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "mvget_wstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvhline_set
  @findex proc mvhline_set*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvhline_set", dynlib꞉ pdcursesdll.@}
@example
proc mvhline_set*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvhline_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinnwstr
  @findex proc mvinnwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinnwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvinnwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvinnwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvins_nwstr
  @findex proc mvins_nwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvins_nwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvins_nwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvins_nwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvins_wch
  @findex proc mvins_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvins_wch", dynlib꞉ pdcursesdll.@}
@example
proc mvins_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvins_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvins_wstr
  @findex proc mvins_wstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvins_wstr",dynlib꞉ pdcursesdll.@}
@example
proc mvins_wstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvins_wstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinwstr
  @findex proc mvinwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvinwstr",dynlib꞉ pdcursesdll.@}
@example
proc mvinwstr*(a2꞉ cint; a3꞉ cint; a4꞉ cstring)꞉ cint @{.extdecl, importc꞉ "mvinwstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvin_wch
  @findex proc mvin_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvin_wch", dynlib꞉ pdcursesdll.@}
@example
proc mvin_wch*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvin_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvin_wchnstr
  @findex proc mvin_wchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvin_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvin_wchnstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvin_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvin_wchstr
  @findex proc mvin_wchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvin_wchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvin_wchstr*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvin_wchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvvline_set
  @findex proc mvvline_set*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvvline_set", dynlib꞉ pdcursesdll.@}
@example
proc mvvline_set*(a2꞉ cint; a3꞉ cint; a4꞉ ptr cunsignedlong; a5꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvvline_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddnwstr
  @findex proc mvwaddnwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwaddnwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddnwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwaddnwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddwstr
  @findex proc mvwaddwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwaddwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwaddwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwadd_wch
  @findex proc mvwadd_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwadd_wch", dynlib꞉ pdcursesdll.@}
@example
proc mvwadd_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwadd_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwadd_wchnstr
  @findex proc mvwadd_wchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwadd_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwadd_wchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwadd_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwadd_wchstr
  @findex proc mvwadd_wchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvwadd_wchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwadd_wchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvwadd_wchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwgetn_wstr
  @findex proc mvwgetn_wstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cint; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwgetn_wstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwgetn_wstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cint; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwgetn_wstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwget_wch
  @findex proc mvwget_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "mvwget_wch", dynlib꞉ pdcursesdll.@}
@example
proc mvwget_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "mvwget_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwget_wstr
  @findex proc mvwget_wstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "mvwget_wstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwget_wstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "mvwget_wstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwhline_set
  @findex proc mvwhline_set*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwhline_set", dynlib꞉ pdcursesdll.@}
@example
proc mvwhline_set*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwhline_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinnwstr
  @findex proc mvwinnwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinnwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinnwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinnwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwins_nwstr
  @findex proc mvwins_nwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwins_nwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwins_nwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwins_nwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwins_wch
  @findex proc mvwins_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwins_wch", dynlib꞉ pdcursesdll.@}
@example
proc mvwins_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwins_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwins_wstr
  @findex proc mvwins_wstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwins_wstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwins_wstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwins_wstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwin_wch
  @findex proc mvwin_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwin_wch", dynlib꞉ pdcursesdll.@}
@example
proc mvwin_wch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwin_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwin_wchnstr
  @findex proc mvwin_wchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwin_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwin_wchnstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwin_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwin_wchstr
  @findex proc mvwin_wchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvwin_wchstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwin_wchstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mvwin_wchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinwstr
  @findex proc mvwinwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwinwstr", dynlib꞉ pdcursesdll.@}
@example
proc mvwinwstr*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cstring)꞉ cint @{.extdecl,importc꞉ "mvwinwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwvline_set
  @findex proc mvwvline_set*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwvline_set", dynlib꞉ pdcursesdll.@}
@example
proc mvwvline_set*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ ptr cunsignedlong; a6꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvwvline_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item pecho_wchar
  @findex proc pecho_wchar*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "pecho_wchar", dynlib꞉ pdcursesdll.@}
@example
proc pecho_wchar*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "pecho_wchar", dynlib꞉ pdcursesdll.@}
@end example
  

@item setcchar
  @findex proc setcchar*(a2꞉ ptr cunsignedlong; a3꞉ cstring; a4꞉ cunsignedlong; a5꞉ cshort;a6꞉ pointer)꞉ cint @{.extdecl, importc꞉ "setcchar", dynlib꞉ pdcursesdll.@}
@example
proc setcchar*(a2꞉ ptr cunsignedlong; a3꞉ cstring; a4꞉ cunsignedlong; a5꞉ cshort;a6꞉ pointer)꞉ cint @{.extdecl, importc꞉ "setcchar", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_wset
  @findex proc slk_wset*(a2꞉ cint; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "slk_wset",dynlib꞉ pdcursesdll.@}
@example
proc slk_wset*(a2꞉ cint; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "slk_wset",dynlib꞉ pdcursesdll.@}
@end example
  

@item unget_wch
  @findex proc unget_wch*(a2꞉ char)꞉ cint @{.extdecl, importc꞉ "unget_wch", dynlib꞉ pdcursesdll.@}
@example
proc unget_wch*(a2꞉ char)꞉ cint @{.extdecl, importc꞉ "unget_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item vline_set
  @findex proc vline_set*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "vline_set",dynlib꞉ pdcursesdll.@}
@example
proc vline_set*(a2꞉ ptr cunsignedlong; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "vline_set",dynlib꞉ pdcursesdll.@}
@end example
  

@item waddnwstr
  @findex proc waddnwstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "waddnwstr", dynlib꞉ pdcursesdll.@}
@example
proc waddnwstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "waddnwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item waddwstr
  @findex proc waddwstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "waddwstr",dynlib꞉ pdcursesdll.@}
@example
proc waddwstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "waddwstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item wadd_wch
  @findex proc wadd_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wadd_wch", dynlib꞉ pdcursesdll.@}
@example
proc wadd_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wadd_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item wadd_wchnstr
  @findex proc wadd_wchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wadd_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc wadd_wchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wadd_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item wadd_wchstr
  @findex proc wadd_wchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wadd_wchstr", dynlib꞉ pdcursesdll.@}
@example
proc wadd_wchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wadd_wchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item wbkgrnd
  @findex proc wbkgrnd*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wbkgrnd",dynlib꞉ pdcursesdll.@}
@example
proc wbkgrnd*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "wbkgrnd",dynlib꞉ pdcursesdll.@}
@end example
  

@item wbkgrndset
  @findex proc wbkgrndset*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong) @{.extdecl,importc꞉ "wbkgrndset", dynlib꞉ pdcursesdll.@}
@example
proc wbkgrndset*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong) @{.extdecl,importc꞉ "wbkgrndset", dynlib꞉ pdcursesdll.@}
@end example
  

@item wborder_set
  @findex proc wborder_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong;
                 a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr cunsignedlong;
                 a8: ptr cunsignedlong; a9: ptr cunsignedlong; a10: ptr cunsignedlong): cint @{.
    extdecl, importc: "wborder_set", dynlib: pdcursesdll.@}
@example
proc wborder_set*(a2: ptr WINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong;
                 a5: ptr cunsignedlong; a6: ptr cunsignedlong; a7: ptr cunsignedlong;
                 a8: ptr cunsignedlong; a9: ptr cunsignedlong; a10: ptr cunsignedlong): cint @{.
    extdecl, importc: "wborder_set", dynlib: pdcursesdll.@}
@end example
  

@item wecho_wchar
  @findex proc wecho_wchar*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wecho_wchar", dynlib꞉ pdcursesdll.@}
@example
proc wecho_wchar*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wecho_wchar", dynlib꞉ pdcursesdll.@}
@end example
  

@item wgetbkgrnd
  @findex proc wgetbkgrnd*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wgetbkgrnd", dynlib꞉ pdcursesdll.@}
@example
proc wgetbkgrnd*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wgetbkgrnd", dynlib꞉ pdcursesdll.@}
@end example
  

@item wgetn_wstr
  @findex proc wgetn_wstr*(a2꞉ ptr WINDOW; a3꞉ ptr cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wgetn_wstr", dynlib꞉ pdcursesdll.@}
@example
proc wgetn_wstr*(a2꞉ ptr WINDOW; a3꞉ ptr cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wgetn_wstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item wget_wch
  @findex proc wget_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "wget_wch",dynlib꞉ pdcursesdll.@}
@example
proc wget_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "wget_wch",dynlib꞉ pdcursesdll.@}
@end example
  

@item wget_wstr
  @findex proc wget_wstr*(a2꞉ ptr WINDOW; a3꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "wget_wstr",dynlib꞉ pdcursesdll.@}
@example
proc wget_wstr*(a2꞉ ptr WINDOW; a3꞉ ptr cint)꞉ cint @{.extdecl, importc꞉ "wget_wstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item whline_set
  @findex proc whline_set*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "whline_set", dynlib꞉ pdcursesdll.@}
@example
proc whline_set*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "whline_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item winnwstr
  @findex proc winnwstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "winnwstr", dynlib꞉ pdcursesdll.@}
@example
proc winnwstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "winnwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item wins_nwstr
  @findex proc wins_nwstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wins_nwstr", dynlib꞉ pdcursesdll.@}
@example
proc wins_nwstr*(a2꞉ ptr WINDOW; a3꞉ cstring; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wins_nwstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item wins_wch
  @findex proc wins_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wins_wch", dynlib꞉ pdcursesdll.@}
@example
proc wins_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "wins_wch", dynlib꞉ pdcursesdll.@}
@end example
  

@item wins_wstr
  @findex proc wins_wstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "wins_wstr",dynlib꞉ pdcursesdll.@}
@example
proc wins_wstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "wins_wstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item winwstr
  @findex proc winwstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "winwstr",dynlib꞉ pdcursesdll.@}
@example
proc winwstr*(a2꞉ ptr WINDOW; a3꞉ cstring)꞉ cint @{.extdecl, importc꞉ "winwstr",dynlib꞉ pdcursesdll.@}
@end example
  

@item win_wch
  @findex proc win_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "win_wch",dynlib꞉ pdcursesdll.@}
@example
proc win_wch*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl, importc꞉ "win_wch",dynlib꞉ pdcursesdll.@}
@end example
  

@item win_wchnstr
  @findex proc win_wchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "win_wchnstr", dynlib꞉ pdcursesdll.@}
@example
proc win_wchnstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "win_wchnstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item win_wchstr
  @findex proc win_wchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "win_wchstr", dynlib꞉ pdcursesdll.@}
@example
proc win_wchstr*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong)꞉ cint @{.extdecl,importc꞉ "win_wchstr", dynlib꞉ pdcursesdll.@}
@end example
  

@item wunctrl
  @findex proc wunctrl*(a2꞉ ptr cunsignedlong)꞉ cstring @{.extdecl, importc꞉ "wunctrl",dynlib꞉ pdcursesdll.@}
@example
proc wunctrl*(a2꞉ ptr cunsignedlong)꞉ cstring @{.extdecl, importc꞉ "wunctrl",dynlib꞉ pdcursesdll.@}
@end example
  

@item wvline_set
  @findex proc wvline_set*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wvline_set", dynlib꞉ pdcursesdll.@}
@example
proc wvline_set*(a2꞉ ptr WINDOW; a3꞉ ptr cunsignedlong; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "wvline_set", dynlib꞉ pdcursesdll.@}
@end example
  

@item getattrs
  @findex proc getattrs*(a2꞉ ptr WINDOW)꞉ cunsignedlong @{.extdecl, importc꞉ "getattrs",dynlib꞉ pdcursesdll.@}
@example
proc getattrs*(a2꞉ ptr WINDOW)꞉ cunsignedlong @{.extdecl, importc꞉ "getattrs",dynlib꞉ pdcursesdll.@}
@end example
  

@item getbegx
  @findex proc getbegx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getbegx", dynlib꞉ pdcursesdll.@}
@example
proc getbegx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getbegx", dynlib꞉ pdcursesdll.@}
@end example
  

@item getbegy
  @findex proc getbegy*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getbegy", dynlib꞉ pdcursesdll.@}
@example
proc getbegy*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getbegy", dynlib꞉ pdcursesdll.@}
@end example
  

@item getmaxx
  @findex proc getmaxx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getmaxx", dynlib꞉ pdcursesdll.@}
@example
proc getmaxx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getmaxx", dynlib꞉ pdcursesdll.@}
@end example
  

@item getmaxy
  @findex proc getmaxy*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getmaxy", dynlib꞉ pdcursesdll.@}
@example
proc getmaxy*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getmaxy", dynlib꞉ pdcursesdll.@}
@end example
  

@item getparx
  @findex proc getparx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getparx", dynlib꞉ pdcursesdll.@}
@example
proc getparx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getparx", dynlib꞉ pdcursesdll.@}
@end example
  

@item getpary
  @findex proc getpary*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getpary", dynlib꞉ pdcursesdll.@}
@example
proc getpary*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getpary", dynlib꞉ pdcursesdll.@}
@end example
  

@item getcurx
  @findex proc getcurx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getcurx", dynlib꞉ pdcursesdll.@}
@example
proc getcurx*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getcurx", dynlib꞉ pdcursesdll.@}
@end example
  

@item getcury
  @findex proc getcury*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getcury", dynlib꞉ pdcursesdll.@}
@example
proc getcury*(a2꞉ ptr WINDOW)꞉ cint @{.extdecl, importc꞉ "getcury", dynlib꞉ pdcursesdll.@}
@end example
  

@item traceoff
  @findex proc traceoff*() @{.extdecl, importc꞉ "traceoff", dynlib꞉ pdcursesdll.@}
@example
proc traceoff*() @{.extdecl, importc꞉ "traceoff", dynlib꞉ pdcursesdll.@}
@end example
  

@item traceon
  @findex proc traceon*() @{.extdecl, importc꞉ "traceon", dynlib꞉ pdcursesdll.@}
@example
proc traceon*() @{.extdecl, importc꞉ "traceon", dynlib꞉ pdcursesdll.@}
@end example
  

@item unctrl
  @findex proc unctrl*(a2꞉ cunsignedlong)꞉ cstring @{.extdecl, importc꞉ "unctrl",dynlib꞉ pdcursesdll.@}
@example
proc unctrl*(a2꞉ cunsignedlong)꞉ cstring @{.extdecl, importc꞉ "unctrl",dynlib꞉ pdcursesdll.@}
@end example
  

@item crmode
  @findex proc crmode*()꞉ cint @{.extdecl, importc꞉ "crmode", dynlib꞉ pdcursesdll.@}
@example
proc crmode*()꞉ cint @{.extdecl, importc꞉ "crmode", dynlib꞉ pdcursesdll.@}
@end example
  

@item nocrmode
  @findex proc nocrmode*()꞉ cint @{.extdecl, importc꞉ "nocrmode", dynlib꞉ pdcursesdll.@}
@example
proc nocrmode*()꞉ cint @{.extdecl, importc꞉ "nocrmode", dynlib꞉ pdcursesdll.@}
@end example
  

@item draino
  @findex proc draino*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "draino", dynlib꞉ pdcursesdll.@}
@example
proc draino*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "draino", dynlib꞉ pdcursesdll.@}
@end example
  

@item resetterm
  @findex proc resetterm*()꞉ cint @{.extdecl, importc꞉ "resetterm", dynlib꞉ pdcursesdll.@}
@example
proc resetterm*()꞉ cint @{.extdecl, importc꞉ "resetterm", dynlib꞉ pdcursesdll.@}
@end example
  

@item fixterm
  @findex proc fixterm*()꞉ cint @{.extdecl, importc꞉ "fixterm", dynlib꞉ pdcursesdll.@}
@example
proc fixterm*()꞉ cint @{.extdecl, importc꞉ "fixterm", dynlib꞉ pdcursesdll.@}
@end example
  

@item saveterm
  @findex proc saveterm*()꞉ cint @{.extdecl, importc꞉ "saveterm", dynlib꞉ pdcursesdll.@}
@example
proc saveterm*()꞉ cint @{.extdecl, importc꞉ "saveterm", dynlib꞉ pdcursesdll.@}
@end example
  

@item setsyx
  @findex proc setsyx*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "setsyx", dynlib꞉ pdcursesdll.@}
@example
proc setsyx*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "setsyx", dynlib꞉ pdcursesdll.@}
@end example
  

@item mouse_set
  @findex proc mouse_set*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mouse_set",dynlib꞉ pdcursesdll.@}
@example
proc mouse_set*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mouse_set",dynlib꞉ pdcursesdll.@}
@end example
  

@item mouse_on
  @findex proc mouse_on*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mouse_on",dynlib꞉ pdcursesdll.@}
@example
proc mouse_on*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mouse_on",dynlib꞉ pdcursesdll.@}
@end example
  

@item mouse_off
  @findex proc mouse_off*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mouse_off",dynlib꞉ pdcursesdll.@}
@example
proc mouse_off*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "mouse_off",dynlib꞉ pdcursesdll.@}
@end example
  

@item request_mouse_pos
  @findex proc request_mouse_pos*()꞉ cint @{.extdecl, importc꞉ "request_mouse_pos",dynlib꞉ pdcursesdll.@}
@example
proc request_mouse_pos*()꞉ cint @{.extdecl, importc꞉ "request_mouse_pos",dynlib꞉ pdcursesdll.@}
@end example
  

@item map_button
  @findex proc map_button*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "map_button",dynlib꞉ pdcursesdll.@}
@example
proc map_button*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "map_button",dynlib꞉ pdcursesdll.@}
@end example
  

@item wmouse_position
  @findex proc wmouse_position*(a2꞉ ptr WINDOW; a3꞉ ptr cint; a4꞉ ptr cint) @{.extdecl,importc꞉ "wmouse_position", dynlib꞉ pdcursesdll.@}
@example
proc wmouse_position*(a2꞉ ptr WINDOW; a3꞉ ptr cint; a4꞉ ptr cint) @{.extdecl,importc꞉ "wmouse_position", dynlib꞉ pdcursesdll.@}
@end example
  

@item getmouse
  @findex proc getmouse*()꞉ cunsignedlong @{.extdecl, importc꞉ "getmouse", dynlib꞉ pdcursesdll.@}
@example
proc getmouse*()꞉ cunsignedlong @{.extdecl, importc꞉ "getmouse", dynlib꞉ pdcursesdll.@}
@end example
  

@item getbmap
  @findex proc getbmap*()꞉ cunsignedlong @{.extdecl, importc꞉ "getbmap", dynlib꞉ pdcursesdll.@}
@example
proc getbmap*()꞉ cunsignedlong @{.extdecl, importc꞉ "getbmap", dynlib꞉ pdcursesdll.@}
@end example
  

@item assume_default_colors
  @findex proc assume_default_colors*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl,importc꞉ "assume_default_colors", dynlib꞉ pdcursesdll.@}
@example
proc assume_default_colors*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl,importc꞉ "assume_default_colors", dynlib꞉ pdcursesdll.@}
@end example
  

@item curses_version
  @findex proc curses_version*()꞉ cstring @{.extdecl, importc꞉ "curses_version",dynlib꞉ pdcursesdll.@}
@example
proc curses_version*()꞉ cstring @{.extdecl, importc꞉ "curses_version",dynlib꞉ pdcursesdll.@}
@end example
  

@item has_key
  @findex proc has_key*(a2꞉ cint)꞉ cunsignedchar @{.extdecl, importc꞉ "has_key",dynlib꞉ pdcursesdll.@}
@example
proc has_key*(a2꞉ cint)꞉ cunsignedchar @{.extdecl, importc꞉ "has_key",dynlib꞉ pdcursesdll.@}
@end example
  

@item use_default_colors
  @findex proc use_default_colors*()꞉ cint @{.extdecl, importc꞉ "use_default_colors",dynlib꞉ pdcursesdll.@}
@example
proc use_default_colors*()꞉ cint @{.extdecl, importc꞉ "use_default_colors",dynlib꞉ pdcursesdll.@}
@end example
  

@item wresize
  @findex proc wresize*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "wresize",dynlib꞉ pdcursesdll.@}
@example
proc wresize*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "wresize",dynlib꞉ pdcursesdll.@}
@end example
  

@item mouseinterval
  @findex proc mouseinterval*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "mouseinterval",dynlib꞉ pdcursesdll.@}
@example
proc mouseinterval*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "mouseinterval",dynlib꞉ pdcursesdll.@}
@end example
  

@item mousemask
  @findex proc mousemask*(a2꞉ cunsignedlong; a3꞉ ptr cunsignedlong)꞉ cunsignedlong @{.extdecl,importc꞉ "mousemask", dynlib꞉ pdcursesdll.@}
@example
proc mousemask*(a2꞉ cunsignedlong; a3꞉ ptr cunsignedlong)꞉ cunsignedlong @{.extdecl,importc꞉ "mousemask", dynlib꞉ pdcursesdll.@}
@end example
  

@item mouse_trafo
  @findex proc mouse_trafo*(a2꞉ ptr cint; a3꞉ ptr cint; a4꞉ cunsignedchar)꞉ cunsignedchar @{.extdecl,importc꞉ "mouse_trafo", dynlib꞉ pdcursesdll.@}
@example
proc mouse_trafo*(a2꞉ ptr cint; a3꞉ ptr cint; a4꞉ cunsignedchar)꞉ cunsignedchar @{.extdecl,importc꞉ "mouse_trafo", dynlib꞉ pdcursesdll.@}
@end example
  

@item nc_getmouse
  @findex proc nc_getmouse*(a2꞉ ptr MEVENT)꞉ cint @{.extdecl, importc꞉ "nc_getmouse",dynlib꞉ pdcursesdll.@}
@example
proc nc_getmouse*(a2꞉ ptr MEVENT)꞉ cint @{.extdecl, importc꞉ "nc_getmouse",dynlib꞉ pdcursesdll.@}
@end example
  

@item ungetmouse
  @findex proc ungetmouse*(a2꞉ ptr MEVENT)꞉ cint @{.extdecl, importc꞉ "ungetmouse",dynlib꞉ pdcursesdll.@}
@example
proc ungetmouse*(a2꞉ ptr MEVENT)꞉ cint @{.extdecl, importc꞉ "ungetmouse",dynlib꞉ pdcursesdll.@}
@end example
  

@item wenclose
  @findex proc wenclose*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cunsignedchar @{.extdecl,importc꞉ "wenclose", dynlib꞉ pdcursesdll.@}
@example
proc wenclose*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cunsignedchar @{.extdecl,importc꞉ "wenclose", dynlib꞉ pdcursesdll.@}
@end example
  

@item wmouse_trafo
  @findex proc wmouse_trafo*(a2꞉ ptr WINDOW; a3꞉ ptr cint; a4꞉ ptr cint; a5꞉ cunsignedchar)꞉ cunsignedchar @{.extdecl, importc꞉ "wmouse_trafo", dynlib꞉ pdcursesdll.@}
@example
proc wmouse_trafo*(a2꞉ ptr WINDOW; a3꞉ ptr cint; a4꞉ ptr cint; a5꞉ cunsignedchar)꞉ cunsignedchar @{.extdecl, importc꞉ "wmouse_trafo", dynlib꞉ pdcursesdll.@}
@end example
  

@item addrawch
  @findex proc addrawch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "addrawch",dynlib꞉ pdcursesdll.@}
@example
proc addrawch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "addrawch",dynlib꞉ pdcursesdll.@}
@end example
  

@item insrawch
  @findex proc insrawch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "insrawch",dynlib꞉ pdcursesdll.@}
@example
proc insrawch*(a2꞉ cunsignedlong)꞉ cint @{.extdecl, importc꞉ "insrawch",dynlib꞉ pdcursesdll.@}
@end example
  

@item is_termresized
  @findex proc is_termresized*()꞉ cunsignedchar @{.extdecl, importc꞉ "is_termresized",dynlib꞉ pdcursesdll.@}
@example
proc is_termresized*()꞉ cunsignedchar @{.extdecl, importc꞉ "is_termresized",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvaddrawch
  @findex proc mvaddrawch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvaddrawch", dynlib꞉ pdcursesdll.@}
@example
proc mvaddrawch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvaddrawch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvdeleteln
  @findex proc mvdeleteln*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvdeleteln",dynlib꞉ pdcursesdll.@}
@example
proc mvdeleteln*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvdeleteln",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinsertln
  @findex proc mvinsertln*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvinsertln",dynlib꞉ pdcursesdll.@}
@example
proc mvinsertln*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "mvinsertln",dynlib꞉ pdcursesdll.@}
@end example
  

@item mvinsrawch
  @findex proc mvinsrawch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvinsrawch", dynlib꞉ pdcursesdll.@}
@example
proc mvinsrawch*(a2꞉ cint; a3꞉ cint; a4꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvinsrawch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwaddrawch
  @findex proc mvwaddrawch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwaddrawch", dynlib꞉ pdcursesdll.@}
@example
proc mvwaddrawch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwaddrawch", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwdeleteln
  @findex proc mvwdeleteln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwdeleteln", dynlib꞉ pdcursesdll.@}
@example
proc mvwdeleteln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwdeleteln", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinsertln
  @findex proc mvwinsertln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinsertln", dynlib꞉ pdcursesdll.@}
@example
proc mvwinsertln*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl,importc꞉ "mvwinsertln", dynlib꞉ pdcursesdll.@}
@end example
  

@item mvwinsrawch
  @findex proc mvwinsrawch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwinsrawch", dynlib꞉ pdcursesdll.@}
@example
proc mvwinsrawch*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint; a5꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "mvwinsrawch", dynlib꞉ pdcursesdll.@}
@end example
  

@item raw_output
  @findex proc raw_output*(a2꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "raw_output",dynlib꞉ pdcursesdll.@}
@example
proc raw_output*(a2꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "raw_output",dynlib꞉ pdcursesdll.@}
@end example
  

@item resize_term
  @findex proc resize_term*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "resize_term",dynlib꞉ pdcursesdll.@}
@example
proc resize_term*(a2꞉ cint; a3꞉ cint)꞉ cint @{.extdecl, importc꞉ "resize_term",dynlib꞉ pdcursesdll.@}
@end example
  

@item resize_window
  @findex proc resize_window*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "resize_window", dynlib꞉ pdcursesdll.@}
@example
proc resize_window*(a2꞉ ptr WINDOW; a3꞉ cint; a4꞉ cint)꞉ ptr WINDOW @{.extdecl,importc꞉ "resize_window", dynlib꞉ pdcursesdll.@}
@end example
  

@item waddrawch
  @findex proc waddrawch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "waddrawch", dynlib꞉ pdcursesdll.@}
@example
proc waddrawch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "waddrawch", dynlib꞉ pdcursesdll.@}
@end example
  

@item winsrawch
  @findex proc winsrawch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "winsrawch", dynlib꞉ pdcursesdll.@}
@example
proc winsrawch*(a2꞉ ptr WINDOW; a3꞉ cunsignedlong)꞉ cint @{.extdecl,importc꞉ "winsrawch", dynlib꞉ pdcursesdll.@}
@end example
  

@item wordchar
  @findex proc wordchar*()꞉ char @{.extdecl, importc꞉ "wordchar", dynlib꞉ pdcursesdll.@}
@example
proc wordchar*()꞉ char @{.extdecl, importc꞉ "wordchar", dynlib꞉ pdcursesdll.@}
@end example
  

@item slk_wlabel
  @findex proc slk_wlabel*(a2꞉ cint)꞉ cstring @{.extdecl, importc꞉ "slk_wlabel",dynlib꞉ pdcursesdll.@}
@example
proc slk_wlabel*(a2꞉ cint)꞉ cstring @{.extdecl, importc꞉ "slk_wlabel",dynlib꞉ pdcursesdll.@}
@end example
  

@item debug
  @findex proc debug*(a2꞉ cstring) @{.varargs, extdecl, importc꞉ "PDC_debug", dynlib꞉ pdcursesdll.@}
@example
proc debug*(a2꞉ cstring) @{.varargs, extdecl, importc꞉ "PDC_debug", dynlib꞉ pdcursesdll.@}
@end example
  

@item ungetch
  @findex proc ungetch*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "PDC_ungetch", dynlib꞉ pdcursesdll.@}
@example
proc ungetch*(a2꞉ cint)꞉ cint @{.extdecl, importc꞉ "PDC_ungetch", dynlib꞉ pdcursesdll.@}
@end example
  

@item set_blink
  @findex proc set_blink*(a2꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "PDC_set_blink",dynlib꞉ pdcursesdll.@}
@example
proc set_blink*(a2꞉ cunsignedchar)꞉ cint @{.extdecl, importc꞉ "PDC_set_blink",dynlib꞉ pdcursesdll.@}
@end example
  

@item set_line_color
  @findex proc set_line_color*(a2꞉ cshort)꞉ cint @{.extdecl, importc꞉ "PDC_set_line_color",dynlib꞉ pdcursesdll.@}
@example
proc set_line_color*(a2꞉ cshort)꞉ cint @{.extdecl, importc꞉ "PDC_set_line_color",dynlib꞉ pdcursesdll.@}
@end example
  

@item set_title
  @findex proc set_title*(a2꞉ cstring) @{.extdecl, importc꞉ "PDC_set_title", dynlib꞉ pdcursesdll.@}
@example
proc set_title*(a2꞉ cstring) @{.extdecl, importc꞉ "PDC_set_title", dynlib꞉ pdcursesdll.@}
@end example
  

@item clearclipboard
  @findex proc clearclipboard*()꞉ cint @{.extdecl, importc꞉ "PDC_clearclipboard",dynlib꞉ pdcursesdll.@}
@example
proc clearclipboard*()꞉ cint @{.extdecl, importc꞉ "PDC_clearclipboard",dynlib꞉ pdcursesdll.@}
@end example
  

@item freeclipboard
  @findex proc freeclipboard*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "PDC_freeclipboard",dynlib꞉ pdcursesdll.@}
@example
proc freeclipboard*(a2꞉ cstring)꞉ cint @{.extdecl, importc꞉ "PDC_freeclipboard",dynlib꞉ pdcursesdll.@}
@end example
  

@item getclipboard
  @findex proc getclipboard*(a2꞉ cstringArray; a3꞉ ptr clong)꞉ cint @{.extdecl,importc꞉ "PDC_getclipboard", dynlib꞉ pdcursesdll.@}
@example
proc getclipboard*(a2꞉ cstringArray; a3꞉ ptr clong)꞉ cint @{.extdecl,importc꞉ "PDC_getclipboard", dynlib꞉ pdcursesdll.@}
@end example
  

@item setclipboard
  @findex proc setclipboard*(a2꞉ cstring; a3꞉ clong)꞉ cint @{.extdecl,importc꞉ "PDC_setclipboard", dynlib꞉ pdcursesdll.@}
@example
proc setclipboard*(a2꞉ cstring; a3꞉ clong)꞉ cint @{.extdecl,importc꞉ "PDC_setclipboard", dynlib꞉ pdcursesdll.@}
@end example
  

@item get_input_fd
  @findex proc get_input_fd*()꞉ cunsignedlong @{.extdecl, importc꞉ "PDC_get_input_fd",dynlib꞉ pdcursesdll.@}
@example
proc get_input_fd*()꞉ cunsignedlong @{.extdecl, importc꞉ "PDC_get_input_fd",dynlib꞉ pdcursesdll.@}
@end example
  

@item get_key_modifiers
  @findex proc get_key_modifiers*()꞉ cunsignedlong @{.extdecl,importc꞉ "PDC_get_key_modifiers",dynlib꞉ pdcursesdll.@}
@example
proc get_key_modifiers*()꞉ cunsignedlong @{.extdecl,importc꞉ "PDC_get_key_modifiers",dynlib꞉ pdcursesdll.@}
@end example
  

@item return_key_modifiers
  @findex proc return_key_modifiers*(a2꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "PDC_return_key_modifiers", dynlib꞉ pdcursesdll.@}
@example
proc return_key_modifiers*(a2꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "PDC_return_key_modifiers", dynlib꞉ pdcursesdll.@}
@end example
  

@item save_key_modifiers
  @findex proc save_key_modifiers*(a2꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "PDC_save_key_modifiers", dynlib꞉ pdcursesdll.@}
@example
proc save_key_modifiers*(a2꞉ cunsignedchar)꞉ cint @{.extdecl,importc꞉ "PDC_save_key_modifiers", dynlib꞉ pdcursesdll.@}
@end example
  

@item bottom_panel
  @findex proc bottom_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "bottom_panel",dynlib꞉ pdcursesdll.@}
@example
proc bottom_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "bottom_panel",dynlib꞉ pdcursesdll.@}
@end example
  

@item del_panel
  @findex proc del_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "del_panel",dynlib꞉ pdcursesdll.@}
@example
proc del_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "del_panel",dynlib꞉ pdcursesdll.@}
@end example
  

@item hide_panel
  @findex proc hide_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "hide_panel",dynlib꞉ pdcursesdll.@}
@example
proc hide_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "hide_panel",dynlib꞉ pdcursesdll.@}
@end example
  

@item move_panel
  @findex proc move_panel*(pan꞉ ptr PANEL; starty꞉ cint; startx꞉ cint)꞉ cint @{.extdecl,importc꞉ "move_panel", dynlib꞉ pdcursesdll.@}
@example
proc move_panel*(pan꞉ ptr PANEL; starty꞉ cint; startx꞉ cint)꞉ cint @{.extdecl,importc꞉ "move_panel", dynlib꞉ pdcursesdll.@}
@end example
  

@item new_panel
  @findex proc new_panel*(win꞉ ptr WINDOW)꞉ ptr PANEL @{.extdecl, importc꞉ "new_panel",dynlib꞉ pdcursesdll.@}
@example
proc new_panel*(win꞉ ptr WINDOW)꞉ ptr PANEL @{.extdecl, importc꞉ "new_panel",dynlib꞉ pdcursesdll.@}
@end example
  

@item panel_above
  @findex proc panel_above*(pan꞉ ptr PANEL)꞉ ptr PANEL @{.extdecl, importc꞉ "panel_above",dynlib꞉ pdcursesdll.@}
@example
proc panel_above*(pan꞉ ptr PANEL)꞉ ptr PANEL @{.extdecl, importc꞉ "panel_above",dynlib꞉ pdcursesdll.@}
@end example
  

@item panel_below
  @findex proc panel_below*(pan꞉ ptr PANEL)꞉ ptr PANEL @{.extdecl, importc꞉ "panel_below",dynlib꞉ pdcursesdll.@}
@example
proc panel_below*(pan꞉ ptr PANEL)꞉ ptr PANEL @{.extdecl, importc꞉ "panel_below",dynlib꞉ pdcursesdll.@}
@end example
  

@item panel_hidden
  @findex proc panel_hidden*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "panel_hidden",dynlib꞉ pdcursesdll.@}
@example
proc panel_hidden*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "panel_hidden",dynlib꞉ pdcursesdll.@}
@end example
  

@item panel_userptr
  @findex proc panel_userptr*(pan꞉ ptr PANEL)꞉ pointer @{.extdecl, importc꞉ "panel_userptr",dynlib꞉ pdcursesdll.@}
@example
proc panel_userptr*(pan꞉ ptr PANEL)꞉ pointer @{.extdecl, importc꞉ "panel_userptr",dynlib꞉ pdcursesdll.@}
@end example
  

@item panel_window
  @findex proc panel_window*(pan꞉ ptr PANEL)꞉ ptr WINDOW @{.extdecl, importc꞉ "panel_window",dynlib꞉ pdcursesdll.@}
@example
proc panel_window*(pan꞉ ptr PANEL)꞉ ptr WINDOW @{.extdecl, importc꞉ "panel_window",dynlib꞉ pdcursesdll.@}
@end example
  

@item replace_panel
  @findex proc replace_panel*(pan꞉ ptr PANEL; win꞉ ptr WINDOW)꞉ cint @{.extdecl,importc꞉ "replace_panel", dynlib꞉ pdcursesdll.@}
@example
proc replace_panel*(pan꞉ ptr PANEL; win꞉ ptr WINDOW)꞉ cint @{.extdecl,importc꞉ "replace_panel", dynlib꞉ pdcursesdll.@}
@end example
  

@item set_panel_userptr
  @findex proc set_panel_userptr*(pan꞉ ptr PANEL; uptr꞉ pointer)꞉ cint @{.extdecl,importc꞉ "set_panel_userptr", dynlib꞉ pdcursesdll.@}
@example
proc set_panel_userptr*(pan꞉ ptr PANEL; uptr꞉ pointer)꞉ cint @{.extdecl,importc꞉ "set_panel_userptr", dynlib꞉ pdcursesdll.@}
@end example
  

@item show_panel
  @findex proc show_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "show_panel",dynlib꞉ pdcursesdll.@}
@example
proc show_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "show_panel",dynlib꞉ pdcursesdll.@}
@end example
  

@item top_panel
  @findex proc top_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "top_panel",dynlib꞉ pdcursesdll.@}
@example
proc top_panel*(pan꞉ ptr PANEL)꞉ cint @{.extdecl, importc꞉ "top_panel",dynlib꞉ pdcursesdll.@}
@end example
  

@item update_panels
  @findex proc update_panels*() @{.extdecl, importc꞉ "update_panels", dynlib꞉ pdcursesdll.@}
@example
proc update_panels*() @{.extdecl, importc꞉ "update_panels", dynlib꞉ pdcursesdll.@}
@end example
  

@item Xinitscr
  @findex proc Xinitscr*(a2꞉ cint; a3꞉ cstringArray)꞉ ptr WINDOW @{.extdecl, importc꞉ "Xinitscr",dynlib꞉ pdcursesdll.@}
@example
proc Xinitscr*(a2꞉ cint; a3꞉ cstringArray)꞉ ptr WINDOW @{.extdecl, importc꞉ "Xinitscr",dynlib꞉ pdcursesdll.@}
@end example
  

@item XCursesExit
  @findex proc XCursesExit*() @{.extdecl, importc꞉ "XCursesExit", dynlib꞉ pdcursesdll.@}
@example
proc XCursesExit*() @{.extdecl, importc꞉ "XCursesExit", dynlib꞉ pdcursesdll.@}
@end example
  

@item sb_init
  @findex proc sb_init*()꞉ cint @{.extdecl, importc꞉ "sb_init", dynlib꞉ pdcursesdll.@}
@example
proc sb_init*()꞉ cint @{.extdecl, importc꞉ "sb_init", dynlib꞉ pdcursesdll.@}
@end example
  

@item sb_set_horz
  @findex proc sb_set_horz*(a2꞉ cint; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "sb_set_horz",dynlib꞉ pdcursesdll.@}
@example
proc sb_set_horz*(a2꞉ cint; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "sb_set_horz",dynlib꞉ pdcursesdll.@}
@end example
  

@item sb_set_vert
  @findex proc sb_set_vert*(a2꞉ cint; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "sb_set_vert",dynlib꞉ pdcursesdll.@}
@example
proc sb_set_vert*(a2꞉ cint; a3꞉ cint; a4꞉ cint)꞉ cint @{.extdecl, importc꞉ "sb_set_vert",dynlib꞉ pdcursesdll.@}
@end example
  

@item sb_get_horz
  @findex proc sb_get_horz*(a2꞉ ptr cint; a3꞉ ptr cint; a4꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "sb_get_horz", dynlib꞉ pdcursesdll.@}
@example
proc sb_get_horz*(a2꞉ ptr cint; a3꞉ ptr cint; a4꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "sb_get_horz", dynlib꞉ pdcursesdll.@}
@end example
  

@item sb_get_vert
  @findex proc sb_get_vert*(a2꞉ ptr cint; a3꞉ ptr cint; a4꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "sb_get_vert", dynlib꞉ pdcursesdll.@}
@example
proc sb_get_vert*(a2꞉ ptr cint; a3꞉ ptr cint; a4꞉ ptr cint)꞉ cint @{.extdecl,importc꞉ "sb_get_vert", dynlib꞉ pdcursesdll.@}
@end example
  

@item sb_refresh
  @findex proc sb_refresh*()꞉ cint @{.extdecl, importc꞉ "sb_refresh", dynlib꞉ pdcursesdll.@}
@example
proc sb_refresh*()꞉ cint @{.extdecl, importc꞉ "sb_refresh", dynlib꞉ pdcursesdll.@}
@end example
  

@item get_buffer_rows
  @findex proc get_buffer_rows*()꞉ cint @{.extdecl, importc꞉ "PDC_get_buffer_rows",dynlib꞉ pdcursesdll.@}
@example
proc get_buffer_rows*()꞉ cint @{.extdecl, importc꞉ "PDC_get_buffer_rows",dynlib꞉ pdcursesdll.@}
@end example
  
@end itemize

@chapter Templates

@itemize


@item BUTTON_CHANGED
  @findex template BUTTON_CHANGED*(x꞉ expr)꞉ expr
@example
template BUTTON_CHANGED*(x꞉ expr)꞉ expr
@end example
  

@item BUTTON_STATUS
  @findex template BUTTON_STATUS*(x꞉ expr)꞉ expr
@example
template BUTTON_STATUS*(x꞉ expr)꞉ expr
@end example
  

@item ACS_PICK
  @findex template ACS_PICK*(w, n꞉ expr)꞉ expr
@example
template ACS_PICK*(w, n꞉ expr)꞉ expr
@end example
  

@item KEY_F
  @findex template KEY_F*(n꞉ expr)꞉ expr
@example
template KEY_F*(n꞉ expr)꞉ expr
@end example
  

@item COLOR_PAIR
  @findex template COLOR_PAIR*(n꞉ expr)꞉ expr
@example
template COLOR_PAIR*(n꞉ expr)꞉ expr
@end example
  

@item PAIR_NUMBER
  @findex template PAIR_NUMBER*(n꞉ expr)꞉ expr
@example
template PAIR_NUMBER*(n꞉ expr)꞉ expr
@end example
  

@item getch
  @findex template getch*()꞉ expr
@example
template getch*()꞉ expr
@end example
  

@item ungetch
  @findex template ungetch*(ch꞉ expr)꞉ expr
@example
template ungetch*(ch꞉ expr)꞉ expr
@end example
  

@item getbegyx
  @findex template getbegyx*(w, y, x꞉ expr)꞉ expr
@example
template getbegyx*(w, y, x꞉ expr)꞉ expr
@end example
  

@item getmaxyx
  @findex template getmaxyx*(w, y, x꞉ expr)꞉ expr
@example
template getmaxyx*(w, y, x꞉ expr)꞉ expr
@end example
  

@item getparyx
  @findex template getparyx*(w, y, x꞉ expr)꞉ expr
@example
template getparyx*(w, y, x꞉ expr)꞉ expr
@end example
  

@item getyx
  @findex template getyx*(w, y, x꞉ expr)꞉ expr
@example
template getyx*(w, y, x꞉ expr)꞉ expr
@end example
  

@item getsyx
  @findex template getsyx*(y, x꞉ expr)꞉ stmt
@example
template getsyx*(y, x꞉ expr)꞉ stmt
@end example
  

@item getmouse
  @findex template getmouse*(x꞉ expr)꞉ expr
@example
template getmouse*(x꞉ expr)꞉ expr
@end example
  
@end itemize





@node /wrappers/odbcsql, /wrappers/openssl , /wrappers/pdcurses, Top
@chapter Constant variables

@itemize


@item SQL_GUID
  @vindex SQL_GUID* = - 11
@example
SQL_GUID* = - 11
@end example
  

@item SQL_INTERVAL_MINUTE_TO_SECOND
  @vindex SQL_INTERVAL_MINUTE_TO_SECOND* = 100 + SQL_CODE_MINUTE_TO_SECOND
@example
SQL_INTERVAL_MINUTE_TO_SECOND* = 100 + SQL_CODE_MINUTE_TO_SECOND
@end example
  

@item SQL_UNICODE_CHAR
  @vindex SQL_UNICODE_CHAR* = SQL_UNICODE
@example
SQL_UNICODE_CHAR* = SQL_UNICODE
@end example
  

@item SQL_TYPE_NULL
  @vindex SQL_TYPE_NULL* = 0
@example
SQL_TYPE_NULL* = 0
@end example
  

@item SQL_TYPE_MAX
  @vindex SQL_TYPE_MAX* = SQL_VARCHAR
@example
SQL_TYPE_MAX* = SQL_VARCHAR
@end example
  

@item SQL_NO_TOTAL
  @vindex SQL_NO_TOTAL* = - 4
@example
SQL_NO_TOTAL* = - 4
@end example
  

@item SQL_COLUMN_ALIAS
  @vindex SQL_COLUMN_ALIAS* = 87
@example
SQL_COLUMN_ALIAS* = 87
@end example
  
@end itemize



@chapter Types

@itemize


@item PSQLHANDLE
  @tindex PSQLHANDLE* = ptr SqlHandle
@example
PSQLHANDLE* = ptr SqlHandle
@end example
  

@item PSQL_TIMESTAMP_STRUCT
  @tindex PSQL_TIMESTAMP_STRUCT* = ptr SQL_TIMESTAMP_STRUCT
@example
PSQL_TIMESTAMP_STRUCT* = ptr SQL_TIMESTAMP_STRUCT
@end example
  
@end itemize

@chapter Procedures

@itemize


@item SQLAllocHandle
  @findex proc SQLAllocHandle*(HandleType꞉ TSqlSmallInt; InputHandle꞉ SqlHandle;OutputHandlePtr꞉ var SqlHandle)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@example
proc SQLAllocHandle*(HandleType꞉ TSqlSmallInt; InputHandle꞉ SqlHandle;OutputHandlePtr꞉ var SqlHandle)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@end example
  

@item SQLSetEnvAttr
  @findex proc SQLSetEnvAttr*(EnvironmentHandle꞉ SqlHEnv; Attribute꞉ TSqlInteger;Value꞉ TSqlInteger; StringLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLSetEnvAttr*(EnvironmentHandle꞉ SqlHEnv; Attribute꞉ TSqlInteger;Value꞉ TSqlInteger; StringLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLGetEnvAttr
  @findex proc SQLGetEnvAttr*(EnvironmentHandle: SqlHEnv; Attribute: TSqlInteger;
                   Value: SqlPointer; BufferLength: TSqlInteger;
                   StringLength: PSQLINTEGER): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@example
proc SQLGetEnvAttr*(EnvironmentHandle: SqlHEnv; Attribute: TSqlInteger;
                   Value: SqlPointer; BufferLength: TSqlInteger;
                   StringLength: PSQLINTEGER): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@end example
  

@item SQLFreeHandle
  @findex proc SQLFreeHandle*(HandleType꞉ TSqlSmallInt; Handle꞉ SqlHandle)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLFreeHandle*(HandleType꞉ TSqlSmallInt; Handle꞉ SqlHandle)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLGetDiagRec
  @findex proc SQLGetDiagRec*(HandleType: TSqlSmallInt; Handle: SqlHandle;
                   RecNumber: TSqlSmallInt; Sqlstate: PSQLCHAR;
                   NativeError: var TSqlInteger; MessageText: PSQLCHAR;
                   BufferLength: TSqlSmallInt; TextLength: var TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLGetDiagRec*(HandleType: TSqlSmallInt; Handle: SqlHandle;
                   RecNumber: TSqlSmallInt; Sqlstate: PSQLCHAR;
                   NativeError: var TSqlInteger; MessageText: PSQLCHAR;
                   BufferLength: TSqlSmallInt; TextLength: var TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLGetDiagField
  @findex proc SQLGetDiagField*(HandleType: TSqlSmallInt; Handle: SqlHandle;
                     RecNumber: TSqlSmallInt; DiagIdentifier: TSqlSmallInt;
                     DiagInfoPtr: SqlPointer; BufferLength: TSqlSmallInt;
                     StringLengthPtr: var TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLGetDiagField*(HandleType: TSqlSmallInt; Handle: SqlHandle;
                     RecNumber: TSqlSmallInt; DiagIdentifier: TSqlSmallInt;
                     DiagInfoPtr: SqlPointer; BufferLength: TSqlSmallInt;
                     StringLengthPtr: var TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLConnect
  @findex proc SQLConnect*(ConnectionHandle: SqlHDBC; ServerName: PSQLCHAR;
                NameLength1: TSqlSmallInt; UserName: PSQLCHAR;
                NameLength2: TSqlSmallInt; Authentication: PSQLCHAR;
                NameLength3: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@example
proc SQLConnect*(ConnectionHandle: SqlHDBC; ServerName: PSQLCHAR;
                NameLength1: TSqlSmallInt; UserName: PSQLCHAR;
                NameLength2: TSqlSmallInt; Authentication: PSQLCHAR;
                NameLength3: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@end example
  

@item SQLDisconnect
  @findex proc SQLDisconnect*(ConnectionHandle꞉ SqlHDBC)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@example
proc SQLDisconnect*(ConnectionHandle꞉ SqlHDBC)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@end example
  

@item SQLDriverConnect
  @findex proc SQLDriverConnect*(hdbc: SqlHDBC; hwnd: SqlHWND; szCsin: cstring;
                      szCLen: TSqlSmallInt; szCsout: cstring; cbCSMax: TSqlSmallInt;
                      cbCsOut: var TSqlSmallInt; f: SqlUSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLDriverConnect*(hdbc: SqlHDBC; hwnd: SqlHWND; szCsin: cstring;
                      szCLen: TSqlSmallInt; szCsout: cstring; cbCSMax: TSqlSmallInt;
                      cbCsOut: var TSqlSmallInt; f: SqlUSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLBrowseConnect
  @findex proc SQLBrowseConnect*(hdbc: SqlHDBC; szConnStrIn: PSQLCHAR;
                      cbConnStrIn: TSqlSmallInt; szConnStrOut: PSQLCHAR;
                      cbConnStrOutMax: TSqlSmallInt;
                      cbConnStrOut: var TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLBrowseConnect*(hdbc: SqlHDBC; szConnStrIn: PSQLCHAR;
                      cbConnStrIn: TSqlSmallInt; szConnStrOut: PSQLCHAR;
                      cbConnStrOutMax: TSqlSmallInt;
                      cbConnStrOut: var TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLExecDirect
  @findex proc SQLExecDirect*(StatementHandle꞉ SqlHStmt; StatementText꞉ PSQLCHAR;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLExecDirect*(StatementHandle꞉ SqlHStmt; StatementText꞉ PSQLCHAR;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLExecDirectW
  @findex proc SQLExecDirectW*(StatementHandle꞉ SqlHStmt; StatementText꞉ WideCString;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLExecDirectW*(StatementHandle꞉ SqlHStmt; StatementText꞉ WideCString;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLPrepare
  @findex proc SQLPrepare*(StatementHandle꞉ SqlHStmt; StatementText꞉ PSQLCHAR;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLPrepare*(StatementHandle꞉ SqlHStmt; StatementText꞉ PSQLCHAR;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLPrepareW
  @findex proc SQLPrepareW*(StatementHandle꞉ SqlHStmt; StatementText꞉ WideCString;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLPrepareW*(StatementHandle꞉ SqlHStmt; StatementText꞉ WideCString;TextLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLCloseCursor
  @findex proc SQLCloseCursor*(StatementHandle꞉ SqlHStmt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@example
proc SQLCloseCursor*(StatementHandle꞉ SqlHStmt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@end example
  

@item SQLExecute
  @findex proc SQLExecute*(StatementHandle꞉ SqlHStmt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLExecute*(StatementHandle꞉ SqlHStmt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLFetch
  @findex proc SQLFetch*(StatementHandle꞉ SqlHStmt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLFetch*(StatementHandle꞉ SqlHStmt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLNumResultCols
  @findex proc SQLNumResultCols*(StatementHandle꞉ SqlHStmt; ColumnCount꞉ var TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLNumResultCols*(StatementHandle꞉ SqlHStmt; ColumnCount꞉ var TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLDescribeCol
  @findex proc SQLDescribeCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                    ColumnName: PSQLCHAR; BufferLength: TSqlSmallInt;
                    NameLength: var TSqlSmallInt; DataType: var TSqlSmallInt;
                    ColumnSize: var SqlUInteger; DecimalDigits: var TSqlSmallInt;
                    Nullable: var TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@example
proc SQLDescribeCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                    ColumnName: PSQLCHAR; BufferLength: TSqlSmallInt;
                    NameLength: var TSqlSmallInt; DataType: var TSqlSmallInt;
                    ColumnSize: var SqlUInteger; DecimalDigits: var TSqlSmallInt;
                    Nullable: var TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@end example
  

@item SQLFetchScroll
  @findex proc SQLFetchScroll*(StatementHandle꞉ SqlHStmt; FetchOrientation꞉ TSqlSmallInt;FetchOffset꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@example
proc SQLFetchScroll*(StatementHandle꞉ SqlHStmt; FetchOrientation꞉ TSqlSmallInt;FetchOffset꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@end example
  

@item SQLExtendedFetch
  @findex proc SQLExtendedFetch*(hstmt꞉ SqlHStmt; fFetchType꞉ SqlUSmallInt; irow꞉ TSqlInteger;pcrow꞉ PSQLUINTEGER; rgfRowStatus꞉ PSQLUSMALLINT)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLExtendedFetch*(hstmt꞉ SqlHStmt; fFetchType꞉ SqlUSmallInt; irow꞉ TSqlInteger;pcrow꞉ PSQLUINTEGER; rgfRowStatus꞉ PSQLUSMALLINT)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLGetData
  @findex proc SQLGetData*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                TargetType: TSqlSmallInt; TargetValue: SqlPointer;
                BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLGetData*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                TargetType: TSqlSmallInt; TargetValue: SqlPointer;
                BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLSetStmtAttr
  @findex proc SQLSetStmtAttr*(StatementHandle꞉ SqlHStmt; Attribute꞉ TSqlInteger;Value꞉ SqlPointer; StringLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLSetStmtAttr*(StatementHandle꞉ SqlHStmt; Attribute꞉ TSqlInteger;Value꞉ SqlPointer; StringLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLGetStmtAttr
  @findex proc SQLGetStmtAttr*(StatementHandle: SqlHStmt; Attribute: TSqlInteger;
                    Value: SqlPointer; BufferLength: TSqlInteger;
                    StringLength: PSQLINTEGER): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@example
proc SQLGetStmtAttr*(StatementHandle: SqlHStmt; Attribute: TSqlInteger;
                    Value: SqlPointer; BufferLength: TSqlInteger;
                    StringLength: PSQLINTEGER): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@end example
  

@item SQLGetInfo
  @findex proc SQLGetInfo*(ConnectionHandle꞉ SqlHDBC; InfoType꞉ SqlUSmallInt;InfoValue꞉ SqlPointer; BufferLength꞉ TSqlSmallInt;StringLength꞉ PSQLSMALLINT)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLGetInfo*(ConnectionHandle꞉ SqlHDBC; InfoType꞉ SqlUSmallInt;InfoValue꞉ SqlPointer; BufferLength꞉ TSqlSmallInt;StringLength꞉ PSQLSMALLINT)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLBulkOperations
  @findex proc SQLBulkOperations*(StatementHandle꞉ SqlHStmt; Operation꞉ TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLBulkOperations*(StatementHandle꞉ SqlHStmt; Operation꞉ TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLPutData
  @findex proc SQLPutData*(StatementHandle꞉ SqlHStmt; Data꞉ SqlPointer;StrLen_or_Ind꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLPutData*(StatementHandle꞉ SqlHStmt; Data꞉ SqlPointer;StrLen_or_Ind꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLBindCol
  @findex proc SQLBindCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                TargetType: TSqlSmallInt; TargetValue: SqlPointer;
                BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLBindCol*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                TargetType: TSqlSmallInt; TargetValue: SqlPointer;
                BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLSetPos
  @findex proc SQLSetPos*(hstmt꞉ SqlHStmt; irow꞉ SqlUSmallInt; fOption꞉ SqlUSmallInt;fLock꞉ SqlUSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLSetPos*(hstmt꞉ SqlHStmt; irow꞉ SqlUSmallInt; fOption꞉ SqlUSmallInt;fLock꞉ SqlUSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLDataSources
  @findex proc SQLDataSources*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;
                    ServerName: PSQLCHAR; BufferLength1: TSqlSmallInt;
                    NameLength1: PSQLSMALLINT; Description: PSQLCHAR;
                    BufferLength2: TSqlSmallInt; NameLength2: PSQLSMALLINT): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLDataSources*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;
                    ServerName: PSQLCHAR; BufferLength1: TSqlSmallInt;
                    NameLength1: PSQLSMALLINT; Description: PSQLCHAR;
                    BufferLength2: TSqlSmallInt; NameLength2: PSQLSMALLINT): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLDrivers
  @findex proc SQLDrivers*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;
                DriverDescription: PSQLCHAR; BufferLength1: TSqlSmallInt;
                DescriptionLength1: PSQLSMALLINT; DriverAttributes: PSQLCHAR;
                BufferLength2: TSqlSmallInt; AttributesLength2: PSQLSMALLINT): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLDrivers*(EnvironmentHandle: SqlHEnv; Direction: SqlUSmallInt;
                DriverDescription: PSQLCHAR; BufferLength1: TSqlSmallInt;
                DescriptionLength1: PSQLSMALLINT; DriverAttributes: PSQLCHAR;
                BufferLength2: TSqlSmallInt; AttributesLength2: PSQLSMALLINT): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLSetConnectAttr
  @findex proc SQLSetConnectAttr*(ConnectionHandle꞉ SqlHDBC; Attribute꞉ TSqlInteger;Value꞉ SqlPointer; StringLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLSetConnectAttr*(ConnectionHandle꞉ SqlHDBC; Attribute꞉ TSqlInteger;Value꞉ SqlPointer; StringLength꞉ TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLGetCursorName
  @findex proc SQLGetCursorName*(StatementHandle꞉ SqlHStmt; CursorName꞉ PSQLCHAR;BufferLength꞉ TSqlSmallInt; NameLength꞉ PSQLSMALLINT)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLGetCursorName*(StatementHandle꞉ SqlHStmt; CursorName꞉ PSQLCHAR;BufferLength꞉ TSqlSmallInt; NameLength꞉ PSQLSMALLINT)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLSetCursorName
  @findex proc SQLSetCursorName*(StatementHandle꞉ SqlHStmt; CursorName꞉ PSQLCHAR;NameLength꞉ TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@example
proc SQLSetCursorName*(StatementHandle꞉ SqlHStmt; CursorName꞉ PSQLCHAR;NameLength꞉ TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@end example
  

@item SQLRowCount
  @findex proc SQLRowCount*(StatementHandle꞉ SqlHStmt; RowCount꞉ var TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLRowCount*(StatementHandle꞉ SqlHStmt; RowCount꞉ var TSqlInteger)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLBindParameter
  @findex proc SQLBindParameter*(hstmt: SqlHStmt; ipar: SqlUSmallInt; fParamType: TSqlSmallInt;
                      fCType: TSqlSmallInt; fSqlType: TSqlSmallInt;
                      cbColDef: SqlUInteger; ibScale: TSqlSmallInt;
                      rgbValue: SqlPointer; cbValueMax: TSqlInteger;
                      pcbValue: PSQLINTEGER): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@example
proc SQLBindParameter*(hstmt: SqlHStmt; ipar: SqlUSmallInt; fParamType: TSqlSmallInt;
                      fCType: TSqlSmallInt; fSqlType: TSqlSmallInt;
                      cbColDef: SqlUInteger; ibScale: TSqlSmallInt;
                      rgbValue: SqlPointer; cbValueMax: TSqlInteger;
                      pcbValue: PSQLINTEGER): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@end example
  

@item SQLFreeStmt
  @findex proc SQLFreeStmt*(StatementHandle꞉ SqlHStmt; Option꞉ SqlUSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@example
proc SQLFreeStmt*(StatementHandle꞉ SqlHStmt; Option꞉ SqlUSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib, importc.@}
@end example
  

@item SQLColAttribute
  @findex proc SQLColAttribute*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                     FieldIdentifier: SqlUSmallInt; CharacterAttribute: PSQLCHAR;
                     BufferLength: TSqlSmallInt; StringLength: PSQLSMALLINT;
                     NumericAttribute: SqlPointer): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@example
proc SQLColAttribute*(StatementHandle: SqlHStmt; ColumnNumber: SqlUSmallInt;
                     FieldIdentifier: SqlUSmallInt; CharacterAttribute: PSQLCHAR;
                     BufferLength: TSqlSmallInt; StringLength: PSQLSMALLINT;
                     NumericAttribute: SqlPointer): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@end example
  

@item SQLEndTran
  @findex proc SQLEndTran*(HandleType꞉ TSqlSmallInt; Handle꞉ SqlHandle;CompletionType꞉ TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@example
proc SQLEndTran*(HandleType꞉ TSqlSmallInt; Handle꞉ SqlHandle;CompletionType꞉ TSqlSmallInt)꞉ TSqlSmallInt @{.dynlib꞉ odbclib,importc.@}
@end example
  

@item SQLTables
  @findex proc SQLTables*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
               cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
               cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
               cbTableName: TSqlSmallInt; szTableType: PSQLCHAR;
               cbTableType: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@example
proc SQLTables*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
               cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
               cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
               cbTableName: TSqlSmallInt; szTableType: PSQLCHAR;
               cbTableType: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@end example
  

@item SQLColumns
  @findex proc SQLColumns*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
                cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
                cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
                cbTableName: TSqlSmallInt; szColumnName: PSQLCHAR;
                cbColumnName: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@example
proc SQLColumns*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
                cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
                cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
                cbTableName: TSqlSmallInt; szColumnName: PSQLCHAR;
                cbColumnName: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@end example
  

@item SQLSpecialColumns
  @findex proc SQLSpecialColumns*(StatementHandle: SqlHStmt; IdentifierType: SqlUSmallInt;
                       CatalogName: PSQLCHAR; NameLength1: TSqlSmallInt;
                       SchemaName: PSQLCHAR; NameLength2: TSqlSmallInt;
                       TableName: PSQLCHAR; NameLength3: TSqlSmallInt;
                       Scope: SqlUSmallInt; Nullable: SqlUSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLSpecialColumns*(StatementHandle: SqlHStmt; IdentifierType: SqlUSmallInt;
                       CatalogName: PSQLCHAR; NameLength1: TSqlSmallInt;
                       SchemaName: PSQLCHAR; NameLength2: TSqlSmallInt;
                       TableName: PSQLCHAR; NameLength3: TSqlSmallInt;
                       Scope: SqlUSmallInt; Nullable: SqlUSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLProcedures
  @findex proc SQLProcedures*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
                   cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
                   cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
                   cbTableName: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@example
proc SQLProcedures*(hstmt: SqlHStmt; szTableQualifier: PSQLCHAR;
                   cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR;
                   cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR;
                   cbTableName: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@end example
  

@item SQLPrimaryKeys
  @findex proc SQLPrimaryKeys*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                    NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                    NameLength2: TSqlSmallInt; TableName: PSQLCHAR;
                    NameLength3: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@example
proc SQLPrimaryKeys*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                    NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                    NameLength2: TSqlSmallInt; TableName: PSQLCHAR;
                    NameLength3: TSqlSmallInt): TSqlSmallInt @{.dynlib: odbclib,
    importc.@}
@end example
  

@item SQLProcedureColumns
  @findex proc SQLProcedureColumns*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                         NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                         NameLength2: TSqlSmallInt; ProcName: PSQLCHAR;
                         NameLength3: TSqlSmallInt; ColumnName: PSQLCHAR;
                         NameLength4: TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@example
proc SQLProcedureColumns*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                         NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                         NameLength2: TSqlSmallInt; ProcName: PSQLCHAR;
                         NameLength3: TSqlSmallInt; ColumnName: PSQLCHAR;
                         NameLength4: TSqlSmallInt): TSqlSmallInt @{.
    dynlib: odbclib, importc.@}
@end example
  

@item SQLStatistics
  @findex proc SQLStatistics*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                   NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                   NameLength2: TSqlSmallInt; TableName: PSQLCHAR;
                   NameLength3: TSqlSmallInt; Unique: SqlUSmallInt;
                   Reserved: SqlUSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@example
proc SQLStatistics*(hstmt: SqlHStmt; CatalogName: PSQLCHAR;
                   NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR;
                   NameLength2: TSqlSmallInt; TableName: PSQLCHAR;
                   NameLength3: TSqlSmallInt; Unique: SqlUSmallInt;
                   Reserved: SqlUSmallInt): TSqlSmallInt @{.dynlib: odbclib, importc.@}
@end example
  

@item SQLErr
  @findex proc SQLErr*(henv: SqlHEnv; hdbc: SqlHDBC; hstmt: SqlHStmt;
            szSqlState, pfNativeError, szErrorMsg: PSQLCHAR;
            cbErrorMsgMax: TSqlSmallInt; pcbErrorMsg: PSQLINTEGER): TSqlSmallInt @{.
    dynlib: odbclib, importc: "SQLError".@}
@example
proc SQLErr*(henv: SqlHEnv; hdbc: SqlHDBC; hstmt: SqlHStmt;
            szSqlState, pfNativeError, szErrorMsg: PSQLCHAR;
            cbErrorMsgMax: TSqlSmallInt; pcbErrorMsg: PSQLINTEGER): TSqlSmallInt @{.
    dynlib: odbclib, importc: "SQLError".@}
@end example
  
@end itemize






@node /wrappers/openssl, /wrappers/iup , /wrappers/odbcsql, Top
@chapter Constant variables

@itemize


@item MD5_DIGEST_LENGTH
  @vindex MD5_DIGEST_LENGTH* = 16
@example
MD5_DIGEST_LENGTH* = 16
@end example
  
@end itemize



@chapter Types

@itemize


@item des_key_schedule
  @tindex des_key_schedule* = array[1 .. 16, des_ks_struct]
@example
des_key_schedule* = array[1 .. 16, des_ks_struct]
@end example
  

@item MD5_LONG
  @tindex MD5_LONG* = cuint
@example
MD5_LONG* = cuint
@end example
  

@item MD5_CTX
  @tindex MD5_CTX* = object
  A, B, C, D, Nl, Nh: MD5_LONG
  data: array[MD5_LBLOCK, MD5_LONG]
  num: cuint

@example
MD5_CTX* = object
  A, B, C, D, Nl, Nh: MD5_LONG
  data: array[MD5_LBLOCK, MD5_LONG]
  num: cuint

@end example
  
@end itemize

@chapter Procedures

@itemize


@item SSL_library_init
  @findex proc SSL_library_init*()꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc, discardable.@}
@example
proc SSL_library_init*()꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc, discardable.@}
@end example
  

@item SSL_load_error_strings
  @findex proc SSL_load_error_strings*() @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_load_error_strings*() @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item ERR_load_BIO_strings
  @findex proc ERR_load_BIO_strings*() @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@example
proc ERR_load_BIO_strings*() @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@end example
  

@item SSLv23_client_method
  @findex proc SSLv23_client_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSLv23_client_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSLv23_method
  @findex proc SSLv23_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSLv23_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSLv2_method
  @findex proc SSLv2_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSLv2_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSLv3_method
  @findex proc SSLv3_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSLv3_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item TLSv1_method
  @findex proc TLSv1_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc TLSv1_method*()꞉ PSSL_METHOD @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_new
  @findex proc SSL_new*(context꞉ SslCtx)꞉ SslPtr @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_new*(context꞉ SslCtx)꞉ SslPtr @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_free
  @findex proc SSL_free*(ssl꞉ SslPtr) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_free*(ssl꞉ SslPtr) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_new
  @findex proc SSL_CTX_new*(meth꞉ PSSL_METHOD)꞉ SslCtx @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_new*(meth꞉ PSSL_METHOD)꞉ SslCtx @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_load_verify_locations
  @findex proc SSL_CTX_load_verify_locations*(ctx꞉ SslCtx; CAfile꞉ cstring; CApath꞉ cstring)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_load_verify_locations*(ctx꞉ SslCtx; CAfile꞉ cstring; CApath꞉ cstring)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_free
  @findex proc SSL_CTX_free*(arg0꞉ SslCtx) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_free*(arg0꞉ SslCtx) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_set_verify
  @findex proc SSL_CTX_set_verify*(s꞉ SslCtx; mode꞉ int;cb꞉ proc (a꞉ int; b꞉ pointer)꞉ int @{.cdecl.@}) @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_set_verify*(s꞉ SslCtx; mode꞉ int;cb꞉ proc (a꞉ int; b꞉ pointer)꞉ int @{.cdecl.@}) @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_get_verify_result
  @findex proc SSL_get_verify_result*(ssl꞉ SslPtr)꞉ int @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_get_verify_result*(ssl꞉ SslPtr)꞉ int @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_set_cipher_list
  @findex proc SSL_CTX_set_cipher_list*(s꞉ SslCtx; ciphers꞉ cstring)꞉ cint @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_set_cipher_list*(s꞉ SslCtx; ciphers꞉ cstring)꞉ cint @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_use_certificate_file
  @findex proc SSL_CTX_use_certificate_file*(ctx꞉ SslCtx; filename꞉ cstring; typ꞉ cInt)꞉ cInt @{.stdcall, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_use_certificate_file*(ctx꞉ SslCtx; filename꞉ cstring; typ꞉ cInt)꞉ cInt @{.stdcall, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_use_certificate_chain_file
  @findex proc SSL_CTX_use_certificate_chain_file*(ctx꞉ SslCtx; filename꞉ cstring)꞉ cInt @{.stdcall, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_use_certificate_chain_file*(ctx꞉ SslCtx; filename꞉ cstring)꞉ cInt @{.stdcall, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_use_PrivateKey_file
  @findex proc SSL_CTX_use_PrivateKey_file*(ctx꞉ SslCtx; filename꞉ cstring; typ꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_use_PrivateKey_file*(ctx꞉ SslCtx; filename꞉ cstring; typ꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_CTX_check_private_key
  @findex proc SSL_CTX_check_private_key*(ctx꞉ SslCtx)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_check_private_key*(ctx꞉ SslCtx)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_set_fd
  @findex proc SSL_set_fd*(ssl꞉ SslPtr; fd꞉ SocketHandle)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc.@}
@example
proc SSL_set_fd*(ssl꞉ SslPtr; fd꞉ SocketHandle)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc.@}
@end example
  

@item SSL_shutdown
  @findex proc SSL_shutdown*(ssl꞉ SslPtr)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_shutdown*(ssl꞉ SslPtr)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_set_shutdown
  @findex proc SSL_set_shutdown*(ssl꞉ SslPtr; mode꞉ cint) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_shutdown".@}
@example
proc SSL_set_shutdown*(ssl꞉ SslPtr; mode꞉ cint) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_shutdown".@}
@end example
  

@item SSL_get_shutdown
  @findex proc SSL_get_shutdown*(ssl꞉ SslPtr)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_get_shutdown".@}
@example
proc SSL_get_shutdown*(ssl꞉ SslPtr)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_get_shutdown".@}
@end example
  

@item SSL_connect
  @findex proc SSL_connect*(ssl꞉ SslPtr)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_connect*(ssl꞉ SslPtr)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_read
  @findex proc SSL_read*(ssl꞉ SslPtr; buf꞉ pointer; num꞉ int)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc.@}
@example
proc SSL_read*(ssl꞉ SslPtr; buf꞉ pointer; num꞉ int)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc.@}
@end example
  

@item SSL_write
  @findex proc SSL_write*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ int)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc.@}
@example
proc SSL_write*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ int)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc.@}
@end example
  

@item SSL_get_error
  @findex proc SSL_get_error*(s꞉ SslPtr; ret_code꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_get_error*(s꞉ SslPtr; ret_code꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_accept
  @findex proc SSL_accept*(ssl꞉ SslPtr)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_accept*(ssl꞉ SslPtr)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_pending
  @findex proc SSL_pending*(ssl꞉ SslPtr)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_pending*(ssl꞉ SslPtr)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item BIO_new_ssl_connect
  @findex proc BIO_new_ssl_connect*(ctx꞉ SslCtx)꞉ BIO @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc BIO_new_ssl_connect*(ctx꞉ SslCtx)꞉ BIO @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item BIO_ctrl
  @findex proc BIO_ctrl*(bio꞉ BIO; cmd꞉ cint; larg꞉ int; arg꞉ cstring)꞉ int @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@example
proc BIO_ctrl*(bio꞉ BIO; cmd꞉ cint; larg꞉ int; arg꞉ cstring)꞉ int @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item BIO_get_ssl
  @findex proc BIO_get_ssl*(bio꞉ BIO; ssl꞉ ptr SslPtr)꞉ int
@example
proc BIO_get_ssl*(bio꞉ BIO; ssl꞉ ptr SslPtr)꞉ int
@end example
  

@item BIO_set_conn_hostname
  @findex proc BIO_set_conn_hostname*(bio꞉ BIO; name꞉ cstring)꞉ int
@example
proc BIO_set_conn_hostname*(bio꞉ BIO; name꞉ cstring)꞉ int
@end example
  

@item BIO_do_handshake
  @findex proc BIO_do_handshake*(bio꞉ BIO)꞉ int
@example
proc BIO_do_handshake*(bio꞉ BIO)꞉ int
@end example
  

@item BIO_do_connect
  @findex proc BIO_do_connect*(bio꞉ BIO)꞉ int
@example
proc BIO_do_connect*(bio꞉ BIO)꞉ int
@end example
  

@item BIO_read
  @findex proc BIO_read*(b꞉ BIO; data꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc.@}
@example
proc BIO_read*(b꞉ BIO; data꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc.@}
@end example
  

@item BIO_write
  @findex proc BIO_write*(b꞉ BIO; data꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc.@}
@example
proc BIO_write*(b꞉ BIO; data꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc.@}
@end example
  

@item BIO_free
  @findex proc BIO_free*(b꞉ BIO)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@example
proc BIO_free*(b꞉ BIO)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@end example
  

@item ERR_print_errors_fp
  @findex proc ERR_print_errors_fp*(fp꞉ File) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc ERR_print_errors_fp*(fp꞉ File) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item ERR_error_string
  @findex proc ERR_error_string*(e꞉ cInt; buf꞉ cstring)꞉ cstring @{.cdecl, dynlib꞉ DLLUtilName,importc.@}
@example
proc ERR_error_string*(e꞉ cInt; buf꞉ cstring)꞉ cstring @{.cdecl, dynlib꞉ DLLUtilName,importc.@}
@end example
  

@item ERR_get_error
  @findex proc ERR_get_error*()꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@example
proc ERR_get_error*()꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@end example
  

@item ERR_peek_last_error
  @findex proc ERR_peek_last_error*()꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@example
proc ERR_peek_last_error*()꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName, importc.@}
@end example
  

@item OpenSSL_add_all_algorithms
  @findex proc OpenSSL_add_all_algorithms*() @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "OPENSSL_add_all_algorithms_conf".@}
@example
proc OpenSSL_add_all_algorithms*() @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "OPENSSL_add_all_algorithms_conf".@}
@end example
  

@item OPENSSL_config
  @findex proc OPENSSL_config*(configName꞉ cstring) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc OPENSSL_config*(configName꞉ cstring) @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item CRYPTO_malloc_init
  @findex proc CRYPTO_malloc_init*()
@example
proc CRYPTO_malloc_init*()
@end example
  

@item SSL_CTX_ctrl
  @findex proc SSL_CTX_ctrl*(ctx꞉ SslCtx; cmd꞉ cInt; larg꞉ int; parg꞉ pointer)꞉ int @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_CTX_ctrl*(ctx꞉ SslCtx; cmd꞉ cInt; larg꞉ int; parg꞉ pointer)꞉ int @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSLCTXSetMode
  @findex proc SSLCTXSetMode*(ctx꞉ SslCtx; mode꞉ int)꞉ int
@example
proc SSLCTXSetMode*(ctx꞉ SslCtx; mode꞉ int)꞉ int
@end example
  

@item SSL_ctrl
  @findex proc SSL_ctrl*(ssl꞉ SslPtr; cmd꞉ cInt; larg꞉ int; parg꞉ pointer)꞉ int @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_ctrl*(ssl꞉ SslPtr; cmd꞉ cInt; larg꞉ int; parg꞉ pointer)꞉ int @{.cdecl,dynlib꞉ DLLSSLName, importc.@}
@end example
  

@item SSL_set_tlsext_host_name
  @findex proc SSL_set_tlsext_host_name*(ssl꞉ SslPtr; name꞉ cstring)꞉ int
@example
proc SSL_set_tlsext_host_name*(ssl꞉ SslPtr; name꞉ cstring)꞉ int
@end example
  Set the SNI server name extension to be used in a client hello. Returns 1 if SNI was set, 0 if current SSL configuration doesn't support SNI.

@item SSL_get_servername
  @findex proc SSL_get_servername*(ssl꞉ SslPtr; typ꞉ cInt = TLSEXT_NAMETYPE_host_name)꞉ cstring @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@example
proc SSL_get_servername*(ssl꞉ SslPtr; typ꞉ cInt = TLSEXT_NAMETYPE_host_name)꞉ cstring @{.cdecl, dynlib꞉ DLLSSLName, importc.@}
@end example
  Retrieve the server name requested in the client hello. This can be used in the callback set in @emph{SSL_CTX_set_tlsext_servername_callback} to implement virtual hosting. May return @emph{nil}.

@item SSL_CTX_set_tlsext_servername_callback
  @findex proc SSL_CTX_set_tlsext_servername_callback*(ctx꞉ SslCtx;cb꞉ proc (ssl꞉ SslPtr; cb_id꞉ int; arg꞉ pointer)꞉ int @{.cdecl.@})꞉ int
@example
proc SSL_CTX_set_tlsext_servername_callback*(ctx꞉ SslCtx;cb꞉ proc (ssl꞉ SslPtr; cb_id꞉ int; arg꞉ pointer)꞉ int @{.cdecl.@})꞉ int
@end example
  Set the callback to be used on listening SSL connections when the client hello is received.

The callback should return one of:


@itemize 
 @item SSL_TLSEXT_ERR_OK
@item SSL_TLSEXT_ERR_ALERT_WARNING
@item SSL_TLSEXT_ERR_ALERT_FATAL
@item SSL_TLSEXT_ERR_NOACK
 
@end itemize

@item SSL_CTX_set_tlsext_servername_arg
  @findex proc SSL_CTX_set_tlsext_servername_arg*(ctx꞉ SslCtx; arg꞉ pointer)꞉ int
@example
proc SSL_CTX_set_tlsext_servername_arg*(ctx꞉ SslCtx; arg꞉ pointer)꞉ int
@end example
  Set the pointer to be used in the callback registered to @code{SSL_CTX_set_tlsext_servername_callback}.

@item bioNew
  @findex proc bioNew*(b꞉ PBIO_METHOD)꞉ BIO @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "BIO_new".@}
@example
proc bioNew*(b꞉ PBIO_METHOD)꞉ BIO @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "BIO_new".@}
@end example
  

@item bioFreeAll
  @findex proc bioFreeAll*(b꞉ BIO) @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "BIO_free_all".@}
@example
proc bioFreeAll*(b꞉ BIO) @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "BIO_free_all".@}
@end example
  

@item bioSMem
  @findex proc bioSMem*()꞉ PBIO_METHOD @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "BIO_s_mem".@}
@example
proc bioSMem*()꞉ PBIO_METHOD @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "BIO_s_mem".@}
@end example
  

@item bioCtrlPending
  @findex proc bioCtrlPending*(b꞉ BIO)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "BIO_ctrl_pending".@}
@example
proc bioCtrlPending*(b꞉ BIO)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "BIO_ctrl_pending".@}
@end example
  

@item bioRead
  @findex proc bioRead*(b꞉ BIO; Buf꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "BIO_read".@}
@example
proc bioRead*(b꞉ BIO; Buf꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "BIO_read".@}
@end example
  

@item bioWrite
  @findex proc bioWrite*(b꞉ BIO; Buf꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "BIO_write".@}
@example
proc bioWrite*(b꞉ BIO; Buf꞉ cstring; length꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "BIO_write".@}
@end example
  

@item sslSetConnectState
  @findex proc sslSetConnectState*(s꞉ SslPtr) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_connect_state".@}
@example
proc sslSetConnectState*(s꞉ SslPtr) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_connect_state".@}
@end example
  

@item sslSetAcceptState
  @findex proc sslSetAcceptState*(s꞉ SslPtr) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_accept_state".@}
@example
proc sslSetAcceptState*(s꞉ SslPtr) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_accept_state".@}
@end example
  

@item sslRead
  @findex proc sslRead*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_read".@}
@example
proc sslRead*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_read".@}
@end example
  

@item sslPeek
  @findex proc sslPeek*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_peek".@}
@example
proc sslPeek*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_peek".@}
@end example
  

@item sslWrite
  @findex proc sslWrite*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_write".@}
@example
proc sslWrite*(ssl꞉ SslPtr; buf꞉ cstring; num꞉ cInt)꞉ cInt @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_write".@}
@end example
  

@item sslSetBio
  @findex proc sslSetBio*(ssl꞉ SslPtr; rbio, wbio꞉ BIO) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_bio".@}
@example
proc sslSetBio*(ssl꞉ SslPtr; rbio, wbio꞉ BIO) @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_set_bio".@}
@end example
  

@item sslDoHandshake
  @findex proc sslDoHandshake*(ssl꞉ SslPtr)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_do_handshake".@}
@example
proc sslDoHandshake*(ssl꞉ SslPtr)꞉ cint @{.cdecl, dynlib꞉ DLLSSLName,importc꞉ "SSL_do_handshake".@}
@end example
  

@item ErrClearError
  @findex proc ErrClearError*() @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "ERR_clear_error".@}
@example
proc ErrClearError*() @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "ERR_clear_error".@}
@end example
  

@item ErrFreeStrings
  @findex proc ErrFreeStrings*() @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "ERR_free_strings".@}
@example
proc ErrFreeStrings*() @{.cdecl, dynlib꞉ DLLUtilName, importc꞉ "ERR_free_strings".@}
@end example
  

@item ErrRemoveState
  @findex proc ErrRemoveState*(pid꞉ cInt) @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "ERR_remove_state".@}
@example
proc ErrRemoveState*(pid꞉ cInt) @{.cdecl, dynlib꞉ DLLUtilName,importc꞉ "ERR_remove_state".@}
@end example
  

@item md5_Init
  @findex proc md5_Init*(c꞉ var MD5_CTX)꞉ cint @{.ic.@}
@example
proc md5_Init*(c꞉ var MD5_CTX)꞉ cint @{.ic.@}
@end example
  

@item md5_Update
  @findex proc md5_Update*(c꞉ var MD5_CTX; data꞉ pointer; len꞉ csize)꞉ cint @{.ic.@}
@example
proc md5_Update*(c꞉ var MD5_CTX; data꞉ pointer; len꞉ csize)꞉ cint @{.ic.@}
@end example
  

@item md5_Final
  @findex proc md5_Final*(md꞉ cstring; c꞉ var MD5_CTX)꞉ cint @{.ic.@}
@example
proc md5_Final*(md꞉ cstring; c꞉ var MD5_CTX)꞉ cint @{.ic.@}
@end example
  

@item md5
  @findex proc md5*(d꞉ ptr cuchar; n꞉ csize; md꞉ ptr cuchar)꞉ ptr cuchar @{.ic.@}
@example
proc md5*(d꞉ ptr cuchar; n꞉ csize; md꞉ ptr cuchar)꞉ ptr cuchar @{.ic.@}
@end example
  

@item md5_Transform
  @findex proc md5_Transform*(c꞉ var MD5_CTX; b꞉ ptr cuchar) @{.ic.@}
@example
proc md5_Transform*(c꞉ var MD5_CTX; b꞉ ptr cuchar) @{.ic.@}
@end example
  

@item md5_File
  @findex proc md5_File*(file꞉ string)꞉ string @{.raises꞉ [IOError, Exception].@}
@example
proc md5_File*(file꞉ string)꞉ string @{.raises꞉ [IOError, Exception].@}
@end example
  Generate MD5 hash for a file. Result is a 32 character

@item md5_Str
  @findex proc md5_Str*(str꞉ string)꞉ string @{.raises꞉ [IOError].@}
@example
proc md5_Str*(str꞉ string)꞉ string @{.raises꞉ [IOError].@}
@end example
  Generate MD5 hash for a string. Result is a 32 character
@end itemize






@node /wrappers/iup, /wrappers/postgres , /wrappers/openssl, Top
@chapter Constant variables

@itemize


@item constIUP_VERSION_DATE
  @vindex constIUP_VERSION_DATE* = "2009/07/18"
@example
constIUP_VERSION_DATE* = "2009/07/18"
@end example
  

@item IUP_BUTTON5
  @vindex IUP_BUTTON5* = cint(ord('5'))
@example
IUP_BUTTON5* = cint(ord('5'))
@end example
  

@item IUP_MASK_UINT
  @vindex IUP_MASK_UINT* = "/d+"
@example
IUP_MASK_UINT* = "/d+"
@end example
  

@item K_tilde
  @vindex K_tilde* = cint(ord('~'))
@example
K_tilde* = cint(ord('~'))
@end example
  

@item K_CR
  @vindex K_CR* = cint(13)
@example
K_CR* = cint(13)
@end example
  

@item K_yAsterisk
  @vindex K_yAsterisk* = iUPyxCODE(K_asterisk)
@example
K_yAsterisk* = iUPyxCODE(K_asterisk)
@end example
  

@item IUP_SECONDARY
  @vindex IUP_SECONDARY* = - 2
@example
IUP_SECONDARY* = - 2
@end example
  
@end itemize



@chapter Types

@itemize


@item Icallback
  @tindex Icallback* = proc (arg꞉ PIhandle)꞉ cint @{.cdecl.@}
@example
Icallback* = proc (arg꞉ PIhandle)꞉ cint @{.cdecl.@}
@end example
  

@item Iparamcb
  @tindex Iparamcb* = proc (dialog꞉ PIhandle; paramIndex꞉ cint; userData꞉ pointer)꞉ cint @{.cdecl.@}
@example
Iparamcb* = proc (dialog꞉ PIhandle; paramIndex꞉ cint; userData꞉ pointer)꞉ cint @{.cdecl.@}
@end example
  
@end itemize

@chapter Procedures

@itemize


@item fileDlg
  @findex proc fileDlg*()꞉ PIhandle @{.importc꞉ "IupFileDlg", dynlib꞉ dllname, cdecl.@}
@example
proc fileDlg*()꞉ PIhandle @{.importc꞉ "IupFileDlg", dynlib꞉ dllname, cdecl.@}
@end example
  

@item messageDlg
  @findex proc messageDlg*()꞉ PIhandle @{.importc꞉ "IupMessageDlg", dynlib꞉ dllname, cdecl.@}
@example
proc messageDlg*()꞉ PIhandle @{.importc꞉ "IupMessageDlg", dynlib꞉ dllname, cdecl.@}
@end example
  

@item colorDlg
  @findex proc colorDlg*()꞉ PIhandle @{.importc꞉ "IupColorDlg", dynlib꞉ dllname, cdecl.@}
@example
proc colorDlg*()꞉ PIhandle @{.importc꞉ "IupColorDlg", dynlib꞉ dllname, cdecl.@}
@end example
  

@item fontDlg
  @findex proc fontDlg*()꞉ PIhandle @{.importc꞉ "IupFontDlg", dynlib꞉ dllname, cdecl.@}
@example
proc fontDlg*()꞉ PIhandle @{.importc꞉ "IupFontDlg", dynlib꞉ dllname, cdecl.@}
@end example
  

@item getFile
  @findex proc getFile*(arq꞉ cstring)꞉ cint @{.importc꞉ "IupGetFile", dynlib꞉ dllname, cdecl.@}
@example
proc getFile*(arq꞉ cstring)꞉ cint @{.importc꞉ "IupGetFile", dynlib꞉ dllname, cdecl.@}
@end example
  

@item message
  @findex proc message*(title, msg꞉ cstring) @{.importc꞉ "IupMessage", dynlib꞉ dllname, cdecl.@}
@example
proc message*(title, msg꞉ cstring) @{.importc꞉ "IupMessage", dynlib꞉ dllname, cdecl.@}
@end example
  

@item messagef
  @findex proc messagef*(title, format꞉ cstring) @{.importc꞉ "IupMessagef", dynlib꞉ dllname, cdecl,varargs.@}
@example
proc messagef*(title, format꞉ cstring) @{.importc꞉ "IupMessagef", dynlib꞉ dllname, cdecl,varargs.@}
@end example
  

@item alarm
  @findex proc alarm*(title, msg, b1, b2, b3꞉ cstring)꞉ cint @{.importc꞉ "IupAlarm", dynlib꞉ dllname,cdecl.@}
@example
proc alarm*(title, msg, b1, b2, b3꞉ cstring)꞉ cint @{.importc꞉ "IupAlarm", dynlib꞉ dllname,cdecl.@}
@end example
  

@item scanf
  @findex proc scanf*(format꞉ cstring)꞉ cint @{.importc꞉ "IupScanf", dynlib꞉ dllname, cdecl, varargs.@}
@example
proc scanf*(format꞉ cstring)꞉ cint @{.importc꞉ "IupScanf", dynlib꞉ dllname, cdecl, varargs.@}
@end example
  

@item listDialog
  @findex proc listDialog*(theType꞉ cint; title꞉ cstring; size꞉ cint; list꞉ cstringArray;op, maxCol, maxLin꞉ cint; marks꞉ ptr cint)꞉ cint @{.importc꞉ "IupListDialog", dynlib꞉ dllname, cdecl.@}
@example
proc listDialog*(theType꞉ cint; title꞉ cstring; size꞉ cint; list꞉ cstringArray;op, maxCol, maxLin꞉ cint; marks꞉ ptr cint)꞉ cint @{.importc꞉ "IupListDialog", dynlib꞉ dllname, cdecl.@}
@end example
  

@item getText
  @findex proc getText*(title, text꞉ cstring)꞉ cint @{.importc꞉ "IupGetText", dynlib꞉ dllname, cdecl.@}
@example
proc getText*(title, text꞉ cstring)꞉ cint @{.importc꞉ "IupGetText", dynlib꞉ dllname, cdecl.@}
@end example
  

@item getColor
  @findex proc getColor*(x, y꞉ cint; r, g, b꞉ var byte)꞉ cint @{.importc꞉ "IupGetColor",dynlib꞉ dllname, cdecl.@}
@example
proc getColor*(x, y꞉ cint; r, g, b꞉ var byte)꞉ cint @{.importc꞉ "IupGetColor",dynlib꞉ dllname, cdecl.@}
@end example
  

@item getParam
  @findex proc getParam*(title꞉ cstring; action꞉ Iparamcb; userData꞉ pointer; format꞉ cstring)꞉ cint @{.importc꞉ "IupGetParam", cdecl, varargs, dynlib꞉ dllname.@}
@example
proc getParam*(title꞉ cstring; action꞉ Iparamcb; userData꞉ pointer; format꞉ cstring)꞉ cint @{.importc꞉ "IupGetParam", cdecl, varargs, dynlib꞉ dllname.@}
@end example
  

@item getParamv
  @findex proc getParamv*(title꞉ cstring; action꞉ Iparamcb; userData꞉ pointer; format꞉ cstring;paramCount, paramExtra꞉ cint; paramData꞉ pointer)꞉ cint @{.importc꞉ "IupGetParamv", cdecl, dynlib꞉ dllname.@}
@example
proc getParamv*(title꞉ cstring; action꞉ Iparamcb; userData꞉ pointer; format꞉ cstring;paramCount, paramExtra꞉ cint; paramData꞉ pointer)꞉ cint @{.importc꞉ "IupGetParamv", cdecl, dynlib꞉ dllname.@}
@end example
  

@item open
  @findex proc open*(argc꞉ ptr cint; argv꞉ ptr cstringArray)꞉ cint @{.importc꞉ "IupOpen", cdecl,dynlib꞉ dllname.@}
@example
proc open*(argc꞉ ptr cint; argv꞉ ptr cstringArray)꞉ cint @{.importc꞉ "IupOpen", cdecl,dynlib꞉ dllname.@}
@end example
  

@item close
  @findex proc close*() @{.importc꞉ "IupClose", cdecl, dynlib꞉ dllname.@}
@example
proc close*() @{.importc꞉ "IupClose", cdecl, dynlib꞉ dllname.@}
@end example
  

@item imageLibOpen
  @findex proc imageLibOpen*() @{.importc꞉ "IupImageLibOpen", cdecl, dynlib꞉ dllname.@}
@example
proc imageLibOpen*() @{.importc꞉ "IupImageLibOpen", cdecl, dynlib꞉ dllname.@}
@end example
  

@item mainLoop
  @findex proc mainLoop*()꞉ cint @{.importc꞉ "IupMainLoop", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc mainLoop*()꞉ cint @{.importc꞉ "IupMainLoop", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item loopStep
  @findex proc loopStep*()꞉ cint @{.importc꞉ "IupLoopStep", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc loopStep*()꞉ cint @{.importc꞉ "IupLoopStep", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item mainLoopLevel
  @findex proc mainLoopLevel*()꞉ cint @{.importc꞉ "IupMainLoopLevel", cdecl, dynlib꞉ dllname,discardable.@}
@example
proc mainLoopLevel*()꞉ cint @{.importc꞉ "IupMainLoopLevel", cdecl, dynlib꞉ dllname,discardable.@}
@end example
  

@item flush
  @findex proc flush*() @{.importc꞉ "IupFlush", cdecl, dynlib꞉ dllname.@}
@example
proc flush*() @{.importc꞉ "IupFlush", cdecl, dynlib꞉ dllname.@}
@end example
  

@item exitLoop
  @findex proc exitLoop*() @{.importc꞉ "IupExitLoop", cdecl, dynlib꞉ dllname.@}
@example
proc exitLoop*() @{.importc꞉ "IupExitLoop", cdecl, dynlib꞉ dllname.@}
@end example
  

@item update
  @findex proc update*(ih꞉ PIhandle) @{.importc꞉ "IupUpdate", cdecl, dynlib꞉ dllname.@}
@example
proc update*(ih꞉ PIhandle) @{.importc꞉ "IupUpdate", cdecl, dynlib꞉ dllname.@}
@end example
  

@item updateChildren
  @findex proc updateChildren*(ih꞉ PIhandle) @{.importc꞉ "IupUpdateChildren", cdecl,dynlib꞉ dllname.@}
@example
proc updateChildren*(ih꞉ PIhandle) @{.importc꞉ "IupUpdateChildren", cdecl,dynlib꞉ dllname.@}
@end example
  

@item redraw
  @findex proc redraw*(ih꞉ PIhandle; children꞉ cint) @{.importc꞉ "IupRedraw", cdecl,dynlib꞉ dllname.@}
@example
proc redraw*(ih꞉ PIhandle; children꞉ cint) @{.importc꞉ "IupRedraw", cdecl,dynlib꞉ dllname.@}
@end example
  

@item refresh
  @findex proc refresh*(ih꞉ PIhandle) @{.importc꞉ "IupRefresh", cdecl, dynlib꞉ dllname.@}
@example
proc refresh*(ih꞉ PIhandle) @{.importc꞉ "IupRefresh", cdecl, dynlib꞉ dllname.@}
@end example
  

@item mapFont
  @findex proc mapFont*(iupfont꞉ cstring)꞉ cstring @{.importc꞉ "IupMapFont", cdecl,dynlib꞉ dllname.@}
@example
proc mapFont*(iupfont꞉ cstring)꞉ cstring @{.importc꞉ "IupMapFont", cdecl,dynlib꞉ dllname.@}
@end example
  

@item unMapFont
  @findex proc unMapFont*(driverfont꞉ cstring)꞉ cstring @{.importc꞉ "IupUnMapFont", cdecl,dynlib꞉ dllname.@}
@example
proc unMapFont*(driverfont꞉ cstring)꞉ cstring @{.importc꞉ "IupUnMapFont", cdecl,dynlib꞉ dllname.@}
@end example
  

@item help
  @findex proc help*(url꞉ cstring)꞉ cint @{.importc꞉ "IupHelp", cdecl, dynlib꞉ dllname.@}
@example
proc help*(url꞉ cstring)꞉ cint @{.importc꞉ "IupHelp", cdecl, dynlib꞉ dllname.@}
@end example
  

@item load
  @findex proc load*(filename꞉ cstring)꞉ cstring @{.importc꞉ "IupLoad", cdecl, dynlib꞉ dllname.@}
@example
proc load*(filename꞉ cstring)꞉ cstring @{.importc꞉ "IupLoad", cdecl, dynlib꞉ dllname.@}
@end example
  

@item iupVersion
  @findex proc iupVersion*()꞉ cstring @{.importc꞉ "IupVersion", cdecl, dynlib꞉ dllname.@}
@example
proc iupVersion*()꞉ cstring @{.importc꞉ "IupVersion", cdecl, dynlib꞉ dllname.@}
@end example
  

@item iupVersionDate
  @findex proc iupVersionDate*()꞉ cstring @{.importc꞉ "IupVersionDate", cdecl, dynlib꞉ dllname.@}
@example
proc iupVersionDate*()꞉ cstring @{.importc꞉ "IupVersionDate", cdecl, dynlib꞉ dllname.@}
@end example
  

@item iupVersionNumber
  @findex proc iupVersionNumber*()꞉ cint @{.importc꞉ "IupVersionNumber", cdecl, dynlib꞉ dllname.@}
@example
proc iupVersionNumber*()꞉ cint @{.importc꞉ "IupVersionNumber", cdecl, dynlib꞉ dllname.@}
@end example
  

@item setLanguage
  @findex proc setLanguage*(lng꞉ cstring) @{.importc꞉ "IupSetLanguage", cdecl, dynlib꞉ dllname.@}
@example
proc setLanguage*(lng꞉ cstring) @{.importc꞉ "IupSetLanguage", cdecl, dynlib꞉ dllname.@}
@end example
  

@item getLanguage
  @findex proc getLanguage*()꞉ cstring @{.importc꞉ "IupGetLanguage", cdecl, dynlib꞉ dllname.@}
@example
proc getLanguage*()꞉ cstring @{.importc꞉ "IupGetLanguage", cdecl, dynlib꞉ dllname.@}
@end example
  

@item destroy
  @findex proc destroy*(ih꞉ PIhandle) @{.importc꞉ "IupDestroy", cdecl, dynlib꞉ dllname.@}
@example
proc destroy*(ih꞉ PIhandle) @{.importc꞉ "IupDestroy", cdecl, dynlib꞉ dllname.@}
@end example
  

@item detach
  @findex proc detach*(child꞉ PIhandle) @{.importc꞉ "IupDetach", cdecl, dynlib꞉ dllname.@}
@example
proc detach*(child꞉ PIhandle) @{.importc꞉ "IupDetach", cdecl, dynlib꞉ dllname.@}
@end example
  

@item append
  @findex proc append*(ih, child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupAppend", cdecl,dynlib꞉ dllname, discardable.@}
@example
proc append*(ih, child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupAppend", cdecl,dynlib꞉ dllname, discardable.@}
@end example
  

@item insert
  @findex proc insert*(ih, refChild, child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupInsert", cdecl,dynlib꞉ dllname, discardable.@}
@example
proc insert*(ih, refChild, child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupInsert", cdecl,dynlib꞉ dllname, discardable.@}
@end example
  

@item getChild
  @findex proc getChild*(ih꞉ PIhandle; pos꞉ cint)꞉ PIhandle @{.importc꞉ "IupGetChild", cdecl,dynlib꞉ dllname.@}
@example
proc getChild*(ih꞉ PIhandle; pos꞉ cint)꞉ PIhandle @{.importc꞉ "IupGetChild", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getChildPos
  @findex proc getChildPos*(ih, child꞉ PIhandle)꞉ cint @{.importc꞉ "IupGetChildPos", cdecl,dynlib꞉ dllname.@}
@example
proc getChildPos*(ih, child꞉ PIhandle)꞉ cint @{.importc꞉ "IupGetChildPos", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getChildCount
  @findex proc getChildCount*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupGetChildCount", cdecl,dynlib꞉ dllname.@}
@example
proc getChildCount*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupGetChildCount", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getNextChild
  @findex proc getNextChild*(ih, child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetNextChild", cdecl,dynlib꞉ dllname.@}
@example
proc getNextChild*(ih, child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetNextChild", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getBrother
  @findex proc getBrother*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetBrother", cdecl,dynlib꞉ dllname.@}
@example
proc getBrother*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetBrother", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getParent
  @findex proc getParent*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetParent", cdecl,dynlib꞉ dllname.@}
@example
proc getParent*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetParent", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getDialog
  @findex proc getDialog*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetDialog", cdecl,dynlib꞉ dllname.@}
@example
proc getDialog*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupGetDialog", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getDialogChild
  @findex proc getDialogChild*(ih꞉ PIhandle; name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupGetDialogChild", cdecl, dynlib꞉ dllname.@}
@example
proc getDialogChild*(ih꞉ PIhandle; name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupGetDialogChild", cdecl, dynlib꞉ dllname.@}
@end example
  

@item reparent
  @findex proc reparent*(ih, newParent꞉ PIhandle)꞉ cint @{.importc꞉ "IupReparent", cdecl,dynlib꞉ dllname.@}
@example
proc reparent*(ih, newParent꞉ PIhandle)꞉ cint @{.importc꞉ "IupReparent", cdecl,dynlib꞉ dllname.@}
@end example
  

@item popup
  @findex proc popup*(ih꞉ PIhandle; x, y꞉ cint)꞉ cint @{.importc꞉ "IupPopup", cdecl, dynlib꞉ dllname,discardable.@}
@example
proc popup*(ih꞉ PIhandle; x, y꞉ cint)꞉ cint @{.importc꞉ "IupPopup", cdecl, dynlib꞉ dllname,discardable.@}
@end example
  

@item show
  @findex proc show*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupShow", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc show*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupShow", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item showXY
  @findex proc showXY*(ih꞉ PIhandle; x, y꞉ cint)꞉ cint @{.importc꞉ "IupShowXY", cdecl,dynlib꞉ dllname, discardable.@}
@example
proc showXY*(ih꞉ PIhandle; x, y꞉ cint)꞉ cint @{.importc꞉ "IupShowXY", cdecl,dynlib꞉ dllname, discardable.@}
@end example
  

@item hide
  @findex proc hide*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupHide", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc hide*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupHide", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item map
  @findex proc map*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupMap", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc map*(ih꞉ PIhandle)꞉ cint @{.importc꞉ "IupMap", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item unmap
  @findex proc unmap*(ih꞉ PIhandle) @{.importc꞉ "IupUnmap", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc unmap*(ih꞉ PIhandle) @{.importc꞉ "IupUnmap", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item setAttribute
  @findex proc setAttribute*(ih꞉ PIhandle; name, value꞉ cstring) @{.importc꞉ "IupSetAttribute",cdecl, dynlib꞉ dllname.@}
@example
proc setAttribute*(ih꞉ PIhandle; name, value꞉ cstring) @{.importc꞉ "IupSetAttribute",cdecl, dynlib꞉ dllname.@}
@end example
  

@item storeAttribute
  @findex proc storeAttribute*(ih꞉ PIhandle; name, value꞉ cstring) @{.importc꞉ "IupStoreAttribute", cdecl, dynlib꞉ dllname.@}
@example
proc storeAttribute*(ih꞉ PIhandle; name, value꞉ cstring) @{.importc꞉ "IupStoreAttribute", cdecl, dynlib꞉ dllname.@}
@end example
  

@item setAttributes
  @findex proc setAttributes*(ih꞉ PIhandle; str꞉ cstring)꞉ PIhandle @{.importc꞉ "IupSetAttributes", cdecl, dynlib꞉ dllname.@}
@example
proc setAttributes*(ih꞉ PIhandle; str꞉ cstring)꞉ PIhandle @{.importc꞉ "IupSetAttributes", cdecl, dynlib꞉ dllname.@}
@end example
  

@item getAttribute
  @findex proc getAttribute*(ih꞉ PIhandle; name꞉ cstring)꞉ cstring @{.importc꞉ "IupGetAttribute",cdecl, dynlib꞉ dllname.@}
@example
proc getAttribute*(ih꞉ PIhandle; name꞉ cstring)꞉ cstring @{.importc꞉ "IupGetAttribute",cdecl, dynlib꞉ dllname.@}
@end example
  

@item getAttributes
  @findex proc getAttributes*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetAttributes", cdecl,dynlib꞉ dllname.@}
@example
proc getAttributes*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetAttributes", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getInt
  @findex proc getInt*(ih꞉ PIhandle; name꞉ cstring)꞉ cint @{.importc꞉ "IupGetInt", cdecl,dynlib꞉ dllname.@}
@example
proc getInt*(ih꞉ PIhandle; name꞉ cstring)꞉ cint @{.importc꞉ "IupGetInt", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getInt2
  @findex proc getInt2*(ih꞉ PIhandle; name꞉ cstring)꞉ cint @{.importc꞉ "IupGetInt2", cdecl,dynlib꞉ dllname.@}
@example
proc getInt2*(ih꞉ PIhandle; name꞉ cstring)꞉ cint @{.importc꞉ "IupGetInt2", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getIntInt
  @findex proc getIntInt*(ih꞉ PIhandle; name꞉ cstring; i1, i2꞉ var cint)꞉ cint @{.importc꞉ "IupGetIntInt", cdecl, dynlib꞉ dllname.@}
@example
proc getIntInt*(ih꞉ PIhandle; name꞉ cstring; i1, i2꞉ var cint)꞉ cint @{.importc꞉ "IupGetIntInt", cdecl, dynlib꞉ dllname.@}
@end example
  

@item getFloat
  @findex proc getFloat*(ih꞉ PIhandle; name꞉ cstring)꞉ cfloat @{.importc꞉ "IupGetFloat", cdecl,dynlib꞉ dllname.@}
@example
proc getFloat*(ih꞉ PIhandle; name꞉ cstring)꞉ cfloat @{.importc꞉ "IupGetFloat", cdecl,dynlib꞉ dllname.@}
@end example
  

@item setfAttribute
  @findex proc setfAttribute*(ih꞉ PIhandle; name, format꞉ cstring) @{.importc꞉ "IupSetfAttribute", cdecl, dynlib꞉ dllname, varargs.@}
@example
proc setfAttribute*(ih꞉ PIhandle; name, format꞉ cstring) @{.importc꞉ "IupSetfAttribute", cdecl, dynlib꞉ dllname, varargs.@}
@end example
  

@item getAllAttributes
  @findex proc getAllAttributes*(ih꞉ PIhandle; names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetAllAttributes", cdecl, dynlib꞉ dllname.@}
@example
proc getAllAttributes*(ih꞉ PIhandle; names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetAllAttributes", cdecl, dynlib꞉ dllname.@}
@end example
  

@item setAtt
  @findex proc setAtt*(handleName꞉ cstring; ih꞉ PIhandle; name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupSetAtt", cdecl, dynlib꞉ dllname, varargs, discardable.@}
@example
proc setAtt*(handleName꞉ cstring; ih꞉ PIhandle; name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupSetAtt", cdecl, dynlib꞉ dllname, varargs, discardable.@}
@end example
  

@item setGlobal
  @findex proc setGlobal*(name, value꞉ cstring) @{.importc꞉ "IupSetGlobal", cdecl, dynlib꞉ dllname.@}
@example
proc setGlobal*(name, value꞉ cstring) @{.importc꞉ "IupSetGlobal", cdecl, dynlib꞉ dllname.@}
@end example
  

@item storeGlobal
  @findex proc storeGlobal*(name, value꞉ cstring) @{.importc꞉ "IupStoreGlobal", cdecl,dynlib꞉ dllname.@}
@example
proc storeGlobal*(name, value꞉ cstring) @{.importc꞉ "IupStoreGlobal", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getGlobal
  @findex proc getGlobal*(name꞉ cstring)꞉ cstring @{.importc꞉ "IupGetGlobal", cdecl,dynlib꞉ dllname.@}
@example
proc getGlobal*(name꞉ cstring)꞉ cstring @{.importc꞉ "IupGetGlobal", cdecl,dynlib꞉ dllname.@}
@end example
  

@item setFocus
  @findex proc setFocus*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSetFocus", cdecl, dynlib꞉ dllname.@}
@example
proc setFocus*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSetFocus", cdecl, dynlib꞉ dllname.@}
@end example
  

@item getFocus
  @findex proc getFocus*()꞉ PIhandle @{.importc꞉ "IupGetFocus", cdecl, dynlib꞉ dllname.@}
@example
proc getFocus*()꞉ PIhandle @{.importc꞉ "IupGetFocus", cdecl, dynlib꞉ dllname.@}
@end example
  

@item previousField
  @findex proc previousField*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupPreviousField", cdecl,dynlib꞉ dllname.@}
@example
proc previousField*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupPreviousField", cdecl,dynlib꞉ dllname.@}
@end example
  

@item nextField
  @findex proc nextField*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupNextField", cdecl,dynlib꞉ dllname.@}
@example
proc nextField*(ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupNextField", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getCallback
  @findex proc getCallback*(ih꞉ PIhandle; name꞉ cstring)꞉ Icallback @{.importc꞉ "IupGetCallback",cdecl, dynlib꞉ dllname.@}
@example
proc getCallback*(ih꞉ PIhandle; name꞉ cstring)꞉ Icallback @{.importc꞉ "IupGetCallback",cdecl, dynlib꞉ dllname.@}
@end example
  

@item setCallback
  @findex proc setCallback*(ih꞉ PIhandle; name꞉ cstring; fn꞉ Icallback)꞉ Icallback @{.importc꞉ "IupSetCallback", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc setCallback*(ih꞉ PIhandle; name꞉ cstring; fn꞉ Icallback)꞉ Icallback @{.importc꞉ "IupSetCallback", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item setCallbacks
  @findex proc setCallbacks*(ih꞉ PIhandle; name꞉ cstring; fn꞉ Icallback)꞉ PIhandle @{.importc꞉ "IupSetCallbacks", cdecl, dynlib꞉ dllname, varargs, discardable.@}
@example
proc setCallbacks*(ih꞉ PIhandle; name꞉ cstring; fn꞉ Icallback)꞉ PIhandle @{.importc꞉ "IupSetCallbacks", cdecl, dynlib꞉ dllname, varargs, discardable.@}
@end example
  

@item getFunction
  @findex proc getFunction*(name꞉ cstring)꞉ Icallback @{.importc꞉ "IupGetFunction", cdecl,dynlib꞉ dllname.@}
@example
proc getFunction*(name꞉ cstring)꞉ Icallback @{.importc꞉ "IupGetFunction", cdecl,dynlib꞉ dllname.@}
@end example
  

@item setFunction
  @findex proc setFunction*(name꞉ cstring; fn꞉ Icallback)꞉ Icallback @{.importc꞉ "IupSetFunction", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc setFunction*(name꞉ cstring; fn꞉ Icallback)꞉ Icallback @{.importc꞉ "IupSetFunction", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item getActionName
  @findex proc getActionName*()꞉ cstring @{.importc꞉ "IupGetActionName", cdecl, dynlib꞉ dllname.@}
@example
proc getActionName*()꞉ cstring @{.importc꞉ "IupGetActionName", cdecl, dynlib꞉ dllname.@}
@end example
  

@item getHandle
  @findex proc getHandle*(name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupGetHandle", cdecl,dynlib꞉ dllname.@}
@example
proc getHandle*(name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupGetHandle", cdecl,dynlib꞉ dllname.@}
@end example
  

@item setHandle
  @findex proc setHandle*(name꞉ cstring; ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSetHandle", cdecl,dynlib꞉ dllname.@}
@example
proc setHandle*(name꞉ cstring; ih꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSetHandle", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getAllNames
  @findex proc getAllNames*(names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetAllNames",cdecl, dynlib꞉ dllname.@}
@example
proc getAllNames*(names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetAllNames",cdecl, dynlib꞉ dllname.@}
@end example
  

@item getAllDialogs
  @findex proc getAllDialogs*(names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetAllDialogs",cdecl, dynlib꞉ dllname.@}
@example
proc getAllDialogs*(names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetAllDialogs",cdecl, dynlib꞉ dllname.@}
@end example
  

@item getName
  @findex proc getName*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetName", cdecl, dynlib꞉ dllname.@}
@example
proc getName*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetName", cdecl, dynlib꞉ dllname.@}
@end example
  

@item setAttributeHandle
  @findex proc setAttributeHandle*(ih꞉ PIhandle; name꞉ cstring; ihNamed꞉ PIhandle) @{.importc꞉ "IupSetAttributeHandle", cdecl, dynlib꞉ dllname.@}
@example
proc setAttributeHandle*(ih꞉ PIhandle; name꞉ cstring; ihNamed꞉ PIhandle) @{.importc꞉ "IupSetAttributeHandle", cdecl, dynlib꞉ dllname.@}
@end example
  

@item getAttributeHandle
  @findex proc getAttributeHandle*(ih꞉ PIhandle; name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupGetAttributeHandle", cdecl, dynlib꞉ dllname.@}
@example
proc getAttributeHandle*(ih꞉ PIhandle; name꞉ cstring)꞉ PIhandle @{.importc꞉ "IupGetAttributeHandle", cdecl, dynlib꞉ dllname.@}
@end example
  

@item getClassName
  @findex proc getClassName*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetClassName", cdecl,dynlib꞉ dllname.@}
@example
proc getClassName*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetClassName", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getClassType
  @findex proc getClassType*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetClassType", cdecl,dynlib꞉ dllname.@}
@example
proc getClassType*(ih꞉ PIhandle)꞉ cstring @{.importc꞉ "IupGetClassType", cdecl,dynlib꞉ dllname.@}
@end example
  

@item getClassAttributes
  @findex proc getClassAttributes*(classname꞉ cstring; names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetClassAttributes", cdecl, dynlib꞉ dllname.@}
@example
proc getClassAttributes*(classname꞉ cstring; names꞉ cstringArray; n꞉ cint)꞉ cint @{.importc꞉ "IupGetClassAttributes", cdecl, dynlib꞉ dllname.@}
@end example
  

@item saveClassAttributes
  @findex proc saveClassAttributes*(ih꞉ PIhandle) @{.importc꞉ "IupSaveClassAttributes", cdecl,dynlib꞉ dllname.@}
@example
proc saveClassAttributes*(ih꞉ PIhandle) @{.importc꞉ "IupSaveClassAttributes", cdecl,dynlib꞉ dllname.@}
@end example
  

@item setClassDefaultAttribute
  @findex proc setClassDefaultAttribute*(classname, name, value꞉ cstring) @{.importc꞉ "IupSetClassDefaultAttribute", cdecl, dynlib꞉ dllname.@}
@example
proc setClassDefaultAttribute*(classname, name, value꞉ cstring) @{.importc꞉ "IupSetClassDefaultAttribute", cdecl, dynlib꞉ dllname.@}
@end example
  

@item create
  @findex proc create*(classname꞉ cstring)꞉ PIhandle @{.importc꞉ "IupCreate", cdecl,dynlib꞉ dllname.@}
@example
proc create*(classname꞉ cstring)꞉ PIhandle @{.importc꞉ "IupCreate", cdecl,dynlib꞉ dllname.@}
@end example
  

@item createv
  @findex proc createv*(classname꞉ cstring; params꞉ pointer)꞉ PIhandle @{.importc꞉ "IupCreatev",cdecl, dynlib꞉ dllname.@}
@example
proc createv*(classname꞉ cstring; params꞉ pointer)꞉ PIhandle @{.importc꞉ "IupCreatev",cdecl, dynlib꞉ dllname.@}
@end example
  

@item createp
  @findex proc createp*(classname꞉ cstring; first꞉ pointer)꞉ PIhandle @{.importc꞉ "IupCreatep",cdecl, dynlib꞉ dllname, varargs.@}
@example
proc createp*(classname꞉ cstring; first꞉ pointer)꞉ PIhandle @{.importc꞉ "IupCreatep",cdecl, dynlib꞉ dllname, varargs.@}
@end example
  

@item fill
  @findex proc fill*()꞉ PIhandle @{.importc꞉ "IupFill", cdecl, dynlib꞉ dllname.@}
@example
proc fill*()꞉ PIhandle @{.importc꞉ "IupFill", cdecl, dynlib꞉ dllname.@}
@end example
  

@item radio
  @findex proc radio*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupRadio", cdecl, dynlib꞉ dllname.@}
@example
proc radio*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupRadio", cdecl, dynlib꞉ dllname.@}
@end example
  

@item vbox
  @findex proc vbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupVbox", cdecl, dynlib꞉ dllname,varargs.@}
@example
proc vbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupVbox", cdecl, dynlib꞉ dllname,varargs.@}
@end example
  

@item vboxv
  @findex proc vboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupVboxv", cdecl,dynlib꞉ dllname.@}
@example
proc vboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupVboxv", cdecl,dynlib꞉ dllname.@}
@end example
  

@item zbox
  @findex proc zbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupZbox", cdecl, dynlib꞉ dllname,varargs.@}
@example
proc zbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupZbox", cdecl, dynlib꞉ dllname,varargs.@}
@end example
  

@item zboxv
  @findex proc zboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupZboxv", cdecl,dynlib꞉ dllname.@}
@example
proc zboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupZboxv", cdecl,dynlib꞉ dllname.@}
@end example
  

@item hbox
  @findex proc hbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupHbox", cdecl, dynlib꞉ dllname,varargs.@}
@example
proc hbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupHbox", cdecl, dynlib꞉ dllname,varargs.@}
@end example
  

@item hboxv
  @findex proc hboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupHboxv", cdecl,dynlib꞉ dllname.@}
@example
proc hboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupHboxv", cdecl,dynlib꞉ dllname.@}
@end example
  

@item normalizer
  @findex proc normalizer*(ihFirst꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupNormalizer", cdecl,dynlib꞉ dllname, varargs.@}
@example
proc normalizer*(ihFirst꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupNormalizer", cdecl,dynlib꞉ dllname, varargs.@}
@end example
  

@item normalizerv
  @findex proc normalizerv*(ihList꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupNormalizerv", cdecl,dynlib꞉ dllname.@}
@example
proc normalizerv*(ihList꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupNormalizerv", cdecl,dynlib꞉ dllname.@}
@end example
  

@item cbox
  @findex proc cbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupCbox", cdecl, dynlib꞉ dllname,varargs.@}
@example
proc cbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupCbox", cdecl, dynlib꞉ dllname,varargs.@}
@end example
  

@item cboxv
  @findex proc cboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupCboxv", cdecl,dynlib꞉ dllname.@}
@example
proc cboxv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupCboxv", cdecl,dynlib꞉ dllname.@}
@end example
  

@item sbox
  @findex proc sbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSbox", cdecl, dynlib꞉ dllname.@}
@example
proc sbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSbox", cdecl, dynlib꞉ dllname.@}
@end example
  

@item frame
  @findex proc frame*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupFrame", cdecl, dynlib꞉ dllname.@}
@example
proc frame*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupFrame", cdecl, dynlib꞉ dllname.@}
@end example
  

@item image
  @findex proc image*(width, height꞉ cint; pixmap꞉ pointer)꞉ PIhandle @{.importc꞉ "IupImage", cdecl,dynlib꞉ dllname.@}
@example
proc image*(width, height꞉ cint; pixmap꞉ pointer)꞉ PIhandle @{.importc꞉ "IupImage", cdecl,dynlib꞉ dllname.@}
@end example
  

@item imageRGB
  @findex proc imageRGB*(width, height꞉ cint; pixmap꞉ pointer)꞉ PIhandle @{.importc꞉ "IupImageRGB", cdecl, dynlib꞉ dllname.@}
@example
proc imageRGB*(width, height꞉ cint; pixmap꞉ pointer)꞉ PIhandle @{.importc꞉ "IupImageRGB", cdecl, dynlib꞉ dllname.@}
@end example
  

@item imageRGBA
  @findex proc imageRGBA*(width, height꞉ cint; pixmap꞉ pointer)꞉ PIhandle @{.importc꞉ "IupImageRGBA", cdecl, dynlib꞉ dllname.@}
@example
proc imageRGBA*(width, height꞉ cint; pixmap꞉ pointer)꞉ PIhandle @{.importc꞉ "IupImageRGBA", cdecl, dynlib꞉ dllname.@}
@end example
  

@item item
  @findex proc item*(title, action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupItem", cdecl,dynlib꞉ dllname.@}
@example
proc item*(title, action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupItem", cdecl,dynlib꞉ dllname.@}
@end example
  

@item submenu
  @findex proc submenu*(title꞉ cstring; child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSubmenu", cdecl,dynlib꞉ dllname.@}
@example
proc submenu*(title꞉ cstring; child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSubmenu", cdecl,dynlib꞉ dllname.@}
@end example
  

@item separator
  @findex proc separator*()꞉ PIhandle @{.importc꞉ "IupSeparator", cdecl, dynlib꞉ dllname.@}
@example
proc separator*()꞉ PIhandle @{.importc꞉ "IupSeparator", cdecl, dynlib꞉ dllname.@}
@end example
  

@item menu
  @findex proc menu*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupMenu", cdecl, dynlib꞉ dllname,varargs.@}
@example
proc menu*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupMenu", cdecl, dynlib꞉ dllname,varargs.@}
@end example
  

@item menuv
  @findex proc menuv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupMenuv", cdecl,dynlib꞉ dllname.@}
@example
proc menuv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupMenuv", cdecl,dynlib꞉ dllname.@}
@end example
  

@item button
  @findex proc button*(title, action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupButton", cdecl,dynlib꞉ dllname.@}
@example
proc button*(title, action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupButton", cdecl,dynlib꞉ dllname.@}
@end example
  

@item link
  @findex proc link*(url, title꞉ cstring)꞉ PIhandle @{.importc꞉ "IupLink", cdecl, dynlib꞉ dllname.@}
@example
proc link*(url, title꞉ cstring)꞉ PIhandle @{.importc꞉ "IupLink", cdecl, dynlib꞉ dllname.@}
@end example
  

@item canvas
  @findex proc canvas*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupCanvas", cdecl, dynlib꞉ dllname.@}
@example
proc canvas*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupCanvas", cdecl, dynlib꞉ dllname.@}
@end example
  

@item dialog
  @findex proc dialog*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupDialog", cdecl, dynlib꞉ dllname.@}
@example
proc dialog*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupDialog", cdecl, dynlib꞉ dllname.@}
@end example
  

@item user
  @findex proc user*()꞉ PIhandle @{.importc꞉ "IupUser", cdecl, dynlib꞉ dllname.@}
@example
proc user*()꞉ PIhandle @{.importc꞉ "IupUser", cdecl, dynlib꞉ dllname.@}
@end example
  

@item label
  @findex proc label*(title꞉ cstring)꞉ PIhandle @{.importc꞉ "IupLabel", cdecl, dynlib꞉ dllname.@}
@example
proc label*(title꞉ cstring)꞉ PIhandle @{.importc꞉ "IupLabel", cdecl, dynlib꞉ dllname.@}
@end example
  

@item list
  @findex proc list*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupList", cdecl, dynlib꞉ dllname.@}
@example
proc list*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupList", cdecl, dynlib꞉ dllname.@}
@end example
  

@item text
  @findex proc text*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupText", cdecl, dynlib꞉ dllname.@}
@example
proc text*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupText", cdecl, dynlib꞉ dllname.@}
@end example
  

@item multiLine
  @findex proc multiLine*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupMultiLine", cdecl,dynlib꞉ dllname.@}
@example
proc multiLine*(action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupMultiLine", cdecl,dynlib꞉ dllname.@}
@end example
  

@item toggle
  @findex proc toggle*(title, action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupToggle", cdecl,dynlib꞉ dllname.@}
@example
proc toggle*(title, action꞉ cstring)꞉ PIhandle @{.importc꞉ "IupToggle", cdecl,dynlib꞉ dllname.@}
@end example
  

@item timer
  @findex proc timer*()꞉ PIhandle @{.importc꞉ "IupTimer", cdecl, dynlib꞉ dllname.@}
@example
proc timer*()꞉ PIhandle @{.importc꞉ "IupTimer", cdecl, dynlib꞉ dllname.@}
@end example
  

@item progressBar
  @findex proc progressBar*()꞉ PIhandle @{.importc꞉ "IupProgressBar", cdecl, dynlib꞉ dllname.@}
@example
proc progressBar*()꞉ PIhandle @{.importc꞉ "IupProgressBar", cdecl, dynlib꞉ dllname.@}
@end example
  

@item val
  @findex proc val*(theType꞉ cstring)꞉ PIhandle @{.importc꞉ "IupVal", cdecl, dynlib꞉ dllname.@}
@example
proc val*(theType꞉ cstring)꞉ PIhandle @{.importc꞉ "IupVal", cdecl, dynlib꞉ dllname.@}
@end example
  

@item tabs
  @findex proc tabs*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupTabs", cdecl, dynlib꞉ dllname,varargs.@}
@example
proc tabs*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupTabs", cdecl, dynlib꞉ dllname,varargs.@}
@end example
  

@item tabsv
  @findex proc tabsv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupTabsv", cdecl,dynlib꞉ dllname.@}
@example
proc tabsv*(children꞉ ptr PIhandle)꞉ PIhandle @{.importc꞉ "IupTabsv", cdecl,dynlib꞉ dllname.@}
@end example
  

@item tree
  @findex proc tree*()꞉ PIhandle @{.importc꞉ "IupTree", cdecl, dynlib꞉ dllname.@}
@example
proc tree*()꞉ PIhandle @{.importc꞉ "IupTree", cdecl, dynlib꞉ dllname.@}
@end example
  

@item spin
  @findex proc spin*()꞉ PIhandle @{.importc꞉ "IupSpin", cdecl, dynlib꞉ dllname.@}
@example
proc spin*()꞉ PIhandle @{.importc꞉ "IupSpin", cdecl, dynlib꞉ dllname.@}
@end example
  

@item spinbox
  @findex proc spinbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSpinbox", cdecl,dynlib꞉ dllname.@}
@example
proc spinbox*(child꞉ PIhandle)꞉ PIhandle @{.importc꞉ "IupSpinbox", cdecl,dynlib꞉ dllname.@}
@end example
  

@item textConvertLinColToPos
  @findex proc textConvertLinColToPos*(ih꞉ PIhandle; lin, col꞉ cint; pos꞉ var cint) @{.importc꞉ "IupTextConvertLinColToPos", cdecl, dynlib꞉ dllname.@}
@example
proc textConvertLinColToPos*(ih꞉ PIhandle; lin, col꞉ cint; pos꞉ var cint) @{.importc꞉ "IupTextConvertLinColToPos", cdecl, dynlib꞉ dllname.@}
@end example
  

@item textConvertPosToLinCol
  @findex proc textConvertPosToLinCol*(ih꞉ PIhandle; pos꞉ cint; lin, col꞉ var cint) @{.importc꞉ "IupTextConvertPosToLinCol", cdecl, dynlib꞉ dllname.@}
@example
proc textConvertPosToLinCol*(ih꞉ PIhandle; pos꞉ cint; lin, col꞉ var cint) @{.importc꞉ "IupTextConvertPosToLinCol", cdecl, dynlib꞉ dllname.@}
@end example
  

@item convertXYToPos
  @findex proc convertXYToPos*(ih꞉ PIhandle; x, y꞉ cint)꞉ cint @{.importc꞉ "IupConvertXYToPos",cdecl, dynlib꞉ dllname.@}
@example
proc convertXYToPos*(ih꞉ PIhandle; x, y꞉ cint)꞉ cint @{.importc꞉ "IupConvertXYToPos",cdecl, dynlib꞉ dllname.@}
@end example
  

@item treeSetUserId
  @findex proc treeSetUserId*(ih꞉ PIhandle; id꞉ cint; userid꞉ pointer)꞉ cint @{.importc꞉ "IupTreeSetUserId", cdecl, dynlib꞉ dllname, discardable.@}
@example
proc treeSetUserId*(ih꞉ PIhandle; id꞉ cint; userid꞉ pointer)꞉ cint @{.importc꞉ "IupTreeSetUserId", cdecl, dynlib꞉ dllname, discardable.@}
@end example
  

@item treeGetUserId
  @findex proc treeGetUserId*(ih꞉ PIhandle; id꞉ cint)꞉ pointer @{.importc꞉ "IupTreeGetUserId",cdecl, dynlib꞉ dllname.@}
@example
proc treeGetUserId*(ih꞉ PIhandle; id꞉ cint)꞉ pointer @{.importc꞉ "IupTreeGetUserId",cdecl, dynlib꞉ dllname.@}
@end example
  

@item treeGetId
  @findex proc treeGetId*(ih꞉ PIhandle; userid꞉ pointer)꞉ cint @{.importc꞉ "IupTreeGetId", cdecl,dynlib꞉ dllname.@}
@example
proc treeGetId*(ih꞉ PIhandle; userid꞉ pointer)꞉ cint @{.importc꞉ "IupTreeGetId", cdecl,dynlib꞉ dllname.@}
@end example
  

@item treeSetAttribute
  @findex proc treeSetAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint; value꞉ cstring) @{.importc꞉ "IupTreeSetAttribute", cdecl, dynlib꞉ dllname.@}
@example
proc treeSetAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint; value꞉ cstring) @{.importc꞉ "IupTreeSetAttribute", cdecl, dynlib꞉ dllname.@}
@end example
  

@item treeStoreAttribute
  @findex proc treeStoreAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint; value꞉ cstring) @{.importc꞉ "IupTreeStoreAttribute", cdecl, dynlib꞉ dllname.@}
@example
proc treeStoreAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint; value꞉ cstring) @{.importc꞉ "IupTreeStoreAttribute", cdecl, dynlib꞉ dllname.@}
@end example
  

@item treeGetAttribute
  @findex proc treeGetAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint)꞉ cstring @{.importc꞉ "IupTreeGetAttribute", cdecl, dynlib꞉ dllname.@}
@example
proc treeGetAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint)꞉ cstring @{.importc꞉ "IupTreeGetAttribute", cdecl, dynlib꞉ dllname.@}
@end example
  

@item treeGetInt
  @findex proc treeGetInt*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint)꞉ cint @{.importc꞉ "IupTreeGetInt", cdecl, dynlib꞉ dllname.@}
@example
proc treeGetInt*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint)꞉ cint @{.importc꞉ "IupTreeGetInt", cdecl, dynlib꞉ dllname.@}
@end example
  

@item treeGetFloat
  @findex proc treeGetFloat*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint)꞉ cfloat @{.importc꞉ "IupTreeGetFloat", cdecl, dynlib꞉ dllname.@}
@example
proc treeGetFloat*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint)꞉ cfloat @{.importc꞉ "IupTreeGetFloat", cdecl, dynlib꞉ dllname.@}
@end example
  

@item treeSetfAttribute
  @findex proc treeSetfAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint; format꞉ cstring) @{.importc꞉ "IupTreeSetfAttribute", cdecl, dynlib꞉ dllname, varargs.@}
@example
proc treeSetfAttribute*(ih꞉ PIhandle; name꞉ cstring; id꞉ cint; format꞉ cstring) @{.importc꞉ "IupTreeSetfAttribute", cdecl, dynlib꞉ dllname, varargs.@}
@end example
  

@item isShift
  @findex proc isShift*(s꞉ cstring)꞉ bool
@example
proc isShift*(s꞉ cstring)꞉ bool
@end example
  

@item isControl
  @findex proc isControl*(s꞉ cstring)꞉ bool
@example
proc isControl*(s꞉ cstring)꞉ bool
@end example
  

@item isButton1
  @findex proc isButton1*(s꞉ cstring)꞉ bool
@example
proc isButton1*(s꞉ cstring)꞉ bool
@end example
  

@item isButton2
  @findex proc isButton2*(s꞉ cstring)꞉ bool
@example
proc isButton2*(s꞉ cstring)꞉ bool
@end example
  

@item isbutton3
  @findex proc isbutton3*(s꞉ cstring)꞉ bool
@example
proc isbutton3*(s꞉ cstring)꞉ bool
@end example
  

@item isDouble
  @findex proc isDouble*(s꞉ cstring)꞉ bool
@example
proc isDouble*(s꞉ cstring)꞉ bool
@end example
  

@item isAlt
  @findex proc isAlt*(s꞉ cstring)꞉ bool
@example
proc isAlt*(s꞉ cstring)꞉ bool
@end example
  

@item isSys
  @findex proc isSys*(s꞉ cstring)꞉ bool
@example
proc isSys*(s꞉ cstring)꞉ bool
@end example
  

@item isButton4
  @findex proc isButton4*(s꞉ cstring)꞉ bool
@example
proc isButton4*(s꞉ cstring)꞉ bool
@end example
  

@item isButton5
  @findex proc isButton5*(s꞉ cstring)꞉ bool
@example
proc isButton5*(s꞉ cstring)꞉ bool
@end example
  

@item isPrint
  @findex proc isPrint*(c꞉ cint)꞉ bool
@example
proc isPrint*(c꞉ cint)꞉ bool
@end example
  

@item isXkey
  @findex proc isXkey*(c꞉ cint)꞉ bool
@example
proc isXkey*(c꞉ cint)꞉ bool
@end example
  

@item isShiftXkey
  @findex proc isShiftXkey*(c꞉ cint)꞉ bool
@example
proc isShiftXkey*(c꞉ cint)꞉ bool
@end example
  

@item isCtrlXkey
  @findex proc isCtrlXkey*(c꞉ cint)꞉ bool
@example
proc isCtrlXkey*(c꞉ cint)꞉ bool
@end example
  

@item isAltXkey
  @findex proc isAltXkey*(c꞉ cint)꞉ bool
@example
proc isAltXkey*(c꞉ cint)꞉ bool
@end example
  

@item isSysXkey
  @findex proc isSysXkey*(c꞉ cint)꞉ bool
@example
proc isSysXkey*(c꞉ cint)꞉ bool
@end example
  

@item iUPxCODE
  @findex proc iUPxCODE*(c꞉ cint)꞉ cint
@example
proc iUPxCODE*(c꞉ cint)꞉ cint
@end example
  

@item iUPsxCODE
  @findex proc iUPsxCODE*(c꞉ cint)꞉ cint
@example
proc iUPsxCODE*(c꞉ cint)꞉ cint
@end example
  

@item iUPcxCODE
  @findex proc iUPcxCODE*(c꞉ cint)꞉ cint
@example
proc iUPcxCODE*(c꞉ cint)꞉ cint
@end example
  

@item iUPmxCODE
  @findex proc iUPmxCODE*(c꞉ cint)꞉ cint
@example
proc iUPmxCODE*(c꞉ cint)꞉ cint
@end example
  

@item iUPyxCODE
  @findex proc iUPyxCODE*(c꞉ cint)꞉ cint
@example
proc iUPyxCODE*(c꞉ cint)꞉ cint
@end example
  

@item controlsOpen
  @findex proc controlsOpen*()꞉ cint @{.cdecl, importc꞉ "IupControlsOpen", dynlib꞉ dllname.@}
@example
proc controlsOpen*()꞉ cint @{.cdecl, importc꞉ "IupControlsOpen", dynlib꞉ dllname.@}
@end example
  

@item controlsClose
  @findex proc controlsClose*() @{.cdecl, importc꞉ "IupControlsClose", dynlib꞉ dllname.@}
@example
proc controlsClose*() @{.cdecl, importc꞉ "IupControlsClose", dynlib꞉ dllname.@}
@end example
  

@item oldValOpen
  @findex proc oldValOpen*() @{.cdecl, importc꞉ "IupOldValOpen", dynlib꞉ dllname.@}
@example
proc oldValOpen*() @{.cdecl, importc꞉ "IupOldValOpen", dynlib꞉ dllname.@}
@end example
  

@item oldTabsOpen
  @findex proc oldTabsOpen*() @{.cdecl, importc꞉ "IupOldTabsOpen", dynlib꞉ dllname.@}
@example
proc oldTabsOpen*() @{.cdecl, importc꞉ "IupOldTabsOpen", dynlib꞉ dllname.@}
@end example
  

@item colorbar
  @findex proc colorbar*()꞉ PIhandle @{.cdecl, importc꞉ "IupColorbar", dynlib꞉ dllname.@}
@example
proc colorbar*()꞉ PIhandle @{.cdecl, importc꞉ "IupColorbar", dynlib꞉ dllname.@}
@end example
  

@item cells
  @findex proc cells*()꞉ PIhandle @{.cdecl, importc꞉ "IupCells", dynlib꞉ dllname.@}
@example
proc cells*()꞉ PIhandle @{.cdecl, importc꞉ "IupCells", dynlib꞉ dllname.@}
@end example
  

@item colorBrowser
  @findex proc colorBrowser*()꞉ PIhandle @{.cdecl, importc꞉ "IupColorBrowser", dynlib꞉ dllname.@}
@example
proc colorBrowser*()꞉ PIhandle @{.cdecl, importc꞉ "IupColorBrowser", dynlib꞉ dllname.@}
@end example
  

@item gauge
  @findex proc gauge*()꞉ PIhandle @{.cdecl, importc꞉ "IupGauge", dynlib꞉ dllname.@}
@example
proc gauge*()꞉ PIhandle @{.cdecl, importc꞉ "IupGauge", dynlib꞉ dllname.@}
@end example
  

@item dial
  @findex proc dial*(theType꞉ cstring)꞉ PIhandle @{.cdecl, importc꞉ "IupDial", dynlib꞉ dllname.@}
@example
proc dial*(theType꞉ cstring)꞉ PIhandle @{.cdecl, importc꞉ "IupDial", dynlib꞉ dllname.@}
@end example
  

@item matrix
  @findex proc matrix*(action꞉ cstring)꞉ PIhandle @{.cdecl, importc꞉ "IupMatrix", dynlib꞉ dllname.@}
@example
proc matrix*(action꞉ cstring)꞉ PIhandle @{.cdecl, importc꞉ "IupMatrix", dynlib꞉ dllname.@}
@end example
  

@item matSetAttribute
  @findex proc matSetAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint; value꞉ cstring) @{.cdecl, importc꞉ "IupMatSetAttribute", dynlib꞉ dllname.@}
@example
proc matSetAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint; value꞉ cstring) @{.cdecl, importc꞉ "IupMatSetAttribute", dynlib꞉ dllname.@}
@end example
  

@item matStoreAttribute
  @findex proc matStoreAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint; value꞉ cstring) @{.cdecl, importc꞉ "IupMatStoreAttribute", dynlib꞉ dllname.@}
@example
proc matStoreAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint; value꞉ cstring) @{.cdecl, importc꞉ "IupMatStoreAttribute", dynlib꞉ dllname.@}
@end example
  

@item matGetAttribute
  @findex proc matGetAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint)꞉ cstring @{.cdecl,importc꞉ "IupMatGetAttribute", dynlib꞉ dllname.@}
@example
proc matGetAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint)꞉ cstring @{.cdecl,importc꞉ "IupMatGetAttribute", dynlib꞉ dllname.@}
@end example
  

@item matGetInt
  @findex proc matGetInt*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint)꞉ cint @{.cdecl,importc꞉ "IupMatGetInt", dynlib꞉ dllname.@}
@example
proc matGetInt*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint)꞉ cint @{.cdecl,importc꞉ "IupMatGetInt", dynlib꞉ dllname.@}
@end example
  

@item matGetFloat
  @findex proc matGetFloat*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint)꞉ cfloat @{.cdecl,importc꞉ "IupMatGetFloat", dynlib꞉ dllname.@}
@example
proc matGetFloat*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint)꞉ cfloat @{.cdecl,importc꞉ "IupMatGetFloat", dynlib꞉ dllname.@}
@end example
  

@item matSetfAttribute
  @findex proc matSetfAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint; format꞉ cstring) @{.cdecl, importc꞉ "IupMatSetfAttribute", dynlib꞉ dllname, varargs.@}
@example
proc matSetfAttribute*(ih꞉ PIhandle; name꞉ cstring; lin, col꞉ cint; format꞉ cstring) @{.cdecl, importc꞉ "IupMatSetfAttribute", dynlib꞉ dllname, varargs.@}
@end example
  

@item pPlotOpen
  @findex proc pPlotOpen*() @{.cdecl, importc꞉ "IupPPlotOpen", dynlib꞉ dllname.@}
@example
proc pPlotOpen*() @{.cdecl, importc꞉ "IupPPlotOpen", dynlib꞉ dllname.@}
@end example
  

@item pPlot
  @findex proc pPlot*()꞉ PIhandle @{.cdecl, importc꞉ "IupPPlot", dynlib꞉ dllname.@}
@example
proc pPlot*()꞉ PIhandle @{.cdecl, importc꞉ "IupPPlot", dynlib꞉ dllname.@}
@end example
  

@item pPlotBegin
  @findex proc pPlotBegin*(ih꞉ PIhandle; strXdata꞉ cint) @{.cdecl, importc꞉ "IupPPlotBegin",dynlib꞉ dllname.@}
@example
proc pPlotBegin*(ih꞉ PIhandle; strXdata꞉ cint) @{.cdecl, importc꞉ "IupPPlotBegin",dynlib꞉ dllname.@}
@end example
  

@item pPlotAdd
  @findex proc pPlotAdd*(ih꞉ PIhandle; x, y꞉ cfloat) @{.cdecl, importc꞉ "IupPPlotAdd",dynlib꞉ dllname.@}
@example
proc pPlotAdd*(ih꞉ PIhandle; x, y꞉ cfloat) @{.cdecl, importc꞉ "IupPPlotAdd",dynlib꞉ dllname.@}
@end example
  

@item pPlotAddStr
  @findex proc pPlotAddStr*(ih꞉ PIhandle; x꞉ cstring; y꞉ cfloat) @{.cdecl,importc꞉ "IupPPlotAddStr", dynlib꞉ dllname.@}
@example
proc pPlotAddStr*(ih꞉ PIhandle; x꞉ cstring; y꞉ cfloat) @{.cdecl,importc꞉ "IupPPlotAddStr", dynlib꞉ dllname.@}
@end example
  

@item pPlotEnd
  @findex proc pPlotEnd*(ih꞉ PIhandle)꞉ cint @{.cdecl, importc꞉ "IupPPlotEnd", dynlib꞉ dllname.@}
@example
proc pPlotEnd*(ih꞉ PIhandle)꞉ cint @{.cdecl, importc꞉ "IupPPlotEnd", dynlib꞉ dllname.@}
@end example
  

@item pPlotInsertStr
  @findex proc pPlotInsertStr*(ih꞉ PIhandle; index, sampleIndex꞉ cint; x꞉ cstring; y꞉ cfloat) @{.cdecl, importc꞉ "IupPPlotInsertStr", dynlib꞉ dllname.@}
@example
proc pPlotInsertStr*(ih꞉ PIhandle; index, sampleIndex꞉ cint; x꞉ cstring; y꞉ cfloat) @{.cdecl, importc꞉ "IupPPlotInsertStr", dynlib꞉ dllname.@}
@end example
  

@item pPlotInsert
  @findex proc pPlotInsert*(ih꞉ PIhandle; index, sampleIndex꞉ cint; x, y꞉ cfloat) @{.cdecl,importc꞉ "IupPPlotInsert", dynlib꞉ dllname.@}
@example
proc pPlotInsert*(ih꞉ PIhandle; index, sampleIndex꞉ cint; x, y꞉ cfloat) @{.cdecl,importc꞉ "IupPPlotInsert", dynlib꞉ dllname.@}
@end example
  

@item pPlotTransform
  @findex proc pPlotTransform*(ih꞉ PIhandle; x, y꞉ cfloat; ix, iy꞉ var cint) @{.cdecl,importc꞉ "IupPPlotTransform", dynlib꞉ dllname.@}
@example
proc pPlotTransform*(ih꞉ PIhandle; x, y꞉ cfloat; ix, iy꞉ var cint) @{.cdecl,importc꞉ "IupPPlotTransform", dynlib꞉ dllname.@}
@end example
  

@item pPlotPaintTo
  @findex proc pPlotPaintTo*(ih꞉ PIhandle; cnv꞉ pointer) @{.cdecl, importc꞉ "IupPPlotPaintTo",dynlib꞉ dllname.@}
@example
proc pPlotPaintTo*(ih꞉ PIhandle; cnv꞉ pointer) @{.cdecl, importc꞉ "IupPPlotPaintTo",dynlib꞉ dllname.@}
@end example
  
@end itemize






@node /wrappers/postgres, /wrappers/tinyc , /wrappers/iup, Top
@chapter Constant variables

@itemize


@item CMDSTATUS_LEN
  @vindex CMDSTATUS_LEN* = 40
@example
CMDSTATUS_LEN* = 40
@end example
  
@end itemize



@chapter Types

@itemize


@item Oid
  @tindex Oid* = int32
@example
Oid* = int32
@end example
  

@item PQArgBlock
  @tindex PQArgBlock* @{.pure, final.@} = object
  length*: int32
  isint*: int32
  p*: pointer

@example
PQArgBlock* @{.pure, final.@} = object
  length*: int32
  isint*: int32
  p*: pointer

@end example
  
@end itemize

@chapter Procedures

@itemize


@item pqconnectStart
  @findex proc pqconnectStart*(conninfo꞉ cstring)꞉ PPGconn @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconnectStart".@}
@example
proc pqconnectStart*(conninfo꞉ cstring)꞉ PPGconn @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconnectStart".@}
@end example
  

@item pqconnectPoll
  @findex proc pqconnectPoll*(conn꞉ PPGconn)꞉ PostgresPollingStatusType @{.cdecl,dynlib꞉ dllName, importc꞉ "PQconnectPoll".@}
@example
proc pqconnectPoll*(conn꞉ PPGconn)꞉ PostgresPollingStatusType @{.cdecl,dynlib꞉ dllName, importc꞉ "PQconnectPoll".@}
@end example
  

@item pqconnectdb
  @findex proc pqconnectdb*(conninfo꞉ cstring)꞉ PPGconn @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconnectdb".@}
@example
proc pqconnectdb*(conninfo꞉ cstring)꞉ PPGconn @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconnectdb".@}
@end example
  

@item pqsetdbLogin
  @findex proc pqsetdbLogin*(pghost꞉ cstring; pgport꞉ cstring; pgoptions꞉ cstring;pgtty꞉ cstring; dbName꞉ cstring; login꞉ cstring; pwd꞉ cstring)꞉ PPGconn @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsetdbLogin".@}
@example
proc pqsetdbLogin*(pghost꞉ cstring; pgport꞉ cstring; pgoptions꞉ cstring;pgtty꞉ cstring; dbName꞉ cstring; login꞉ cstring; pwd꞉ cstring)꞉ PPGconn @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsetdbLogin".@}
@end example
  

@item pqsetdb
  @findex proc pqsetdb*(M_PGHOST, M_PGPORT, M_PGOPT, M_PGTTY, M_DBNAME꞉ cstring)꞉ Ppgconn
@example
proc pqsetdb*(M_PGHOST, M_PGPORT, M_PGOPT, M_PGTTY, M_DBNAME꞉ cstring)꞉ Ppgconn
@end example
  

@item pqfinish
  @findex proc pqfinish*(conn꞉ PPGconn) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQfinish".@}
@example
proc pqfinish*(conn꞉ PPGconn) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQfinish".@}
@end example
  

@item pqconndefaults
  @findex proc pqconndefaults*()꞉ PPQconninfoOption @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconndefaults".@}
@example
proc pqconndefaults*()꞉ PPQconninfoOption @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconndefaults".@}
@end example
  

@item pqconninfoFree
  @findex proc pqconninfoFree*(connOptions꞉ PPQconninfoOption) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconninfoFree".@}
@example
proc pqconninfoFree*(connOptions꞉ PPQconninfoOption) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconninfoFree".@}
@end example
  

@item pqresetStart
  @findex proc pqresetStart*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresetStart".@}
@example
proc pqresetStart*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresetStart".@}
@end example
  

@item pqresetPoll
  @findex proc pqresetPoll*(conn꞉ PPGconn)꞉ PostgresPollingStatusType @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresetPoll".@}
@example
proc pqresetPoll*(conn꞉ PPGconn)꞉ PostgresPollingStatusType @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresetPoll".@}
@end example
  

@item pqreset
  @findex proc pqreset*(conn꞉ PPGconn) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQreset".@}
@example
proc pqreset*(conn꞉ PPGconn) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQreset".@}
@end example
  

@item pqrequestCancel
  @findex proc pqrequestCancel*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQrequestCancel".@}
@example
proc pqrequestCancel*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQrequestCancel".@}
@end example
  

@item pqdb
  @findex proc pqdb*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQdb".@}
@example
proc pqdb*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQdb".@}
@end example
  

@item pquser
  @findex proc pquser*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQuser".@}
@example
proc pquser*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQuser".@}
@end example
  

@item pqpass
  @findex proc pqpass*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQpass".@}
@example
proc pqpass*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQpass".@}
@end example
  

@item pqhost
  @findex proc pqhost*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQhost".@}
@example
proc pqhost*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQhost".@}
@end example
  

@item pqport
  @findex proc pqport*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQport".@}
@example
proc pqport*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQport".@}
@end example
  

@item pqtty
  @findex proc pqtty*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQtty".@}
@example
proc pqtty*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQtty".@}
@end example
  

@item pqoptions
  @findex proc pqoptions*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQoptions".@}
@example
proc pqoptions*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName, importc꞉ "PQoptions".@}
@end example
  

@item pqstatus
  @findex proc pqstatus*(conn꞉ PPGconn)꞉ ConnStatusType @{.cdecl, dynlib꞉ dllName,importc꞉ "PQstatus".@}
@example
proc pqstatus*(conn꞉ PPGconn)꞉ ConnStatusType @{.cdecl, dynlib꞉ dllName,importc꞉ "PQstatus".@}
@end example
  

@item pqtransactionStatus
  @findex proc pqtransactionStatus*(conn꞉ PPGconn)꞉ PGTransactionStatusType @{.cdecl,dynlib꞉ dllName, importc꞉ "PQtransactionStatus".@}
@example
proc pqtransactionStatus*(conn꞉ PPGconn)꞉ PGTransactionStatusType @{.cdecl,dynlib꞉ dllName, importc꞉ "PQtransactionStatus".@}
@end example
  

@item pqparameterStatus
  @findex proc pqparameterStatus*(conn꞉ PPGconn; paramName꞉ cstring)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQparameterStatus".@}
@example
proc pqparameterStatus*(conn꞉ PPGconn; paramName꞉ cstring)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQparameterStatus".@}
@end example
  

@item pqprotocolVersion
  @findex proc pqprotocolVersion*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprotocolVersion".@}
@example
proc pqprotocolVersion*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprotocolVersion".@}
@end example
  

@item pqerrorMessage
  @findex proc pqerrorMessage*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQerrorMessage".@}
@example
proc pqerrorMessage*(conn꞉ PPGconn)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQerrorMessage".@}
@end example
  

@item pqsocket
  @findex proc pqsocket*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsocket".@}
@example
proc pqsocket*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsocket".@}
@end example
  

@item pqbackendPID
  @findex proc pqbackendPID*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQbackendPID".@}
@example
proc pqbackendPID*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQbackendPID".@}
@end example
  

@item pqclientEncoding
  @findex proc pqclientEncoding*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQclientEncoding".@}
@example
proc pqclientEncoding*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQclientEncoding".@}
@end example
  

@item pqsetClientEncoding
  @findex proc pqsetClientEncoding*(conn꞉ PPGconn; encoding꞉ cstring)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQsetClientEncoding".@}
@example
proc pqsetClientEncoding*(conn꞉ PPGconn; encoding꞉ cstring)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQsetClientEncoding".@}
@end example
  

@item pqgetssl
  @findex proc pqgetssl*(conn꞉ PPGconn)꞉ PSSL @{.cdecl, dynlib꞉ dllName, importc꞉ "PQgetssl".@}
@example
proc pqgetssl*(conn꞉ PPGconn)꞉ PSSL @{.cdecl, dynlib꞉ dllName, importc꞉ "PQgetssl".@}
@end example
  

@item pqsetErrorVerbosity
  @findex proc pqsetErrorVerbosity*(conn꞉ PPGconn; verbosity꞉ PGVerbosity)꞉ PGVerbosity @{.cdecl,dynlib꞉ dllName, importc꞉ "PQsetErrorVerbosity".@}
@example
proc pqsetErrorVerbosity*(conn꞉ PPGconn; verbosity꞉ PGVerbosity)꞉ PGVerbosity @{.cdecl,dynlib꞉ dllName, importc꞉ "PQsetErrorVerbosity".@}
@end example
  

@item pqtrace
  @findex proc pqtrace*(conn꞉ PPGconn; debug_port꞉ File) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQtrace".@}
@example
proc pqtrace*(conn꞉ PPGconn; debug_port꞉ File) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQtrace".@}
@end example
  

@item pquntrace
  @findex proc pquntrace*(conn꞉ PPGconn) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQuntrace".@}
@example
proc pquntrace*(conn꞉ PPGconn) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQuntrace".@}
@end example
  

@item pqsetNoticeReceiver
  @findex proc pqsetNoticeReceiver*(conn꞉ PPGconn; theProc꞉ PQnoticeReceiver; arg꞉ pointer)꞉ PQnoticeReceiver @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsetNoticeReceiver".@}
@example
proc pqsetNoticeReceiver*(conn꞉ PPGconn; theProc꞉ PQnoticeReceiver; arg꞉ pointer)꞉ PQnoticeReceiver @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsetNoticeReceiver".@}
@end example
  

@item pqsetNoticeProcessor
  @findex proc pqsetNoticeProcessor*(conn꞉ PPGconn; theProc꞉ PQnoticeProcessor; arg꞉ pointer)꞉ PQnoticeProcessor @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsetNoticeProcessor".@}
@example
proc pqsetNoticeProcessor*(conn꞉ PPGconn; theProc꞉ PQnoticeProcessor; arg꞉ pointer)꞉ PQnoticeProcessor @{.cdecl, dynlib꞉ dllName, importc꞉ "PQsetNoticeProcessor".@}
@end example
  

@item pqexec
  @findex proc pqexec*(conn꞉ PPGconn; query꞉ cstring)꞉ PPGresult @{.cdecl, dynlib꞉ dllName,importc꞉ "PQexec".@}
@example
proc pqexec*(conn꞉ PPGconn; query꞉ cstring)꞉ PPGresult @{.cdecl, dynlib꞉ dllName,importc꞉ "PQexec".@}
@end example
  

@item pqexecParams
  @findex proc pqexecParams*(conn: PPGconn; command: cstring; nParams: int32; paramTypes: POid;
                  paramValues: cstringArray;
                  paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult @{.
    cdecl, dynlib: dllName, importc: "PQexecParams".@}
@example
proc pqexecParams*(conn: PPGconn; command: cstring; nParams: int32; paramTypes: POid;
                  paramValues: cstringArray;
                  paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult @{.
    cdecl, dynlib: dllName, importc: "PQexecParams".@}
@end example
  

@item pqprepare
  @findex proc pqprepare*(conn꞉ PPGconn; stmtName, query꞉ cstring; nParams꞉ int32;paramTypes꞉ POid)꞉ PPGresult @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprepare".@}
@example
proc pqprepare*(conn꞉ PPGconn; stmtName, query꞉ cstring; nParams꞉ int32;paramTypes꞉ POid)꞉ PPGresult @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprepare".@}
@end example
  

@item pqexecPrepared
  @findex proc pqexecPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;
                    paramValues: cstringArray;
                    paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult @{.
    cdecl, dynlib: dllName, importc: "PQexecPrepared".@}
@example
proc pqexecPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;
                    paramValues: cstringArray;
                    paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult @{.
    cdecl, dynlib: dllName, importc: "PQexecPrepared".@}
@end example
  

@item pqsendQuery
  @findex proc pqsendQuery*(conn꞉ PPGconn; query꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQsendQuery".@}
@example
proc pqsendQuery*(conn꞉ PPGconn; query꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQsendQuery".@}
@end example
  

@item pqsendQueryParams
  @findex proc pqsendQueryParams*(conn: PPGconn; command: cstring; nParams: int32;
                       paramTypes: POid; paramValues: cstringArray;
                       paramLengths, paramFormats: ptr int32; resultFormat: int32): int32 @{.
    cdecl, dynlib: dllName, importc: "PQsendQueryParams".@}
@example
proc pqsendQueryParams*(conn: PPGconn; command: cstring; nParams: int32;
                       paramTypes: POid; paramValues: cstringArray;
                       paramLengths, paramFormats: ptr int32; resultFormat: int32): int32 @{.
    cdecl, dynlib: dllName, importc: "PQsendQueryParams".@}
@end example
  

@item pqsendQueryPrepared
  @findex proc pqsendQueryPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;
                         paramValues: cstringArray;
                         paramLengths, paramFormats: ptr int32; resultFormat: int32): int32 @{.
    cdecl, dynlib: dllName, importc: "PQsendQueryPrepared".@}
@example
proc pqsendQueryPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32;
                         paramValues: cstringArray;
                         paramLengths, paramFormats: ptr int32; resultFormat: int32): int32 @{.
    cdecl, dynlib: dllName, importc: "PQsendQueryPrepared".@}
@end example
  

@item pqgetResult
  @findex proc pqgetResult*(conn꞉ PPGconn)꞉ PPGresult @{.cdecl, dynlib꞉ dllName,importc꞉ "PQgetResult".@}
@example
proc pqgetResult*(conn꞉ PPGconn)꞉ PPGresult @{.cdecl, dynlib꞉ dllName,importc꞉ "PQgetResult".@}
@end example
  

@item pqisBusy
  @findex proc pqisBusy*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQisBusy".@}
@example
proc pqisBusy*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQisBusy".@}
@end example
  

@item pqconsumeInput
  @findex proc pqconsumeInput*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconsumeInput".@}
@example
proc pqconsumeInput*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQconsumeInput".@}
@end example
  

@item pqnotifies
  @findex proc pqnotifies*(conn꞉ PPGconn)꞉ PPGnotify @{.cdecl, dynlib꞉ dllName,importc꞉ "PQnotifies".@}
@example
proc pqnotifies*(conn꞉ PPGconn)꞉ PPGnotify @{.cdecl, dynlib꞉ dllName,importc꞉ "PQnotifies".@}
@end example
  

@item pqputCopyData
  @findex proc pqputCopyData*(conn꞉ PPGconn; buffer꞉ cstring; nbytes꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQputCopyData".@}
@example
proc pqputCopyData*(conn꞉ PPGconn; buffer꞉ cstring; nbytes꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQputCopyData".@}
@end example
  

@item pqputCopyEnd
  @findex proc pqputCopyEnd*(conn꞉ PPGconn; errormsg꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQputCopyEnd".@}
@example
proc pqputCopyEnd*(conn꞉ PPGconn; errormsg꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQputCopyEnd".@}
@end example
  

@item pqgetCopyData
  @findex proc pqgetCopyData*(conn꞉ PPGconn; buffer꞉ cstringArray; async꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetCopyData".@}
@example
proc pqgetCopyData*(conn꞉ PPGconn; buffer꞉ cstringArray; async꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetCopyData".@}
@end example
  

@item pqgetline
  @findex proc pqgetline*(conn꞉ PPGconn; str꞉ cstring; len꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQgetline".@}
@example
proc pqgetline*(conn꞉ PPGconn; str꞉ cstring; len꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQgetline".@}
@end example
  

@item pqputline
  @findex proc pqputline*(conn꞉ PPGconn; str꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQputline".@}
@example
proc pqputline*(conn꞉ PPGconn; str꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQputline".@}
@end example
  

@item pqgetlineAsync
  @findex proc pqgetlineAsync*(conn꞉ PPGconn; buffer꞉ cstring; bufsize꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetlineAsync".@}
@example
proc pqgetlineAsync*(conn꞉ PPGconn; buffer꞉ cstring; bufsize꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetlineAsync".@}
@end example
  

@item pqputnbytes
  @findex proc pqputnbytes*(conn꞉ PPGconn; buffer꞉ cstring; nbytes꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQputnbytes".@}
@example
proc pqputnbytes*(conn꞉ PPGconn; buffer꞉ cstring; nbytes꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQputnbytes".@}
@end example
  

@item pqendcopy
  @findex proc pqendcopy*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQendcopy".@}
@example
proc pqendcopy*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQendcopy".@}
@end example
  

@item pqsetnonblocking
  @findex proc pqsetnonblocking*(conn꞉ PPGconn; arg꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQsetnonblocking".@}
@example
proc pqsetnonblocking*(conn꞉ PPGconn; arg꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQsetnonblocking".@}
@end example
  

@item pqisnonblocking
  @findex proc pqisnonblocking*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQisnonblocking".@}
@example
proc pqisnonblocking*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQisnonblocking".@}
@end example
  

@item pqflush
  @findex proc pqflush*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQflush".@}
@example
proc pqflush*(conn꞉ PPGconn)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQflush".@}
@end example
  

@item pqfn
  @findex proc pqfn*(conn꞉ PPGconn; fnid꞉ int32; result_buf, result_len꞉ ptr int32;result_is_int꞉ int32; args꞉ PPQArgBlock; nargs꞉ int32)꞉ PPGresult @{.cdecl,dynlib꞉ dllName, importc꞉ "PQfn".@}
@example
proc pqfn*(conn꞉ PPGconn; fnid꞉ int32; result_buf, result_len꞉ ptr int32;result_is_int꞉ int32; args꞉ PPQArgBlock; nargs꞉ int32)꞉ PPGresult @{.cdecl,dynlib꞉ dllName, importc꞉ "PQfn".@}
@end example
  

@item pqresultStatus
  @findex proc pqresultStatus*(res꞉ PPGresult)꞉ ExecStatusType @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresultStatus".@}
@example
proc pqresultStatus*(res꞉ PPGresult)꞉ ExecStatusType @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresultStatus".@}
@end example
  

@item pqresStatus
  @findex proc pqresStatus*(status꞉ ExecStatusType)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresStatus".@}
@example
proc pqresStatus*(status꞉ ExecStatusType)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresStatus".@}
@end example
  

@item pqresultErrorMessage
  @findex proc pqresultErrorMessage*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresultErrorMessage".@}
@example
proc pqresultErrorMessage*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQresultErrorMessage".@}
@end example
  

@item pqresultErrorField
  @findex proc pqresultErrorField*(res꞉ PPGresult; fieldcode꞉ int32)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQresultErrorField".@}
@example
proc pqresultErrorField*(res꞉ PPGresult; fieldcode꞉ int32)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQresultErrorField".@}
@end example
  

@item pqntuples
  @findex proc pqntuples*(res꞉ PPGresult)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQntuples".@}
@example
proc pqntuples*(res꞉ PPGresult)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQntuples".@}
@end example
  

@item pqnfields
  @findex proc pqnfields*(res꞉ PPGresult)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQnfields".@}
@example
proc pqnfields*(res꞉ PPGresult)꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQnfields".@}
@end example
  

@item pqbinaryTuples
  @findex proc pqbinaryTuples*(res꞉ PPGresult)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQbinaryTuples".@}
@example
proc pqbinaryTuples*(res꞉ PPGresult)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQbinaryTuples".@}
@end example
  

@item pqfname
  @findex proc pqfname*(res꞉ PPGresult; field_num꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfname".@}
@example
proc pqfname*(res꞉ PPGresult; field_num꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfname".@}
@end example
  

@item pqfnumber
  @findex proc pqfnumber*(res꞉ PPGresult; field_name꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfnumber".@}
@example
proc pqfnumber*(res꞉ PPGresult; field_name꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfnumber".@}
@end example
  

@item pqftable
  @findex proc pqftable*(res꞉ PPGresult; field_num꞉ int32)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "PQftable".@}
@example
proc pqftable*(res꞉ PPGresult; field_num꞉ int32)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "PQftable".@}
@end example
  

@item pqftablecol
  @findex proc pqftablecol*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQftablecol".@}
@example
proc pqftablecol*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQftablecol".@}
@end example
  

@item pqfformat
  @findex proc pqfformat*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfformat".@}
@example
proc pqfformat*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfformat".@}
@end example
  

@item pqftype
  @findex proc pqftype*(res꞉ PPGresult; field_num꞉ int32)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "PQftype".@}
@example
proc pqftype*(res꞉ PPGresult; field_num꞉ int32)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "PQftype".@}
@end example
  

@item pqfsize
  @findex proc pqfsize*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfsize".@}
@example
proc pqfsize*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfsize".@}
@end example
  

@item pqfmod
  @findex proc pqfmod*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfmod".@}
@example
proc pqfmod*(res꞉ PPGresult; field_num꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQfmod".@}
@end example
  

@item pqcmdStatus
  @findex proc pqcmdStatus*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQcmdStatus".@}
@example
proc pqcmdStatus*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQcmdStatus".@}
@end example
  

@item pqoidStatus
  @findex proc pqoidStatus*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQoidStatus".@}
@example
proc pqoidStatus*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQoidStatus".@}
@end example
  

@item pqoidValue
  @findex proc pqoidValue*(res꞉ PPGresult)꞉ Oid @{.cdecl, dynlib꞉ dllName, importc꞉ "PQoidValue".@}
@example
proc pqoidValue*(res꞉ PPGresult)꞉ Oid @{.cdecl, dynlib꞉ dllName, importc꞉ "PQoidValue".@}
@end example
  

@item pqcmdTuples
  @findex proc pqcmdTuples*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQcmdTuples".@}
@example
proc pqcmdTuples*(res꞉ PPGresult)꞉ cstring @{.cdecl, dynlib꞉ dllName,importc꞉ "PQcmdTuples".@}
@end example
  

@item pqgetvalue
  @findex proc pqgetvalue*(res꞉ PPGresult; tup_num꞉ int32; field_num꞉ int32)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetvalue".@}
@example
proc pqgetvalue*(res꞉ PPGresult; tup_num꞉ int32; field_num꞉ int32)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetvalue".@}
@end example
  

@item pqgetlength
  @findex proc pqgetlength*(res꞉ PPGresult; tup_num꞉ int32; field_num꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetlength".@}
@example
proc pqgetlength*(res꞉ PPGresult; tup_num꞉ int32; field_num꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetlength".@}
@end example
  

@item pqgetisnull
  @findex proc pqgetisnull*(res꞉ PPGresult; tup_num꞉ int32; field_num꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetisnull".@}
@example
proc pqgetisnull*(res꞉ PPGresult; tup_num꞉ int32; field_num꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "PQgetisnull".@}
@end example
  

@item pqclear
  @findex proc pqclear*(res꞉ PPGresult) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQclear".@}
@example
proc pqclear*(res꞉ PPGresult) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQclear".@}
@end example
  

@item pqfreemem
  @findex proc pqfreemem*(p꞉ pointer) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQfreemem".@}
@example
proc pqfreemem*(p꞉ pointer) @{.cdecl, dynlib꞉ dllName, importc꞉ "PQfreemem".@}
@end example
  

@item pqmakeEmptyPGresult
  @findex proc pqmakeEmptyPGresult*(conn꞉ PPGconn; status꞉ ExecStatusType)꞉ PPGresult @{.cdecl,dynlib꞉ dllName, importc꞉ "PQmakeEmptyPGresult".@}
@example
proc pqmakeEmptyPGresult*(conn꞉ PPGconn; status꞉ ExecStatusType)꞉ PPGresult @{.cdecl,dynlib꞉ dllName, importc꞉ "PQmakeEmptyPGresult".@}
@end example
  

@item pqescapeString
  @findex proc pqescapeString*(till, `from`꞉ cstring; len꞉ int)꞉ int @{.cdecl, dynlib꞉ dllName,importc꞉ "PQescapeString".@}
@example
proc pqescapeString*(till, `from`꞉ cstring; len꞉ int)꞉ int @{.cdecl, dynlib꞉ dllName,importc꞉ "PQescapeString".@}
@end example
  

@item pqescapeBytea
  @findex proc pqescapeBytea*(bintext꞉ cstring; binlen꞉ int; bytealen꞉ var int)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQescapeBytea".@}
@example
proc pqescapeBytea*(bintext꞉ cstring; binlen꞉ int; bytealen꞉ var int)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQescapeBytea".@}
@end example
  

@item pqunescapeBytea
  @findex proc pqunescapeBytea*(strtext꞉ cstring; retbuflen꞉ var int)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQunescapeBytea".@}
@example
proc pqunescapeBytea*(strtext꞉ cstring; retbuflen꞉ var int)꞉ cstring @{.cdecl,dynlib꞉ dllName, importc꞉ "PQunescapeBytea".@}
@end example
  

@item pqprint
  @findex proc pqprint*(fout꞉ File; res꞉ PPGresult; ps꞉ PPQprintOpt) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprint".@}
@example
proc pqprint*(fout꞉ File; res꞉ PPGresult; ps꞉ PPQprintOpt) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprint".@}
@end example
  

@item pqdisplayTuples
  @findex proc pqdisplayTuples*(res꞉ PPGresult; fp꞉ File; fillAlign꞉ int32; fieldSep꞉ cstring;printHeader꞉ int32; quiet꞉ int32) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQdisplayTuples".@}
@example
proc pqdisplayTuples*(res꞉ PPGresult; fp꞉ File; fillAlign꞉ int32; fieldSep꞉ cstring;printHeader꞉ int32; quiet꞉ int32) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQdisplayTuples".@}
@end example
  

@item pqprintTuples
  @findex proc pqprintTuples*(res꞉ PPGresult; fout꞉ File; printAttName꞉ int32;terseOutput꞉ int32; width꞉ int32) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprintTuples".@}
@example
proc pqprintTuples*(res꞉ PPGresult; fout꞉ File; printAttName꞉ int32;terseOutput꞉ int32; width꞉ int32) @{.cdecl, dynlib꞉ dllName,importc꞉ "PQprintTuples".@}
@end example
  

@item lo_open
  @findex proc lo_open*(conn꞉ PPGconn; lobjId꞉ Oid; mode꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_open".@}
@example
proc lo_open*(conn꞉ PPGconn; lobjId꞉ Oid; mode꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_open".@}
@end example
  

@item lo_close
  @findex proc lo_close*(conn꞉ PPGconn; fd꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_close".@}
@example
proc lo_close*(conn꞉ PPGconn; fd꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_close".@}
@end example
  

@item lo_read
  @findex proc lo_read*(conn꞉ PPGconn; fd꞉ int32; buf꞉ cstring; length꞉ int)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_read".@}
@example
proc lo_read*(conn꞉ PPGconn; fd꞉ int32; buf꞉ cstring; length꞉ int)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_read".@}
@end example
  

@item lo_write
  @findex proc lo_write*(conn꞉ PPGconn; fd꞉ int32; buf꞉ cstring; length꞉ int)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_write".@}
@example
proc lo_write*(conn꞉ PPGconn; fd꞉ int32; buf꞉ cstring; length꞉ int)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_write".@}
@end example
  

@item lo_lseek
  @findex proc lo_lseek*(conn꞉ PPGconn; fd꞉ int32; offset꞉ int32; whence꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_lseek".@}
@example
proc lo_lseek*(conn꞉ PPGconn; fd꞉ int32; offset꞉ int32; whence꞉ int32)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_lseek".@}
@end example
  

@item lo_creat
  @findex proc lo_creat*(conn꞉ PPGconn; mode꞉ int32)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_creat".@}
@example
proc lo_creat*(conn꞉ PPGconn; mode꞉ int32)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_creat".@}
@end example
  

@item lo_tell
  @findex proc lo_tell*(conn꞉ PPGconn; fd꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_tell".@}
@example
proc lo_tell*(conn꞉ PPGconn; fd꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_tell".@}
@end example
  

@item lo_unlink
  @findex proc lo_unlink*(conn꞉ PPGconn; lobjId꞉ Oid)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_unlink".@}
@example
proc lo_unlink*(conn꞉ PPGconn; lobjId꞉ Oid)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_unlink".@}
@end example
  

@item lo_import
  @findex proc lo_import*(conn꞉ PPGconn; filename꞉ cstring)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_import".@}
@example
proc lo_import*(conn꞉ PPGconn; filename꞉ cstring)꞉ Oid @{.cdecl, dynlib꞉ dllName,importc꞉ "lo_import".@}
@end example
  

@item lo_export
  @findex proc lo_export*(conn꞉ PPGconn; lobjId꞉ Oid; filename꞉ cstring)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_export".@}
@example
proc lo_export*(conn꞉ PPGconn; lobjId꞉ Oid; filename꞉ cstring)꞉ int32 @{.cdecl,dynlib꞉ dllName, importc꞉ "lo_export".@}
@end example
  

@item pqmblen
  @findex proc pqmblen*(s꞉ cstring; encoding꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQmblen".@}
@example
proc pqmblen*(s꞉ cstring; encoding꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ dllName,importc꞉ "PQmblen".@}
@end example
  

@item pqenv2encoding
  @findex proc pqenv2encoding*()꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQenv2encoding".@}
@example
proc pqenv2encoding*()꞉ int32 @{.cdecl, dynlib꞉ dllName, importc꞉ "PQenv2encoding".@}
@end example
  
@end itemize






@node /wrappers/tinyc, /wrappers/pcre , /wrappers/postgres, Top
@chapter Constant variables

@itemize


@item OutputFormatCoff
  @vindex OutputFormatCoff*꞉ cint = 2
@example
OutputFormatCoff*꞉ cint = 2
@end example
  COFF
@end itemize



@chapter Types

@itemize


@item ErrorFunc
  @tindex ErrorFunc* = proc (opaque꞉ pointer; msg꞉ cstring) @{.cdecl.@}
@example
ErrorFunc* = proc (opaque꞉ pointer; msg꞉ cstring) @{.cdecl.@}
@end example
  
@end itemize

@chapter Procedures

@itemize


@item openCCState
  @findex proc openCCState*()꞉ PccState @{.importc꞉ "tcc_new", cdecl.@}
@example
proc openCCState*()꞉ PccState @{.importc꞉ "tcc_new", cdecl.@}
@end example
  create a new TCC compilation context

@item closeCCState
  @findex proc closeCCState*(s꞉ PccState) @{.importc꞉ "tcc_delete", cdecl.@}
@example
proc closeCCState*(s꞉ PccState) @{.importc꞉ "tcc_delete", cdecl.@}
@end example
  free a TCC compilation context

@item enableDebug
  @findex proc enableDebug*(s꞉ PccState) @{.importc꞉ "tcc_enable_debug", cdecl.@}
@example
proc enableDebug*(s꞉ PccState) @{.importc꞉ "tcc_enable_debug", cdecl.@}
@end example
  add debug information in the generated code

@item setErrorFunc
  @findex proc setErrorFunc*(s꞉ PccState; errorOpaque꞉ pointer; errorFun꞉ ErrorFunc) @{.cdecl,importc꞉ "tcc_set_error_func".@}
@example
proc setErrorFunc*(s꞉ PccState; errorOpaque꞉ pointer; errorFun꞉ ErrorFunc) @{.cdecl,importc꞉ "tcc_set_error_func".@}
@end example
  set error/warning display callback

@item setWarning
  @findex proc setWarning*(s꞉ PccState; warningName꞉ cstring; value꞉ int) @{.cdecl,importc꞉ "tcc_set_warning".@}
@example
proc setWarning*(s꞉ PccState; warningName꞉ cstring; value꞉ int) @{.cdecl,importc꞉ "tcc_set_warning".@}
@end example
  set/reset a warning

@item addIncludePath
  @findex proc addIncludePath*(s꞉ PccState; pathname꞉ cstring) @{.cdecl,importc꞉ "tcc_add_include_path".@}
@example
proc addIncludePath*(s꞉ PccState; pathname꞉ cstring) @{.cdecl,importc꞉ "tcc_add_include_path".@}
@end example
  add include path

@item addSysincludePath
  @findex proc addSysincludePath*(s꞉ PccState; pathname꞉ cstring) @{.cdecl,importc꞉ "tcc_add_sysinclude_path".@}
@example
proc addSysincludePath*(s꞉ PccState; pathname꞉ cstring) @{.cdecl,importc꞉ "tcc_add_sysinclude_path".@}
@end example
  add in system include path

@item defineSymbol
  @findex proc defineSymbol*(s꞉ PccState; sym, value꞉ cstring) @{.cdecl,importc꞉ "tcc_define_symbol".@}
@example
proc defineSymbol*(s꞉ PccState; sym, value꞉ cstring) @{.cdecl,importc꞉ "tcc_define_symbol".@}
@end example
  define preprocessor symbol 'sym'. Can put optional value

@item undefineSymbol
  @findex proc undefineSymbol*(s꞉ PccState; sym꞉ cstring) @{.cdecl,importc꞉ "tcc_undefine_symbol".@}
@example
proc undefineSymbol*(s꞉ PccState; sym꞉ cstring) @{.cdecl,importc꞉ "tcc_undefine_symbol".@}
@end example
  undefine preprocess symbol 'sym'

@item addFile
  @findex proc addFile*(s꞉ PccState; filename꞉ cstring)꞉ cint @{.cdecl, importc꞉ "tcc_add_file".@}
@example
proc addFile*(s꞉ PccState; filename꞉ cstring)꞉ cint @{.cdecl, importc꞉ "tcc_add_file".@}
@end example
  add a file (either a C file, dll, an object, a library or an ld script). Return -1 if error.

@item compileString
  @findex proc compileString*(s꞉ PccState; buf꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_compile_string".@}
@example
proc compileString*(s꞉ PccState; buf꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_compile_string".@}
@end example
  compile a string containing a C source. Return non zero if error.

@item setOutputType
  @findex proc setOutputType*(s꞉ PCCState; outputType꞉ cint)꞉ cint @{.cdecl,importc꞉ "tcc_set_output_type".@}
@example
proc setOutputType*(s꞉ PCCState; outputType꞉ cint)꞉ cint @{.cdecl,importc꞉ "tcc_set_output_type".@}
@end example
  set output type. MUST BE CALLED before any compilation

@item addLibraryPath
  @findex proc addLibraryPath*(s꞉ PccState; pathname꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_add_library_path".@}
@example
proc addLibraryPath*(s꞉ PccState; pathname꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_add_library_path".@}
@end example
  equivalent to -Lpath option

@item addLibrary
  @findex proc addLibrary*(s꞉ PCCState; libraryname꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_add_library".@}
@example
proc addLibrary*(s꞉ PCCState; libraryname꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_add_library".@}
@end example
  the library name is the same as the argument of the '-l' option

@item addSymbol
  @findex proc addSymbol*(s꞉ PccState; name꞉ cstring; val꞉ pointer)꞉ cint @{.cdecl,importc꞉ "tcc_add_symbol".@}
@example
proc addSymbol*(s꞉ PccState; name꞉ cstring; val꞉ pointer)꞉ cint @{.cdecl,importc꞉ "tcc_add_symbol".@}
@end example
  add a symbol to the compiled program

@item outputFile
  @findex proc outputFile*(s꞉ PccState; filename꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_output_file".@}
@example
proc outputFile*(s꞉ PccState; filename꞉ cstring)꞉ cint @{.cdecl,importc꞉ "tcc_output_file".@}
@end example
  output an executable, library or object file. DO NOT call tcc_relocate() before.

@item run
  @findex proc run*(s꞉ PccState; argc꞉ cint; argv꞉ cstringArray)꞉ cint @{.cdecl, importc꞉ "tcc_run".@}
@example
proc run*(s꞉ PccState; argc꞉ cint; argv꞉ cstringArray)꞉ cint @{.cdecl, importc꞉ "tcc_run".@}
@end example
  link and run main() function and return its value. DO NOT call tcc_relocate() before.

@item relocate
  @findex proc relocate*(s꞉ PccState; p꞉ pointer)꞉ cint @{.cdecl, importc꞉ "tcc_relocate".@}
@example
proc relocate*(s꞉ PccState; p꞉ pointer)꞉ cint @{.cdecl, importc꞉ "tcc_relocate".@}
@end example
  copy code into memory passed in by the caller and do all relocations (needed before using tcc_get_symbol()). returns -1 on error and required size if ptr is NULL

@item getSymbol
  @findex proc getSymbol*(s꞉ PccState; name꞉ cstring)꞉ pointer @{.cdecl, importc꞉ "tcc_get_symbol".@}
@example
proc getSymbol*(s꞉ PccState; name꞉ cstring)꞉ pointer @{.cdecl, importc꞉ "tcc_get_symbol".@}
@end example
  return symbol value or NULL if not found

@item setLibPath
  @findex proc setLibPath*(s꞉ PccState; path꞉ cstring) @{.cdecl, importc꞉ "tcc_set_lib_path".@}
@example
proc setLibPath*(s꞉ PccState; path꞉ cstring) @{.cdecl, importc꞉ "tcc_set_lib_path".@}
@end example
  set CONFIG_TCCDIR at runtime
@end itemize






@node /wrappers/pcre, /wrappers/sqlite3 , /wrappers/tinyc, Top
@chapter Constant variables

@itemize


@item PCRE_DATE
  @vindex PCRE_DATE* = "2014-09-26"
@example
PCRE_DATE* = "2014-09-26"
@end example
  

@item PARTIAL
  @vindex PARTIAL* = 0x00008000
@example
PARTIAL* = 0x00008000
@end example
  

@item DFA_SHORTEST
  @vindex DFA_SHORTEST* = 0x00010000
@example
DFA_SHORTEST* = 0x00010000
@end example
  

@item DFA_RESTART
  @vindex DFA_RESTART* = 0x00020000
@example
DFA_RESTART* = 0x00020000
@end example
  

@item UCP
  @vindex UCP* = 0x20000000
@example
UCP* = 0x20000000
@end example
  

@item ERROR_UNSET
  @vindex ERROR_UNSET* = - 33
@example
ERROR_UNSET* = - 33
@end example
  

@item UTF8_ERR22
  @vindex UTF8_ERR22* = 22
@example
UTF8_ERR22* = 22
@end example
  

@item UTF16_ERR4
  @vindex UTF16_ERR4* = 4
@example
UTF16_ERR4* = 4
@end example
  

@item UTF32_ERR3
  @vindex UTF32_ERR3* = 3
@example
UTF32_ERR3* = 3
@end example
  

@item INFO_MATCH_EMPTY
  @vindex INFO_MATCH_EMPTY* = 25
@example
INFO_MATCH_EMPTY* = 25
@end example
  

@item CONFIG_PARENS_LIMIT
  @vindex CONFIG_PARENS_LIMIT* = 13
@example
CONFIG_PARENS_LIMIT* = 13
@end example
  

@item STUDY_EXTRA_NEEDED
  @vindex STUDY_EXTRA_NEEDED* = 0x00000008
@example
STUDY_EXTRA_NEEDED* = 0x00000008
@end example
  

@item EXTRA_EXECUTABLE_JIT
  @vindex EXTRA_EXECUTABLE_JIT* = 0x00000040
@example
EXTRA_EXECUTABLE_JIT* = 0x00000040
@end example
  
@end itemize



@chapter Types

@itemize


@item JitStack32
  @tindex JitStack32* = object
@example
JitStack32* = object
@end example
  

@item ExtraData
  @tindex ExtraData* = object
  flags*: clong
  study_data*: pointer         ## Opaque data from pcre_study()
  match_limit*: clong          ## Maximum number of calls to match()
  callout_data*: pointer       ## Data passed back in callouts
  tables*: pointer             ## Pointer to character tables
  match_limit_recursion*: clong ## Max recursive calls to match()
  mark*: pointer               ## For passing back a mark pointer
  executable_jit*: pointer     ## Contains a pointer to a compiled jit code
  
@example
ExtraData* = object
  flags*: clong
  study_data*: pointer         ## Opaque data from pcre_study()
  match_limit*: clong          ## Maximum number of calls to match()
  callout_data*: pointer       ## Data passed back in callouts
  tables*: pointer             ## Pointer to character tables
  match_limit_recursion*: clong ## Max recursive calls to match()
  mark*: pointer               ## For passing back a mark pointer
  executable_jit*: pointer     ## Contains a pointer to a compiled jit code
  
@end example
  Bits for which fields are set

@item CalloutBlock
  @tindex CalloutBlock* = object
  version*: cint
  callout_number*: cint        ## Number compiled into pattern
  offset_vector*: ptr cint      ## The offset vector
  subject*: cstring            ## The subject being matched
  subject_length*: cint        ## The length of the subject
  start_match*: cint           ## Offset to start of this match attempt
  current_position*: cint      ## Where we currently are in the subject
  capture_top*: cint           ## Max current capture
  capture_last*: cint          ## Most recently closed capture
  callout_data*: pointer       ## Data passed in with the call
  pattern_position*: cint      ## Offset to next item in the pattern
  next_item_length*: cint      ## Length of next item in the pattern
  mark*: pointer               ## Pointer to current mark or NULL
  
@example
CalloutBlock* = object
  version*: cint
  callout_number*: cint        ## Number compiled into pattern
  offset_vector*: ptr cint      ## The offset vector
  subject*: cstring            ## The subject being matched
  subject_length*: cint        ## The length of the subject
  start_match*: cint           ## Offset to start of this match attempt
  current_position*: cint      ## Where we currently are in the subject
  capture_top*: cint           ## Max current capture
  capture_last*: cint          ## Most recently closed capture
  callout_data*: pointer       ## Data passed in with the call
  pattern_position*: cint      ## Offset to next item in the pattern
  next_item_length*: cint      ## Length of next item in the pattern
  mark*: pointer               ## Pointer to current mark or NULL
  
@end example
  Identifies version of block

@item JitCallback
  @tindex JitCallback* = proc (a꞉ pointer)꞉ ptr JitStack @{.cdecl.@}
@example
JitCallback* = proc (a꞉ pointer)꞉ ptr JitStack @{.cdecl.@}
@end example
  

@item PJitStack
  @tindex PJitStack* @{.deprecated.@} = ptr JitStack
@example
PJitStack* @{.deprecated.@} = ptr JitStack
@end example
  
@end itemize

@chapter Procedures

@itemize


@item compile
  @findex proc compile*(pattern꞉ cstring; options꞉ cint; errptr꞉ ptr cstring; erroffset꞉ ptr cint;tableptr꞉ pointer)꞉ ptr Pcre
@example
proc compile*(pattern꞉ cstring; options꞉ cint; errptr꞉ ptr cstring; erroffset꞉ ptr cint;tableptr꞉ pointer)꞉ ptr Pcre
@end example
  

@item compile2
  @findex proc compile2*(pattern꞉ cstring; options꞉ cint; errorcodeptr꞉ ptr cint;errptr꞉ ptr cstring; erroffset꞉ ptr cint; tableptr꞉ pointer)꞉ ptr Pcre
@example
proc compile2*(pattern꞉ cstring; options꞉ cint; errorcodeptr꞉ ptr cint;errptr꞉ ptr cstring; erroffset꞉ ptr cint; tableptr꞉ pointer)꞉ ptr Pcre
@end example
  

@item config
  @findex proc config*(what꞉ cint; where꞉ pointer)꞉ cint
@example
proc config*(what꞉ cint; where꞉ pointer)꞉ cint
@end example
  

@item copy_named_substring
  @findex proc copy_named_substring*(code꞉ ptr Pcre; subject꞉ cstring; ovector꞉ ptr cint;stringcount꞉ cint; stringname꞉ cstring; buffer꞉ cstring;buffersize꞉ cint)꞉ cint
@example
proc copy_named_substring*(code꞉ ptr Pcre; subject꞉ cstring; ovector꞉ ptr cint;stringcount꞉ cint; stringname꞉ cstring; buffer꞉ cstring;buffersize꞉ cint)꞉ cint
@end example
  

@item copy_substring
  @findex proc copy_substring*(subject꞉ cstring; ovector꞉ ptr cint; stringcount꞉ cint;stringnumber꞉ cint; buffer꞉ cstring; buffersize꞉ cint)꞉ cint
@example
proc copy_substring*(subject꞉ cstring; ovector꞉ ptr cint; stringcount꞉ cint;stringnumber꞉ cint; buffer꞉ cstring; buffersize꞉ cint)꞉ cint
@end example
  

@item dfa_exec
  @findex proc dfa_exec*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; subject꞉ cstring; length꞉ cint;startoffset꞉ cint; options꞉ cint; ovector꞉ ptr cint; ovecsize꞉ cint;workspace꞉ ptr cint; wscount꞉ cint)꞉ cint
@example
proc dfa_exec*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; subject꞉ cstring; length꞉ cint;startoffset꞉ cint; options꞉ cint; ovector꞉ ptr cint; ovecsize꞉ cint;workspace꞉ ptr cint; wscount꞉ cint)꞉ cint
@end example
  

@item exec
  @findex proc exec*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; subject꞉ cstring; length꞉ cint;startoffset꞉ cint; options꞉ cint; ovector꞉ ptr cint; ovecsize꞉ cint)꞉ cint
@example
proc exec*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; subject꞉ cstring; length꞉ cint;startoffset꞉ cint; options꞉ cint; ovector꞉ ptr cint; ovecsize꞉ cint)꞉ cint
@end example
  

@item jit_exec
  @findex proc jit_exec*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; subject꞉ cstring; length꞉ cint;startoffset꞉ cint; options꞉ cint; ovector꞉ ptr cint; ovecsize꞉ cint;jstack꞉ ptr JitStack)꞉ cint
@example
proc jit_exec*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; subject꞉ cstring; length꞉ cint;startoffset꞉ cint; options꞉ cint; ovector꞉ ptr cint; ovecsize꞉ cint;jstack꞉ ptr JitStack)꞉ cint
@end example
  

@item free_substring
  @findex proc free_substring*(stringptr꞉ cstring)
@example
proc free_substring*(stringptr꞉ cstring)
@end example
  

@item free_substring_list
  @findex proc free_substring_list*(stringptr꞉ cstringArray)
@example
proc free_substring_list*(stringptr꞉ cstringArray)
@end example
  

@item fullinfo
  @findex proc fullinfo*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; what꞉ cint; where꞉ pointer)꞉ cint
@example
proc fullinfo*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; what꞉ cint; where꞉ pointer)꞉ cint
@end example
  

@item get_named_substring
  @findex proc get_named_substring*(code꞉ ptr Pcre; subject꞉ cstring; ovector꞉ ptr cint;stringcount꞉ cint; stringname꞉ cstring;stringptr꞉ cstringArray)꞉ cint
@example
proc get_named_substring*(code꞉ ptr Pcre; subject꞉ cstring; ovector꞉ ptr cint;stringcount꞉ cint; stringname꞉ cstring;stringptr꞉ cstringArray)꞉ cint
@end example
  

@item get_stringnumber
  @findex proc get_stringnumber*(code꞉ ptr Pcre; name꞉ cstring)꞉ cint
@example
proc get_stringnumber*(code꞉ ptr Pcre; name꞉ cstring)꞉ cint
@end example
  

@item get_stringtable_entries
  @findex proc get_stringtable_entries*(code꞉ ptr Pcre; name꞉ cstring; first꞉ cstringArray;last꞉ cstringArray)꞉ cint
@example
proc get_stringtable_entries*(code꞉ ptr Pcre; name꞉ cstring; first꞉ cstringArray;last꞉ cstringArray)꞉ cint
@end example
  

@item get_substring
  @findex proc get_substring*(subject꞉ cstring; ovector꞉ ptr cint; stringcount꞉ cint;stringnumber꞉ cint; stringptr꞉ cstringArray)꞉ cint
@example
proc get_substring*(subject꞉ cstring; ovector꞉ ptr cint; stringcount꞉ cint;stringnumber꞉ cint; stringptr꞉ cstringArray)꞉ cint
@end example
  

@item get_substring_list
  @findex proc get_substring_list*(subject꞉ cstring; ovector꞉ ptr cint; stringcount꞉ cint;listptr꞉ ptr cstringArray)꞉ cint
@example
proc get_substring_list*(subject꞉ cstring; ovector꞉ ptr cint; stringcount꞉ cint;listptr꞉ ptr cstringArray)꞉ cint
@end example
  

@item maketables
  @findex proc maketables*()꞉ pointer
@example
proc maketables*()꞉ pointer
@end example
  

@item refcount
  @findex proc refcount*(code꞉ ptr Pcre; adjust꞉ cint)꞉ cint
@example
proc refcount*(code꞉ ptr Pcre; adjust꞉ cint)꞉ cint
@end example
  

@item study
  @findex proc study*(code꞉ ptr Pcre; options꞉ cint; errptr꞉ ptr cstring)꞉ ptr ExtraData
@example
proc study*(code꞉ ptr Pcre; options꞉ cint; errptr꞉ ptr cstring)꞉ ptr ExtraData
@end example
  

@item free_study
  @findex proc free_study*(extra꞉ ptr ExtraData)
@example
proc free_study*(extra꞉ ptr ExtraData)
@end example
  

@item version
  @findex proc version*()꞉ cstring
@example
proc version*()꞉ cstring
@end example
  

@item pattern_to_host_byte_order
  @findex proc pattern_to_host_byte_order*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; tables꞉ pointer)꞉ cint
@example
proc pattern_to_host_byte_order*(code꞉ ptr Pcre; extra꞉ ptr ExtraData; tables꞉ pointer)꞉ cint
@end example
  

@item jit_stack_alloc
  @findex proc jit_stack_alloc*(startsize꞉ cint; maxsize꞉ cint)꞉ ptr JitStack
@example
proc jit_stack_alloc*(startsize꞉ cint; maxsize꞉ cint)꞉ ptr JitStack
@end example
  

@item jit_stack_free
  @findex proc jit_stack_free*(stack꞉ ptr JitStack)
@example
proc jit_stack_free*(stack꞉ ptr JitStack)
@end example
  

@item assign_jit_stack
  @findex proc assign_jit_stack*(extra꞉ ptr ExtraData; callback꞉ JitCallback; data꞉ pointer)
@example
proc assign_jit_stack*(extra꞉ ptr ExtraData; callback꞉ JitCallback; data꞉ pointer)
@end example
  

@item jit_free_unused_memory
  @findex proc jit_free_unused_memory*()
@example
proc jit_free_unused_memory*()
@end example
  

@item study
  @findex proc study*(code꞉ ptr Pcre; options꞉ cint; errptr꞉ var cstring)꞉ ptr ExtraData @{.deprecated.@}
@example
proc study*(code꞉ ptr Pcre; options꞉ cint; errptr꞉ var cstring)꞉ ptr ExtraData @{.deprecated.@}
@end example
  
@end itemize






@node /wrappers/sqlite3, /wrappers/mysql , /wrappers/pcre, Top
@chapter Constant variables

@itemize


@item SQLITE_DETERMINISTIC
  @vindex SQLITE_DETERMINISTIC* = 0x00000800
@example
SQLITE_DETERMINISTIC* = 0x00000800
@end example
  

@item SQLITE_TRANSIENT
  @vindex SQLITE_TRANSIENT* = cast[pointer](- 1)
@example
SQLITE_TRANSIENT* = cast[pointer](- 1)
@end example
  
@end itemize



@chapter Types

@itemize


@item Collation_needed_func
  @tindex Collation_needed_func* = proc (para1꞉ pointer; para2꞉ PSqlite3; eTextRep꞉ int32;para4꞉ cstring) @{.cdecl.@}
@example
Collation_needed_func* = proc (para1꞉ pointer; para2꞉ PSqlite3; eTextRep꞉ int32;para4꞉ cstring) @{.cdecl.@}
@end example
  
@end itemize

@chapter Procedures

@itemize


@item close
  @findex proc close*(para1꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_close".@}
@example
proc close*(para1꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_close".@}
@end example
  

@item exec
  @findex proc exec*(para1꞉ PSqlite3; sql꞉ cstring; para3꞉ Callback; para4꞉ pointer;errmsg꞉ var cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_exec".@}
@example
proc exec*(para1꞉ PSqlite3; sql꞉ cstring; para3꞉ Callback; para4꞉ pointer;errmsg꞉ var cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_exec".@}
@end example
  

@item last_insert_rowid
  @findex proc last_insert_rowid*(para1꞉ PSqlite3)꞉ int64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_last_insert_rowid".@}
@example
proc last_insert_rowid*(para1꞉ PSqlite3)꞉ int64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_last_insert_rowid".@}
@end example
  

@item changes
  @findex proc changes*(para1꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_changes".@}
@example
proc changes*(para1꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_changes".@}
@end example
  

@item total_changes
  @findex proc total_changes*(para1꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_total_changes".@}
@example
proc total_changes*(para1꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_total_changes".@}
@end example
  

@item interrupt
  @findex proc interrupt*(para1꞉ PSqlite3) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_interrupt".@}
@example
proc interrupt*(para1꞉ PSqlite3) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_interrupt".@}
@end example
  

@item complete
  @findex proc complete*(sql꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_complete".@}
@example
proc complete*(sql꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_complete".@}
@end example
  

@item complete16
  @findex proc complete16*(sql꞉ pointer)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_complete16".@}
@example
proc complete16*(sql꞉ pointer)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_complete16".@}
@end example
  

@item busy_handler
  @findex proc busy_handler*(para1: PSqlite3;
                  para2: proc (para1: pointer; para2: int32): int32 @{.cdecl.@};
                  para3: pointer): int32 @{.cdecl, dynlib: Lib,
                                        importc: "sqlite3_busy_handler".@}
@example
proc busy_handler*(para1: PSqlite3;
                  para2: proc (para1: pointer; para2: int32): int32 @{.cdecl.@};
                  para3: pointer): int32 @{.cdecl, dynlib: Lib,
                                        importc: "sqlite3_busy_handler".@}
@end example
  

@item busy_timeout
  @findex proc busy_timeout*(para1꞉ PSqlite3; ms꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_busy_timeout".@}
@example
proc busy_timeout*(para1꞉ PSqlite3; ms꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_busy_timeout".@}
@end example
  

@item get_table
  @findex proc get_table*(para1꞉ PSqlite3; sql꞉ cstring; resultp꞉ var cstringArray;nrow, ncolumn꞉ var cint; errmsg꞉ ptr cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_get_table".@}
@example
proc get_table*(para1꞉ PSqlite3; sql꞉ cstring; resultp꞉ var cstringArray;nrow, ncolumn꞉ var cint; errmsg꞉ ptr cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_get_table".@}
@end example
  

@item free_table
  @findex proc free_table*(result꞉ cstringArray) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_free_table".@}
@example
proc free_table*(result꞉ cstringArray) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_free_table".@}
@end example
  

@item mprintf
  @findex proc mprintf*(para1꞉ cstring)꞉ cstring @{.cdecl, varargs, dynlib꞉ Lib,importc꞉ "sqlite3_mprintf".@}
@example
proc mprintf*(para1꞉ cstring)꞉ cstring @{.cdecl, varargs, dynlib꞉ Lib,importc꞉ "sqlite3_mprintf".@}
@end example
  

@item free
  @findex proc free*(z꞉ cstring) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_free".@}
@example
proc free*(z꞉ cstring) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_free".@}
@end example
  

@item snprintf
  @findex proc snprintf*(para1꞉ int32; para2꞉ cstring; para3꞉ cstring)꞉ cstring @{.cdecl,dynlib꞉ Lib, varargs, importc꞉ "sqlite3_snprintf".@}
@example
proc snprintf*(para1꞉ int32; para2꞉ cstring; para3꞉ cstring)꞉ cstring @{.cdecl,dynlib꞉ Lib, varargs, importc꞉ "sqlite3_snprintf".@}
@end example
  

@item set_authorizer
  @findex proc set_authorizer*(para1: PSqlite3; xAuth: proc (para1: pointer; para2: int32;
    para3: cstring; para4: cstring; para5: cstring; para6: cstring): int32 @{.cdecl.@};
                    pUserData: pointer): int32 @{.cdecl, dynlib: Lib,
    importc: "sqlite3_set_authorizer".@}
@example
proc set_authorizer*(para1: PSqlite3; xAuth: proc (para1: pointer; para2: int32;
    para3: cstring; para4: cstring; para5: cstring; para6: cstring): int32 @{.cdecl.@};
                    pUserData: pointer): int32 @{.cdecl, dynlib: Lib,
    importc: "sqlite3_set_authorizer".@}
@end example
  

@item trace
  @findex proc trace*(para1꞉ PSqlite3;xTrace꞉ proc (para1꞉ pointer; para2꞉ cstring) @{.cdecl.@}; para3꞉ pointer)꞉ pointer @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_trace".@}
@example
proc trace*(para1꞉ PSqlite3;xTrace꞉ proc (para1꞉ pointer; para2꞉ cstring) @{.cdecl.@}; para3꞉ pointer)꞉ pointer @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_trace".@}
@end example
  

@item progress_handler
  @findex proc progress_handler*(para1꞉ PSqlite3; para2꞉ int32;para3꞉ proc (para1꞉ pointer)꞉ int32 @{.cdecl.@}; para4꞉ pointer) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_progress_handler".@}
@example
proc progress_handler*(para1꞉ PSqlite3; para2꞉ int32;para3꞉ proc (para1꞉ pointer)꞉ int32 @{.cdecl.@}; para4꞉ pointer) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_progress_handler".@}
@end example
  

@item commit_hook
  @findex proc commit_hook*(para1꞉ PSqlite3; para2꞉ proc (para1꞉ pointer)꞉ int32 @{.cdecl.@};para3꞉ pointer)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_commit_hook".@}
@example
proc commit_hook*(para1꞉ PSqlite3; para2꞉ proc (para1꞉ pointer)꞉ int32 @{.cdecl.@};para3꞉ pointer)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_commit_hook".@}
@end example
  

@item open
  @findex proc open*(filename꞉ cstring; ppDb꞉ var PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_open".@}
@example
proc open*(filename꞉ cstring; ppDb꞉ var PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_open".@}
@end example
  

@item open16
  @findex proc open16*(filename꞉ pointer; ppDb꞉ var PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_open16".@}
@example
proc open16*(filename꞉ pointer; ppDb꞉ var PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_open16".@}
@end example
  

@item errcode
  @findex proc errcode*(db꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_errcode".@}
@example
proc errcode*(db꞉ PSqlite3)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_errcode".@}
@end example
  

@item errmsg
  @findex proc errmsg*(para1꞉ PSqlite3)꞉ cstring @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_errmsg".@}
@example
proc errmsg*(para1꞉ PSqlite3)꞉ cstring @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_errmsg".@}
@end example
  

@item errmsg16
  @findex proc errmsg16*(para1꞉ PSqlite3)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_errmsg16".@}
@example
proc errmsg16*(para1꞉ PSqlite3)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_errmsg16".@}
@end example
  

@item prepare
  @findex proc prepare*(db꞉ PSqlite3; zSql꞉ cstring; nBytes꞉ int32; ppStmt꞉ var Pstmt;pzTail꞉ ptr cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_prepare".@}
@example
proc prepare*(db꞉ PSqlite3; zSql꞉ cstring; nBytes꞉ int32; ppStmt꞉ var Pstmt;pzTail꞉ ptr cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_prepare".@}
@end example
  

@item prepare_v2
  @findex proc prepare_v2*(db꞉ PSqlite3; zSql꞉ cstring; nByte꞉ cint; ppStmt꞉ var Pstmt;pzTail꞉ ptr cstring)꞉ cint @{.importc꞉ "sqlite3_prepare_v2", cdecl,dynlib꞉ Lib.@}
@example
proc prepare_v2*(db꞉ PSqlite3; zSql꞉ cstring; nByte꞉ cint; ppStmt꞉ var Pstmt;pzTail꞉ ptr cstring)꞉ cint @{.importc꞉ "sqlite3_prepare_v2", cdecl,dynlib꞉ Lib.@}
@end example
  

@item prepare16
  @findex proc prepare16*(db꞉ PSqlite3; zSql꞉ pointer; nBytes꞉ int32; ppStmt꞉ var Pstmt;pzTail꞉ var pointer)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_prepare16".@}
@example
proc prepare16*(db꞉ PSqlite3; zSql꞉ pointer; nBytes꞉ int32; ppStmt꞉ var Pstmt;pzTail꞉ var pointer)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_prepare16".@}
@end example
  

@item bind_blob
  @findex proc bind_blob*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; n꞉ int32;para5꞉ Tbind_destructor_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_blob".@}
@example
proc bind_blob*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; n꞉ int32;para5꞉ Tbind_destructor_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_blob".@}
@end example
  

@item bind_double
  @findex proc bind_double*(para1꞉ Pstmt; para2꞉ int32; para3꞉ float64)꞉ int32 @{.cdecl,dynlib꞉ Lib, importc꞉ "sqlite3_bind_double".@}
@example
proc bind_double*(para1꞉ Pstmt; para2꞉ int32; para3꞉ float64)꞉ int32 @{.cdecl,dynlib꞉ Lib, importc꞉ "sqlite3_bind_double".@}
@end example
  

@item bind_int
  @findex proc bind_int*(para1꞉ Pstmt; para2꞉ int32; para3꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_int".@}
@example
proc bind_int*(para1꞉ Pstmt; para2꞉ int32; para3꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_int".@}
@end example
  

@item bind_int64
  @findex proc bind_int64*(para1꞉ Pstmt; para2꞉ int32; para3꞉ int64)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_int64".@}
@example
proc bind_int64*(para1꞉ Pstmt; para2꞉ int32; para3꞉ int64)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_int64".@}
@end example
  

@item bind_null
  @findex proc bind_null*(para1꞉ Pstmt; para2꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_null".@}
@example
proc bind_null*(para1꞉ Pstmt; para2꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_null".@}
@end example
  

@item bind_text
  @findex proc bind_text*(para1꞉ Pstmt; para2꞉ int32; para3꞉ cstring; n꞉ int32;para5꞉ Tbind_destructor_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_text".@}
@example
proc bind_text*(para1꞉ Pstmt; para2꞉ int32; para3꞉ cstring; n꞉ int32;para5꞉ Tbind_destructor_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_text".@}
@end example
  

@item bind_text16
  @findex proc bind_text16*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; para4꞉ int32;para5꞉ Tbind_destructor_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_text16".@}
@example
proc bind_text16*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; para4꞉ int32;para5꞉ Tbind_destructor_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_text16".@}
@end example
  

@item bind_blob
  @findex proc bind_blob*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; n꞉ int32; para5꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_bind_blob".@}
@example
proc bind_blob*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; n꞉ int32; para5꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_bind_blob".@}
@end example
  

@item bind_text
  @findex proc bind_text*(para1꞉ Pstmt; para2꞉ int32; para3꞉ cstring; n꞉ int32; para5꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_bind_text".@}
@example
proc bind_text*(para1꞉ Pstmt; para2꞉ int32; para3꞉ cstring; n꞉ int32; para5꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_bind_text".@}
@end example
  

@item bind_text16
  @findex proc bind_text16*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; para4꞉ int32; para5꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_bind_text16".@}
@example
proc bind_text16*(para1꞉ Pstmt; para2꞉ int32; para3꞉ pointer; para4꞉ int32; para5꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_bind_text16".@}
@end example
  

@item bind_parameter_count
  @findex proc bind_parameter_count*(para1꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_parameter_count".@}
@example
proc bind_parameter_count*(para1꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_parameter_count".@}
@end example
  

@item bind_parameter_name
  @findex proc bind_parameter_name*(para1꞉ Pstmt; para2꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_parameter_name".@}
@example
proc bind_parameter_name*(para1꞉ Pstmt; para2꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_parameter_name".@}
@end example
  

@item bind_parameter_index
  @findex proc bind_parameter_index*(para1꞉ Pstmt; zName꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_parameter_index".@}
@example
proc bind_parameter_index*(para1꞉ Pstmt; zName꞉ cstring)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_bind_parameter_index".@}
@end example
  

@item column_count
  @findex proc column_count*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_count".@}
@example
proc column_count*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_count".@}
@end example
  

@item column_name
  @findex proc column_name*(para1꞉ Pstmt; para2꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_name".@}
@example
proc column_name*(para1꞉ Pstmt; para2꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_name".@}
@end example
  

@item column_table_name
  @findex proc column_table_name*(para1꞉ Pstmt; para2꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_table_name".@}
@example
proc column_table_name*(para1꞉ Pstmt; para2꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_table_name".@}
@end example
  

@item column_name16
  @findex proc column_name16*(para1꞉ Pstmt; para2꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_name16".@}
@example
proc column_name16*(para1꞉ Pstmt; para2꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_name16".@}
@end example
  

@item column_decltype
  @findex proc column_decltype*(para1꞉ Pstmt; i꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_decltype".@}
@example
proc column_decltype*(para1꞉ Pstmt; i꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_decltype".@}
@end example
  

@item column_decltype16
  @findex proc column_decltype16*(para1꞉ Pstmt; para2꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_decltype16".@}
@example
proc column_decltype16*(para1꞉ Pstmt; para2꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_decltype16".@}
@end example
  

@item step
  @findex proc step*(para1꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_step".@}
@example
proc step*(para1꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_step".@}
@end example
  

@item data_count
  @findex proc data_count*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_data_count".@}
@example
proc data_count*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_data_count".@}
@end example
  

@item column_blob
  @findex proc column_blob*(para1꞉ Pstmt; iCol꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_blob".@}
@example
proc column_blob*(para1꞉ Pstmt; iCol꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_blob".@}
@end example
  

@item column_bytes
  @findex proc column_bytes*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_bytes".@}
@example
proc column_bytes*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_bytes".@}
@end example
  

@item column_bytes16
  @findex proc column_bytes16*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_bytes16".@}
@example
proc column_bytes16*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_bytes16".@}
@end example
  

@item column_double
  @findex proc column_double*(para1꞉ Pstmt; iCol꞉ int32)꞉ float64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_double".@}
@example
proc column_double*(para1꞉ Pstmt; iCol꞉ int32)꞉ float64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_double".@}
@end example
  

@item column_int
  @findex proc column_int*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_int".@}
@example
proc column_int*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_int".@}
@end example
  

@item column_int64
  @findex proc column_int64*(para1꞉ Pstmt; iCol꞉ int32)꞉ int64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_int64".@}
@example
proc column_int64*(para1꞉ Pstmt; iCol꞉ int32)꞉ int64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_int64".@}
@end example
  

@item column_text
  @findex proc column_text*(para1꞉ Pstmt; iCol꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_text".@}
@example
proc column_text*(para1꞉ Pstmt; iCol꞉ int32)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_text".@}
@end example
  

@item column_text16
  @findex proc column_text16*(para1꞉ Pstmt; iCol꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_text16".@}
@example
proc column_text16*(para1꞉ Pstmt; iCol꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_text16".@}
@end example
  

@item column_type
  @findex proc column_type*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_type".@}
@example
proc column_type*(para1꞉ Pstmt; iCol꞉ int32)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_column_type".@}
@end example
  

@item finalize
  @findex proc finalize*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_finalize".@}
@example
proc finalize*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_finalize".@}
@end example
  

@item reset
  @findex proc reset*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_reset".@}
@example
proc reset*(pStmt꞉ Pstmt)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_reset".@}
@end example
  

@item create_function
  @findex proc create_function*(para1: PSqlite3; zFunctionName: cstring; nArg: int32;
                     eTextRep: int32; para5: pointer;
                     xFunc: Create_function_func_func;
                     xStep: Create_function_step_func;
                     xFinal: Create_function_final_func): int32 @{.cdecl,
    dynlib: Lib, importc: "sqlite3_create_function".@}
@example
proc create_function*(para1: PSqlite3; zFunctionName: cstring; nArg: int32;
                     eTextRep: int32; para5: pointer;
                     xFunc: Create_function_func_func;
                     xStep: Create_function_step_func;
                     xFinal: Create_function_final_func): int32 @{.cdecl,
    dynlib: Lib, importc: "sqlite3_create_function".@}
@end example
  

@item create_function16
  @findex proc create_function16*(para1: PSqlite3; zFunctionName: pointer; nArg: int32;
                       eTextRep: int32; para5: pointer;
                       xFunc: Create_function_func_func;
                       xStep: Create_function_step_func;
                       xFinal: Create_function_final_func): int32 @{.cdecl,
    dynlib: Lib, importc: "sqlite3_create_function16".@}
@example
proc create_function16*(para1: PSqlite3; zFunctionName: pointer; nArg: int32;
                       eTextRep: int32; para5: pointer;
                       xFunc: Create_function_func_func;
                       xStep: Create_function_step_func;
                       xFinal: Create_function_final_func): int32 @{.cdecl,
    dynlib: Lib, importc: "sqlite3_create_function16".@}
@end example
  

@item aggregate_count
  @findex proc aggregate_count*(para1꞉ Pcontext)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_aggregate_count".@}
@example
proc aggregate_count*(para1꞉ Pcontext)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_aggregate_count".@}
@end example
  

@item value_blob
  @findex proc value_blob*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_blob".@}
@example
proc value_blob*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_blob".@}
@end example
  

@item value_bytes
  @findex proc value_bytes*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_bytes".@}
@example
proc value_bytes*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_bytes".@}
@end example
  

@item value_bytes16
  @findex proc value_bytes16*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_bytes16".@}
@example
proc value_bytes16*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_bytes16".@}
@end example
  

@item value_double
  @findex proc value_double*(para1꞉ Pvalue)꞉ float64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_double".@}
@example
proc value_double*(para1꞉ Pvalue)꞉ float64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_double".@}
@end example
  

@item value_int
  @findex proc value_int*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_int".@}
@example
proc value_int*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_int".@}
@end example
  

@item value_int64
  @findex proc value_int64*(para1꞉ Pvalue)꞉ int64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_int64".@}
@example
proc value_int64*(para1꞉ Pvalue)꞉ int64 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_int64".@}
@end example
  

@item value_text
  @findex proc value_text*(para1꞉ Pvalue)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text".@}
@example
proc value_text*(para1꞉ Pvalue)꞉ cstring @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text".@}
@end example
  

@item value_text16
  @findex proc value_text16*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text16".@}
@example
proc value_text16*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text16".@}
@end example
  

@item value_text16le
  @findex proc value_text16le*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text16le".@}
@example
proc value_text16le*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text16le".@}
@end example
  

@item value_text16be
  @findex proc value_text16be*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text16be".@}
@example
proc value_text16be*(para1꞉ Pvalue)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_text16be".@}
@end example
  

@item value_type
  @findex proc value_type*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_type".@}
@example
proc value_type*(para1꞉ Pvalue)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_value_type".@}
@end example
  

@item aggregate_context
  @findex proc aggregate_context*(para1꞉ Pcontext; nBytes꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_aggregate_context".@}
@example
proc aggregate_context*(para1꞉ Pcontext; nBytes꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_aggregate_context".@}
@end example
  

@item user_data
  @findex proc user_data*(para1꞉ Pcontext)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_user_data".@}
@example
proc user_data*(para1꞉ Pcontext)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_user_data".@}
@end example
  

@item get_auxdata
  @findex proc get_auxdata*(para1꞉ Pcontext; para2꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_get_auxdata".@}
@example
proc get_auxdata*(para1꞉ Pcontext; para2꞉ int32)꞉ pointer @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_get_auxdata".@}
@end example
  

@item set_auxdata
  @findex proc set_auxdata*(para1꞉ Pcontext; para2꞉ int32; para3꞉ pointer;para4꞉ proc (para1꞉ pointer) @{.cdecl.@}) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_set_auxdata".@}
@example
proc set_auxdata*(para1꞉ Pcontext; para2꞉ int32; para3꞉ pointer;para4꞉ proc (para1꞉ pointer) @{.cdecl.@}) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_set_auxdata".@}
@end example
  

@item result_blob
  @findex proc result_blob*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_blob".@}
@example
proc result_blob*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_blob".@}
@end example
  

@item result_double
  @findex proc result_double*(para1꞉ Pcontext; para2꞉ float64) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_double".@}
@example
proc result_double*(para1꞉ Pcontext; para2꞉ float64) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_double".@}
@end example
  

@item result_error
  @findex proc result_error*(para1꞉ Pcontext; para2꞉ cstring; para3꞉ int32) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_error".@}
@example
proc result_error*(para1꞉ Pcontext; para2꞉ cstring; para3꞉ int32) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_error".@}
@end example
  

@item result_error16
  @findex proc result_error16*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32) @{.cdecl,dynlib꞉ Lib, importc꞉ "sqlite3_result_error16".@}
@example
proc result_error16*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32) @{.cdecl,dynlib꞉ Lib, importc꞉ "sqlite3_result_error16".@}
@end example
  

@item result_int
  @findex proc result_int*(para1꞉ Pcontext; para2꞉ int32) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_int".@}
@example
proc result_int*(para1꞉ Pcontext; para2꞉ int32) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_int".@}
@end example
  

@item result_int64
  @findex proc result_int64*(para1꞉ Pcontext; para2꞉ int64) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_int64".@}
@example
proc result_int64*(para1꞉ Pcontext; para2꞉ int64) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_int64".@}
@end example
  

@item result_null
  @findex proc result_null*(para1꞉ Pcontext) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_null".@}
@example
proc result_null*(para1꞉ Pcontext) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_null".@}
@end example
  

@item result_text
  @findex proc result_text*(para1꞉ Pcontext; para2꞉ cstring; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text".@}
@example
proc result_text*(para1꞉ Pcontext; para2꞉ cstring; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text".@}
@end example
  

@item result_text16
  @findex proc result_text16*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text16".@}
@example
proc result_text16*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text16".@}
@end example
  

@item result_text16le
  @findex proc result_text16le*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text16le".@}
@example
proc result_text16le*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text16le".@}
@end example
  

@item result_text16be
  @findex proc result_text16be*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text16be".@}
@example
proc result_text16be*(para1꞉ Pcontext; para2꞉ pointer; para3꞉ int32; para4꞉ Result_func) @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_result_text16be".@}
@end example
  

@item result_value
  @findex proc result_value*(para1꞉ Pcontext; para2꞉ Pvalue) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_value".@}
@example
proc result_value*(para1꞉ Pcontext; para2꞉ Pvalue) @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_result_value".@}
@end example
  

@item create_collation
  @findex proc create_collation*(para1꞉ PSqlite3; zName꞉ cstring; eTextRep꞉ int32;para4꞉ pointer; xCompare꞉ Create_collation_func)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_create_collation".@}
@example
proc create_collation*(para1꞉ PSqlite3; zName꞉ cstring; eTextRep꞉ int32;para4꞉ pointer; xCompare꞉ Create_collation_func)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_create_collation".@}
@end example
  

@item create_collation16
  @findex proc create_collation16*(para1꞉ PSqlite3; zName꞉ cstring; eTextRep꞉ int32;para4꞉ pointer; xCompare꞉ Create_collation_func)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_create_collation16".@}
@example
proc create_collation16*(para1꞉ PSqlite3; zName꞉ cstring; eTextRep꞉ int32;para4꞉ pointer; xCompare꞉ Create_collation_func)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_create_collation16".@}
@end example
  

@item collation_needed
  @findex proc collation_needed*(para1꞉ PSqlite3; para2꞉ pointer; para3꞉ Collation_needed_func)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_collation_needed".@}
@example
proc collation_needed*(para1꞉ PSqlite3; para2꞉ pointer; para3꞉ Collation_needed_func)꞉ int32 @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_collation_needed".@}
@end example
  

@item collation_needed16
  @findex proc collation_needed16*(para1꞉ PSqlite3; para2꞉ pointer;para3꞉ Collation_needed_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_collation_needed16".@}
@example
proc collation_needed16*(para1꞉ PSqlite3; para2꞉ pointer;para3꞉ Collation_needed_func)꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_collation_needed16".@}
@end example
  

@item libversion
  @findex proc libversion*()꞉ cstring @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_libversion".@}
@example
proc libversion*()꞉ cstring @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_libversion".@}
@end example
  

@item version
  @findex proc version*()꞉ cstring @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_libversion".@}
@example
proc version*()꞉ cstring @{.cdecl, dynlib꞉ Lib, importc꞉ "sqlite3_libversion".@}
@end example
  

@item libversion_number
  @findex proc libversion_number*()꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_libversion_number".@}
@example
proc libversion_number*()꞉ int32 @{.cdecl, dynlib꞉ Lib,importc꞉ "sqlite3_libversion_number".@}
@end example
  
@end itemize






@node /wrappers/mysql, /wrappers/joyent_http_parser , /wrappers/sqlite3, Top
@chapter Constant variables

@itemize


@item LOCAL_HOST_NAMEDPIPE
  @vindex LOCAL_HOST_NAMEDPIPE* = '.'
@example
LOCAL_HOST_NAMEDPIPE* = '.'
@end example
  

@item SERVICENAME
  @vindex SERVICENAME* = "MySQL"
@example
SERVICENAME* = "MySQL"
@end example
  

@item ONLY_KILL_QUERY
  @vindex ONLY_KILL_QUERY* = 1
@example
ONLY_KILL_QUERY* = 1
@end example
  

@item MAX_BLOB_WIDTH
  @vindex MAX_BLOB_WIDTH* = 8192
@example
MAX_BLOB_WIDTH* = 8192
@end example
  

@item packet_error
  @vindex packet_error* = - 1
@example
packet_error* = - 1
@end example
  

@item SHUTDOWN_KILLABLE_UPDATE
  @vindex SHUTDOWN_KILLABLE_UPDATE* = chr(1 shl 3)
@example
SHUTDOWN_KILLABLE_UPDATE* = chr(1 shl 3)
@end example
  

@item COMP_HEADER_SIZE
  @vindex COMP_HEADER_SIZE* = 3
@example
COMP_HEADER_SIZE* = 3
@end example
  

@item NULL_LENGTH
  @vindex NULL_LENGTH*꞉ int = int(not (0))
@example
NULL_LENGTH*꞉ int = int(not (0))
@end example
  

@item LONG_DATA_HEADER
  @vindex LONG_DATA_HEADER* = 6
@example
LONG_DATA_HEADER* = 6
@end example
  

@item CLIENT_NET_WRITE_TIMEOUT
  @vindex CLIENT_NET_WRITE_TIMEOUT* = 365 * 24 * 3600
@example
CLIENT_NET_WRITE_TIMEOUT* = 365 * 24 * 3600
@end example
  

@item COUNT_ERROR
  @vindex COUNT_ERROR* = not (my_ulonglong(0))
@example
COUNT_ERROR* = not (my_ulonglong(0))
@end example
  

@item ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP
  @vindex ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP* = 10
@example
ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP* = 10
@end example
  

@item MANAGER_INTERNAL_ERR
  @vindex MANAGER_INTERNAL_ERR* = 500
@example
MANAGER_INTERNAL_ERR* = 500
@end example
  

@item LOCAL_INFILE_ERROR_LEN
  @vindex LOCAL_INFILE_ERROR_LEN* = 512
@example
LOCAL_INFILE_ERROR_LEN* = 512
@end example
  

@item DATA_TRUNCATED
  @vindex DATA_TRUNCATED* = 101
@example
DATA_TRUNCATED* = 101
@end example
  
@end itemize



@chapter Types

@itemize


@item cuint
  @tindex cuint* = cint
@example
cuint* = cint
@end example
  

@item Enum_server_command
  @tindex Enum_server_command* = enum
  COM_SLEEP, COM_QUIT, COM_INIT_DB, COM_QUERY, COM_FIELD_LIST, COM_CREATE_DB,
  COM_DROP_DB, COM_REFRESH, COM_SHUTDOWN, COM_STATISTICS, COM_PROCESS_INFO,
  COM_CONNECT, COM_PROCESS_KILL, COM_DEBUG, COM_PING, COM_TIME, COM_DELAYED_INSERT,
  COM_CHANGE_USER, COM_BINLOG_DUMP, COM_TABLE_DUMP, COM_CONNECT_OUT,
  COM_REGISTER_SLAVE, COM_STMT_PREPARE, COM_STMT_EXECUTE, COM_STMT_SEND_LONG_DATA,
  COM_STMT_CLOSE, COM_STMT_RESET, COM_SET_OPTION, COM_STMT_FETCH, COM_END
@example
Enum_server_command* = enum
  COM_SLEEP, COM_QUIT, COM_INIT_DB, COM_QUERY, COM_FIELD_LIST, COM_CREATE_DB,
  COM_DROP_DB, COM_REFRESH, COM_SHUTDOWN, COM_STATISTICS, COM_PROCESS_INFO,
  COM_CONNECT, COM_PROCESS_KILL, COM_DEBUG, COM_PING, COM_TIME, COM_DELAYED_INSERT,
  COM_CHANGE_USER, COM_BINLOG_DUMP, COM_TABLE_DUMP, COM_CONNECT_OUT,
  COM_REGISTER_SLAVE, COM_STMT_PREPARE, COM_STMT_EXECUTE, COM_STMT_SEND_LONG_DATA,
  COM_STMT_CLOSE, COM_STMT_RESET, COM_SET_OPTION, COM_STMT_FETCH, COM_END
@end example
  

@item PNET
  @tindex PNET* = ptr NET
@example
PNET* = ptr NET
@end example
  

@item Enum_field_types
  @tindex Enum_field_types* = enum
  TYPE_DECIMAL, TYPE_TINY, TYPE_SHORT, TYPE_LONG, TYPE_FLOAT, TYPE_DOUBLE, TYPE_NULL,
  TYPE_TIMESTAMP, TYPE_LONGLONG, TYPE_INT24, TYPE_DATE, TYPE_TIME, TYPE_DATETIME,
  TYPE_YEAR, TYPE_NEWDATE, TYPE_VARCHAR, TYPE_BIT, TYPE_NEWDECIMAL = 246,
  TYPE_ENUM = 247, TYPE_SET = 248, TYPE_TINY_BLOB = 249, TYPE_MEDIUM_BLOB = 250,
  TYPE_LONG_BLOB = 251, TYPE_BLOB = 252, TYPE_VAR_STRING = 253, TYPE_STRING = 254,
  TYPE_GEOMETRY = 255
@example
Enum_field_types* = enum
  TYPE_DECIMAL, TYPE_TINY, TYPE_SHORT, TYPE_LONG, TYPE_FLOAT, TYPE_DOUBLE, TYPE_NULL,
  TYPE_TIMESTAMP, TYPE_LONGLONG, TYPE_INT24, TYPE_DATE, TYPE_TIME, TYPE_DATETIME,
  TYPE_YEAR, TYPE_NEWDATE, TYPE_VARCHAR, TYPE_BIT, TYPE_NEWDECIMAL = 246,
  TYPE_ENUM = 247, TYPE_SET = 248, TYPE_TINY_BLOB = 249, TYPE_MEDIUM_BLOB = 250,
  TYPE_LONG_BLOB = 251, TYPE_BLOB = 252, TYPE_VAR_STRING = 253, TYPE_STRING = 254,
  TYPE_GEOMETRY = 255
@end example
  

@item Enum_mysql_set_option
  @tindex Enum_mysql_set_option* = enumOPTION_MULTI_STATEMENTS_ON, OPTION_MULTI_STATEMENTS_OFF
@example
Enum_mysql_set_option* = enumOPTION_MULTI_STATEMENTS_ON, OPTION_MULTI_STATEMENTS_OFF
@end example
  

@item Sockaddr
  @tindex Sockaddr* @{.final.@} = object
@example
Sockaddr* @{.final.@} = object
@end example
  

@item PUDF_INIT
  @tindex PUDF_INIT* = ptr UDF_INIT
@example
PUDF_INIT* = ptr UDF_INIT
@end example
  

@item FIELD_OFFSET
  @tindex FIELD_OFFSET* = cuint
@example
FIELD_OFFSET* = cuint
@end example
  

@item Pmy_ulonglong
  @tindex Pmy_ulonglong* = ptr my_ulonglong
@example
Pmy_ulonglong* = ptr my_ulonglong
@end example
  

@item ROW_OFFSET
  @tindex ROW_OFFSET* = ROWS
@example
ROW_OFFSET* = ROWS
@end example
  

@item PMEM_ROOT
  @tindex PMEM_ROOT* = ptr MEM_ROOT
@example
PMEM_ROOT* = ptr MEM_ROOT
@end example
  

@item Option
  @tindex Option* = enum
  OPT_CONNECT_TIMEOUT, OPT_COMPRESS, OPT_NAMED_PIPE, INIT_COMMAND,
  READ_DEFAULT_FILE, READ_DEFAULT_GROUP, SET_CHARSET_DIR, SET_CHARSET_NAME,
  OPT_LOCAL_INFILE, OPT_PROTOCOL, SHARED_MEMORY_BASE_NAME, OPT_READ_TIMEOUT,
  OPT_WRITE_TIMEOUT, OPT_USE_RESULT, OPT_USE_REMOTE_CONNECTION,
  OPT_USE_EMBEDDED_CONNECTION, OPT_GUESS_CONNECTION, SET_CLIENT_IP, SECURE_AUTH,
  REPORT_DATA_TRUNCATION, OPT_RECONNECT
@example
Option* = enum
  OPT_CONNECT_TIMEOUT, OPT_COMPRESS, OPT_NAMED_PIPE, INIT_COMMAND,
  READ_DEFAULT_FILE, READ_DEFAULT_GROUP, SET_CHARSET_DIR, SET_CHARSET_NAME,
  OPT_LOCAL_INFILE, OPT_PROTOCOL, SHARED_MEMORY_BASE_NAME, OPT_READ_TIMEOUT,
  OPT_WRITE_TIMEOUT, OPT_USE_RESULT, OPT_USE_REMOTE_CONNECTION,
  OPT_USE_EMBEDDED_CONNECTION, OPT_GUESS_CONNECTION, SET_CLIENT_IP, SECURE_AUTH,
  REPORT_DATA_TRUNCATION, OPT_RECONNECT
@end example
  

@item Enum_stmt_attr_type
  @tindex Enum_stmt_attr_type* = enumSTMT_ATTR_UPDATE_MAX_LENGTH, STMT_ATTR_CURSOR_TYPE, STMT_ATTR_PREFETCH_ROWS
@example
Enum_stmt_attr_type* = enumSTMT_ATTR_UPDATE_MAX_LENGTH, STMT_ATTR_CURSOR_TYPE, STMT_ATTR_PREFETCH_ROWS
@end example
  
@end itemize

@chapter Procedures

@itemize


@item my_net_init
  @findex proc my_net_init*(net꞉ PNET; vio꞉ PVio)꞉ my_bool @{.cdecl, dynlib꞉ lib,importc꞉ "my_net_init".@}
@example
proc my_net_init*(net꞉ PNET; vio꞉ PVio)꞉ my_bool @{.cdecl, dynlib꞉ lib,importc꞉ "my_net_init".@}
@end example
  

@item my_net_local_init
  @findex proc my_net_local_init*(net꞉ PNET) @{.cdecl, dynlib꞉ lib, importc꞉ "my_net_local_init".@}
@example
proc my_net_local_init*(net꞉ PNET) @{.cdecl, dynlib꞉ lib, importc꞉ "my_net_local_init".@}
@end example
  

@item net_end
  @findex proc net_end*(net꞉ PNET) @{.cdecl, dynlib꞉ lib, importc꞉ "net_end".@}
@example
proc net_end*(net꞉ PNET) @{.cdecl, dynlib꞉ lib, importc꞉ "net_end".@}
@end example
  

@item net_clear
  @findex proc net_clear*(net꞉ PNET) @{.cdecl, dynlib꞉ lib, importc꞉ "net_clear".@}
@example
proc net_clear*(net꞉ PNET) @{.cdecl, dynlib꞉ lib, importc꞉ "net_clear".@}
@end example
  

@item net_realloc
  @findex proc net_realloc*(net꞉ PNET; len꞉ int)꞉ my_bool @{.cdecl, dynlib꞉ lib,importc꞉ "net_realloc".@}
@example
proc net_realloc*(net꞉ PNET; len꞉ int)꞉ my_bool @{.cdecl, dynlib꞉ lib,importc꞉ "net_realloc".@}
@end example
  

@item net_flush
  @findex proc net_flush*(net꞉ PNET)꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "net_flush".@}
@example
proc net_flush*(net꞉ PNET)꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "net_flush".@}
@end example
  

@item my_net_write
  @findex proc my_net_write*(net꞉ PNET; packet꞉ cstring; length꞉ int)꞉ my_bool @{.cdecl,dynlib꞉ lib, importc꞉ "my_net_write".@}
@example
proc my_net_write*(net꞉ PNET; packet꞉ cstring; length꞉ int)꞉ my_bool @{.cdecl,dynlib꞉ lib, importc꞉ "my_net_write".@}
@end example
  

@item net_write_command
  @findex proc net_write_command*(net꞉ PNET; command꞉ char; header꞉ cstring; head_len꞉ int;packet꞉ cstring; length꞉ int)꞉ my_bool @{.cdecl, dynlib꞉ lib,importc꞉ "net_write_command".@}
@example
proc net_write_command*(net꞉ PNET; command꞉ char; header꞉ cstring; head_len꞉ int;packet꞉ cstring; length꞉ int)꞉ my_bool @{.cdecl, dynlib꞉ lib,importc꞉ "net_write_command".@}
@end example
  

@item net_real_write
  @findex proc net_real_write*(net꞉ PNET; packet꞉ cstring; length꞉ int)꞉ cint @{.cdecl, dynlib꞉ lib,importc꞉ "net_real_write".@}
@example
proc net_real_write*(net꞉ PNET; packet꞉ cstring; length꞉ int)꞉ cint @{.cdecl, dynlib꞉ lib,importc꞉ "net_real_write".@}
@end example
  

@item my_net_read
  @findex proc my_net_read*(net꞉ PNET)꞉ int @{.cdecl, dynlib꞉ lib, importc꞉ "my_net_read".@}
@example
proc my_net_read*(net꞉ PNET)꞉ int @{.cdecl, dynlib꞉ lib, importc꞉ "my_net_read".@}
@end example
  

@item my_connect
  @findex proc my_connect*(s꞉ my_socket; name꞉ Psockaddr; namelen꞉ cuint; timeout꞉ cuint)꞉ cint @{.cdecl, dynlib꞉ lib, importc꞉ "my_connect".@}
@example
proc my_connect*(s꞉ my_socket; name꞉ Psockaddr; namelen꞉ cuint; timeout꞉ cuint)꞉ cint @{.cdecl, dynlib꞉ lib, importc꞉ "my_connect".@}
@end example
  

@item randominit
  @findex proc randominit*(para1꞉ Prand_struct; seed1꞉ int; seed2꞉ int) @{.cdecl, dynlib꞉ lib,importc꞉ "randominit".@}
@example
proc randominit*(para1꞉ Prand_struct; seed1꞉ int; seed2꞉ int) @{.cdecl, dynlib꞉ lib,importc꞉ "randominit".@}
@end example
  

@item my_rnd
  @findex proc my_rnd*(para1꞉ Prand_struct)꞉ cdouble @{.cdecl, dynlib꞉ lib, importc꞉ "my_rnd".@}
@example
proc my_rnd*(para1꞉ Prand_struct)꞉ cdouble @{.cdecl, dynlib꞉ lib, importc꞉ "my_rnd".@}
@end example
  

@item create_random_string
  @findex proc create_random_string*(fto꞉ cstring; len꞉ cuint; rand_st꞉ Prand_struct) @{.cdecl,dynlib꞉ lib, importc꞉ "create_random_string".@}
@example
proc create_random_string*(fto꞉ cstring; len꞉ cuint; rand_st꞉ Prand_struct) @{.cdecl,dynlib꞉ lib, importc꞉ "create_random_string".@}
@end example
  

@item hash_password
  @findex proc hash_password*(fto꞉ int; password꞉ cstring; password_len꞉ cuint) @{.cdecl,dynlib꞉ lib, importc꞉ "hash_password".@}
@example
proc hash_password*(fto꞉ int; password꞉ cstring; password_len꞉ cuint) @{.cdecl,dynlib꞉ lib, importc꞉ "hash_password".@}
@end example
  

@item make_scrambled_password_323
  @findex proc make_scrambled_password_323*(fto꞉ cstring; password꞉ cstring) @{.cdecl,dynlib꞉ lib, importc꞉ "make_scrambled_password_323".@}
@example
proc make_scrambled_password_323*(fto꞉ cstring; password꞉ cstring) @{.cdecl,dynlib꞉ lib, importc꞉ "make_scrambled_password_323".@}
@end example
  

@item scramble_323
  @findex proc scramble_323*(fto꞉ cstring; message꞉ cstring; password꞉ cstring) @{.cdecl,dynlib꞉ lib, importc꞉ "scramble_323".@}
@example
proc scramble_323*(fto꞉ cstring; message꞉ cstring; password꞉ cstring) @{.cdecl,dynlib꞉ lib, importc꞉ "scramble_323".@}
@end example
  

@item check_scramble_323
  @findex proc check_scramble_323*(para1꞉ cstring; message꞉ cstring; salt꞉ int)꞉ my_bool @{.cdecl,dynlib꞉ lib, importc꞉ "check_scramble_323".@}
@example
proc check_scramble_323*(para1꞉ cstring; message꞉ cstring; salt꞉ int)꞉ my_bool @{.cdecl,dynlib꞉ lib, importc꞉ "check_scramble_323".@}
@end example
  

@item get_salt_from_password_323
  @findex proc get_salt_from_password_323*(res꞉ ptr int; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "get_salt_from_password_323".@}
@example
proc get_salt_from_password_323*(res꞉ ptr int; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "get_salt_from_password_323".@}
@end example
  

@item make_password_from_salt_323
  @findex proc make_password_from_salt_323*(fto꞉ cstring; salt꞉ ptr int) @{.cdecl, dynlib꞉ lib,importc꞉ "make_password_from_salt_323".@}
@example
proc make_password_from_salt_323*(fto꞉ cstring; salt꞉ ptr int) @{.cdecl, dynlib꞉ lib,importc꞉ "make_password_from_salt_323".@}
@end example
  

@item octet2hex
  @findex proc octet2hex*(fto꞉ cstring; str꞉ cstring; length꞉ cuint)꞉ cstring @{.cdecl, dynlib꞉ lib,importc꞉ "octet2hex".@}
@example
proc octet2hex*(fto꞉ cstring; str꞉ cstring; length꞉ cuint)꞉ cstring @{.cdecl, dynlib꞉ lib,importc꞉ "octet2hex".@}
@end example
  

@item make_scrambled_password
  @findex proc make_scrambled_password*(fto꞉ cstring; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "make_scrambled_password".@}
@example
proc make_scrambled_password*(fto꞉ cstring; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "make_scrambled_password".@}
@end example
  

@item scramble
  @findex proc scramble*(fto꞉ cstring; message꞉ cstring; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "scramble".@}
@example
proc scramble*(fto꞉ cstring; message꞉ cstring; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "scramble".@}
@end example
  

@item check_scramble
  @findex proc check_scramble*(reply꞉ cstring; message꞉ cstring; hash_stage2꞉ pointer)꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "check_scramble".@}
@example
proc check_scramble*(reply꞉ cstring; message꞉ cstring; hash_stage2꞉ pointer)꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "check_scramble".@}
@end example
  

@item get_salt_from_password
  @findex proc get_salt_from_password*(res꞉ pointer; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "get_salt_from_password".@}
@example
proc get_salt_from_password*(res꞉ pointer; password꞉ cstring) @{.cdecl, dynlib꞉ lib,importc꞉ "get_salt_from_password".@}
@end example
  

@item make_password_from_salt
  @findex proc make_password_from_salt*(fto꞉ cstring; hash_stage2꞉ pointer) @{.cdecl,dynlib꞉ lib, importc꞉ "make_password_from_salt".@}
@example
proc make_password_from_salt*(fto꞉ cstring; hash_stage2꞉ pointer) @{.cdecl,dynlib꞉ lib, importc꞉ "make_password_from_salt".@}
@end example
  

@item get_tty_password
  @findex proc get_tty_password*(opt_message꞉ cstring)꞉ cstring @{.cdecl, dynlib꞉ lib,importc꞉ "get_tty_password".@}
@example
proc get_tty_password*(opt_message꞉ cstring)꞉ cstring @{.cdecl, dynlib꞉ lib,importc꞉ "get_tty_password".@}
@end example
  

@item errno_to_sqlstate
  @findex proc errno_to_sqlstate*(errno꞉ cuint)꞉ cstring @{.cdecl, dynlib꞉ lib,importc꞉ "mysql_errno_to_sqlstate".@}
@example
proc errno_to_sqlstate*(errno꞉ cuint)꞉ cstring @{.cdecl, dynlib꞉ lib,importc꞉ "mysql_errno_to_sqlstate".@}
@end example
  

@item modify_defaults_file
  @findex proc modify_defaults_file*(file_location: cstring; option: cstring;
                          option_value: cstring; section_name: cstring;
                          remove_option: cint): cint @{.cdecl, dynlib: lib,
    importc: "load_defaults".@}
@example
proc modify_defaults_file*(file_location: cstring; option: cstring;
                          option_value: cstring; section_name: cstring;
                          remove_option: cint): cint @{.cdecl, dynlib: lib,
    importc: "load_defaults".@}
@end example
  

@item load_defaults
  @findex proc load_defaults*(conf_file꞉ cstring; groups꞉ cstringArray; argc꞉ ptr cint;argv꞉ ptr cstringArray)꞉ cint @{.cdecl, dynlib꞉ lib,importc꞉ "load_defaults".@}
@example
proc load_defaults*(conf_file꞉ cstring; groups꞉ cstringArray; argc꞉ ptr cint;argv꞉ ptr cstringArray)꞉ cint @{.cdecl, dynlib꞉ lib,importc꞉ "load_defaults".@}
@end example
  

@item my_init
  @findex proc my_init*()꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "my_init".@}
@example
proc my_init*()꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "my_init".@}
@end example
  

@item my_thread_init
  @findex proc my_thread_init*()꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "my_thread_init".@}
@example
proc my_thread_init*()꞉ my_bool @{.cdecl, dynlib꞉ lib, importc꞉ "my_thread_init".@}
@end example
  

@item my_thread_end
  @findex proc my_thread_end*() @{.cdecl, dynlib꞉ lib, importc꞉ "my_thread_end".@}
@example
proc my_thread_end*() @{.cdecl, dynlib꞉ lib, importc꞉ "my_thread_end".@}
@end example
  

@item IS_PRI_KEY
  @findex proc IS_PRI_KEY*(n꞉ int32)꞉ bool
@example
proc IS_PRI_KEY*(n꞉ int32)꞉ bool
@end example
  

@item IS_NOT_NULL
  @findex proc IS_NOT_NULL*(n꞉ int32)꞉ bool
@example
proc IS_NOT_NULL*(n꞉ int32)꞉ bool
@end example
  

@item IS_BLOB
  @findex proc IS_BLOB*(n꞉ int32)꞉ bool
@example
proc IS_BLOB*(n꞉ int32)꞉ bool
@end example
  

@item IS_NUM
  @findex proc IS_NUM*(t꞉ Enum_field_types)꞉ bool
@example
proc IS_NUM*(t꞉ Enum_field_types)꞉ bool
@end example
  

@item INTERNAL_NUM_FIELD
  @findex proc INTERNAL_NUM_FIELD*(f꞉ Pst_mysql_field)꞉ bool
@example
proc INTERNAL_NUM_FIELD*(f꞉ Pst_mysql_field)꞉ bool
@end example
  

@item IS_NUM_FIELD
  @findex proc IS_NUM_FIELD*(f꞉ Pst_mysql_field)꞉ bool
@example
proc IS_NUM_FIELD*(f꞉ Pst_mysql_field)꞉ bool
@end example
  

@item server_init
  @findex proc server_init*(argc꞉ cint; argv꞉ cstringArray; groups꞉ cstringArray)꞉ cint @{.cdecl,dynlib꞉ lib, importc꞉ "mysql_server_init".@}
@example
proc server_init*(argc꞉ cint; argv꞉ cstringArray; groups꞉ cstringArray)꞉ cint @{.cdecl,dynlib꞉ lib, importc꞉ "mysql_server_init".@}
@end example
  

@item server_end
  @findex proc server_end*() @{.cdecl, dynlib꞉ lib, importc꞉ "mysql_server_end".@}
@example
proc server_end*() @{.cdecl, dynlib꞉ lib, importc꞉ "mysql_server_end".@}
@end example
  

@item library_init
  @findex proc library_init*(argc꞉ cint; argv꞉ cstringArray; groups꞉ cstringArray)꞉ cint @{.cdecl,dynlib꞉ lib, importc꞉ "mysql_server_init".@}
@example
proc library_init*(argc꞉ cint; argv꞉ cstringArray; groups꞉ cstringArray)꞉ cint @{.cdecl,dynlib꞉ lib, importc꞉ "mysql_server_init".@}
@end example
  

@item library_end
  @findex proc library_end*() @{.cdecl, dynlib꞉ lib, importc꞉ "mysql_server_end".@}
@example
proc library_end*() @{.cdecl, dynlib꞉ lib, importc꞉ "mysql_server_end".@}
@end example
  

@item get_parameters
  @findex proc get_parameters*()꞉ PPARAMETERS @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_parameters".@}
@example
proc get_parameters*()꞉ PPARAMETERS @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_parameters".@}
@end example
  

@item thread_init
  @findex proc thread_init*()꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_init".@}
@example
proc thread_init*()꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_init".@}
@end example
  

@item thread_end
  @findex proc thread_end*() @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_end".@}
@example
proc thread_end*() @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_end".@}
@end example
  

@item num_rows
  @findex proc num_rows*(res꞉ PRES)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_num_rows".@}
@example
proc num_rows*(res꞉ PRES)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_num_rows".@}
@end example
  

@item num_fields
  @findex proc num_fields*(res꞉ PRES)꞉ cuint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_num_fields".@}
@example
proc num_fields*(res꞉ PRES)꞉ cuint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_num_fields".@}
@end example
  

@item eof
  @findex proc eof*(res꞉ PRES)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_eof".@}
@example
proc eof*(res꞉ PRES)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_eof".@}
@end example
  

@item fetch_field_direct
  @findex proc fetch_field_direct*(res꞉ PRES; fieldnr꞉ cuint)꞉ PFIELD @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_field_direct".@}
@example
proc fetch_field_direct*(res꞉ PRES; fieldnr꞉ cuint)꞉ PFIELD @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_field_direct".@}
@end example
  

@item fetch_fields
  @findex proc fetch_fields*(res꞉ PRES)꞉ PFIELD @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_fields".@}
@example
proc fetch_fields*(res꞉ PRES)꞉ PFIELD @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_fields".@}
@end example
  

@item row_tell
  @findex proc row_tell*(res꞉ PRES)꞉ ROW_OFFSET @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_row_tell".@}
@example
proc row_tell*(res꞉ PRES)꞉ ROW_OFFSET @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_row_tell".@}
@end example
  

@item field_tell
  @findex proc field_tell*(res꞉ PRES)꞉ FIELD_OFFSET @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_field_tell".@}
@example
proc field_tell*(res꞉ PRES)꞉ FIELD_OFFSET @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_field_tell".@}
@end example
  

@item field_count
  @findex proc field_count*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_field_count".@}
@example
proc field_count*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_field_count".@}
@end example
  

@item affected_rows
  @findex proc affected_rows*(MySQL꞉ PMySQL)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_affected_rows".@}
@example
proc affected_rows*(MySQL꞉ PMySQL)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_affected_rows".@}
@end example
  

@item insert_id
  @findex proc insert_id*(MySQL꞉ PMySQL)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_insert_id".@}
@example
proc insert_id*(MySQL꞉ PMySQL)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_insert_id".@}
@end example
  

@item errno
  @findex proc errno*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_errno".@}
@example
proc errno*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_errno".@}
@end example
  

@item error
  @findex proc error*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_error".@}
@example
proc error*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_error".@}
@end example
  

@item sqlstate
  @findex proc sqlstate*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_sqlstate".@}
@example
proc sqlstate*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_sqlstate".@}
@end example
  

@item warning_count
  @findex proc warning_count*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_warning_count".@}
@example
proc warning_count*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_warning_count".@}
@end example
  

@item info
  @findex proc info*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_info".@}
@example
proc info*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_info".@}
@end example
  

@item thread_id
  @findex proc thread_id*(MySQL꞉ PMySQL)꞉ int @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_id".@}
@example
proc thread_id*(MySQL꞉ PMySQL)꞉ int @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_id".@}
@end example
  

@item character_set_name
  @findex proc character_set_name*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_character_set_name".@}
@example
proc character_set_name*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_character_set_name".@}
@end example
  

@item set_character_set
  @findex proc set_character_set*(MySQL꞉ PMySQL; csname꞉ cstring)꞉ int32 @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_set_character_set".@}
@example
proc set_character_set*(MySQL꞉ PMySQL; csname꞉ cstring)꞉ int32 @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_set_character_set".@}
@end example
  

@item init
  @findex proc init*(MySQL꞉ PMySQL)꞉ PMySQL @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_init".@}
@example
proc init*(MySQL꞉ PMySQL)꞉ PMySQL @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_init".@}
@end example
  

@item ssl_set
  @findex proc ssl_set*(MySQL꞉ PMySQL; key꞉ cstring; cert꞉ cstring; ca꞉ cstring; capath꞉ cstring;cipher꞉ cstring)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_ssl_set".@}
@example
proc ssl_set*(MySQL꞉ PMySQL; key꞉ cstring; cert꞉ cstring; ca꞉ cstring; capath꞉ cstring;cipher꞉ cstring)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_ssl_set".@}
@end example
  

@item change_user
  @findex proc change_user*(MySQL꞉ PMySQL; user꞉ cstring; passwd꞉ cstring; db꞉ cstring)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_change_user".@}
@example
proc change_user*(MySQL꞉ PMySQL; user꞉ cstring; passwd꞉ cstring; db꞉ cstring)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_change_user".@}
@end example
  

@item real_connect
  @findex proc real_connect*(MySQL꞉ PMySQL; host꞉ cstring; user꞉ cstring; passwd꞉ cstring;db꞉ cstring; port꞉ cuint; unix_socket꞉ cstring; clientflag꞉ int)꞉ PMySQL @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_real_connect".@}
@example
proc real_connect*(MySQL꞉ PMySQL; host꞉ cstring; user꞉ cstring; passwd꞉ cstring;db꞉ cstring; port꞉ cuint; unix_socket꞉ cstring; clientflag꞉ int)꞉ PMySQL @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_real_connect".@}
@end example
  

@item select_db
  @findex proc select_db*(MySQL꞉ PMySQL; db꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_select_db".@}
@example
proc select_db*(MySQL꞉ PMySQL; db꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_select_db".@}
@end example
  

@item query
  @findex proc query*(MySQL꞉ PMySQL; q꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_query".@}
@example
proc query*(MySQL꞉ PMySQL; q꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_query".@}
@end example
  

@item send_query
  @findex proc send_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_send_query".@}
@example
proc send_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_send_query".@}
@end example
  

@item real_query
  @findex proc real_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_real_query".@}
@example
proc real_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_real_query".@}
@end example
  

@item store_result
  @findex proc store_result*(MySQL꞉ PMySQL)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_store_result".@}
@example
proc store_result*(MySQL꞉ PMySQL)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_store_result".@}
@end example
  

@item use_result
  @findex proc use_result*(MySQL꞉ PMySQL)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_use_result".@}
@example
proc use_result*(MySQL꞉ PMySQL)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_use_result".@}
@end example
  

@item master_query
  @findex proc master_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_master_query".@}
@example
proc master_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_master_query".@}
@end example
  

@item master_send_query
  @findex proc master_send_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_master_send_query".@}
@example
proc master_send_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_master_send_query".@}
@end example
  

@item slave_query
  @findex proc slave_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_slave_query".@}
@example
proc slave_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_slave_query".@}
@end example
  

@item slave_send_query
  @findex proc slave_send_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_slave_send_query".@}
@example
proc slave_send_query*(MySQL꞉ PMySQL; q꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_slave_send_query".@}
@end example
  

@item get_character_set_info
  @findex proc get_character_set_info*(MySQL꞉ PMySQL; charset꞉ PMY_CHARSET_INFO) @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_get_character_set_info".@}
@example
proc get_character_set_info*(MySQL꞉ PMySQL; charset꞉ PMY_CHARSET_INFO) @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_get_character_set_info".@}
@end example
  

@item set_local_infile_default
  @findex proc set_local_infile_default*(MySQL꞉ PMySQL) @{.cdecl, dynlib꞉ lib,importc꞉ "mysql_set_local_infile_default".@}
@example
proc set_local_infile_default*(MySQL꞉ PMySQL) @{.cdecl, dynlib꞉ lib,importc꞉ "mysql_set_local_infile_default".@}
@end example
  

@item enable_rpl_parse
  @findex proc enable_rpl_parse*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_enable_rpl_parse".@}
@example
proc enable_rpl_parse*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_enable_rpl_parse".@}
@end example
  

@item disable_rpl_parse
  @findex proc disable_rpl_parse*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_disable_rpl_parse".@}
@example
proc disable_rpl_parse*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_disable_rpl_parse".@}
@end example
  

@item rpl_parse_enabled
  @findex proc rpl_parse_enabled*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rpl_parse_enabled".@}
@example
proc rpl_parse_enabled*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rpl_parse_enabled".@}
@end example
  

@item enable_reads_from_master
  @findex proc enable_reads_from_master*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_enable_reads_from_master".@}
@example
proc enable_reads_from_master*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_enable_reads_from_master".@}
@end example
  

@item disable_reads_from_master
  @findex proc disable_reads_from_master*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_disable_reads_from_master".@}
@example
proc disable_reads_from_master*(MySQL꞉ PMySQL) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_disable_reads_from_master".@}
@end example
  

@item reads_from_master_enabled
  @findex proc reads_from_master_enabled*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_reads_from_master_enabled".@}
@example
proc reads_from_master_enabled*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_reads_from_master_enabled".@}
@end example
  

@item rpl_query_type
  @findex proc rpl_query_type*(q꞉ cstring; length꞉ cint)꞉ Rpl_type @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rpl_query_type".@}
@example
proc rpl_query_type*(q꞉ cstring; length꞉ cint)꞉ Rpl_type @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rpl_query_type".@}
@end example
  

@item rpl_probe
  @findex proc rpl_probe*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rpl_probe".@}
@example
proc rpl_probe*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rpl_probe".@}
@end example
  

@item set_master
  @findex proc set_master*(MySQL꞉ PMySQL; host꞉ cstring; port꞉ cuint; user꞉ cstring;passwd꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_set_master".@}
@example
proc set_master*(MySQL꞉ PMySQL; host꞉ cstring; port꞉ cuint; user꞉ cstring;passwd꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_set_master".@}
@end example
  

@item add_slave
  @findex proc add_slave*(MySQL꞉ PMySQL; host꞉ cstring; port꞉ cuint; user꞉ cstring; passwd꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_add_slave".@}
@example
proc add_slave*(MySQL꞉ PMySQL; host꞉ cstring; port꞉ cuint; user꞉ cstring; passwd꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_add_slave".@}
@end example
  

@item shutdown
  @findex proc shutdown*(MySQL꞉ PMySQL; shutdown_level꞉ Enum_shutdown_level)꞉ cint @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_shutdown".@}
@example
proc shutdown*(MySQL꞉ PMySQL; shutdown_level꞉ Enum_shutdown_level)꞉ cint @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_shutdown".@}
@end example
  

@item dump_debug_info
  @findex proc dump_debug_info*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_dump_debug_info".@}
@example
proc dump_debug_info*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_dump_debug_info".@}
@end example
  

@item refresh
  @findex proc refresh*(sql꞉ PMySQL; refresh_options꞉ cuint)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_refresh".@}
@example
proc refresh*(sql꞉ PMySQL; refresh_options꞉ cuint)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_refresh".@}
@end example
  

@item kill
  @findex proc kill*(MySQL꞉ PMySQL; pid꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_kill".@}
@example
proc kill*(MySQL꞉ PMySQL; pid꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_kill".@}
@end example
  

@item set_server_option
  @findex proc set_server_option*(MySQL꞉ PMySQL; option꞉ Enum_mysql_set_option)꞉ cint @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_set_server_option".@}
@example
proc set_server_option*(MySQL꞉ PMySQL; option꞉ Enum_mysql_set_option)꞉ cint @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_set_server_option".@}
@end example
  

@item ping
  @findex proc ping*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_ping".@}
@example
proc ping*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_ping".@}
@end example
  

@item stat
  @findex proc stat*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stat".@}
@example
proc stat*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stat".@}
@end example
  

@item get_server_info
  @findex proc get_server_info*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_server_info".@}
@example
proc get_server_info*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_server_info".@}
@end example
  

@item get_client_info
  @findex proc get_client_info*()꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_client_info".@}
@example
proc get_client_info*()꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_client_info".@}
@end example
  

@item get_client_version
  @findex proc get_client_version*()꞉ int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_client_version".@}
@example
proc get_client_version*()꞉ int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_client_version".@}
@end example
  

@item get_host_info
  @findex proc get_host_info*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_host_info".@}
@example
proc get_host_info*(MySQL꞉ PMySQL)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_host_info".@}
@end example
  

@item get_server_version
  @findex proc get_server_version*(MySQL꞉ PMySQL)꞉ int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_server_version".@}
@example
proc get_server_version*(MySQL꞉ PMySQL)꞉ int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_server_version".@}
@end example
  

@item get_proto_info
  @findex proc get_proto_info*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_proto_info".@}
@example
proc get_proto_info*(MySQL꞉ PMySQL)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_get_proto_info".@}
@end example
  

@item list_dbs
  @findex proc list_dbs*(MySQL꞉ PMySQL; wild꞉ cstring)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_list_dbs".@}
@example
proc list_dbs*(MySQL꞉ PMySQL; wild꞉ cstring)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_list_dbs".@}
@end example
  

@item list_tables
  @findex proc list_tables*(MySQL꞉ PMySQL; wild꞉ cstring)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_list_tables".@}
@example
proc list_tables*(MySQL꞉ PMySQL; wild꞉ cstring)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_list_tables".@}
@end example
  

@item list_processes
  @findex proc list_processes*(MySQL꞉ PMySQL)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_list_processes".@}
@example
proc list_processes*(MySQL꞉ PMySQL)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_list_processes".@}
@end example
  

@item options
  @findex proc options*(MySQL꞉ PMySQL; option꞉ Option; arg꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_options".@}
@example
proc options*(MySQL꞉ PMySQL; option꞉ Option; arg꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_options".@}
@end example
  

@item free_result
  @findex proc free_result*(result꞉ PRES) @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_free_result".@}
@example
proc free_result*(result꞉ PRES) @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_free_result".@}
@end example
  

@item data_seek
  @findex proc data_seek*(result꞉ PRES; offset꞉ my_ulonglong) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_data_seek".@}
@example
proc data_seek*(result꞉ PRES; offset꞉ my_ulonglong) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_data_seek".@}
@end example
  

@item row_seek
  @findex proc row_seek*(result꞉ PRES; offset꞉ ROW_OFFSET)꞉ ROW_OFFSET @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_row_seek".@}
@example
proc row_seek*(result꞉ PRES; offset꞉ ROW_OFFSET)꞉ ROW_OFFSET @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_row_seek".@}
@end example
  

@item field_seek
  @findex proc field_seek*(result꞉ PRES; offset꞉ FIELD_OFFSET)꞉ FIELD_OFFSET @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_field_seek".@}
@example
proc field_seek*(result꞉ PRES; offset꞉ FIELD_OFFSET)꞉ FIELD_OFFSET @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_field_seek".@}
@end example
  

@item fetch_row
  @findex proc fetch_row*(result꞉ PRES)꞉ ROW @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_fetch_row".@}
@example
proc fetch_row*(result꞉ PRES)꞉ ROW @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_fetch_row".@}
@end example
  

@item fetch_lengths
  @findex proc fetch_lengths*(result꞉ PRES)꞉ ptr int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_lengths".@}
@example
proc fetch_lengths*(result꞉ PRES)꞉ ptr int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_lengths".@}
@end example
  

@item fetch_field
  @findex proc fetch_field*(result꞉ PRES)꞉ PFIELD @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_field".@}
@example
proc fetch_field*(result꞉ PRES)꞉ PFIELD @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_fetch_field".@}
@end example
  

@item list_fields
  @findex proc list_fields*(MySQL꞉ PMySQL; table꞉ cstring; wild꞉ cstring)꞉ PRES @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_list_fields".@}
@example
proc list_fields*(MySQL꞉ PMySQL; table꞉ cstring; wild꞉ cstring)꞉ PRES @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_list_fields".@}
@end example
  

@item escape_string
  @findex proc escape_string*(fto꞉ cstring; `from`꞉ cstring; from_length꞉ int)꞉ int @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_escape_string".@}
@example
proc escape_string*(fto꞉ cstring; `from`꞉ cstring; from_length꞉ int)꞉ int @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_escape_string".@}
@end example
  

@item hex_string
  @findex proc hex_string*(fto꞉ cstring; `from`꞉ cstring; from_length꞉ int)꞉ int @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_hex_string".@}
@example
proc hex_string*(fto꞉ cstring; `from`꞉ cstring; from_length꞉ int)꞉ int @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_hex_string".@}
@end example
  

@item real_escape_string
  @findex proc real_escape_string*(MySQL꞉ PMySQL; fto꞉ cstring; `from`꞉ cstring; len꞉ int)꞉ int @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_real_escape_string".@}
@example
proc real_escape_string*(MySQL꞉ PMySQL; fto꞉ cstring; `from`꞉ cstring; len꞉ int)꞉ int @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_real_escape_string".@}
@end example
  

@item debug
  @findex proc debug*(debug꞉ cstring) @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_debug".@}
@example
proc debug*(debug꞉ cstring) @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_debug".@}
@end example
  

@item myodbc_remove_escape
  @findex proc myodbc_remove_escape*(MySQL꞉ PMySQL; name꞉ cstring) @{.stdcall, dynlib꞉ lib,importc꞉ "myodbc_remove_escape".@}
@example
proc myodbc_remove_escape*(MySQL꞉ PMySQL; name꞉ cstring) @{.stdcall, dynlib꞉ lib,importc꞉ "myodbc_remove_escape".@}
@end example
  

@item thread_safe
  @findex proc thread_safe*()꞉ cuint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_safe".@}
@example
proc thread_safe*()꞉ cuint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_thread_safe".@}
@end example
  

@item embedded
  @findex proc embedded*()꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_embedded".@}
@example
proc embedded*()꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_embedded".@}
@end example
  

@item manager_init
  @findex proc manager_init*(con꞉ PMANAGER)꞉ PMANAGER @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_manager_init".@}
@example
proc manager_init*(con꞉ PMANAGER)꞉ PMANAGER @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_manager_init".@}
@end example
  

@item manager_connect
  @findex proc manager_connect*(con꞉ PMANAGER; host꞉ cstring; user꞉ cstring; passwd꞉ cstring;port꞉ cuint)꞉ PMANAGER @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_manager_connect".@}
@example
proc manager_connect*(con꞉ PMANAGER; host꞉ cstring; user꞉ cstring; passwd꞉ cstring;port꞉ cuint)꞉ PMANAGER @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_manager_connect".@}
@end example
  

@item manager_close
  @findex proc manager_close*(con꞉ PMANAGER) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_manager_close".@}
@example
proc manager_close*(con꞉ PMANAGER) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_manager_close".@}
@end example
  

@item manager_command
  @findex proc manager_command*(con꞉ PMANAGER; cmd꞉ cstring; cmd_len꞉ cint)꞉ cint @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_manager_command".@}
@example
proc manager_command*(con꞉ PMANAGER; cmd꞉ cstring; cmd_len꞉ cint)꞉ cint @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_manager_command".@}
@end example
  

@item manager_fetch_line
  @findex proc manager_fetch_line*(con꞉ PMANAGER; res_buf꞉ cstring; res_buf_size꞉ cint)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_manager_fetch_line".@}
@example
proc manager_fetch_line*(con꞉ PMANAGER; res_buf꞉ cstring; res_buf_size꞉ cint)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_manager_fetch_line".@}
@end example
  

@item read_query_result
  @findex proc read_query_result*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_read_query_result".@}
@example
proc read_query_result*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_read_query_result".@}
@end example
  

@item stmt_init
  @findex proc stmt_init*(MySQL꞉ PMySQL)꞉ PSTMT @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_init".@}
@example
proc stmt_init*(MySQL꞉ PMySQL)꞉ PSTMT @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_init".@}
@end example
  

@item stmt_prepare
  @findex proc stmt_prepare*(stmt꞉ PSTMT; query꞉ cstring; len꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_prepare".@}
@example
proc stmt_prepare*(stmt꞉ PSTMT; query꞉ cstring; len꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_prepare".@}
@end example
  

@item stmt_execute
  @findex proc stmt_execute*(stmt꞉ PSTMT)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_execute".@}
@example
proc stmt_execute*(stmt꞉ PSTMT)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_execute".@}
@end example
  

@item stmt_fetch
  @findex proc stmt_fetch*(stmt꞉ PSTMT)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_fetch".@}
@example
proc stmt_fetch*(stmt꞉ PSTMT)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_fetch".@}
@end example
  

@item stmt_fetch_column
  @findex proc stmt_fetch_column*(stmt꞉ PSTMT; `bind`꞉ PBIND; column꞉ cuint; offset꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_fetch_column".@}
@example
proc stmt_fetch_column*(stmt꞉ PSTMT; `bind`꞉ PBIND; column꞉ cuint; offset꞉ int)꞉ cint @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_fetch_column".@}
@end example
  

@item stmt_store_result
  @findex proc stmt_store_result*(stmt꞉ PSTMT)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_store_result".@}
@example
proc stmt_store_result*(stmt꞉ PSTMT)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_store_result".@}
@end example
  

@item stmt_param_count
  @findex proc stmt_param_count*(stmt꞉ PSTMT)꞉ int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_param_count".@}
@example
proc stmt_param_count*(stmt꞉ PSTMT)꞉ int @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_param_count".@}
@end example
  

@item stmt_attr_set
  @findex proc stmt_attr_set*(stmt꞉ PSTMT; attr_type꞉ Enum_stmt_attr_type; attr꞉ pointer)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_attr_set".@}
@example
proc stmt_attr_set*(stmt꞉ PSTMT; attr_type꞉ Enum_stmt_attr_type; attr꞉ pointer)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_attr_set".@}
@end example
  

@item stmt_attr_get
  @findex proc stmt_attr_get*(stmt꞉ PSTMT; attr_type꞉ Enum_stmt_attr_type; attr꞉ pointer)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_attr_get".@}
@example
proc stmt_attr_get*(stmt꞉ PSTMT; attr_type꞉ Enum_stmt_attr_type; attr꞉ pointer)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_attr_get".@}
@end example
  

@item stmt_bind_param
  @findex proc stmt_bind_param*(stmt꞉ PSTMT; bnd꞉ PBIND)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_bind_param".@}
@example
proc stmt_bind_param*(stmt꞉ PSTMT; bnd꞉ PBIND)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_bind_param".@}
@end example
  

@item stmt_bind_result
  @findex proc stmt_bind_result*(stmt꞉ PSTMT; bnd꞉ PBIND)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_bind_result".@}
@example
proc stmt_bind_result*(stmt꞉ PSTMT; bnd꞉ PBIND)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_bind_result".@}
@end example
  

@item stmt_close
  @findex proc stmt_close*(stmt꞉ PSTMT)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_close".@}
@example
proc stmt_close*(stmt꞉ PSTMT)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_close".@}
@end example
  

@item stmt_reset
  @findex proc stmt_reset*(stmt꞉ PSTMT)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_reset".@}
@example
proc stmt_reset*(stmt꞉ PSTMT)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_reset".@}
@end example
  

@item stmt_free_result
  @findex proc stmt_free_result*(stmt꞉ PSTMT)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_free_result".@}
@example
proc stmt_free_result*(stmt꞉ PSTMT)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_free_result".@}
@end example
  

@item stmt_send_long_data
  @findex proc stmt_send_long_data*(stmt꞉ PSTMT; param_number꞉ cuint; data꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_send_long_data".@}
@example
proc stmt_send_long_data*(stmt꞉ PSTMT; param_number꞉ cuint; data꞉ cstring; len꞉ int)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_stmt_send_long_data".@}
@end example
  

@item stmt_result_metadata
  @findex proc stmt_result_metadata*(stmt꞉ PSTMT)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_result_metadata".@}
@example
proc stmt_result_metadata*(stmt꞉ PSTMT)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_result_metadata".@}
@end example
  

@item stmt_param_metadata
  @findex proc stmt_param_metadata*(stmt꞉ PSTMT)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_param_metadata".@}
@example
proc stmt_param_metadata*(stmt꞉ PSTMT)꞉ PRES @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_param_metadata".@}
@end example
  

@item stmt_errno
  @findex proc stmt_errno*(stmt꞉ PSTMT)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_errno".@}
@example
proc stmt_errno*(stmt꞉ PSTMT)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_errno".@}
@end example
  

@item stmt_error
  @findex proc stmt_error*(stmt꞉ PSTMT)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_error".@}
@example
proc stmt_error*(stmt꞉ PSTMT)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_error".@}
@end example
  

@item stmt_sqlstate
  @findex proc stmt_sqlstate*(stmt꞉ PSTMT)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_sqlstate".@}
@example
proc stmt_sqlstate*(stmt꞉ PSTMT)꞉ cstring @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_sqlstate".@}
@end example
  

@item stmt_row_seek
  @findex proc stmt_row_seek*(stmt꞉ PSTMT; offset꞉ ROW_OFFSET)꞉ ROW_OFFSET @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_stmt_row_seek".@}
@example
proc stmt_row_seek*(stmt꞉ PSTMT; offset꞉ ROW_OFFSET)꞉ ROW_OFFSET @{.stdcall,dynlib꞉ lib, importc꞉ "mysql_stmt_row_seek".@}
@end example
  

@item stmt_row_tell
  @findex proc stmt_row_tell*(stmt꞉ PSTMT)꞉ ROW_OFFSET @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_row_tell".@}
@example
proc stmt_row_tell*(stmt꞉ PSTMT)꞉ ROW_OFFSET @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_row_tell".@}
@end example
  

@item stmt_data_seek
  @findex proc stmt_data_seek*(stmt꞉ PSTMT; offset꞉ my_ulonglong) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_data_seek".@}
@example
proc stmt_data_seek*(stmt꞉ PSTMT; offset꞉ my_ulonglong) @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_data_seek".@}
@end example
  

@item stmt_num_rows
  @findex proc stmt_num_rows*(stmt꞉ PSTMT)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_num_rows".@}
@example
proc stmt_num_rows*(stmt꞉ PSTMT)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_num_rows".@}
@end example
  

@item stmt_affected_rows
  @findex proc stmt_affected_rows*(stmt꞉ PSTMT)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_affected_rows".@}
@example
proc stmt_affected_rows*(stmt꞉ PSTMT)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_affected_rows".@}
@end example
  

@item stmt_insert_id
  @findex proc stmt_insert_id*(stmt꞉ PSTMT)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_insert_id".@}
@example
proc stmt_insert_id*(stmt꞉ PSTMT)꞉ my_ulonglong @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_insert_id".@}
@end example
  

@item stmt_field_count
  @findex proc stmt_field_count*(stmt꞉ PSTMT)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_field_count".@}
@example
proc stmt_field_count*(stmt꞉ PSTMT)꞉ cuint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_stmt_field_count".@}
@end example
  

@item commit
  @findex proc commit*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_commit".@}
@example
proc commit*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_commit".@}
@end example
  

@item rollback
  @findex proc rollback*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rollback".@}
@example
proc rollback*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_rollback".@}
@end example
  

@item autocommit
  @findex proc autocommit*(MySQL꞉ PMySQL; auto_mode꞉ my_bool)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_autocommit".@}
@example
proc autocommit*(MySQL꞉ PMySQL; auto_mode꞉ my_bool)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_autocommit".@}
@end example
  

@item more_results
  @findex proc more_results*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_more_results".@}
@example
proc more_results*(MySQL꞉ PMySQL)꞉ my_bool @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_more_results".@}
@end example
  

@item next_result
  @findex proc next_result*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_next_result".@}
@example
proc next_result*(MySQL꞉ PMySQL)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_next_result".@}
@end example
  

@item close
  @findex proc close*(sock꞉ PMySQL) @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_close".@}
@example
proc close*(sock꞉ PMySQL) @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_close".@}
@end example
  

@item reload
  @findex proc reload*(x꞉ PMySQL)꞉ cint
@example
proc reload*(x꞉ PMySQL)꞉ cint
@end example
  

@item connect
  @findex proc connect*(MySQL꞉ PMySQL; host꞉ cstring; user꞉ cstring; passwd꞉ cstring)꞉ PMySQL @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_connect".@}
@example
proc connect*(MySQL꞉ PMySQL; host꞉ cstring; user꞉ cstring; passwd꞉ cstring)꞉ PMySQL @{.stdcall, dynlib꞉ lib, importc꞉ "mysql_connect".@}
@end example
  

@item create_db
  @findex proc create_db*(MySQL꞉ PMySQL; DB꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_create_db".@}
@example
proc create_db*(MySQL꞉ PMySQL; DB꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_create_db".@}
@end example
  

@item drop_db
  @findex proc drop_db*(MySQL꞉ PMySQL; DB꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_drop_db".@}
@example
proc drop_db*(MySQL꞉ PMySQL; DB꞉ cstring)꞉ cint @{.stdcall, dynlib꞉ lib,importc꞉ "mysql_drop_db".@}
@end example
  

@item net_safe_read
  @findex proc net_safe_read*(MySQL꞉ PMySQL)꞉ cuint @{.cdecl, dynlib꞉ lib,importc꞉ "net_safe_read".@}
@example
proc net_safe_read*(MySQL꞉ PMySQL)꞉ cuint @{.cdecl, dynlib꞉ lib,importc꞉ "net_safe_read".@}
@end example
  
@end itemize






@node /wrappers/joyent_http_parser, /wrappers/libuv , /wrappers/mysql, Top



@chapter Types

@itemize


@item HttpParserSettings
  @tindex HttpParserSettings* @{.pure, final, importc: "http_parser_settings",
                     header: "http_parser.h".@} = object
  on_message_begin* @{.importc: "on_message_begin".@}: HttpProc
  on_url* @{.importc: "on_url".@}: HttpDataProc
  on_header_field* @{.importc: "on_header_field".@}: HttpDataProc
  on_header_value* @{.importc: "on_header_value".@}: HttpDataProc
  on_headers_complete* @{.importc: "on_headers_complete".@}: HttpProc
  on_body* @{.importc: "on_body".@}: HttpDataProc
  on_message_complete* @{.importc: "on_message_complete".@}: HttpProc

@example
HttpParserSettings* @{.pure, final, importc: "http_parser_settings",
                     header: "http_parser.h".@} = object
  on_message_begin* @{.importc: "on_message_begin".@}: HttpProc
  on_url* @{.importc: "on_url".@}: HttpDataProc
  on_header_field* @{.importc: "on_header_field".@}: HttpDataProc
  on_header_value* @{.importc: "on_header_value".@}: HttpDataProc
  on_headers_complete* @{.importc: "on_headers_complete".@}: HttpProc
  on_body* @{.importc: "on_body".@}: HttpDataProc
  on_message_complete* @{.importc: "on_message_complete".@}: HttpProc

@end example
  
@end itemize

@chapter Procedures

@itemize


@item http_parser_init
  @findex proc http_parser_init*(parser꞉ var HttpParser; typ꞉ HttpParserType) @{.importc꞉ "http_parser_init", header꞉ "http_parser.h".@}
@example
proc http_parser_init*(parser꞉ var HttpParser; typ꞉ HttpParserType) @{.importc꞉ "http_parser_init", header꞉ "http_parser.h".@}
@end example
  

@item http_parser_execute
  @findex proc http_parser_execute*(parser꞉ var HttpParser; settings꞉ var HttpParserSettings;data꞉ cstring; len꞉ csize)꞉ csize @{.importc꞉ "http_parser_execute", header꞉ "http_parser.h".@}
@example
proc http_parser_execute*(parser꞉ var HttpParser; settings꞉ var HttpParserSettings;data꞉ cstring; len꞉ csize)꞉ csize @{.importc꞉ "http_parser_execute", header꞉ "http_parser.h".@}
@end example
  

@item http_should_keep_alive
  @findex proc http_should_keep_alive*(parser꞉ var HttpParser)꞉ cint @{.importc꞉ "http_should_keep_alive", header꞉ "http_parser.h".@}
@example
proc http_should_keep_alive*(parser꞉ var HttpParser)꞉ cint @{.importc꞉ "http_should_keep_alive", header꞉ "http_parser.h".@}
@end example
  

@item http_method_str
  @findex proc http_method_str*(m꞉ HttpMethod)꞉ cstring @{.importc꞉ "http_method_str",header꞉ "http_parser.h".@}
@example
proc http_method_str*(m꞉ HttpMethod)꞉ cstring @{.importc꞉ "http_method_str",header꞉ "http_parser.h".@}
@end example
  

@item http_errno_name
  @findex proc http_errno_name*(err꞉ HttpErrNo)꞉ cstring @{.importc꞉ "http_errno_name",header꞉ "http_parser.h".@}
@example
proc http_errno_name*(err꞉ HttpErrNo)꞉ cstring @{.importc꞉ "http_errno_name",header꞉ "http_parser.h".@}
@end example
  

@item http_errno_description
  @findex proc http_errno_description*(err꞉ HttpErrNo)꞉ cstring @{.importc꞉ "http_errno_description", header꞉ "http_parser.h".@}
@example
proc http_errno_description*(err꞉ HttpErrNo)꞉ cstring @{.importc꞉ "http_errno_description", header꞉ "http_parser.h".@}
@end example
  
@end itemize






@node /wrappers/libuv, /wrappers/libsvm , /wrappers/joyent_http_parser, Top



@chapter Types

@itemize


@item PAresChannel
  @tindex PAresChannel* = pointer
@example
PAresChannel* = pointer
@end example
  
@end itemize

@chapter Procedures

@itemize


@item loop_new
  @findex proc loop_new*()꞉ PLoop @{.importc꞉ "uv_loop_new", header꞉ "uv.h".@}
@example
proc loop_new*()꞉ PLoop @{.importc꞉ "uv_loop_new", header꞉ "uv.h".@}
@end example
  

@item loop_delete
  @findex proc loop_delete*(a2꞉ PLoop) @{.importc꞉ "uv_loop_delete", header꞉ "uv.h".@}
@example
proc loop_delete*(a2꞉ PLoop) @{.importc꞉ "uv_loop_delete", header꞉ "uv.h".@}
@end example
  

@item default_loop
  @findex proc default_loop*()꞉ PLoop @{.importc꞉ "uv_default_loop", header꞉ "uv.h".@}
@example
proc default_loop*()꞉ PLoop @{.importc꞉ "uv_default_loop", header꞉ "uv.h".@}
@end example
  

@item run
  @findex proc run*(a2꞉ PLoop)꞉ cint @{.importc꞉ "uv_run", header꞉ "uv.h".@}
@example
proc run*(a2꞉ PLoop)꞉ cint @{.importc꞉ "uv_run", header꞉ "uv.h".@}
@end example
  

@item addref
  @findex proc addref*(a2꞉ PLoop) @{.importc꞉ "uv_ref", header꞉ "uv.h".@}
@example
proc addref*(a2꞉ PLoop) @{.importc꞉ "uv_ref", header꞉ "uv.h".@}
@end example
  

@item unref
  @findex proc unref*(a2꞉ PLoop) @{.importc꞉ "uv_unref", header꞉ "uv.h".@}
@example
proc unref*(a2꞉ PLoop) @{.importc꞉ "uv_unref", header꞉ "uv.h".@}
@end example
  

@item update_time
  @findex proc update_time*(a2꞉ PLoop) @{.importc꞉ "uv_update_time", header꞉ "uv.h".@}
@example
proc update_time*(a2꞉ PLoop) @{.importc꞉ "uv_update_time", header꞉ "uv.h".@}
@end example
  

@item now
  @findex proc now*(a2꞉ PLoop)꞉ int64 @{.importc꞉ "uv_now", header꞉ "uv.h".@}
@example
proc now*(a2꞉ PLoop)꞉ int64 @{.importc꞉ "uv_now", header꞉ "uv.h".@}
@end example
  

@item last_error
  @findex proc last_error*(a2꞉ PLoop)꞉ Err @{.importc꞉ "uv_last_error", header꞉ "uv.h".@}
@example
proc last_error*(a2꞉ PLoop)꞉ Err @{.importc꞉ "uv_last_error", header꞉ "uv.h".@}
@end example
  

@item strerror
  @findex proc strerror*(err꞉ Err)꞉ cstring @{.importc꞉ "uv_strerror", header꞉ "uv.h".@}
@example
proc strerror*(err꞉ Err)꞉ cstring @{.importc꞉ "uv_strerror", header꞉ "uv.h".@}
@end example
  

@item err_name
  @findex proc err_name*(err꞉ Err)꞉ cstring @{.importc꞉ "uv_err_name", header꞉ "uv.h".@}
@example
proc err_name*(err꞉ Err)꞉ cstring @{.importc꞉ "uv_err_name", header꞉ "uv.h".@}
@end example
  

@item shutdown
  @findex proc shutdown*(req꞉ PShutdown; handle꞉ PStream; cb꞉ ShutdownProc)꞉ cint @{.importc꞉ "uv_shutdown", header꞉ "uv.h".@}
@example
proc shutdown*(req꞉ PShutdown; handle꞉ PStream; cb꞉ ShutdownProc)꞉ cint @{.importc꞉ "uv_shutdown", header꞉ "uv.h".@}
@end example
  

@item is_active
  @findex proc is_active*(handle꞉ PHandle)꞉ cint @{.importc꞉ "uv_is_active", header꞉ "uv.h".@}
@example
proc is_active*(handle꞉ PHandle)꞉ cint @{.importc꞉ "uv_is_active", header꞉ "uv.h".@}
@end example
  

@item close
  @findex proc close*(handle꞉ PHandle; close_cb꞉ CloseProc) @{.importc꞉ "uv_close", header꞉ "uv.h".@}
@example
proc close*(handle꞉ PHandle; close_cb꞉ CloseProc) @{.importc꞉ "uv_close", header꞉ "uv.h".@}
@end example
  

@item buf_init
  @findex proc buf_init*(base꞉ cstring; len꞉ csize)꞉ Buf @{.importc꞉ "uv_buf_init", header꞉ "uv.h".@}
@example
proc buf_init*(base꞉ cstring; len꞉ csize)꞉ Buf @{.importc꞉ "uv_buf_init", header꞉ "uv.h".@}
@end example
  

@item listen
  @findex proc listen*(stream꞉ PStream; backlog꞉ cint; cb꞉ ConnectionProc)꞉ cint @{.importc꞉ "uv_listen", header꞉ "uv.h".@}
@example
proc listen*(stream꞉ PStream; backlog꞉ cint; cb꞉ ConnectionProc)꞉ cint @{.importc꞉ "uv_listen", header꞉ "uv.h".@}
@end example
  

@item accept
  @findex proc accept*(server꞉ PStream; client꞉ PStream)꞉ cint @{.importc꞉ "uv_accept",header꞉ "uv.h".@}
@example
proc accept*(server꞉ PStream; client꞉ PStream)꞉ cint @{.importc꞉ "uv_accept",header꞉ "uv.h".@}
@end example
  

@item read_start
  @findex proc read_start*(a2꞉ PStream; alloc_cb꞉ AllocProc; read_cb꞉ ReadProc)꞉ cint @{.importc꞉ "uv_read_start", header꞉ "uv.h".@}
@example
proc read_start*(a2꞉ PStream; alloc_cb꞉ AllocProc; read_cb꞉ ReadProc)꞉ cint @{.importc꞉ "uv_read_start", header꞉ "uv.h".@}
@end example
  

@item read_start
  @findex proc read_start*(a2꞉ PStream; alloc_cb꞉ AllocProc; read_cb꞉ ReadProc2)꞉ cint @{.importc꞉ "uv_read2_start", header꞉ "uv.h".@}
@example
proc read_start*(a2꞉ PStream; alloc_cb꞉ AllocProc; read_cb꞉ ReadProc2)꞉ cint @{.importc꞉ "uv_read2_start", header꞉ "uv.h".@}
@end example
  

@item read_stop
  @findex proc read_stop*(a2꞉ PStream)꞉ cint @{.importc꞉ "uv_read_stop", header꞉ "uv.h".@}
@example
proc read_stop*(a2꞉ PStream)꞉ cint @{.importc꞉ "uv_read_stop", header꞉ "uv.h".@}
@end example
  

@item write
  @findex proc write*(req꞉ PWrite; handle꞉ PStream; bufs꞉ ptr Buf; bufcnt꞉ cint; cb꞉ WriteProc)꞉ cint @{.importc꞉ "uv_write", header꞉ "uv.h".@}
@example
proc write*(req꞉ PWrite; handle꞉ PStream; bufs꞉ ptr Buf; bufcnt꞉ cint; cb꞉ WriteProc)꞉ cint @{.importc꞉ "uv_write", header꞉ "uv.h".@}
@end example
  

@item write
  @findex proc write*(req꞉ PWrite; handle꞉ PStream; bufs꞉ ptr Buf; bufcnt꞉ cint;send_handle꞉ PStream; cb꞉ WriteProc)꞉ cint @{.importc꞉ "uv_write2",header꞉ "uv.h".@}
@example
proc write*(req꞉ PWrite; handle꞉ PStream; bufs꞉ ptr Buf; bufcnt꞉ cint;send_handle꞉ PStream; cb꞉ WriteProc)꞉ cint @{.importc꞉ "uv_write2",header꞉ "uv.h".@}
@end example
  

@item tcp_init
  @findex proc tcp_init*(a2꞉ PLoop; handle꞉ PTcp)꞉ cint @{.importc꞉ "uv_tcp_init", header꞉ "uv.h".@}
@example
proc tcp_init*(a2꞉ PLoop; handle꞉ PTcp)꞉ cint @{.importc꞉ "uv_tcp_init", header꞉ "uv.h".@}
@end example
  

@item tcp_bind
  @findex proc tcp_bind*(handle꞉ PTcp; a3꞉ SockAddrIn)꞉ cint @{.importc꞉ "uv_tcp_bind",header꞉ "uv.h".@}
@example
proc tcp_bind*(handle꞉ PTcp; a3꞉ SockAddrIn)꞉ cint @{.importc꞉ "uv_tcp_bind",header꞉ "uv.h".@}
@end example
  

@item tcp_bind6
  @findex proc tcp_bind6*(handle꞉ PTcp; a3꞉ TSockAddrIn6)꞉ cint @{.importc꞉ "uv_tcp_bind6",header꞉ "uv.h".@}
@example
proc tcp_bind6*(handle꞉ PTcp; a3꞉ TSockAddrIn6)꞉ cint @{.importc꞉ "uv_tcp_bind6",header꞉ "uv.h".@}
@end example
  

@item tcp_getsockname
  @findex proc tcp_getsockname*(handle꞉ PTcp; name꞉ ptr SockAddr; namelen꞉ var cint)꞉ cint @{.importc꞉ "uv_tcp_getsockname", header꞉ "uv.h".@}
@example
proc tcp_getsockname*(handle꞉ PTcp; name꞉ ptr SockAddr; namelen꞉ var cint)꞉ cint @{.importc꞉ "uv_tcp_getsockname", header꞉ "uv.h".@}
@end example
  

@item tcp_getpeername
  @findex proc tcp_getpeername*(handle꞉ PTcp; name꞉ ptr SockAddr; namelen꞉ var cint)꞉ cint @{.importc꞉ "uv_tcp_getpeername", header꞉ "uv.h".@}
@example
proc tcp_getpeername*(handle꞉ PTcp; name꞉ ptr SockAddr; namelen꞉ var cint)꞉ cint @{.importc꞉ "uv_tcp_getpeername", header꞉ "uv.h".@}
@end example
  

@item tcp_connect
  @findex proc tcp_connect*(req꞉ PConnect; handle꞉ PTcp; address꞉ SockAddrIn; cb꞉ ConnectProc)꞉ cint @{.importc꞉ "uv_tcp_connect", header꞉ "uv.h".@}
@example
proc tcp_connect*(req꞉ PConnect; handle꞉ PTcp; address꞉ SockAddrIn; cb꞉ ConnectProc)꞉ cint @{.importc꞉ "uv_tcp_connect", header꞉ "uv.h".@}
@end example
  

@item tcp_connect6
  @findex proc tcp_connect6*(req꞉ PConnect; handle꞉ PTcp; address꞉ TSockAddrIn6; cb꞉ ConnectProc)꞉ cint @{.importc꞉ "uv_tcp_connect6", header꞉ "uv.h".@}
@example
proc tcp_connect6*(req꞉ PConnect; handle꞉ PTcp; address꞉ TSockAddrIn6; cb꞉ ConnectProc)꞉ cint @{.importc꞉ "uv_tcp_connect6", header꞉ "uv.h".@}
@end example
  

@item udp_init
  @findex proc udp_init*(a2꞉ PLoop; handle꞉ PUdp)꞉ cint @{.importc꞉ "uv_udp_init", header꞉ "uv.h".@}
@example
proc udp_init*(a2꞉ PLoop; handle꞉ PUdp)꞉ cint @{.importc꞉ "uv_udp_init", header꞉ "uv.h".@}
@end example
  

@item udp_bind
  @findex proc udp_bind*(handle꞉ PUdp; adr꞉ SockAddrIn; flags꞉ cunsigned)꞉ cint @{.importc꞉ "uv_udp_bind", header꞉ "uv.h".@}
@example
proc udp_bind*(handle꞉ PUdp; adr꞉ SockAddrIn; flags꞉ cunsigned)꞉ cint @{.importc꞉ "uv_udp_bind", header꞉ "uv.h".@}
@end example
  

@item udp_bind6
  @findex proc udp_bind6*(handle꞉ PUdp; adr꞉ TSockAddrIn6; flags꞉ cunsigned)꞉ cint @{.importc꞉ "uv_udp_bind6", header꞉ "uv.h".@}
@example
proc udp_bind6*(handle꞉ PUdp; adr꞉ TSockAddrIn6; flags꞉ cunsigned)꞉ cint @{.importc꞉ "uv_udp_bind6", header꞉ "uv.h".@}
@end example
  

@item udp_getsockname
  @findex proc udp_getsockname*(handle꞉ PUdp; name꞉ ptr SockAddr; namelen꞉ var cint)꞉ cint @{.importc꞉ "uv_udp_getsockname", header꞉ "uv.h".@}
@example
proc udp_getsockname*(handle꞉ PUdp; name꞉ ptr SockAddr; namelen꞉ var cint)꞉ cint @{.importc꞉ "uv_udp_getsockname", header꞉ "uv.h".@}
@end example
  

@item udp_send
  @findex proc udp_send*(req꞉ PUdpSend; handle꞉ PUdp; bufs꞉ ptr Buf; bufcnt꞉ cint; adr꞉ SockAddrIn;send_cb꞉ UdpSendProc)꞉ cint @{.importc꞉ "uv_udp_send", header꞉ "uv.h".@}
@example
proc udp_send*(req꞉ PUdpSend; handle꞉ PUdp; bufs꞉ ptr Buf; bufcnt꞉ cint; adr꞉ SockAddrIn;send_cb꞉ UdpSendProc)꞉ cint @{.importc꞉ "uv_udp_send", header꞉ "uv.h".@}
@end example
  

@item udp_send6
  @findex proc udp_send6*(req꞉ PUdpSend; handle꞉ PUdp; bufs꞉ ptr Buf; bufcnt꞉ cint;adr꞉ TSockAddrIn6; send_cb꞉ UdpSendProc)꞉ cint @{.importc꞉ "uv_udp_send6", header꞉ "uv.h".@}
@example
proc udp_send6*(req꞉ PUdpSend; handle꞉ PUdp; bufs꞉ ptr Buf; bufcnt꞉ cint;adr꞉ TSockAddrIn6; send_cb꞉ UdpSendProc)꞉ cint @{.importc꞉ "uv_udp_send6", header꞉ "uv.h".@}
@end example
  

@item udp_recv_start
  @findex proc udp_recv_start*(handle꞉ PUdp; alloc_cb꞉ AllocProc; recv_cb꞉ UdpRecvProc)꞉ cint @{.importc꞉ "uv_udp_recv_start", header꞉ "uv.h".@}
@example
proc udp_recv_start*(handle꞉ PUdp; alloc_cb꞉ AllocProc; recv_cb꞉ UdpRecvProc)꞉ cint @{.importc꞉ "uv_udp_recv_start", header꞉ "uv.h".@}
@end example
  

@item udp_recv_stop
  @findex proc udp_recv_stop*(handle꞉ PUdp)꞉ cint @{.importc꞉ "uv_udp_recv_stop", header꞉ "uv.h".@}
@example
proc udp_recv_stop*(handle꞉ PUdp)꞉ cint @{.importc꞉ "uv_udp_recv_stop", header꞉ "uv.h".@}
@end example
  

@item tty_init
  @findex proc tty_init*(a2꞉ PLoop; a3꞉ pTTy; fd꞉ File)꞉ cint @{.importc꞉ "uv_tty_init",header꞉ "uv.h".@}
@example
proc tty_init*(a2꞉ PLoop; a3꞉ pTTy; fd꞉ File)꞉ cint @{.importc꞉ "uv_tty_init",header꞉ "uv.h".@}
@end example
  

@item tty_set_mode
  @findex proc tty_set_mode*(a2꞉ pTTy; mode꞉ cint)꞉ cint @{.importc꞉ "uv_tty_set_mode",header꞉ "uv.h".@}
@example
proc tty_set_mode*(a2꞉ pTTy; mode꞉ cint)꞉ cint @{.importc꞉ "uv_tty_set_mode",header꞉ "uv.h".@}
@end example
  

@item tty_get_winsize
  @findex proc tty_get_winsize*(a2꞉ pTTy; width꞉ var cint; height꞉ var cint)꞉ cint @{.importc꞉ "uv_tty_get_winsize", header꞉ "uv.h".@}
@example
proc tty_get_winsize*(a2꞉ pTTy; width꞉ var cint; height꞉ var cint)꞉ cint @{.importc꞉ "uv_tty_get_winsize", header꞉ "uv.h".@}
@end example
  

@item tty_reset_mode
  @findex proc tty_reset_mode*() @{.importc꞉ "uv_tty_reset_mode", header꞉ "uv.h".@}
@example
proc tty_reset_mode*() @{.importc꞉ "uv_tty_reset_mode", header꞉ "uv.h".@}
@end example
  

@item guess_handle
  @findex proc guess_handle*(file꞉ File)꞉ HandleType @{.importc꞉ "uv_guess_handle",header꞉ "uv.h".@}
@example
proc guess_handle*(file꞉ File)꞉ HandleType @{.importc꞉ "uv_guess_handle",header꞉ "uv.h".@}
@end example
  

@item pipe_init
  @findex proc pipe_init*(a2꞉ PLoop; handle꞉ PPipe; ipc꞉ int)꞉ cint @{.importc꞉ "uv_pipe_init",header꞉ "uv.h".@}
@example
proc pipe_init*(a2꞉ PLoop; handle꞉ PPipe; ipc꞉ int)꞉ cint @{.importc꞉ "uv_pipe_init",header꞉ "uv.h".@}
@end example
  

@item pipe_open
  @findex proc pipe_open*(a2꞉ PPipe; file꞉ File) @{.importc꞉ "uv_pipe_open", header꞉ "uv.h".@}
@example
proc pipe_open*(a2꞉ PPipe; file꞉ File) @{.importc꞉ "uv_pipe_open", header꞉ "uv.h".@}
@end example
  

@item pipe_bind
  @findex proc pipe_bind*(handle꞉ PPipe; name꞉ cstring)꞉ cint @{.importc꞉ "uv_pipe_bind",header꞉ "uv.h".@}
@example
proc pipe_bind*(handle꞉ PPipe; name꞉ cstring)꞉ cint @{.importc꞉ "uv_pipe_bind",header꞉ "uv.h".@}
@end example
  

@item pipe_connect
  @findex proc pipe_connect*(req꞉ PConnect; handle꞉ PPipe; name꞉ cstring; cb꞉ ConnectProc)꞉ cint @{.importc꞉ "uv_pipe_connect", header꞉ "uv.h".@}
@example
proc pipe_connect*(req꞉ PConnect; handle꞉ PPipe; name꞉ cstring; cb꞉ ConnectProc)꞉ cint @{.importc꞉ "uv_pipe_connect", header꞉ "uv.h".@}
@end example
  

@item prepare_init
  @findex proc prepare_init*(a2꞉ PLoop; prepare꞉ PPrepare)꞉ cint @{.importc꞉ "uv_prepare_init",header꞉ "uv.h".@}
@example
proc prepare_init*(a2꞉ PLoop; prepare꞉ PPrepare)꞉ cint @{.importc꞉ "uv_prepare_init",header꞉ "uv.h".@}
@end example
  

@item prepare_start
  @findex proc prepare_start*(prepare꞉ PPrepare; cb꞉ PrepareProc)꞉ cint @{.importc꞉ "uv_prepare_start", header꞉ "uv.h".@}
@example
proc prepare_start*(prepare꞉ PPrepare; cb꞉ PrepareProc)꞉ cint @{.importc꞉ "uv_prepare_start", header꞉ "uv.h".@}
@end example
  

@item prepare_stop
  @findex proc prepare_stop*(prepare꞉ PPrepare)꞉ cint @{.importc꞉ "uv_prepare_stop",header꞉ "uv.h".@}
@example
proc prepare_stop*(prepare꞉ PPrepare)꞉ cint @{.importc꞉ "uv_prepare_stop",header꞉ "uv.h".@}
@end example
  

@item check_init
  @findex proc check_init*(a2꞉ PLoop; check꞉ PCheck)꞉ cint @{.importc꞉ "uv_check_init",header꞉ "uv.h".@}
@example
proc check_init*(a2꞉ PLoop; check꞉ PCheck)꞉ cint @{.importc꞉ "uv_check_init",header꞉ "uv.h".@}
@end example
  

@item check_start
  @findex proc check_start*(check꞉ PCheck; cb꞉ CheckProc)꞉ cint @{.importc꞉ "uv_check_start",header꞉ "uv.h".@}
@example
proc check_start*(check꞉ PCheck; cb꞉ CheckProc)꞉ cint @{.importc꞉ "uv_check_start",header꞉ "uv.h".@}
@end example
  

@item check_stop
  @findex proc check_stop*(check꞉ PCheck)꞉ cint @{.importc꞉ "uv_check_stop", header꞉ "uv.h".@}
@example
proc check_stop*(check꞉ PCheck)꞉ cint @{.importc꞉ "uv_check_stop", header꞉ "uv.h".@}
@end example
  

@item idle_init
  @findex proc idle_init*(a2꞉ PLoop; idle꞉ PIdle)꞉ cint @{.importc꞉ "uv_idle_init", header꞉ "uv.h".@}
@example
proc idle_init*(a2꞉ PLoop; idle꞉ PIdle)꞉ cint @{.importc꞉ "uv_idle_init", header꞉ "uv.h".@}
@end example
  

@item idle_start
  @findex proc idle_start*(idle꞉ PIdle; cb꞉ IdleProc)꞉ cint @{.importc꞉ "uv_idle_start",header꞉ "uv.h".@}
@example
proc idle_start*(idle꞉ PIdle; cb꞉ IdleProc)꞉ cint @{.importc꞉ "uv_idle_start",header꞉ "uv.h".@}
@end example
  

@item idle_stop
  @findex proc idle_stop*(idle꞉ PIdle)꞉ cint @{.importc꞉ "uv_idle_stop", header꞉ "uv.h".@}
@example
proc idle_stop*(idle꞉ PIdle)꞉ cint @{.importc꞉ "uv_idle_stop", header꞉ "uv.h".@}
@end example
  

@item async_init
  @findex proc async_init*(a2꞉ PLoop; async꞉ PAsync; async_cb꞉ AsyncProc)꞉ cint @{.importc꞉ "uv_async_init", header꞉ "uv.h".@}
@example
proc async_init*(a2꞉ PLoop; async꞉ PAsync; async_cb꞉ AsyncProc)꞉ cint @{.importc꞉ "uv_async_init", header꞉ "uv.h".@}
@end example
  

@item async_send
  @findex proc async_send*(async꞉ PAsync)꞉ cint @{.importc꞉ "uv_async_send", header꞉ "uv.h".@}
@example
proc async_send*(async꞉ PAsync)꞉ cint @{.importc꞉ "uv_async_send", header꞉ "uv.h".@}
@end example
  

@item timer_init
  @findex proc timer_init*(a2꞉ PLoop; timer꞉ PTimer)꞉ cint @{.importc꞉ "uv_timer_init",header꞉ "uv.h".@}
@example
proc timer_init*(a2꞉ PLoop; timer꞉ PTimer)꞉ cint @{.importc꞉ "uv_timer_init",header꞉ "uv.h".@}
@end example
  

@item timer_start
  @findex proc timer_start*(timer꞉ PTimer; cb꞉ TimerProc; timeout꞉ int64; repeat꞉ int64)꞉ cint @{.importc꞉ "uv_timer_start", header꞉ "uv.h".@}
@example
proc timer_start*(timer꞉ PTimer; cb꞉ TimerProc; timeout꞉ int64; repeat꞉ int64)꞉ cint @{.importc꞉ "uv_timer_start", header꞉ "uv.h".@}
@end example
  

@item timer_stop
  @findex proc timer_stop*(timer꞉ PTimer)꞉ cint @{.importc꞉ "uv_timer_stop", header꞉ "uv.h".@}
@example
proc timer_stop*(timer꞉ PTimer)꞉ cint @{.importc꞉ "uv_timer_stop", header꞉ "uv.h".@}
@end example
  

@item timer_again
  @findex proc timer_again*(timer꞉ PTimer)꞉ cint @{.importc꞉ "uv_timer_again", header꞉ "uv.h".@}
@example
proc timer_again*(timer꞉ PTimer)꞉ cint @{.importc꞉ "uv_timer_again", header꞉ "uv.h".@}
@end example
  

@item timer_set_repeat
  @findex proc timer_set_repeat*(timer꞉ PTimer; repeat꞉ int64) @{.importc꞉ "uv_timer_set_repeat", header꞉ "uv.h".@}
@example
proc timer_set_repeat*(timer꞉ PTimer; repeat꞉ int64) @{.importc꞉ "uv_timer_set_repeat", header꞉ "uv.h".@}
@end example
  

@item timer_get_repeat
  @findex proc timer_get_repeat*(timer꞉ PTimer)꞉ int64 @{.importc꞉ "uv_timer_get_repeat",header꞉ "uv.h".@}
@example
proc timer_get_repeat*(timer꞉ PTimer)꞉ int64 @{.importc꞉ "uv_timer_get_repeat",header꞉ "uv.h".@}
@end example
  

@item ares_init_options
  @findex proc ares_init_options*(a2꞉ PLoop; channel꞉ PAresChannel; options꞉ PAresOptions;optmask꞉ cint)꞉ cint @{.importc꞉ "uv_ares_init_options",header꞉ "uv.h".@}
@example
proc ares_init_options*(a2꞉ PLoop; channel꞉ PAresChannel; options꞉ PAresOptions;optmask꞉ cint)꞉ cint @{.importc꞉ "uv_ares_init_options",header꞉ "uv.h".@}
@end example
  

@item ares_destroy
  @findex proc ares_destroy*(a2꞉ PLoop; channel꞉ PAresChannel) @{.importc꞉ "uv_ares_destroy",header꞉ "uv.h".@}
@example
proc ares_destroy*(a2꞉ PLoop; channel꞉ PAresChannel) @{.importc꞉ "uv_ares_destroy",header꞉ "uv.h".@}
@end example
  

@item getaddrinfo
  @findex proc getaddrinfo*(a2꞉ PLoop; handle꞉ PGetAddrInfo; getaddrinfo_cb꞉ GetAddrInfoProc;node꞉ cstring; service꞉ cstring; hints꞉ ptr AddrInfo)꞉ cint @{.importc꞉ "uv_getaddrinfo", header꞉ "uv.h".@}
@example
proc getaddrinfo*(a2꞉ PLoop; handle꞉ PGetAddrInfo; getaddrinfo_cb꞉ GetAddrInfoProc;node꞉ cstring; service꞉ cstring; hints꞉ ptr AddrInfo)꞉ cint @{.importc꞉ "uv_getaddrinfo", header꞉ "uv.h".@}
@end example
  

@item freeaddrinfo
  @findex proc freeaddrinfo*(ai꞉ ptr AddrInfo) @{.importc꞉ "uv_freeaddrinfo", header꞉ "uv.h".@}
@example
proc freeaddrinfo*(ai꞉ ptr AddrInfo) @{.importc꞉ "uv_freeaddrinfo", header꞉ "uv.h".@}
@end example
  

@item spawn
  @findex proc spawn*(a2꞉ PLoop; a3꞉ PProcess; options꞉ ProcessOptions)꞉ cint @{.importc꞉ "uv_spawn", header꞉ "uv.h".@}
@example
proc spawn*(a2꞉ PLoop; a3꞉ PProcess; options꞉ ProcessOptions)꞉ cint @{.importc꞉ "uv_spawn", header꞉ "uv.h".@}
@end example
  

@item process_kill
  @findex proc process_kill*(a2꞉ PProcess; signum꞉ cint)꞉ cint @{.importc꞉ "uv_process_kill",header꞉ "uv.h".@}
@example
proc process_kill*(a2꞉ PProcess; signum꞉ cint)꞉ cint @{.importc꞉ "uv_process_kill",header꞉ "uv.h".@}
@end example
  

@item queue_work
  @findex proc queue_work*(loop꞉ PLoop; req꞉ PWork; work_cb꞉ WorkProc;after_work_cb꞉ AfterWorkProc)꞉ cint @{.importc꞉ "uv_queue_work",header꞉ "uv.h".@}
@example
proc queue_work*(loop꞉ PLoop; req꞉ PWork; work_cb꞉ WorkProc;after_work_cb꞉ AfterWorkProc)꞉ cint @{.importc꞉ "uv_queue_work",header꞉ "uv.h".@}
@end example
  

@item req_cleanup
  @findex proc req_cleanup*(req꞉ PFS) @{.importc꞉ "uv_fs_req_cleanup", header꞉ "uv.h".@}
@example
proc req_cleanup*(req꞉ PFS) @{.importc꞉ "uv_fs_req_cleanup", header꞉ "uv.h".@}
@end example
  

@item close
  @findex proc close*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_close",header꞉ "uv.h".@}
@example
proc close*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_close",header꞉ "uv.h".@}
@end example
  

@item open
  @findex proc open*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; flags꞉ cint; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_open", header꞉ "uv.h".@}
@example
proc open*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; flags꞉ cint; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_open", header꞉ "uv.h".@}
@end example
  

@item read
  @findex proc read*(loop꞉ PLoop; req꞉ PFS; file꞉ File; buf꞉ pointer; length꞉ csize; offset꞉ coff;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_read", header꞉ "uv.h".@}
@example
proc read*(loop꞉ PLoop; req꞉ PFS; file꞉ File; buf꞉ pointer; length꞉ csize; offset꞉ coff;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_read", header꞉ "uv.h".@}
@end example
  

@item unlink
  @findex proc unlink*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_unlink", header꞉ "uv.h".@}
@example
proc unlink*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_unlink", header꞉ "uv.h".@}
@end example
  

@item write
  @findex proc write*(loop꞉ PLoop; req꞉ PFS; file꞉ File; buf꞉ pointer; length꞉ csize; offset꞉ coff;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_write", header꞉ "uv.h".@}
@example
proc write*(loop꞉ PLoop; req꞉ PFS; file꞉ File; buf꞉ pointer; length꞉ csize; offset꞉ coff;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_write", header꞉ "uv.h".@}
@end example
  

@item mkdir
  @findex proc mkdir*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_mkdir", header꞉ "uv.h".@}
@example
proc mkdir*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_mkdir", header꞉ "uv.h".@}
@end example
  

@item rmdir
  @findex proc rmdir*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_rmdir", header꞉ "uv.h".@}
@example
proc rmdir*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_rmdir", header꞉ "uv.h".@}
@end example
  

@item readdir
  @findex proc readdir*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; flags꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_readdir", header꞉ "uv.h".@}
@example
proc readdir*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; flags꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_readdir", header꞉ "uv.h".@}
@end example
  

@item stat
  @findex proc stat*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_stat", header꞉ "uv.h".@}
@example
proc stat*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_stat", header꞉ "uv.h".@}
@end example
  

@item fstat
  @findex proc fstat*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fstat",header꞉ "uv.h".@}
@example
proc fstat*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fstat",header꞉ "uv.h".@}
@end example
  

@item rename
  @findex proc rename*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; new_path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_rename", header꞉ "uv.h".@}
@example
proc rename*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; new_path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_rename", header꞉ "uv.h".@}
@end example
  

@item fsync
  @findex proc fsync*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fsync",header꞉ "uv.h".@}
@example
proc fsync*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fsync",header꞉ "uv.h".@}
@end example
  

@item fdatasync
  @findex proc fdatasync*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fdatasync", header꞉ "uv.h".@}
@example
proc fdatasync*(loop꞉ PLoop; req꞉ PFS; file꞉ File; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fdatasync", header꞉ "uv.h".@}
@end example
  

@item ftruncate
  @findex proc ftruncate*(loop꞉ PLoop; req꞉ PFS; file꞉ File; offset꞉ coff; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_ftruncate", header꞉ "uv.h".@}
@example
proc ftruncate*(loop꞉ PLoop; req꞉ PFS; file꞉ File; offset꞉ coff; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_ftruncate", header꞉ "uv.h".@}
@end example
  

@item sendfile
  @findex proc sendfile*(loop꞉ PLoop; req꞉ PFS; out_fd꞉ File; in_fd꞉ File; in_offset꞉ coff;length꞉ csize; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_sendfile",header꞉ "uv.h".@}
@example
proc sendfile*(loop꞉ PLoop; req꞉ PFS; out_fd꞉ File; in_fd꞉ File; in_offset꞉ coff;length꞉ csize; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_sendfile",header꞉ "uv.h".@}
@end example
  

@item chmod
  @findex proc chmod*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_chmod", header꞉ "uv.h".@}
@example
proc chmod*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_chmod", header꞉ "uv.h".@}
@end example
  

@item utime
  @findex proc utime*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; atime꞉ cdouble; mtime꞉ cdouble;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_utime", header꞉ "uv.h".@}
@example
proc utime*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; atime꞉ cdouble; mtime꞉ cdouble;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_utime", header꞉ "uv.h".@}
@end example
  

@item futime
  @findex proc futime*(loop꞉ PLoop; req꞉ PFS; file꞉ File; atime꞉ cdouble; mtime꞉ cdouble; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_futime", header꞉ "uv.h".@}
@example
proc futime*(loop꞉ PLoop; req꞉ PFS; file꞉ File; atime꞉ cdouble; mtime꞉ cdouble; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_futime", header꞉ "uv.h".@}
@end example
  

@item lstat
  @findex proc lstat*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_lstat", header꞉ "uv.h".@}
@example
proc lstat*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_lstat", header꞉ "uv.h".@}
@end example
  

@item link
  @findex proc link*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; new_path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_link", header꞉ "uv.h".@}
@example
proc link*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; new_path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_link", header꞉ "uv.h".@}
@end example
  

@item symlink
  @findex proc symlink*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; new_path꞉ cstring; flags꞉ cint;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_symlink", header꞉ "uv.h".@}
@example
proc symlink*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; new_path꞉ cstring; flags꞉ cint;cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_symlink", header꞉ "uv.h".@}
@end example
  

@item readlink
  @findex proc readlink*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_readlink", header꞉ "uv.h".@}
@example
proc readlink*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_readlink", header꞉ "uv.h".@}
@end example
  

@item fchmod
  @findex proc fchmod*(loop꞉ PLoop; req꞉ PFS; file꞉ File; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fchmod", header꞉ "uv.h".@}
@example
proc fchmod*(loop꞉ PLoop; req꞉ PFS; file꞉ File; mode꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fchmod", header꞉ "uv.h".@}
@end example
  

@item chown
  @findex proc chown*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; uid꞉ cint; gid꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_chown", header꞉ "uv.h".@}
@example
proc chown*(loop꞉ PLoop; req꞉ PFS; path꞉ cstring; uid꞉ cint; gid꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_chown", header꞉ "uv.h".@}
@end example
  

@item fchown
  @findex proc fchown*(loop꞉ PLoop; req꞉ PFS; file꞉ File; uid꞉ cint; gid꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fchown", header꞉ "uv.h".@}
@example
proc fchown*(loop꞉ PLoop; req꞉ PFS; file꞉ File; uid꞉ cint; gid꞉ cint; cb꞉ FsProc)꞉ cint @{.importc꞉ "uv_fs_fchown", header꞉ "uv.h".@}
@end example
  

@item event_init
  @findex proc event_init*(loop꞉ PLoop; handle꞉ PFSEvent; filename꞉ cstring; cb꞉ FsEventProc)꞉ cint @{.importc꞉ "uv_fs_event_init", header꞉ "uv.h".@}
@example
proc event_init*(loop꞉ PLoop; handle꞉ PFSEvent; filename꞉ cstring; cb꞉ FsEventProc)꞉ cint @{.importc꞉ "uv_fs_event_init", header꞉ "uv.h".@}
@end example
  

@item ip4_addr
  @findex proc ip4_addr*(ip꞉ cstring; port꞉ cint)꞉ SockAddrIn @{.importc꞉ "uv_ip4_addr",header꞉ "uv.h".@}
@example
proc ip4_addr*(ip꞉ cstring; port꞉ cint)꞉ SockAddrIn @{.importc꞉ "uv_ip4_addr",header꞉ "uv.h".@}
@end example
  

@item ip6_addr
  @findex proc ip6_addr*(ip꞉ cstring; port꞉ cint)꞉ TSockAddrIn6 @{.importc꞉ "uv_ip6_addr",header꞉ "uv.h".@}
@example
proc ip6_addr*(ip꞉ cstring; port꞉ cint)꞉ TSockAddrIn6 @{.importc꞉ "uv_ip6_addr",header꞉ "uv.h".@}
@end example
  

@item ip4_name
  @findex proc ip4_name*(src꞉ ptr SockAddrIn; dst꞉ cstring; size꞉ csize)꞉ cint @{.importc꞉ "uv_ip4_name", header꞉ "uv.h".@}
@example
proc ip4_name*(src꞉ ptr SockAddrIn; dst꞉ cstring; size꞉ csize)꞉ cint @{.importc꞉ "uv_ip4_name", header꞉ "uv.h".@}
@end example
  

@item ip6_name
  @findex proc ip6_name*(src꞉ ptr TSockAddrIn6; dst꞉ cstring; size꞉ csize)꞉ cint @{.importc꞉ "uv_ip6_name", header꞉ "uv.h".@}
@example
proc ip6_name*(src꞉ ptr TSockAddrIn6; dst꞉ cstring; size꞉ csize)꞉ cint @{.importc꞉ "uv_ip6_name", header꞉ "uv.h".@}
@end example
  

@item exepath
  @findex proc exepath*(buffer꞉ cstring; size꞉ var csize)꞉ cint @{.importc꞉ "uv_exepath",header꞉ "uv.h".@}
@example
proc exepath*(buffer꞉ cstring; size꞉ var csize)꞉ cint @{.importc꞉ "uv_exepath",header꞉ "uv.h".@}
@end example
  

@item hrtime
  @findex proc hrtime*()꞉ uint64 @{.importc꞉ "uv_hrtime", header꞉ "uv.h".@}
@example
proc hrtime*()꞉ uint64 @{.importc꞉ "uv_hrtime", header꞉ "uv.h".@}
@end example
  

@item loadavg
  @findex proc loadavg*(load꞉ var array[0 .. 2, cdouble]) @{.importc꞉ "uv_loadavg", header꞉ "uv.h".@}
@example
proc loadavg*(load꞉ var array[0 .. 2, cdouble]) @{.importc꞉ "uv_loadavg", header꞉ "uv.h".@}
@end example
  

@item get_free_memory
  @findex proc get_free_memory*()꞉ cdouble @{.importc꞉ "uv_get_free_memory", header꞉ "uv.h".@}
@example
proc get_free_memory*()꞉ cdouble @{.importc꞉ "uv_get_free_memory", header꞉ "uv.h".@}
@end example
  

@item get_total_memory
  @findex proc get_total_memory*()꞉ cdouble @{.importc꞉ "uv_get_total_memory", header꞉ "uv.h".@}
@example
proc get_total_memory*()꞉ cdouble @{.importc꞉ "uv_get_total_memory", header꞉ "uv.h".@}
@end example
  
@end itemize






@node /wrappers/libsvm, /wrappers/linenoise/linenoise , /wrappers/libuv, Top
@chapter Constant variables

@itemize


@item LIBSVM_VERSION
  @vindex LIBSVM_VERSION* = 312
@example
LIBSVM_VERSION* = 312
@end example
  

@item svmdll
  @vindex svmdll* = "libsvm.dll"
@example
svmdll* = "libsvm.dll"
@end example
  
@end itemize



@chapter Types

@itemize


@item Parameter
  @tindex Parameter* @{.pure, final.@} = object
  typ*: Type
  kernelType*: KernelType
  degree*: cint
  gamma*: cdouble
  coef0*: cdouble
  cache_size*: cdouble
  eps*: cdouble
  C*: cdouble
  nr_weight*: cint
  weight_label*: ptr cint
  weight*: ptr cdouble
  nu*: cdouble
  p*: cdouble
  shrinking*: cint
  probability*: cint

@example
Parameter* @{.pure, final.@} = object
  typ*: Type
  kernelType*: KernelType
  degree*: cint
  gamma*: cdouble
  coef0*: cdouble
  cache_size*: cdouble
  eps*: cdouble
  C*: cdouble
  nr_weight*: cint
  weight_label*: ptr cint
  weight*: ptr cdouble
  nu*: cdouble
  p*: cdouble
  shrinking*: cint
  probability*: cint

@end example
  

@item Model
  @tindex Model* @{.pure, final.@} = object
  param*: Parameter
  nr_class*: cint
  L*: cint
  SV*: ptr ptr Node
  sv_coef*: ptr ptr cdouble
  rho*: ptr cdouble
  probA*: ptr cdouble
  probB*: ptr cdouble
  label*: ptr cint
  nSV*: ptr cint
  free_sv*: cint

@example
Model* @{.pure, final.@} = object
  param*: Parameter
  nr_class*: cint
  L*: cint
  SV*: ptr ptr Node
  sv_coef*: ptr ptr cdouble
  rho*: ptr cdouble
  probA*: ptr cdouble
  probB*: ptr cdouble
  label*: ptr cint
  nSV*: ptr cint
  free_sv*: cint

@end example
  
@end itemize

@chapter Procedures

@itemize


@item train
  @findex proc train*(prob꞉ ptr Problem; param꞉ ptr Parameter)꞉ ptr Model @{.cdecl,importc꞉ "svm_train", dynlib꞉ svmdll.@}
@example
proc train*(prob꞉ ptr Problem; param꞉ ptr Parameter)꞉ ptr Model @{.cdecl,importc꞉ "svm_train", dynlib꞉ svmdll.@}
@end example
  

@item cross_validation
  @findex proc cross_validation*(prob꞉ ptr Problem; param꞉ ptr Parameter; nr_fold꞉ cint;target꞉ ptr cdouble) @{.cdecl, importc꞉ "svm_cross_validation",dynlib꞉ svmdll.@}
@example
proc cross_validation*(prob꞉ ptr Problem; param꞉ ptr Parameter; nr_fold꞉ cint;target꞉ ptr cdouble) @{.cdecl, importc꞉ "svm_cross_validation",dynlib꞉ svmdll.@}
@end example
  

@item save_model
  @findex proc save_model*(model_file_name꞉ cstring; model꞉ ptr Model)꞉ cint @{.cdecl,importc꞉ "svm_save_model", dynlib꞉ svmdll.@}
@example
proc save_model*(model_file_name꞉ cstring; model꞉ ptr Model)꞉ cint @{.cdecl,importc꞉ "svm_save_model", dynlib꞉ svmdll.@}
@end example
  

@item load_model
  @findex proc load_model*(model_file_name꞉ cstring)꞉ ptr Model @{.cdecl,importc꞉ "svm_load_model", dynlib꞉ svmdll.@}
@example
proc load_model*(model_file_name꞉ cstring)꞉ ptr Model @{.cdecl,importc꞉ "svm_load_model", dynlib꞉ svmdll.@}
@end example
  

@item get_svm_type
  @findex proc get_svm_type*(model꞉ ptr Model)꞉ cint @{.cdecl, importc꞉ "svm_get_svm_type",dynlib꞉ svmdll.@}
@example
proc get_svm_type*(model꞉ ptr Model)꞉ cint @{.cdecl, importc꞉ "svm_get_svm_type",dynlib꞉ svmdll.@}
@end example
  

@item get_nr_class
  @findex proc get_nr_class*(model꞉ ptr Model)꞉ cint @{.cdecl, importc꞉ "svm_get_nr_class",dynlib꞉ svmdll.@}
@example
proc get_nr_class*(model꞉ ptr Model)꞉ cint @{.cdecl, importc꞉ "svm_get_nr_class",dynlib꞉ svmdll.@}
@end example
  

@item get_labels
  @findex proc get_labels*(model꞉ ptr Model; label꞉ ptr cint) @{.cdecl, importc꞉ "svm_get_labels",dynlib꞉ svmdll.@}
@example
proc get_labels*(model꞉ ptr Model; label꞉ ptr cint) @{.cdecl, importc꞉ "svm_get_labels",dynlib꞉ svmdll.@}
@end example
  

@item get_svr_probability
  @findex proc get_svr_probability*(model꞉ ptr Model)꞉ cdouble @{.cdecl,importc꞉ "svm_get_svr_probability", dynlib꞉ svmdll.@}
@example
proc get_svr_probability*(model꞉ ptr Model)꞉ cdouble @{.cdecl,importc꞉ "svm_get_svr_probability", dynlib꞉ svmdll.@}
@end example
  

@item predict_values
  @findex proc predict_values*(model꞉ ptr Model; x꞉ ptr Node; dec_values꞉ ptr cdouble)꞉ cdouble @{.cdecl, importc꞉ "svm_predict_values", dynlib꞉ svmdll.@}
@example
proc predict_values*(model꞉ ptr Model; x꞉ ptr Node; dec_values꞉ ptr cdouble)꞉ cdouble @{.cdecl, importc꞉ "svm_predict_values", dynlib꞉ svmdll.@}
@end example
  

@item predict
  @findex proc predict*(model꞉ ptr Model; x꞉ ptr Node)꞉ cdouble @{.cdecl, importc꞉ "svm_predict",dynlib꞉ svmdll.@}
@example
proc predict*(model꞉ ptr Model; x꞉ ptr Node)꞉ cdouble @{.cdecl, importc꞉ "svm_predict",dynlib꞉ svmdll.@}
@end example
  

@item predict_probability
  @findex proc predict_probability*(model꞉ ptr Model; x꞉ ptr Node; prob_estimates꞉ ptr cdouble)꞉ cdouble @{.cdecl, importc꞉ "svm_predict_probability", dynlib꞉ svmdll.@}
@example
proc predict_probability*(model꞉ ptr Model; x꞉ ptr Node; prob_estimates꞉ ptr cdouble)꞉ cdouble @{.cdecl, importc꞉ "svm_predict_probability", dynlib꞉ svmdll.@}
@end example
  

@item free_model_content
  @findex proc free_model_content*(model_ptr꞉ ptr Model) @{.cdecl,importc꞉ "svm_free_model_content", dynlib꞉ svmdll.@}
@example
proc free_model_content*(model_ptr꞉ ptr Model) @{.cdecl,importc꞉ "svm_free_model_content", dynlib꞉ svmdll.@}
@end example
  

@item free_and_destroy_model
  @findex proc free_and_destroy_model*(model_ptr_ptr꞉ ptr ptr Model) @{.cdecl,importc꞉ "svm_free_and_destroy_model", dynlib꞉ svmdll.@}
@example
proc free_and_destroy_model*(model_ptr_ptr꞉ ptr ptr Model) @{.cdecl,importc꞉ "svm_free_and_destroy_model", dynlib꞉ svmdll.@}
@end example
  

@item destroy_param
  @findex proc destroy_param*(param꞉ ptr Parameter) @{.cdecl, importc꞉ "svm_destroy_param",dynlib꞉ svmdll.@}
@example
proc destroy_param*(param꞉ ptr Parameter) @{.cdecl, importc꞉ "svm_destroy_param",dynlib꞉ svmdll.@}
@end example
  

@item check_parameter
  @findex proc check_parameter*(prob꞉ ptr Problem; param꞉ ptr Parameter)꞉ cstring @{.cdecl,importc꞉ "svm_check_parameter", dynlib꞉ svmdll.@}
@example
proc check_parameter*(prob꞉ ptr Problem; param꞉ ptr Parameter)꞉ cstring @{.cdecl,importc꞉ "svm_check_parameter", dynlib꞉ svmdll.@}
@end example
  

@item check_probability_model
  @findex proc check_probability_model*(model꞉ ptr Model)꞉ cint @{.cdecl,importc꞉ "svm_check_probability_model", dynlib꞉ svmdll.@}
@example
proc check_probability_model*(model꞉ ptr Model)꞉ cint @{.cdecl,importc꞉ "svm_check_probability_model", dynlib꞉ svmdll.@}
@end example
  

@item set_print_string_function
  @findex proc set_print_string_function*(print_func꞉ proc (arg꞉ cstring) @{.cdecl.@}) @{.cdecl,importc꞉ "svm_set_print_string_function", dynlib꞉ svmdll.@}
@example
proc set_print_string_function*(print_func꞉ proc (arg꞉ cstring) @{.cdecl.@}) @{.cdecl,importc꞉ "svm_set_print_string_function", dynlib꞉ svmdll.@}
@end example
  
@end itemize






@node /wrappers/linenoise/linenoise, /system/sysspawn , /wrappers/libsvm, Top



@chapter Types

@itemize


@item CompletionCallback
  @tindex CompletionCallback* = proc (a2꞉ cstring; a3꞉ ptr Completions) @{.cdecl.@}
@example
CompletionCallback* = proc (a2꞉ cstring; a3꞉ ptr Completions) @{.cdecl.@}
@end example
  
@end itemize

@chapter Procedures

@itemize


@item setCompletionCallback
  @findex proc setCompletionCallback*(a2꞉ ptr CompletionCallback) @{.importc꞉ "linenoiseSetCompletionCallback".@}
@example
proc setCompletionCallback*(a2꞉ ptr CompletionCallback) @{.importc꞉ "linenoiseSetCompletionCallback".@}
@end example
  

@item addCompletion
  @findex proc addCompletion*(a2꞉ ptr Completions; a3꞉ cstring) @{.importc꞉ "linenoiseAddCompletion".@}
@example
proc addCompletion*(a2꞉ ptr Completions; a3꞉ cstring) @{.importc꞉ "linenoiseAddCompletion".@}
@end example
  

@item readLine
  @findex proc readLine*(prompt꞉ cstring)꞉ cstring @{.importc꞉ "linenoise".@}
@example
proc readLine*(prompt꞉ cstring)꞉ cstring @{.importc꞉ "linenoise".@}
@end example
  

@item historyAdd
  @findex proc historyAdd*(line꞉ cstring)꞉ cint @{.importc꞉ "linenoiseHistoryAdd", discardable.@}
@example
proc historyAdd*(line꞉ cstring)꞉ cint @{.importc꞉ "linenoiseHistoryAdd", discardable.@}
@end example
  

@item historySetMaxLen
  @findex proc historySetMaxLen*(len꞉ cint)꞉ cint @{.importc꞉ "linenoiseHistorySetMaxLen".@}
@example
proc historySetMaxLen*(len꞉ cint)꞉ cint @{.importc꞉ "linenoiseHistorySetMaxLen".@}
@end example
  

@item historySave
  @findex proc historySave*(filename꞉ cstring)꞉ cint @{.importc꞉ "linenoiseHistorySave".@}
@example
proc historySave*(filename꞉ cstring)꞉ cint @{.importc꞉ "linenoiseHistorySave".@}
@end example
  

@item historyLoad
  @findex proc historyLoad*(filename꞉ cstring)꞉ cint @{.importc꞉ "linenoiseHistoryLoad".@}
@example
proc historyLoad*(filename꞉ cstring)꞉ cint @{.importc꞉ "linenoiseHistoryLoad".@}
@end example
  

@item clearScreen
  @findex proc clearScreen*() @{.importc꞉ "linenoiseClearScreen".@}
@example
proc clearScreen*() @{.importc꞉ "linenoiseClearScreen".@}
@end example
  

@item setMultiLine
  @findex proc setMultiLine*(ml꞉ cint) @{.importc꞉ "linenoiseSetMultiLine".@}
@example
proc setMultiLine*(ml꞉ cint) @{.importc꞉ "linenoiseSetMultiLine".@}
@end example
  

@item printKeyCodes
  @findex proc printKeyCodes*() @{.importc꞉ "linenoisePrintKeyCodes".@}
@example
proc printKeyCodes*() @{.importc꞉ "linenoisePrintKeyCodes".@}
@end example
  

@item free
  @findex proc free*(s꞉ cstring) @{.importc꞉ "free", header꞉ "<stdlib.h>".@}
@example
proc free*(s꞉ cstring) @{.importc꞉ "free", header꞉ "<stdlib.h>".@}
@end example
  
@end itemize






@node /system/sysspawn, /system/threads , /wrappers/linenoise/linenoise, Top



@chapter Types

@itemize


@item Barrier
  @tindex Barrier* @{.compilerProc.@} = object
  counter: int
  cv: CondVar

@example
Barrier* @{.compilerProc.@} = object
  counter: int
  cv: CondVar

@end example
  
@end itemize

@chapter Procedures

@itemize


@item barrierEnter
  @findex proc barrierEnter*(b꞉ ptr Barrier) @{.compilerProc.@}
@example
proc barrierEnter*(b꞉ ptr Barrier) @{.compilerProc.@}
@end example
  

@item barrierLeave
  @findex proc barrierLeave*(b꞉ ptr Barrier) @{.compilerProc.@}
@example
proc barrierLeave*(b꞉ ptr Barrier) @{.compilerProc.@}
@end example
  

@item openBarrier
  @findex proc openBarrier*(b꞉ ptr Barrier) @{.compilerProc.@}
@example
proc openBarrier*(b꞉ ptr Barrier) @{.compilerProc.@}
@end example
  

@item closeBarrier
  @findex proc closeBarrier*(b꞉ ptr Barrier) @{.compilerProc.@}
@example
proc closeBarrier*(b꞉ ptr Barrier) @{.compilerProc.@}
@end example
  

@item preferSpawn
  @findex proc preferSpawn*()꞉ bool
@example
proc preferSpawn*()꞉ bool
@end example
  Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead.

@item spawn
  @findex proc spawn*(call꞉ stmt) @{.magic꞉ "Spawn".@}
@example
proc spawn*(call꞉ stmt) @{.magic꞉ "Spawn".@}
@end example
  always spawns a new task, so that the 'call' is never executed on the calling thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has 'void' as the return type.

@item sync
  @findex proc sync*()
@example
proc sync*()
@end example
  a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier.
@end itemize

@chapter Templates

@itemize


@item spawnX
  @findex template spawnX*(call꞉ stmt)
@example
template spawnX*(call꞉ stmt)
@end example
  spawns a new task if a CPU core is ready, otherwise executes the call in the calling thread. Usually it is advised to use 'spawn' in order to not block the producer for an unknown amount of time. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has 'void' as the return type.
@end itemize





@node /system/threads, /system/gc , /system/sysspawn, Top



@chapter Types

@itemize


@item ThreadId
  @tindex ThreadId*[TArg] = ptr Thread[TArg]
@example
ThreadId*[TArg] = ptr Thread[TArg]
@end example
  the current implementation uses a pointer as a thread ID.
@end itemize

@chapter Procedures

@itemize


@item running
  @findex proc running*[TArg](t꞉ Thread[TArg])꞉ bool @{.inline.@}
@example
proc running*[TArg](t꞉ Thread[TArg])꞉ bool @{.inline.@}
@end example
  returns true if @emph{t} is running.

@item joinThread
  @findex proc joinThread*[TArg](t꞉ Thread[TArg]) @{.inline.@}
@example
proc joinThread*[TArg](t꞉ Thread[TArg]) @{.inline.@}
@end example
  waits for the thread @emph{t} to finish.

@item joinThreads
  @findex proc joinThreads*[TArg](t꞉ varargs[Thread[TArg]])
@example
proc joinThreads*[TArg](t꞉ varargs[Thread[TArg]])
@end example
  waits for every thread in @emph{t} to finish.

@item createThread
  @findex proc createThread*[TArg](t꞉ var Thread[TArg]; tp꞉ proc (arg꞉ TArg) @{.thread.@};param꞉ TArg)
@example
proc createThread*[TArg](t꞉ var Thread[TArg]; tp꞉ proc (arg꞉ TArg) @{.thread.@};param꞉ TArg)
@end example
  creates a new thread @emph{t} and starts its execution. Entry point is the proc @emph{tp}. @emph{param} is passed to @emph{tp}. @emph{TArg} can be @code{void} if you don't need to pass any data to the thread.

@item pinToCpu
  @findex proc pinToCpu*[Arg](t꞉ var Thread[Arg]; cpu꞉ Natural)
@example
proc pinToCpu*[Arg](t꞉ var Thread[Arg]; cpu꞉ Natural)
@end example
  pins a thread to a . In other words sets a thread's . If you don't know what this means, you shouldn't use this proc.

@item createThread
  @findex proc createThread*(t꞉ var Thread[void]; tp꞉ proc () @{.thread.@})
@example
proc createThread*(t꞉ var Thread[void]; tp꞉ proc () @{.thread.@})
@end example
  

@item threadId
  @findex proc threadId*[TArg](t꞉ var Thread[TArg])꞉ ThreadId[TArg] @{.inline.@}
@example
proc threadId*[TArg](t꞉ var Thread[TArg])꞉ ThreadId[TArg] @{.inline.@}
@end example
  returns the thread ID of @emph{t}.
@end itemize






@node /system/gc, /system/profiler , /system/threads, Top




@chapter Procedures

@itemize


@item GC_addCycleRoot
  @findex proc GC_addCycleRoot*[T](p꞉ ref T) @{.inline.@}
@example
proc GC_addCycleRoot*[T](p꞉ ref T) @{.inline.@}
@end example
  adds 'p' to the cycle candidate set for the cycle collector. It is necessary if you used the 'acyclic' pragma for optimization purposes and need to break cycles manually.

@item gcInvariant
  @findex proc gcInvariant*()
@example
proc gcInvariant*()
@end example
  

@item GC_setMaxPause
  @findex proc GC_setMaxPause*(MaxPauseInUs꞉ int)
@example
proc GC_setMaxPause*(MaxPauseInUs꞉ int)
@end example
  

@item GC_step
  @findex proc GC_step*(us꞉ int; strongAdvice = false)
@example
proc GC_step*(us꞉ int; strongAdvice = false)
@end example
  
@end itemize






@node /system/profiler, /system/alloc , /system/gc, Top


@chapter Variables

@itemize


@item profilingRequestedHook
  @vindex profilingRequestedHook*꞉ proc ()꞉ bool @{.nimcall, benign.@}
@example
profilingRequestedHook*꞉ proc ()꞉ bool @{.nimcall, benign.@}
@end example
  set this variable to provide a procedure that implements a profiler in user space. See the @emph{nimprof} module for a reference implementation.

@item profilerHook
  @vindex profilerHook*꞉ MemProfilerHook
@example
profilerHook*꞉ MemProfilerHook
@end example
  set this variable to provide a procedure that implements a profiler in user space. See the @emph{nimprof} module for a reference implementation.
@end itemize

@chapter Types

@itemize


@item ProfilerHook
  @tindex ProfilerHook* = proc (st꞉ StackTrace) @{.nimcall.@}
@example
ProfilerHook* = proc (st꞉ StackTrace) @{.nimcall.@}
@end example
  

@item MemProfilerHook
  @tindex MemProfilerHook* = proc (st꞉ StackTrace; requestedSize꞉ int) @{.nimcall, benign.@}
@example
MemProfilerHook* = proc (st꞉ StackTrace; requestedSize꞉ int) @{.nimcall, benign.@}
@end example
  
@end itemize







@node /system/alloc, /system/gc2 , /system/profiler, Top




@chapter Procedures

@itemize


@item iterToProc
  @findex proc iterToProc*(iter꞉ typed; envType꞉ typedesc; procName꞉ untyped) @{.magic꞉ "Plugin",compileTime.@}
@example
proc iterToProc*(iter꞉ typed; envType꞉ typedesc; procName꞉ untyped) @{.magic꞉ "Plugin",compileTime.@}
@end example
  
@end itemize






@node /system/gc2, /system/channels , /system/alloc, Top




@chapter Procedures

@itemize


@item GC_addCycleRoot
  @findex proc GC_addCycleRoot*[T](p꞉ ref T) @{.inline.@}
@example
proc GC_addCycleRoot*[T](p꞉ ref T) @{.inline.@}
@end example
  adds 'p' to the cycle candidate set for the cycle collector. It is necessary if you used the 'acyclic' pragma for optimization purposes and need to break cycles manually.

@item gcInvariant
  @findex proc gcInvariant*()
@example
proc gcInvariant*()
@end example
  

@item GC_setMaxPause
  @findex proc GC_setMaxPause*(MaxPauseInUs꞉ int)
@example
proc GC_setMaxPause*(MaxPauseInUs꞉ int)
@end example
  

@item GC_step
  @findex proc GC_step*(us꞉ int; strongAdvice = false)
@example
proc GC_step*(us꞉ int; strongAdvice = false)
@end example
  
@end itemize






@node /system/channels, /system/debugger , /system/gc2, Top



@chapter Types

@itemize


@item Channel
  @tindex Channel* @{.gcsafe.@}[TMsg] = RawChannel
@example
Channel* @{.gcsafe.@}[TMsg] = RawChannel
@end example
  a channel for thread communication
@end itemize

@chapter Procedures

@itemize


@item send
  @findex proc send*[TMsg](c꞉ var Channel[TMsg]; msg꞉ TMsg)
@example
proc send*[TMsg](c꞉ var Channel[TMsg]; msg꞉ TMsg)
@end example
  sends a message to a thread. @emph{msg} is deeply copied.

@item recv
  @findex proc recv*[TMsg](c꞉ var Channel[TMsg])꞉ TMsg
@example
proc recv*[TMsg](c꞉ var Channel[TMsg])꞉ TMsg
@end example
  receives a message from the channel @emph{c}. This blocks until a message has arrived! You may use @code{peek} to avoid the blocking.

@item tryRecv
  @findex proc tryRecv*[TMsg](c꞉ var Channel[TMsg])꞉ tuple[dataAvailable꞉ bool, msg꞉ TMsg]
@example
proc tryRecv*[TMsg](c꞉ var Channel[TMsg])꞉ tuple[dataAvailable꞉ bool, msg꞉ TMsg]
@end example
  try to receives a message from the channel @emph{c} if available. Otherwise it returns @code{(false, default(msg))}.

@item peek
  @findex proc peek*[TMsg](c꞉ var Channel[TMsg])꞉ int
@example
proc peek*[TMsg](c꞉ var Channel[TMsg])꞉ int
@end example
  returns the current number of messages in the channel @emph{c}. Returns -1 if the channel has been closed. @strong{Note}: This is dangerous to use as it encourages races. It's much better to use @code{tryRecv} instead.

@item open
  @findex proc open*[TMsg](c꞉ var Channel[TMsg])
@example
proc open*[TMsg](c꞉ var Channel[TMsg])
@end example
  opens a channel @emph{c} for inter thread communication.

@item close
  @findex proc close*[TMsg](c꞉ var Channel[TMsg])
@example
proc close*[TMsg](c꞉ var Channel[TMsg])
@end example
  closes a channel @emph{c} and frees its associated resources.

@item ready
  @findex proc ready*[TMsg](c꞉ var Channel[TMsg])꞉ bool
@example
proc ready*[TMsg](c꞉ var Channel[TMsg])꞉ bool
@end example
  returns true iff some thread is waiting on the channel @emph{c} for new messages.
@end itemize






@node /system/debugger, /system/atomics , /system/channels, Top


@chapter Variables

@itemize


@item dbgWatchpointHook
  @vindex dbgWatchpointHook*꞉ proc (watchpointName꞉ cstring) @{.nimcall.@}
@example
dbgWatchpointHook*꞉ proc (watchpointName꞉ cstring) @{.nimcall.@}
@end example
  
@end itemize

@chapter Types

@itemize


@item Breakpoint
  @tindex Breakpoint* = object
  low*, high*: int              ## range from low to high; if disabled
                ## both low and high are set to their negative values
  filename*: cstring           ## the filename of the breakpoint
  
@example
Breakpoint* = object
  low*, high*: int              ## range from low to high; if disabled
                ## both low and high are set to their negative values
  filename*: cstring           ## the filename of the breakpoint
  
@end example
  represents a break point
@end itemize

@chapter Procedures

@itemize


@item getLocal
  @findex proc getLocal*(frame꞉ PFrame; slot꞉ int)꞉ VarSlot @{.inline.@}
@example
proc getLocal*(frame꞉ PFrame; slot꞉ int)꞉ VarSlot @{.inline.@}
@end example
  retrieves the meta data for the local variable at @emph{slot}. CAUTION: An invalid @emph{slot} value causes a corruption!

@item getGlobalLen
  @findex proc getGlobalLen*()꞉ int @{.inline.@}
@example
proc getGlobalLen*()꞉ int @{.inline.@}
@end example
  gets the number of registered globals.

@item getGlobal
  @findex proc getGlobal*(slot꞉ int)꞉ VarSlot @{.inline.@}
@example
proc getGlobal*(slot꞉ int)꞉ VarSlot @{.inline.@}
@end example
  retrieves the meta data for the global variable at @emph{slot}. CAUTION: An invalid @emph{slot} value causes a corruption!

@item addBreakpoint
  @findex proc addBreakpoint*(filename꞉ cstring; lo, hi꞉ int)꞉ bool
@example
proc addBreakpoint*(filename꞉ cstring; lo, hi꞉ int)꞉ bool
@end example
  

@item canonFilename
  @findex proc canonFilename*(filename꞉ cstring)꞉ cstring
@example
proc canonFilename*(filename꞉ cstring)꞉ cstring
@end example
  returns 'nil' if the filename cannot be found.

@item isActive
  @findex proc isActive*(b꞉ ptr Breakpoint)꞉ bool
@example
proc isActive*(b꞉ ptr Breakpoint)꞉ bool
@end example
  

@item flip
  @findex proc flip*(b꞉ ptr Breakpoint)
@example
proc flip*(b꞉ ptr Breakpoint)
@end example
  enables or disables 'b' depending on its current state.

@item checkBreakpoints
  @findex proc checkBreakpoints*(filename꞉ cstring; line꞉ int)꞉ ptr Breakpoint
@example
proc checkBreakpoints*(filename꞉ cstring; line꞉ int)꞉ ptr Breakpoint
@end example
  in which breakpoint (if any) we are.

@item dbgUnregisterWatchpoints
  @findex proc dbgUnregisterWatchpoints*()
@example
proc dbgUnregisterWatchpoints*()
@end example
  
@end itemize





@chapter Iterators

@itemize


@item listBreakpoints
  @itindex iterator listBreakpoints*()꞉ ptr Breakpoint
@example
iterator listBreakpoints*()꞉ ptr Breakpoint
@end example
  lists all breakpoints.
@end itemize

@node /system/atomics, /system/nimscript , /system/debugger, Top


@chapter Variables

@itemize


@item ATOMIC_RELAXED
  @vindex ATOMIC_RELAXED* @{.importc꞉ "__ATOMIC_RELAXED", nodecl.@}꞉ AtomMemModel
@example
ATOMIC_RELAXED* @{.importc꞉ "__ATOMIC_RELAXED", nodecl.@}꞉ AtomMemModel
@end example
  No barriers or synchronization.

@item ATOMIC_CONSUME
  @vindex ATOMIC_CONSUME* @{.importc꞉ "__ATOMIC_CONSUME", nodecl.@}꞉ AtomMemModel
@example
ATOMIC_CONSUME* @{.importc꞉ "__ATOMIC_CONSUME", nodecl.@}꞉ AtomMemModel
@end example
  Data dependency only for both barrier and synchronization with another thread.

@item ATOMIC_ACQUIRE
  @vindex ATOMIC_ACQUIRE* @{.importc꞉ "__ATOMIC_ACQUIRE", nodecl.@}꞉ AtomMemModel
@example
ATOMIC_ACQUIRE* @{.importc꞉ "__ATOMIC_ACQUIRE", nodecl.@}꞉ AtomMemModel
@end example
  Barrier to hoisting of code and synchronizes with release (or stronger) semantic stores from another thread.

@item ATOMIC_RELEASE
  @vindex ATOMIC_RELEASE* @{.importc꞉ "__ATOMIC_RELEASE", nodecl.@}꞉ AtomMemModel
@example
ATOMIC_RELEASE* @{.importc꞉ "__ATOMIC_RELEASE", nodecl.@}꞉ AtomMemModel
@end example
  Barrier to sinking of code and synchronizes with acquire (or stronger) semantic loads from another thread.

@item ATOMIC_ACQ_REL
  @vindex ATOMIC_ACQ_REL* @{.importc꞉ "__ATOMIC_ACQ_REL", nodecl.@}꞉ AtomMemModel
@example
ATOMIC_ACQ_REL* @{.importc꞉ "__ATOMIC_ACQ_REL", nodecl.@}꞉ AtomMemModel
@end example
  Full barrier in both directions and synchronizes with acquire loads and release stores in another thread.

@item ATOMIC_SEQ_CST
  @vindex ATOMIC_SEQ_CST* @{.importc꞉ "__ATOMIC_SEQ_CST", nodecl.@}꞉ AtomMemModel
@example
ATOMIC_SEQ_CST* @{.importc꞉ "__ATOMIC_SEQ_CST", nodecl.@}꞉ AtomMemModel
@end example
  Full barrier in both directions and synchronizes with acquire loads and release stores in all threads.
@end itemize

@chapter Types

@itemize


@item AtomMemModel
  @tindex AtomMemModel* = distinct cint
@example
AtomMemModel* = distinct cint
@end example
  

@item AtomType
  @tindex AtomType* = SomeNumber | pointer | ptr | char | bool
@example
AtomType* = SomeNumber | pointer | ptr | char | bool
@end example
  Type Class representing valid types for use with atomic procs
@end itemize

@chapter Procedures

@itemize


@item atomicLoadN
  @findex proc atomicLoadN*[T꞉ AtomType](p꞉ ptr T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_load_n", nodecl.@}
@example
proc atomicLoadN*[T꞉ AtomType](p꞉ ptr T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_load_n", nodecl.@}
@end example
  This proc implements an atomic load operation. It returns the contents at p. ATOMIC_RELAXED, ATOMIC_SEQ_CST, ATOMIC_ACQUIRE, ATOMIC_CONSUME.

@item atomicLoad
  @findex proc atomicLoad*[T꞉ AtomType](p, ret꞉ ptr T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_load", nodecl.@}
@example
proc atomicLoad*[T꞉ AtomType](p, ret꞉ ptr T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_load", nodecl.@}
@end example
  This is the generic version of an atomic load. It returns the contents at p in ret.

@item atomicStoreN
  @findex proc atomicStoreN*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_store_n", nodecl.@}
@example
proc atomicStoreN*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_store_n", nodecl.@}
@end example
  This proc implements an atomic store operation. It writes val at p. ATOMIC_RELAXED, ATOMIC_SEQ_CST, and ATOMIC_RELEASE.

@item atomicStore
  @findex proc atomicStore*[T꞉ AtomType](p, val꞉ ptr T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_store", nodecl.@}
@example
proc atomicStore*[T꞉ AtomType](p, val꞉ ptr T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_store", nodecl.@}
@end example
  This is the generic version of an atomic store. It stores the value of val at p

@item atomicExchangeN
  @findex proc atomicExchangeN*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_exchange_n", nodecl.@}
@example
proc atomicExchangeN*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_exchange_n", nodecl.@}
@end example
  This proc implements an atomic exchange operation. It writes val at p, and returns the previous contents at p. ATOMIC_RELAXED, ATOMIC_SEQ_CST, ATOMIC_ACQUIRE, ATOMIC_RELEASE, ATOMIC_ACQ_REL

@item atomicExchange
  @findex proc atomicExchange*[T꞉ AtomType](p, val, ret꞉ ptr T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_exchange", nodecl.@}
@example
proc atomicExchange*[T꞉ AtomType](p, val, ret꞉ ptr T; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_exchange", nodecl.@}
@end example
  This is the generic version of an atomic exchange. It stores the contents at val at p. The original value at p is copied into ret.

@item atomicCompareExchangeN
  @findex proc atomicCompareExchangeN*[T: AtomType](p, expected: ptr T; desired: T; weak: bool;
                                        success_memmodel: AtomMemModel;
                                        failure_memmodel: AtomMemModel): bool @{.
    importc: "__atomic_compare_exchange_n ", nodecl.@}
@example
proc atomicCompareExchangeN*[T: AtomType](p, expected: ptr T; desired: T; weak: bool;
                                        success_memmodel: AtomMemModel;
                                        failure_memmodel: AtomMemModel): bool @{.
    importc: "__atomic_compare_exchange_n ", nodecl.@}
@end example
  This proc implements an atomic compare and exchange operation. This compares the contents at p with the contents at expected and if equal, writes desired at p. If they are not equal, the current contents at p is written into expected. Weak is true for weak compare_exchange, and false for the strong variation. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation. True is returned if desired is written at p and the execution is considered to conform to the memory model specified by success_memmodel. There are no restrictions on what memory model can be used here. False is returned otherwise, and the execution is considered to conform to failure_memmodel. This memory model cannot be __ATOMIC_RELEASE nor __ATOMIC_ACQ_REL. It also cannot be a stronger model than that specified by success_memmodel.

@item atomicCompareExchange
  @findex proc atomicCompareExchange*[T: AtomType](p, expected, desired: ptr T; weak: bool;
                                       success_memmodel: AtomMemModel;
                                       failure_memmodel: AtomMemModel): bool @{.
    importc: "__atomic_compare_exchange", nodecl.@}
@example
proc atomicCompareExchange*[T: AtomType](p, expected, desired: ptr T; weak: bool;
                                       success_memmodel: AtomMemModel;
                                       failure_memmodel: AtomMemModel): bool @{.
    importc: "__atomic_compare_exchange", nodecl.@}
@end example
  This proc implements the generic version of atomic_compare_exchange. The proc is virtually identical to atomic_compare_exchange_n, except the desired value is also a pointer.

@item atomicAddFetch
  @findex proc atomicAddFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_add_fetch", nodecl.@}
@example
proc atomicAddFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_add_fetch", nodecl.@}
@end example
  

@item atomicSubFetch
  @findex proc atomicSubFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_sub_fetch", nodecl.@}
@example
proc atomicSubFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_sub_fetch", nodecl.@}
@end example
  

@item atomicOrFetch
  @findex proc atomicOrFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_or_fetch ", nodecl.@}
@example
proc atomicOrFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_or_fetch ", nodecl.@}
@end example
  

@item atomicAndFetch
  @findex proc atomicAndFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_and_fetch", nodecl.@}
@example
proc atomicAndFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_and_fetch", nodecl.@}
@end example
  

@item atomicXorFetch
  @findex proc atomicXorFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_xor_fetch", nodecl.@}
@example
proc atomicXorFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_xor_fetch", nodecl.@}
@end example
  

@item atomicNandFetch
  @findex proc atomicNandFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_nand_fetch ", nodecl.@}
@example
proc atomicNandFetch*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_nand_fetch ", nodecl.@}
@end example
  

@item atomicFetchAdd
  @findex proc atomicFetchAdd*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_add", nodecl.@}
@example
proc atomicFetchAdd*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_add", nodecl.@}
@end example
  

@item atomicFetchSub
  @findex proc atomicFetchSub*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_sub", nodecl.@}
@example
proc atomicFetchSub*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_sub", nodecl.@}
@end example
  

@item atomicFetchOr
  @findex proc atomicFetchOr*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_or", nodecl.@}
@example
proc atomicFetchOr*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_or", nodecl.@}
@end example
  

@item atomicFetchAnd
  @findex proc atomicFetchAnd*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_and", nodecl.@}
@example
proc atomicFetchAnd*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_and", nodecl.@}
@end example
  

@item atomicFetchXor
  @findex proc atomicFetchXor*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_xor", nodecl.@}
@example
proc atomicFetchXor*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_xor", nodecl.@}
@end example
  

@item atomicFetchNand
  @findex proc atomicFetchNand*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_nand", nodecl.@}
@example
proc atomicFetchNand*[T꞉ AtomType](p꞉ ptr T; val꞉ T; mem꞉ AtomMemModel)꞉ T @{.importc꞉ "__atomic_fetch_nand", nodecl.@}
@end example
  

@item atomicTestAndSet
  @findex proc atomicTestAndSet*(p꞉ pointer; mem꞉ AtomMemModel)꞉ bool @{.importc꞉ "__atomic_test_and_set", nodecl.@}
@example
proc atomicTestAndSet*(p꞉ pointer; mem꞉ AtomMemModel)꞉ bool @{.importc꞉ "__atomic_test_and_set", nodecl.@}
@end example
  This built-in function performs an atomic test-and-set operation on the byte at p. The byte is set to some implementation defined nonzero “set” value and the return value is true if and only if the previous contents were “set”. All memory models are valid.

@item atomicClear
  @findex proc atomicClear*(p꞉ pointer; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_clear", nodecl.@}
@example
proc atomicClear*(p꞉ pointer; mem꞉ AtomMemModel) @{.importc꞉ "__atomic_clear", nodecl.@}
@end example
  This built-in function performs an atomic clear operation at p. After the operation, at p contains 0. ATOMIC_RELAXED, ATOMIC_SEQ_CST, ATOMIC_RELEASE

@item atomicThreadFence
  @findex proc atomicThreadFence*(mem꞉ AtomMemModel) @{.importc꞉ "__atomic_thread_fence", nodecl.@}
@example
proc atomicThreadFence*(mem꞉ AtomMemModel) @{.importc꞉ "__atomic_thread_fence", nodecl.@}
@end example
  This built-in function acts as a synchronization fence between threads based on the specified memory model. All memory orders are valid.

@item atomicSignalFence
  @findex proc atomicSignalFence*(mem꞉ AtomMemModel) @{.importc꞉ "__atomic_signal_fence", nodecl.@}
@example
proc atomicSignalFence*(mem꞉ AtomMemModel) @{.importc꞉ "__atomic_signal_fence", nodecl.@}
@end example
  This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread. All memory orders are valid.

@item atomicAlwaysLockFree
  @findex proc atomicAlwaysLockFree*(size꞉ int; p꞉ pointer)꞉ bool @{.importc꞉ "__atomic_always_lock_free", nodecl.@}
@example
proc atomicAlwaysLockFree*(size꞉ int; p꞉ pointer)꞉ bool @{.importc꞉ "__atomic_always_lock_free", nodecl.@}
@end example
  This built-in function returns true if objects of size bytes always generate lock free atomic instructions for the target architecture. size must resolve to a compile-time constant and the result also resolves to a compile-time constant. ptr is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.

@item atomicIsLockFree
  @findex proc atomicIsLockFree*(size꞉ int; p꞉ pointer)꞉ bool @{.importc꞉ "__atomic_is_lock_free", nodecl.@}
@example
proc atomicIsLockFree*(size꞉ int; p꞉ pointer)꞉ bool @{.importc꞉ "__atomic_is_lock_free", nodecl.@}
@end example
  This built-in function returns true if objects of size bytes always generate lock free atomic instructions for the target architecture. If it is not known to be lock free a call is made to a runtime routine named __atomic_is_lock_free. ptr is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.

@item atomicInc
  @findex proc atomicInc*(memLoc꞉ var int; x꞉ int = 1)꞉ int
@example
proc atomicInc*(memLoc꞉ var int; x꞉ int = 1)꞉ int
@end example
  

@item atomicDec
  @findex proc atomicDec*(memLoc꞉ var int; x꞉ int = 1)꞉ int
@example
proc atomicDec*(memLoc꞉ var int; x꞉ int = 1)꞉ int
@end example
  

@item cas
  @findex proc cas*[T꞉ bool | int | ptr](p꞉ ptr T; oldValue, newValue꞉ T)꞉ bool
@example
proc cas*[T꞉ bool | int | ptr](p꞉ ptr T; oldValue, newValue꞉ T)꞉ bool
@end example
  

@item cpuRelax
  @findex proc cpuRelax*() @{.inline.@}
@example
proc cpuRelax*() @{.inline.@}
@end example
  

@item fence
  @findex proc fence*() @{.inline.@}
@example
proc fence*() @{.inline.@}
@end example
  
@end itemize

@chapter Templates

@itemize


@item fence
  @findex template fence*()
@example
template fence*()
@end example
  
@end itemize





@node /system/nimscript, /system/jssys , /system/atomics, Top


@chapter Variables

@itemize


@item mode
  @vindex mode*꞉ ScriptMode
@example
mode*꞉ ScriptMode
@end example
  Set this to influence how mkDir, rmDir, rmFile etc. behave

@item requiresData
  @vindex requiresData*꞉ seq[string] = @@ []
@example
requiresData*꞉ seq[string] = @@ []
@end example
  Exposes the list of requirements for read and write accesses.
@end itemize

@chapter Types

@itemize


@item ScriptMode
  @tindex ScriptMode* @{.pure.@} = enum
  Silent,                     ## Be silent.
  Verbose,                    ## Be verbose.
  Whatif                      ## Do not run commands, instead just echo what
        ## would have been done.
@example
ScriptMode* @{.pure.@} = enum
  Silent,                     ## Be silent.
  Verbose,                    ## Be verbose.
  Whatif                      ## Do not run commands, instead just echo what
        ## would have been done.
@end example
  Controls the behaviour of the script.
@end itemize

@chapter Procedures

@itemize


@item listDirs
  @findex proc listDirs*(dir꞉ string)꞉ seq[string]
@example
proc listDirs*(dir꞉ string)꞉ seq[string]
@end example
  Lists all the subdirectories (non-recursively) in the directory @emph{dir}.

@item listFiles
  @findex proc listFiles*(dir꞉ string)꞉ seq[string]
@example
proc listFiles*(dir꞉ string)꞉ seq[string]
@end example
  Lists all the files (non-recursively) in the directory @emph{dir}.

@item paramStr
  @findex proc paramStr*(i꞉ int)꞉ string
@example
proc paramStr*(i꞉ int)꞉ string
@end example
  Retrieves the @code{i}'th command line parameter.

@item paramCount
  @findex proc paramCount*()꞉ int
@example
proc paramCount*()꞉ int
@end example
  Retrieves the number of command line parameters.

@item switch
  @findex proc switch*(key꞉ string; val = "")
@example
proc switch*(key꞉ string; val = "")
@end example
  Sets a Nim compiler command line switch, for example @code{switch("checks", "on")}.

@item getCommand
  @findex proc getCommand*()꞉ string
@example
proc getCommand*()꞉ string
@end example
  Gets the Nim command that the compiler has been invoked with, for example "c", "js", "build", "help".

@item setCommand
  @findex proc setCommand*(cmd꞉ string; project = "")
@example
proc setCommand*(cmd꞉ string; project = "")
@end example
  Sets the Nim command that should be continued with after this Nimscript has finished.

@item cmpic
  @findex proc cmpic*(a, b꞉ string)꞉ int
@example
proc cmpic*(a, b꞉ string)꞉ int
@end example
  Compares @emph{a} and @emph{b} ignoring case.

@item getEnv
  @findex proc getEnv*(key꞉ string)꞉ string @{.tags꞉ [ReadIOEffect].@}
@example
proc getEnv*(key꞉ string)꞉ string @{.tags꞉ [ReadIOEffect].@}
@end example
  Retrieves the environment variable of name @emph{key}.

@item existsEnv
  @findex proc existsEnv*(key꞉ string)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@example
proc existsEnv*(key꞉ string)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@end example
  Checks for the existance of an environment variable named @emph{key}.

@item fileExists
  @findex proc fileExists*(filename꞉ string)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@example
proc fileExists*(filename꞉ string)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@end example
  Checks if the file exists.

@item dirExists
  @findex proc dirExists*(dir꞉ string)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@example
proc dirExists*(dir꞉ string)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@end example
  Checks if the directory @emph{dir} exists.

@item existsFile
  @findex proc existsFile*(filename꞉ string)꞉ bool
@example
proc existsFile*(filename꞉ string)꞉ bool
@end example
  An alias for @code{fileExists}.

@item existsDir
  @findex proc existsDir*(dir꞉ string)꞉ bool
@example
proc existsDir*(dir꞉ string)꞉ bool
@end example
  An alias for @code{dirExists}.

@item toExe
  @findex proc toExe*(filename꞉ string)꞉ string
@example
proc toExe*(filename꞉ string)꞉ string
@end example
  On Windows adds ".exe" to @emph{filename}, else returns @emph{filename} unmodified.

@item toDll
  @findex proc toDll*(filename꞉ string)꞉ string
@example
proc toDll*(filename꞉ string)꞉ string
@end example
  On Windows adds ".dll" to @emph{filename}, on Posix produces "lib$filename.so".

@item rmDir
  @findex proc rmDir*(dir꞉ string) @{.raises꞉ [OSError].@}
@example
proc rmDir*(dir꞉ string) @{.raises꞉ [OSError].@}
@end example
  Removes the directory @emph{dir}.

@item rmFile
  @findex proc rmFile*(file꞉ string) @{.raises꞉ [OSError].@}
@example
proc rmFile*(file꞉ string) @{.raises꞉ [OSError].@}
@end example
  Removes the @emph{file}.

@item mkDir
  @findex proc mkDir*(dir꞉ string) @{.raises꞉ [OSError].@}
@example
proc mkDir*(dir꞉ string) @{.raises꞉ [OSError].@}
@end example
  Creates the directory @emph{dir} including all necessary subdirectories. If the directory already exists, no error is raised.

@item mvFile
  @findex proc mvFile*(`from`, to꞉ string) @{.raises꞉ [OSError].@}
@example
proc mvFile*(`from`, to꞉ string) @{.raises꞉ [OSError].@}
@end example
  Moves the file @emph{from} to @emph{to}.

@item cpFile
  @findex proc cpFile*(`from`, to꞉ string) @{.raises꞉ [OSError].@}
@example
proc cpFile*(`from`, to꞉ string) @{.raises꞉ [OSError].@}
@end example
  Copies the file @emph{from} to @emph{to}.

@item exec
  @findex proc exec*(command꞉ string)
@example
proc exec*(command꞉ string)
@end example
  Executes an external process.

@item exec
  @findex proc exec*(command꞉ string; input꞉ string; cache = "") @{.raises꞉ [OSError],tags꞉ [ExecIOEffect].@}
@example
proc exec*(command꞉ string; input꞉ string; cache = "") @{.raises꞉ [OSError],tags꞉ [ExecIOEffect].@}
@end example
  Executes an external process.

@item put
  @findex proc put*(key, value꞉ string)
@example
proc put*(key, value꞉ string)
@end example
  Sets a configuration 'key' like 'gcc.options.always' to its value.

@item get
  @findex proc get*(key꞉ string)꞉ string
@example
proc get*(key꞉ string)꞉ string
@end example
  Retrieves a configuration 'key' like 'gcc.options.always'.

@item exists
  @findex proc exists*(key꞉ string)꞉ bool
@example
proc exists*(key꞉ string)꞉ bool
@end example
  Checks for the existance of a configuration 'key' like 'gcc.options.always'.

@item nimcacheDir
  @findex proc nimcacheDir*()꞉ string
@example
proc nimcacheDir*()꞉ string
@end example
  Retrieves the location of 'nimcache'.

@item thisDir
  @findex proc thisDir*()꞉ string
@example
proc thisDir*()꞉ string
@end example
  Retrieves the location of the current @code{nims} script file.

@item cd
  @findex proc cd*(dir꞉ string) @{.raises꞉ [OSError].@}
@example
proc cd*(dir꞉ string) @{.raises꞉ [OSError].@}
@end example
  Changes the current directory.

The change is permanent for the rest of the execution, since this is just a shortcut for @uref{http://nim-lang.org/os.html#setCurrentDir,string, os.setCurrentDir()} . Use the @uref{#withDir, withDir()} template if you want to perform a temporary change only.

@item requires
  @findex proc requires*(deps꞉ varargs[string])
@example
proc requires*(deps꞉ varargs[string])
@end example
  Nimble support: Call this to set the list of requirements of your Nimble package.
@end itemize

@chapter Templates

@itemize


@item `--`
  @findex template `--`*(key, val꞉ untyped)
@example
template `--`*(key, val꞉ untyped)
@end example
  A shortcut for @code{switch(astToStr(key), astToStr(val))}.

@item `--`
  @findex template `--`*(key꞉ untyped)
@example
template `--`*(key꞉ untyped)
@end example
  A shortcut for @code{switch(astToStr(key)}.

@item withDir
  @findex template withDir*(dir꞉ string; body꞉ untyped)꞉ untyped
@example
template withDir*(dir꞉ string; body꞉ untyped)꞉ untyped
@end example
  Changes the current directory temporarily.

If you need a permanent change, use the @uref{#cd, cd()} proc. Usage example:


@example
withDir "foo":
  # inside foo
#back to last dir
@end example

@item task
  @findex template task*(name꞉ untyped; description꞉ string; body꞉ untyped)꞉ untyped
@example
template task*(name꞉ untyped; description꞉ string; body꞉ untyped)꞉ untyped
@end example
  Defines a task. Hidden tasks are supported via an empty description. Example:
@example
task build, "default build is via the C backend":
  setCommand "c"
@end example
@end itemize





@node /system/jssys, /system/excpt , /system/nimscript, Top




@chapter Procedures

@itemize


@item alert
  @findex proc alert*(s꞉ cstring) @{.importc꞉ "console.log", nodecl.@}
@example
proc alert*(s꞉ cstring) @{.importc꞉ "console.log", nodecl.@}
@end example
  

@item log
  @findex proc log*(s꞉ cstring) @{.importc꞉ "console.log", varargs, nodecl.@}
@example
proc log*(s꞉ cstring) @{.importc꞉ "console.log", varargs, nodecl.@}
@end example
  

@item getCurrentExceptionMsg
  @findex proc getCurrentExceptionMsg*()꞉ string
@example
proc getCurrentExceptionMsg*()꞉ string
@end example
  

@item ze
  @findex proc ze*(a꞉ int)꞉ int @{.compilerproc.@}
@example
proc ze*(a꞉ int)꞉ int @{.compilerproc.@}
@end example
  

@item ze64
  @findex proc ze64*(a꞉ int64)꞉ int64 @{.compilerproc.@}
@example
proc ze64*(a꞉ int64)꞉ int64 @{.compilerproc.@}
@end example
  

@item toU8
  @findex proc toU8*(a꞉ int)꞉ int8 @{.asmNoStackFrame, compilerproc.@}
@example
proc toU8*(a꞉ int)꞉ int8 @{.asmNoStackFrame, compilerproc.@}
@end example
  

@item toU16
  @findex proc toU16*(a꞉ int)꞉ int16 @{.asmNoStackFrame, compilerproc.@}
@example
proc toU16*(a꞉ int)꞉ int16 @{.asmNoStackFrame, compilerproc.@}
@end example
  

@item toU32
  @findex proc toU32*(a꞉ int64)꞉ int32 @{.asmNoStackFrame, compilerproc.@}
@example
proc toU32*(a꞉ int64)꞉ int32 @{.asmNoStackFrame, compilerproc.@}
@end example
  
@end itemize






@node /system/excpt, /system/platforms , /system/jssys, Top


@chapter Variables

@itemize


@item errorMessageWriter
  @vindex errorMessageWriter*꞉ (proc (msg꞉ string) @{.tags꞉ [WriteIOEffect], benign.@})
@example
errorMessageWriter*꞉ (proc (msg꞉ string) @{.tags꞉ [WriteIOEffect], benign.@})
@end example
  Function that will be called instead of stdmsg.write when printing stacktrace. Unstable API.
@end itemize


@chapter Procedures

@itemize


@item getFrame
  @findex proc getFrame*()꞉ PFrame @{.compilerRtl, inl.@}
@example
proc getFrame*()꞉ PFrame @{.compilerRtl, inl.@}
@end example
  

@item setFrame
  @findex proc setFrame*(s꞉ PFrame) @{.compilerRtl, inl.@}
@example
proc setFrame*(s꞉ PFrame) @{.compilerRtl, inl.@}
@end example
  

@item stackTraceAvailable
  @findex proc stackTraceAvailable*()꞉ bool
@example
proc stackTraceAvailable*()꞉ bool
@end example
  
@end itemize






@node /system/platforms, /system/gc_ms , /system/excpt, Top
@chapter Constant variables

@itemize


@item targetCPU
  @vindex targetCPU* = when defined(i386): CpuPlatform.i386
 elif defined(m68k): CpuPlatform.m68k
 elif defined(alpha): CpuPlatform.alpha
 elif defined(powerpc): CpuPlatform.powerpc
 elif defined(powerpc64): CpuPlatform.powerpc64
 elif defined(powerpc64el): CpuPlatform.powerpc64el
 elif defined(sparc): CpuPlatform.sparc
 elif defined(ia64): CpuPlatform.ia64
 elif defined(amd64): CpuPlatform.amd64
 elif defined(mips): CpuPlatform.mips
 elif defined(mipsel): CpuPlatform.mipsel
 elif defined(arm): CpuPlatform.arm
 elif defined(arm64): CpuPlatform.arm64
 elif defined(vm): CpuPlatform.vm
 elif defined(avr): CpuPlatform.avr
 elif defined(msp430): CpuPlatform.msp430
 else: CpuPlatform.none
@example
targetCPU* = when defined(i386): CpuPlatform.i386
 elif defined(m68k): CpuPlatform.m68k
 elif defined(alpha): CpuPlatform.alpha
 elif defined(powerpc): CpuPlatform.powerpc
 elif defined(powerpc64): CpuPlatform.powerpc64
 elif defined(powerpc64el): CpuPlatform.powerpc64el
 elif defined(sparc): CpuPlatform.sparc
 elif defined(ia64): CpuPlatform.ia64
 elif defined(amd64): CpuPlatform.amd64
 elif defined(mips): CpuPlatform.mips
 elif defined(mipsel): CpuPlatform.mipsel
 elif defined(arm): CpuPlatform.arm
 elif defined(arm64): CpuPlatform.arm64
 elif defined(vm): CpuPlatform.vm
 elif defined(avr): CpuPlatform.avr
 elif defined(msp430): CpuPlatform.msp430
 else: CpuPlatform.none
@end example
  the CPU this program will run on.
@end itemize



@chapter Types

@itemize


@item OsPlatform
  @tindex OsPlatform* @{.pure.@} = enumnone, dos, windows, os2, linux, morphos, skyos, solaris, irix, netbsd, freebsd, openbsd,aix, palmos, qnx, amiga, atari, netware, macos, macosx, haiku, js, nimVM, standalone
@example
OsPlatform* @{.pure.@} = enumnone, dos, windows, os2, linux, morphos, skyos, solaris, irix, netbsd, freebsd, openbsd,aix, palmos, qnx, amiga, atari, netware, macos, macosx, haiku, js, nimVM, standalone
@end example
  the OS this program will run on.
@end itemize







@node /system/gc_ms, /system/gc_common , /system/platforms, Top




@chapter Procedures

@itemize


@item getCellId
  @findex proc getCellId*[T](x꞉ ref T)꞉ int
@example
proc getCellId*[T](x꞉ ref T)꞉ int
@end example
  
@end itemize






@node /system/gc_common, /system/widestrs , /system/gc_ms, Top




@chapter Procedures

@itemize


@item GC_addStack
  @findex proc GC_addStack*(starts꞉ pointer) @{.cdecl, exportc.@}
@example
proc GC_addStack*(starts꞉ pointer) @{.cdecl, exportc.@}
@end example
  

@item GC_removeStack
  @findex proc GC_removeStack*(starts꞉ pointer) @{.cdecl, exportc.@}
@example
proc GC_removeStack*(starts꞉ pointer) @{.cdecl, exportc.@}
@end example
  

@item GC_setCurrentStack
  @findex proc GC_setCurrentStack*(starts, pos꞉ pointer) @{.cdecl, exportc.@}
@example
proc GC_setCurrentStack*(starts, pos꞉ pointer) @{.cdecl, exportc.@}
@end example
  

@item setupForeignThreadGc
  @findex proc setupForeignThreadGc*()
@example
proc setupForeignThreadGc*()
@end example
  call this if you registered a callback that will be run from a thread not under your control. This has a cheap thread-local guard, so the GC for this thread will only be initialized once per thread, no matter how often it is called.
@end itemize






@node /system/widestrs, /js/dom , /system/gc_common, Top



@chapter Types

@itemize


@item WideCString
  @tindex WideCString* = ref array[0 .. 1000000, Utf16Char]
@example
WideCString* = ref array[0 .. 1000000, Utf16Char]
@end example
  
@end itemize

@chapter Procedures

@itemize


@item len
  @findex proc len*(w꞉ WideCString)꞉ int
@example
proc len*(w꞉ WideCString)꞉ int
@end example
  returns the length of a widestring. This traverses the whole string to find the binary zero end marker!

@item newWideCString
  @findex proc newWideCString*(source꞉ cstring; L꞉ int)꞉ WideCString
@example
proc newWideCString*(source꞉ cstring; L꞉ int)꞉ WideCString
@end example
  

@item newWideCString
  @findex proc newWideCString*(s꞉ cstring)꞉ WideCString
@example
proc newWideCString*(s꞉ cstring)꞉ WideCString
@end example
  

@item newWideCString
  @findex proc newWideCString*(s꞉ string)꞉ WideCString
@example
proc newWideCString*(s꞉ string)꞉ WideCString
@end example
  

@item `$`
  @findex proc `$`*(w꞉ WideCString; estimate꞉ int; replacement꞉ int = 0x0000FFFD)꞉ string
@example
proc `$`*(w꞉ WideCString; estimate꞉ int; replacement꞉ int = 0x0000FFFD)꞉ string
@end example
  

@item `$`
  @findex proc `$`*(s꞉ WideCString)꞉ string
@example
proc `$`*(s꞉ WideCString)꞉ string
@end example
  
@end itemize






@node /js/dom, /core/locks , /system/widestrs, Top


@chapter Variables

@itemize


@item screen
  @vindex screen* @{.importc, nodecl.@}꞉ Screen
@example
screen* @{.importc, nodecl.@}꞉ Screen
@end example
  
@end itemize

@chapter Types

@itemize


@item TInterval
  @tindex TInterval* @{.importc.@} = object of RootObj
@example
TInterval* @{.importc.@} = object of RootObj
@end example
  

@item TApplet
  @tindex TApplet* @{.importc, deprecated.@} = object of RootObj
@example
TApplet* @{.importc, deprecated.@} = object of RootObj
@end example
  
@end itemize

@chapter Procedures

@itemize


@item addEventListener
  @findex proc addEventListener*(et꞉ EventTarget; ev꞉ cstring; cb꞉ proc (ev꞉ Event);useCapture꞉ bool = false)
@example
proc addEventListener*(et꞉ EventTarget; ev꞉ cstring; cb꞉ proc (ev꞉ Event);useCapture꞉ bool = false)
@end example
  

@item alert
  @findex proc alert*(w꞉ Window; msg꞉ cstring)
@example
proc alert*(w꞉ Window; msg꞉ cstring)
@end example
  

@item back
  @findex proc back*(w꞉ Window)
@example
proc back*(w꞉ Window)
@end example
  

@item blur
  @findex proc blur*(w꞉ Window)
@example
proc blur*(w꞉ Window)
@end example
  

@item captureEvents
  @findex proc captureEvents*(w꞉ Window; eventMask꞉ int) @{.deprecated.@}
@example
proc captureEvents*(w꞉ Window; eventMask꞉ int) @{.deprecated.@}
@end example
  

@item clearInterval
  @findex proc clearInterval*(w꞉ Window; interval꞉ ref TInterval)
@example
proc clearInterval*(w꞉ Window; interval꞉ ref TInterval)
@end example
  

@item clearTimeout
  @findex proc clearTimeout*(w꞉ Window; timeout꞉ ref TTimeOut)
@example
proc clearTimeout*(w꞉ Window; timeout꞉ ref TTimeOut)
@end example
  

@item close
  @findex proc close*(w꞉ Window)
@example
proc close*(w꞉ Window)
@end example
  

@item confirm
  @findex proc confirm*(w꞉ Window; msg꞉ cstring)꞉ bool
@example
proc confirm*(w꞉ Window; msg꞉ cstring)꞉ bool
@end example
  

@item disableExternalCapture
  @findex proc disableExternalCapture*(w꞉ Window)
@example
proc disableExternalCapture*(w꞉ Window)
@end example
  

@item enableExternalCapture
  @findex proc enableExternalCapture*(w꞉ Window)
@example
proc enableExternalCapture*(w꞉ Window)
@end example
  

@item find
  @findex proc find*(w꞉ Window; text꞉ cstring; caseSensitive = false; backwards = false)
@example
proc find*(w꞉ Window; text꞉ cstring; caseSensitive = false; backwards = false)
@end example
  

@item focus
  @findex proc focus*(w꞉ Window)
@example
proc focus*(w꞉ Window)
@end example
  

@item forward
  @findex proc forward*(w꞉ Window)
@example
proc forward*(w꞉ Window)
@end example
  

@item handleEvent
  @findex proc handleEvent*(w꞉ Window; e꞉ Event)
@example
proc handleEvent*(w꞉ Window; e꞉ Event)
@end example
  

@item home
  @findex proc home*(w꞉ Window)
@example
proc home*(w꞉ Window)
@end example
  

@item moveBy
  @findex proc moveBy*(w꞉ Window; x, y꞉ int)
@example
proc moveBy*(w꞉ Window; x, y꞉ int)
@end example
  

@item moveTo
  @findex proc moveTo*(w꞉ Window; x, y꞉ int)
@example
proc moveTo*(w꞉ Window; x, y꞉ int)
@end example
  

@item open
  @findex proc open*(w꞉ Window; uri, windowname꞉ cstring; properties꞉ cstring = nil)꞉ Window
@example
proc open*(w꞉ Window; uri, windowname꞉ cstring; properties꞉ cstring = nil)꞉ Window
@end example
  

@item print
  @findex proc print*(w꞉ Window)
@example
proc print*(w꞉ Window)
@end example
  

@item prompt
  @findex proc prompt*(w꞉ Window; text, default꞉ cstring)꞉ cstring
@example
proc prompt*(w꞉ Window; text, default꞉ cstring)꞉ cstring
@end example
  

@item releaseEvents
  @findex proc releaseEvents*(w꞉ Window; eventMask꞉ int) @{.deprecated.@}
@example
proc releaseEvents*(w꞉ Window; eventMask꞉ int) @{.deprecated.@}
@end example
  

@item resizeBy
  @findex proc resizeBy*(w꞉ Window; x, y꞉ int)
@example
proc resizeBy*(w꞉ Window; x, y꞉ int)
@end example
  

@item resizeTo
  @findex proc resizeTo*(w꞉ Window; x, y꞉ int)
@example
proc resizeTo*(w꞉ Window; x, y꞉ int)
@end example
  

@item routeEvent
  @findex proc routeEvent*(w꞉ Window; event꞉ Event)
@example
proc routeEvent*(w꞉ Window; event꞉ Event)
@end example
  

@item scrollBy
  @findex proc scrollBy*(w꞉ Window; x, y꞉ int)
@example
proc scrollBy*(w꞉ Window; x, y꞉ int)
@end example
  

@item scrollTo
  @findex proc scrollTo*(w꞉ Window; x, y꞉ int)
@example
proc scrollTo*(w꞉ Window; x, y꞉ int)
@end example
  

@item setInterval
  @findex proc setInterval*(w꞉ Window; code꞉ cstring; pause꞉ int)꞉ ref TInterval
@example
proc setInterval*(w꞉ Window; code꞉ cstring; pause꞉ int)꞉ ref TInterval
@end example
  

@item setTimeout
  @findex proc setTimeout*(w꞉ Window; code꞉ cstring; pause꞉ int)꞉ ref TTimeOut
@example
proc setTimeout*(w꞉ Window; code꞉ cstring; pause꞉ int)꞉ ref TTimeOut
@end example
  

@item stop
  @findex proc stop*(w꞉ Window)
@example
proc stop*(w꞉ Window)
@end example
  

@item appendChild
  @findex proc appendChild*(n, child꞉ Node)
@example
proc appendChild*(n, child꞉ Node)
@end example
  

@item appendData
  @findex proc appendData*(n꞉ Node; data꞉ cstring)
@example
proc appendData*(n꞉ Node; data꞉ cstring)
@end example
  

@item cloneNode
  @findex proc cloneNode*(n꞉ Node; copyContent꞉ bool)꞉ Node
@example
proc cloneNode*(n꞉ Node; copyContent꞉ bool)꞉ Node
@end example
  

@item deleteData
  @findex proc deleteData*(n꞉ Node; start, len꞉ int)
@example
proc deleteData*(n꞉ Node; start, len꞉ int)
@end example
  

@item getAttribute
  @findex proc getAttribute*(n꞉ Node; attr꞉ cstring)꞉ cstring
@example
proc getAttribute*(n꞉ Node; attr꞉ cstring)꞉ cstring
@end example
  

@item getAttributeNode
  @findex proc getAttributeNode*(n꞉ Node; attr꞉ cstring)꞉ Node
@example
proc getAttributeNode*(n꞉ Node; attr꞉ cstring)꞉ Node
@end example
  

@item hasChildNodes
  @findex proc hasChildNodes*(n꞉ Node)꞉ bool
@example
proc hasChildNodes*(n꞉ Node)꞉ bool
@end example
  

@item insertBefore
  @findex proc insertBefore*(n, newNode, before꞉ Node)
@example
proc insertBefore*(n, newNode, before꞉ Node)
@end example
  

@item insertData
  @findex proc insertData*(n꞉ Node; position꞉ int; data꞉ cstring)
@example
proc insertData*(n꞉ Node; position꞉ int; data꞉ cstring)
@end example
  

@item removeAttribute
  @findex proc removeAttribute*(n꞉ Node; attr꞉ cstring)
@example
proc removeAttribute*(n꞉ Node; attr꞉ cstring)
@end example
  

@item removeAttributeNode
  @findex proc removeAttributeNode*(n, attr꞉ Node)
@example
proc removeAttributeNode*(n, attr꞉ Node)
@end example
  

@item removeChild
  @findex proc removeChild*(n, child꞉ Node)
@example
proc removeChild*(n, child꞉ Node)
@end example
  

@item replaceChild
  @findex proc replaceChild*(n, newNode, oldNode꞉ Node)
@example
proc replaceChild*(n, newNode, oldNode꞉ Node)
@end example
  

@item replaceData
  @findex proc replaceData*(n꞉ Node; start, len꞉ int; text꞉ cstring)
@example
proc replaceData*(n꞉ Node; start, len꞉ int; text꞉ cstring)
@end example
  

@item scrollIntoView
  @findex proc scrollIntoView*(n꞉ Node)
@example
proc scrollIntoView*(n꞉ Node)
@end example
  

@item setAttribute
  @findex proc setAttribute*(n꞉ Node; name, value꞉ cstring)
@example
proc setAttribute*(n꞉ Node; name, value꞉ cstring)
@end example
  

@item setAttributeNode
  @findex proc setAttributeNode*(n꞉ Node; attr꞉ Node)
@example
proc setAttributeNode*(n꞉ Node; attr꞉ Node)
@end example
  

@item captureEvents
  @findex proc captureEvents*(d꞉ Document; eventMask꞉ int) @{.deprecated.@}
@example
proc captureEvents*(d꞉ Document; eventMask꞉ int) @{.deprecated.@}
@end example
  

@item createAttribute
  @findex proc createAttribute*(d꞉ Document; identifier꞉ cstring)꞉ Node
@example
proc createAttribute*(d꞉ Document; identifier꞉ cstring)꞉ Node
@end example
  

@item createElement
  @findex proc createElement*(d꞉ Document; identifier꞉ cstring)꞉ Element
@example
proc createElement*(d꞉ Document; identifier꞉ cstring)꞉ Element
@end example
  

@item createTextNode
  @findex proc createTextNode*(d꞉ Document; identifier꞉ cstring)꞉ Node
@example
proc createTextNode*(d꞉ Document; identifier꞉ cstring)꞉ Node
@end example
  

@item getElementById
  @findex proc getElementById*(d꞉ Document; id꞉ cstring)꞉ Element
@example
proc getElementById*(d꞉ Document; id꞉ cstring)꞉ Element
@end example
  

@item getElementsByName
  @findex proc getElementsByName*(d꞉ Document; name꞉ cstring)꞉ seq[Element]
@example
proc getElementsByName*(d꞉ Document; name꞉ cstring)꞉ seq[Element]
@end example
  

@item getElementsByTagName
  @findex proc getElementsByTagName*(d꞉ Document; name꞉ cstring)꞉ seq[Element]
@example
proc getElementsByTagName*(d꞉ Document; name꞉ cstring)꞉ seq[Element]
@end example
  

@item getElementsByClassName
  @findex proc getElementsByClassName*(d꞉ Document; name꞉ cstring)꞉ seq[Element]
@example
proc getElementsByClassName*(d꞉ Document; name꞉ cstring)꞉ seq[Element]
@end example
  

@item getSelection
  @findex proc getSelection*(d꞉ Document)꞉ cstring
@example
proc getSelection*(d꞉ Document)꞉ cstring
@end example
  

@item handleEvent
  @findex proc handleEvent*(d꞉ Document; event꞉ Event)
@example
proc handleEvent*(d꞉ Document; event꞉ Event)
@end example
  

@item open
  @findex proc open*(d꞉ Document)
@example
proc open*(d꞉ Document)
@end example
  

@item releaseEvents
  @findex proc releaseEvents*(d꞉ Document; eventMask꞉ int) @{.deprecated.@}
@example
proc releaseEvents*(d꞉ Document; eventMask꞉ int) @{.deprecated.@}
@end example
  

@item routeEvent
  @findex proc routeEvent*(d꞉ Document; event꞉ Event)
@example
proc routeEvent*(d꞉ Document; event꞉ Event)
@end example
  

@item write
  @findex proc write*(d꞉ Document; text꞉ cstring)
@example
proc write*(d꞉ Document; text꞉ cstring)
@end example
  

@item writeln
  @findex proc writeln*(d꞉ Document; text꞉ cstring)
@example
proc writeln*(d꞉ Document; text꞉ cstring)
@end example
  

@item blur
  @findex proc blur*(e꞉ Element)
@example
proc blur*(e꞉ Element)
@end example
  

@item click
  @findex proc click*(e꞉ Element)
@example
proc click*(e꞉ Element)
@end example
  

@item focus
  @findex proc focus*(e꞉ Element)
@example
proc focus*(e꞉ Element)
@end example
  

@item handleEvent
  @findex proc handleEvent*(e꞉ Element; event꞉ Event)
@example
proc handleEvent*(e꞉ Element; event꞉ Event)
@end example
  

@item select
  @findex proc select*(e꞉ Element)
@example
proc select*(e꞉ Element)
@end example
  

@item getElementsByTagName
  @findex proc getElementsByTagName*(e꞉ Element; name꞉ cstring)꞉ seq[Element]
@example
proc getElementsByTagName*(e꞉ Element; name꞉ cstring)꞉ seq[Element]
@end example
  

@item getElementsByClassName
  @findex proc getElementsByClassName*(e꞉ Element; name꞉ cstring)꞉ seq[Element]
@example
proc getElementsByClassName*(e꞉ Element; name꞉ cstring)꞉ seq[Element]
@end example
  

@item reset
  @findex proc reset*(f꞉ FormElement)
@example
proc reset*(f꞉ FormElement)
@end example
  

@item submit
  @findex proc submit*(f꞉ FormElement)
@example
proc submit*(f꞉ FormElement)
@end example
  

@item play
  @findex proc play*(e꞉ EmbedElement)
@example
proc play*(e꞉ EmbedElement)
@end example
  

@item stop
  @findex proc stop*(e꞉ EmbedElement)
@example
proc stop*(e꞉ EmbedElement)
@end example
  

@item reload
  @findex proc reload*(loc꞉ Location)
@example
proc reload*(loc꞉ Location)
@end example
  

@item replace
  @findex proc replace*(loc꞉ Location; s꞉ cstring)
@example
proc replace*(loc꞉ Location; s꞉ cstring)
@end example
  

@item back
  @findex proc back*(h꞉ History)
@example
proc back*(h꞉ History)
@end example
  

@item forward
  @findex proc forward*(h꞉ History)
@example
proc forward*(h꞉ History)
@end example
  

@item go
  @findex proc go*(h꞉ History; pagesToJump꞉ int)
@example
proc go*(h꞉ History; pagesToJump꞉ int)
@end example
  

@item javaEnabled
  @findex proc javaEnabled*(h꞉ Navigator)꞉ bool
@example
proc javaEnabled*(h꞉ Navigator)꞉ bool
@end example
  

@item add
  @findex proc add*(c꞉ ClassList; class꞉ cstring)
@example
proc add*(c꞉ ClassList; class꞉ cstring)
@end example
  

@item remove
  @findex proc remove*(c꞉ ClassList; class꞉ cstring)
@example
proc remove*(c꞉ ClassList; class꞉ cstring)
@end example
  

@item contains
  @findex proc contains*(c꞉ ClassList; class꞉ cstring)꞉ bool
@example
proc contains*(c꞉ ClassList; class꞉ cstring)꞉ bool
@end example
  

@item toggle
  @findex proc toggle*(c꞉ ClassList; class꞉ cstring)
@example
proc toggle*(c꞉ ClassList; class꞉ cstring)
@end example
  

@item getAttribute
  @findex proc getAttribute*(s꞉ Style; attr꞉ cstring; caseSensitive = false)꞉ cstring
@example
proc getAttribute*(s꞉ Style; attr꞉ cstring; caseSensitive = false)꞉ cstring
@end example
  

@item removeAttribute
  @findex proc removeAttribute*(s꞉ Style; attr꞉ cstring; caseSensitive = false)
@example
proc removeAttribute*(s꞉ Style; attr꞉ cstring; caseSensitive = false)
@end example
  

@item setAttribute
  @findex proc setAttribute*(s꞉ Style; attr, value꞉ cstring; caseSensitive = false)
@example
proc setAttribute*(s꞉ Style; attr, value꞉ cstring; caseSensitive = false)
@end example
  

@item decodeURI
  @findex proc decodeURI*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@example
proc decodeURI*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@end example
  

@item encodeURI
  @findex proc encodeURI*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@example
proc encodeURI*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@end example
  

@item escape
  @findex proc escape*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@example
proc escape*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@end example
  

@item unescape
  @findex proc unescape*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@example
proc unescape*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@end example
  

@item decodeURIComponent
  @findex proc decodeURIComponent*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@example
proc decodeURIComponent*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@end example
  

@item encodeURIComponent
  @findex proc encodeURIComponent*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@example
proc encodeURIComponent*(uri꞉ cstring)꞉ cstring @{.importc, nodecl.@}
@end example
  

@item isFinite
  @findex proc isFinite*(x꞉ BiggestFloat)꞉ bool @{.importc, nodecl.@}
@example
proc isFinite*(x꞉ BiggestFloat)꞉ bool @{.importc, nodecl.@}
@end example
  

@item isNaN
  @findex proc isNaN*(x꞉ BiggestFloat)꞉ bool @{.importc, nodecl.@}
@example
proc isNaN*(x꞉ BiggestFloat)꞉ bool @{.importc, nodecl.@}
@end example
  

@item parseFloat
  @findex proc parseFloat*(s꞉ cstring)꞉ BiggestFloat @{.importc, nodecl.@}
@example
proc parseFloat*(s꞉ cstring)꞉ BiggestFloat @{.importc, nodecl.@}
@end example
  

@item parseInt
  @findex proc parseInt*(s꞉ cstring)꞉ int @{.importc, nodecl.@}
@example
proc parseInt*(s꞉ cstring)꞉ int @{.importc, nodecl.@}
@end example
  

@item parseInt
  @findex proc parseInt*(s꞉ cstring; radix꞉ int)꞉ int @{.importc, nodecl.@}
@example
proc parseInt*(s꞉ cstring; radix꞉ int)꞉ int @{.importc, nodecl.@}
@end example
  
@end itemize






@node /core/locks, /core/typeinfo , /js/dom, Top



@chapter Types

@itemize


@item Cond
  @tindex Cond* = SysCond
@example
Cond* = SysCond
@end example
  Nim condition variable
@end itemize

@chapter Procedures

@itemize


@item initLock
  @findex proc initLock*(lock꞉ var Lock) @{.inline.@}
@example
proc initLock*(lock꞉ var Lock) @{.inline.@}
@end example
  Initializes the given lock.

@item deinitLock
  @findex proc deinitLock*(lock꞉ var Lock) @{.inline.@}
@example
proc deinitLock*(lock꞉ var Lock) @{.inline.@}
@end example
  Frees the resources associated with the lock.

@item tryAcquire
  @findex proc tryAcquire*(lock꞉ var Lock)꞉ bool
@example
proc tryAcquire*(lock꞉ var Lock)꞉ bool
@end example
  Tries to acquire the given lock. Returns @emph{true} on success.

@item acquire
  @findex proc acquire*(lock꞉ var Lock)
@example
proc acquire*(lock꞉ var Lock)
@end example
  Acquires the given lock.

@item release
  @findex proc release*(lock꞉ var Lock)
@example
proc release*(lock꞉ var Lock)
@end example
  Releases the given lock.

@item initCond
  @findex proc initCond*(cond꞉ var Cond) @{.inline.@}
@example
proc initCond*(cond꞉ var Cond) @{.inline.@}
@end example
  Initializes the given condition variable.

@item deinitCond
  @findex proc deinitCond*(cond꞉ var Cond) @{.inline.@}
@example
proc deinitCond*(cond꞉ var Cond) @{.inline.@}
@end example
  Frees the resources associated with the lock.

@item wait
  @findex proc wait*(cond꞉ var Cond; lock꞉ var Lock) @{.inline.@}
@example
proc wait*(cond꞉ var Cond; lock꞉ var Lock) @{.inline.@}
@end example
  waits on the condition variable @emph{cond}.

@item signal
  @findex proc signal*(cond꞉ var Cond) @{.inline.@}
@example
proc signal*(cond꞉ var Cond) @{.inline.@}
@end example
  sends a signal to the condition variable @emph{cond}.
@end itemize






@node /core/typeinfo, /core/macros , /core/locks, Top




@chapter Procedures

@itemize


@item toAny
  @findex proc toAny*(x꞉ VarSlot)꞉ Any @{.inline.@}
@example
proc toAny*(x꞉ VarSlot)꞉ Any @{.inline.@}
@end example
  constructs a @code{Any} object from a variable slot @code{x}. This captures @emph{x}'s address, so @emph{x} can be modified with its @code{Any} wrapper! The client needs to ensure that the wrapper @strong{does not} live longer than @emph{x}! This is provided for easier reflection capabilities of a debugger.

@item toAny
  @findex proc toAny*[T](x꞉ var T)꞉ Any @{.inline.@}
@example
proc toAny*[T](x꞉ var T)꞉ Any @{.inline.@}
@end example
  constructs a @code{Any} object from @emph{x}. This captures @emph{x}'s address, so @emph{x} can be modified with its @code{Any} wrapper! The client needs to ensure that the wrapper @strong{does not} live longer than @emph{x}!

@item kind
  @findex proc kind*(x꞉ Any)꞉ AnyKind @{.inline.@}
@example
proc kind*(x꞉ Any)꞉ AnyKind @{.inline.@}
@end example
  get the type kind

@item size
  @findex proc size*(x꞉ Any)꞉ int @{.inline.@}
@example
proc size*(x꞉ Any)꞉ int @{.inline.@}
@end example
  returns the size of @emph{x}'s type.

@item baseTypeKind
  @findex proc baseTypeKind*(x꞉ Any)꞉ AnyKind @{.inline.@}
@example
proc baseTypeKind*(x꞉ Any)꞉ AnyKind @{.inline.@}
@end example
  get the base type's kind; @code{akNone} is returned if @emph{x} has no base type.

@item baseTypeSize
  @findex proc baseTypeSize*(x꞉ Any)꞉ int @{.inline.@}
@example
proc baseTypeSize*(x꞉ Any)꞉ int @{.inline.@}
@end example
  returns the size of @emph{x}'s basetype.

@item invokeNew
  @findex proc invokeNew*(x꞉ Any)
@example
proc invokeNew*(x꞉ Any)
@end example
  performs @code{new(x)}. @emph{x} needs to represent a @code{ref}.

@item invokeNewSeq
  @findex proc invokeNewSeq*(x꞉ Any; len꞉ int)
@example
proc invokeNewSeq*(x꞉ Any; len꞉ int)
@end example
  performs @code{newSeq(x, len)}. @emph{x} needs to represent a @code{seq}.

@item extendSeq
  @findex proc extendSeq*(x꞉ Any)
@example
proc extendSeq*(x꞉ Any)
@end example
  performs @code{setLen(x, x.len+1)}. @emph{x} needs to represent a @code{seq}.

@item setObjectRuntimeType
  @findex proc setObjectRuntimeType*(x꞉ Any)
@example
proc setObjectRuntimeType*(x꞉ Any)
@end example
  this needs to be called to set @emph{x}'s runtime object type field.

@item `[]`
  @findex proc `[]`*(x꞉ Any; i꞉ int)꞉ Any
@example
proc `[]`*(x꞉ Any; i꞉ int)꞉ Any
@end example
  accessor for an any @emph{x} that represents an array or a sequence.

@item `[]=`
  @findex proc `[]=`*(x꞉ Any; i꞉ int; y꞉ Any)
@example
proc `[]=`*(x꞉ Any; i꞉ int; y꞉ Any)
@end example
  accessor for an any @emph{x} that represents an array or a sequence.

@item len
  @findex proc len*(x꞉ Any)꞉ int
@example
proc len*(x꞉ Any)꞉ int
@end example
  len for an any @emph{x} that represents an array or a sequence.

@item base
  @findex proc base*(x꞉ Any)꞉ Any
@example
proc base*(x꞉ Any)꞉ Any
@end example
  returns base Any (useful for inherited object types).

@item isNil
  @findex proc isNil*(x꞉ Any)꞉ bool
@example
proc isNil*(x꞉ Any)꞉ bool
@end example
  @emph{isNil} for an any @emph{x} that represents a sequence, string, cstring, proc or some pointer type.

@item getPointer
  @findex proc getPointer*(x꞉ Any)꞉ pointer
@example
proc getPointer*(x꞉ Any)꞉ pointer
@end example
  retrieve the pointer value out of @emph{x}. @code{x} needs to be of kind @code{akString}, @code{akCString}, @code{akProc}, @code{akRef}, @code{akPtr}, @code{akPointer}, @code{akSequence}.

@item setPointer
  @findex proc setPointer*(x꞉ Any; y꞉ pointer)
@example
proc setPointer*(x꞉ Any; y꞉ pointer)
@end example
  sets the pointer value of @emph{x}. @code{x} needs to be of kind @code{akString}, @code{akCString}, @code{akProc}, @code{akRef}, @code{akPtr}, @code{akPointer}, @code{akSequence}.

@item `[]=`
  @findex proc `[]=`*(x꞉ Any; fieldName꞉ string; value꞉ Any)
@example
proc `[]=`*(x꞉ Any; fieldName꞉ string; value꞉ Any)
@end example
  sets a field of @emph{x}; @emph{x} represents an object or a tuple.

@item `[]`
  @findex proc `[]`*(x꞉ Any; fieldName꞉ string)꞉ Any
@example
proc `[]`*(x꞉ Any; fieldName꞉ string)꞉ Any
@end example
  gets a field of @emph{x}; @emph{x} represents an object or a tuple.

@item `[]`
  @findex proc `[]`*(x꞉ Any)꞉ Any
@example
proc `[]`*(x꞉ Any)꞉ Any
@end example
  dereference operation for the any @emph{x} that represents a ptr or a ref.

@item `[]=`
  @findex proc `[]=`*(x, y꞉ Any)
@example
proc `[]=`*(x, y꞉ Any)
@end example
  dereference operation for the any @emph{x} that represents a ptr or a ref.

@item getInt
  @findex proc getInt*(x꞉ Any)꞉ int
@example
proc getInt*(x꞉ Any)꞉ int
@end example
  retrieve the int value out of @emph{x}. @emph{x} needs to represent an int.

@item getInt8
  @findex proc getInt8*(x꞉ Any)꞉ int8
@example
proc getInt8*(x꞉ Any)꞉ int8
@end example
  retrieve the int8 value out of @emph{x}. @emph{x} needs to represent an int8.

@item getInt16
  @findex proc getInt16*(x꞉ Any)꞉ int16
@example
proc getInt16*(x꞉ Any)꞉ int16
@end example
  retrieve the int16 value out of @emph{x}. @emph{x} needs to represent an int16.

@item getInt32
  @findex proc getInt32*(x꞉ Any)꞉ int32
@example
proc getInt32*(x꞉ Any)꞉ int32
@end example
  retrieve the int32 value out of @emph{x}. @emph{x} needs to represent an int32.

@item getInt64
  @findex proc getInt64*(x꞉ Any)꞉ int64
@example
proc getInt64*(x꞉ Any)꞉ int64
@end example
  retrieve the int64 value out of @emph{x}. @emph{x} needs to represent an int64.

@item getBiggestInt
  @findex proc getBiggestInt*(x꞉ Any)꞉ BiggestInt
@example
proc getBiggestInt*(x꞉ Any)꞉ BiggestInt
@end example
  retrieve the integer value out of @emph{x}. @emph{x} needs to represent some integer, a bool, a char, an enum or a small enough bit set. The value might be sign-extended to @code{BiggestInt}.

@item setBiggestInt
  @findex proc setBiggestInt*(x꞉ Any; y꞉ BiggestInt)
@example
proc setBiggestInt*(x꞉ Any; y꞉ BiggestInt)
@end example
  sets the integer value of @emph{x}. @emph{x} needs to represent some integer, a bool, a char, an enum or a small enough bit set.

@item getUInt
  @findex proc getUInt*(x꞉ Any)꞉ uint
@example
proc getUInt*(x꞉ Any)꞉ uint
@end example
  retrieve the uint value out of @emph{x}, @emph{x} needs to represent an uint.

@item getUInt8
  @findex proc getUInt8*(x꞉ Any)꞉ uint8
@example
proc getUInt8*(x꞉ Any)꞉ uint8
@end example
  retrieve the uint8 value out of @emph{x}, @emph{x} needs to represent an uint8.

@item getUInt16
  @findex proc getUInt16*(x꞉ Any)꞉ uint16
@example
proc getUInt16*(x꞉ Any)꞉ uint16
@end example
  retrieve the uint16 value out of @emph{x}, @emph{x} needs to represent an uint16.

@item getUInt32
  @findex proc getUInt32*(x꞉ Any)꞉ uint32
@example
proc getUInt32*(x꞉ Any)꞉ uint32
@end example
  retrieve the uint32 value out of @emph{x}, @emph{x} needs to represent an uint32.

@item getUInt64
  @findex proc getUInt64*(x꞉ Any)꞉ uint64
@example
proc getUInt64*(x꞉ Any)꞉ uint64
@end example
  retrieve the uint64 value out of @emph{x}, @emph{x} needs to represent an uint64.

@item getBiggestUint
  @findex proc getBiggestUint*(x꞉ Any)꞉ uint64
@example
proc getBiggestUint*(x꞉ Any)꞉ uint64
@end example
  retrieve the unsigned integer value out of @emph{x}. @emph{x} needs to represent an unsigned integer.

@item setBiggestUint
  @findex proc setBiggestUint*(x꞉ Any; y꞉ uint64)
@example
proc setBiggestUint*(x꞉ Any; y꞉ uint64)
@end example
  sets the unsigned integer value of @emph{c}. @emph{c} needs to represent an unsigned integer.

@item getChar
  @findex proc getChar*(x꞉ Any)꞉ char
@example
proc getChar*(x꞉ Any)꞉ char
@end example
  retrieve the char value out of @emph{x}. @emph{x} needs to represent a char.

@item getBool
  @findex proc getBool*(x꞉ Any)꞉ bool
@example
proc getBool*(x꞉ Any)꞉ bool
@end example
  retrieve the bool value out of @emph{x}. @emph{x} needs to represent a bool.

@item skipRange
  @findex proc skipRange*(x꞉ Any)꞉ Any
@example
proc skipRange*(x꞉ Any)꞉ Any
@end example
  skips the range information of @emph{x}.

@item getEnumOrdinal
  @findex proc getEnumOrdinal*(x꞉ Any; name꞉ string)꞉ int
@example
proc getEnumOrdinal*(x꞉ Any; name꞉ string)꞉ int
@end example
  gets the enum field ordinal from @emph{name}. @emph{x} needs to represent an enum but is only used to access the type information. In case of an error @code{low(int)} is returned.

@item getEnumField
  @findex proc getEnumField*(x꞉ Any; ordinalValue꞉ int)꞉ string
@example
proc getEnumField*(x꞉ Any; ordinalValue꞉ int)꞉ string
@end example
  gets the enum field name as a string. @emph{x} needs to represent an enum but is only used to access the type information. The field name of @emph{ordinalValue} is returned.

@item getEnumField
  @findex proc getEnumField*(x꞉ Any)꞉ string
@example
proc getEnumField*(x꞉ Any)꞉ string
@end example
  gets the enum field name as a string. @emph{x} needs to represent an enum.

@item getFloat
  @findex proc getFloat*(x꞉ Any)꞉ float
@example
proc getFloat*(x꞉ Any)꞉ float
@end example
  retrieve the float value out of @emph{x}. @emph{x} needs to represent an float.

@item getFloat32
  @findex proc getFloat32*(x꞉ Any)꞉ float32
@example
proc getFloat32*(x꞉ Any)꞉ float32
@end example
  retrieve the float32 value out of @emph{x}. @emph{x} needs to represent an float32.

@item getFloat64
  @findex proc getFloat64*(x꞉ Any)꞉ float64
@example
proc getFloat64*(x꞉ Any)꞉ float64
@end example
  retrieve the float64 value out of @emph{x}. @emph{x} needs to represent an float64.

@item getBiggestFloat
  @findex proc getBiggestFloat*(x꞉ Any)꞉ BiggestFloat
@example
proc getBiggestFloat*(x꞉ Any)꞉ BiggestFloat
@end example
  retrieve the float value out of @emph{x}. @emph{x} needs to represent some float. The value is extended to @code{BiggestFloat}.

@item setBiggestFloat
  @findex proc setBiggestFloat*(x꞉ Any; y꞉ BiggestFloat)
@example
proc setBiggestFloat*(x꞉ Any; y꞉ BiggestFloat)
@end example
  sets the float value of @emph{x}. @emph{x} needs to represent some float.

@item getString
  @findex proc getString*(x꞉ Any)꞉ string
@example
proc getString*(x꞉ Any)꞉ string
@end example
  retrieve the string value out of @emph{x}. @emph{x} needs to represent a string.

@item setString
  @findex proc setString*(x꞉ Any; y꞉ string)
@example
proc setString*(x꞉ Any; y꞉ string)
@end example
  sets the string value of @emph{x}. @emph{x} needs to represent a string.

@item getCString
  @findex proc getCString*(x꞉ Any)꞉ cstring
@example
proc getCString*(x꞉ Any)꞉ cstring
@end example
  retrieve the cstring value out of @emph{x}. @emph{x} needs to represent a cstring.

@item assign
  @findex proc assign*(x, y꞉ Any)
@example
proc assign*(x, y꞉ Any)
@end example
  copies the value of @emph{y} to @emph{x}. The assignment operator for @code{Any} does NOT do this; it performs a shallow copy instead!

@item inclSetElement
  @findex proc inclSetElement*(x꞉ Any; elem꞉ int)
@example
proc inclSetElement*(x꞉ Any; elem꞉ int)
@end example
  includes an element @emph{elem} in @emph{x}. @emph{x} needs to represent a Nim bitset.
@end itemize





@chapter Iterators

@itemize


@item fields
  @itindex iterator fields*(x꞉ Any)꞉ tuple[name꞉ string, any꞉ Any]
@example
iterator fields*(x꞉ Any)꞉ tuple[name꞉ string, any꞉ Any]
@end example
  iterates over every active field of the any @emph{x} that represents an object or a tuple.

@item elements
  @itindex iterator elements*(x꞉ Any)꞉ int
@example
iterator elements*(x꞉ Any)꞉ int
@end example
  iterates over every element of @emph{x} that represents a Nim bitset.
@end itemize

@node /core/macros, /windows/winlean , /core/typeinfo, Top
@chapter Constant variables

@itemize


@item nnkCallKinds
  @vindex nnkCallKinds* = @{nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit@}
@example
nnkCallKinds* = @{nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit@}
@end example
  

@item CallNodes
  @vindex CallNodes* = @{nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit,nnkHiddenCallConv@}
@example
CallNodes* = @{nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand, nnkCallStrLit,nnkHiddenCallConv@}
@end example
  
@end itemize



@chapter Types

@itemize


@item TNimSymKinds
  @tindex TNimSymKinds* @{.deprecated.@} = set[NimSymKind]
@example
TNimSymKinds* @{.deprecated.@} = set[NimSymKind]
@end example
  

@item NimSym
  @tindex NimSym* = ref NimSymObj
@example
NimSym* = ref NimSymObj
@end example
  represents a Nim @emph{symbol} in the compiler; a @emph{symbol} is a looked-up @emph{ident}.

@item BindSymRule
  @tindex BindSymRule* = enum
  brClosed,                   ## only the symbols in current scope are bound
  brOpen,                     ## open wrt overloaded symbols, but may be a single
         ## symbol if not ambiguous (the rules match that of
         ## binding in generics)
  brForceOpen                 ## same as brOpen, but it will always be open even
             ## if not ambiguous (this cannot be achieved with
             ## any other means in the language currently)
@example
BindSymRule* = enum
  brClosed,                   ## only the symbols in current scope are bound
  brOpen,                     ## open wrt overloaded symbols, but may be a single
         ## symbol if not ambiguous (the rules match that of
         ## binding in generics)
  brForceOpen                 ## same as brOpen, but it will always be open even
             ## if not ambiguous (this cannot be achieved with
             ## any other means in the language currently)
@end example
  specifies how @code{bindSym} behaves
@end itemize

@chapter Procedures

@itemize


@item `[]`
  @findex proc `[]`*(n꞉ NimNode; i꞉ int)꞉ NimNode @{.magic꞉ "NChild", noSideEffect.@}
@example
proc `[]`*(n꞉ NimNode; i꞉ int)꞉ NimNode @{.magic꞉ "NChild", noSideEffect.@}
@end example
  get @emph{n}'s @emph{i}'th child.

@item `[]=`
  @findex proc `[]=`*(n꞉ NimNode; i꞉ int; child꞉ NimNode) @{.magic꞉ "NSetChild", noSideEffect.@}
@example
proc `[]=`*(n꞉ NimNode; i꞉ int; child꞉ NimNode) @{.magic꞉ "NSetChild", noSideEffect.@}
@end example
  set @emph{n}'s @emph{i}'th child to @emph{child}.

@item `!`
  @findex proc `!`*(s꞉ string)꞉ NimIdent @{.magic꞉ "StrToIdent", noSideEffect.@}
@example
proc `!`*(s꞉ string)꞉ NimIdent @{.magic꞉ "StrToIdent", noSideEffect.@}
@end example
  constructs an identifier from the string @emph{s}

@item `$`
  @findex proc `$`*(i꞉ NimIdent)꞉ string @{.magic꞉ "IdentToStr", noSideEffect.@}
@example
proc `$`*(i꞉ NimIdent)꞉ string @{.magic꞉ "IdentToStr", noSideEffect.@}
@end example
  converts a Nim identifier to a string

@item `$`
  @findex proc `$`*(s꞉ NimSym)꞉ string @{.magic꞉ "IdentToStr", noSideEffect.@}
@example
proc `$`*(s꞉ NimSym)꞉ string @{.magic꞉ "IdentToStr", noSideEffect.@}
@end example
  converts a Nim symbol to a string

@item `==`
  @findex proc `==`*(a, b꞉ NimIdent)꞉ bool @{.magic꞉ "EqIdent", noSideEffect.@}
@example
proc `==`*(a, b꞉ NimIdent)꞉ bool @{.magic꞉ "EqIdent", noSideEffect.@}
@end example
  compares two Nim identifiers

@item `==`
  @findex proc `==`*(a, b꞉ NimNode)꞉ bool @{.magic꞉ "EqNimrodNode", noSideEffect.@}
@example
proc `==`*(a, b꞉ NimNode)꞉ bool @{.magic꞉ "EqNimrodNode", noSideEffect.@}
@end example
  compares two Nim nodes

@item sameType
  @findex proc sameType*(a, b꞉ NimNode)꞉ bool @{.magic꞉ "SameNodeType", noSideEffect.@}
@example
proc sameType*(a, b꞉ NimNode)꞉ bool @{.magic꞉ "SameNodeType", noSideEffect.@}
@end example
  compares two Nim nodes' types. Return true if the types are the same, eg. true when comparing alias with original type.

@item len
  @findex proc len*(n꞉ NimNode)꞉ int @{.magic꞉ "NLen", noSideEffect.@}
@example
proc len*(n꞉ NimNode)꞉ int @{.magic꞉ "NLen", noSideEffect.@}
@end example
  returns the number of children of @emph{n}.

@item add
  @findex proc add*(father, child꞉ NimNode)꞉ NimNode @{.magic꞉ "NAdd", discardable, noSideEffect,locks꞉ 0.@}
@example
proc add*(father, child꞉ NimNode)꞉ NimNode @{.magic꞉ "NAdd", discardable, noSideEffect,locks꞉ 0.@}
@end example
  Adds the @emph{child} to the @emph{father} node. Returns the father node so that calls can be nested.

@item add
  @findex proc add*(father꞉ NimNode; children꞉ varargs[NimNode])꞉ NimNode @{.magic꞉ "NAddMultiple", discardable, noSideEffect, locks꞉ 0.@}
@example
proc add*(father꞉ NimNode; children꞉ varargs[NimNode])꞉ NimNode @{.magic꞉ "NAddMultiple", discardable, noSideEffect, locks꞉ 0.@}
@end example
  Adds each child of @emph{children} to the @emph{father} node. Returns the @emph{father} node so that calls can be nested.

@item del
  @findex proc del*(father꞉ NimNode; idx = 0; n = 1) @{.magic꞉ "NDel", noSideEffect.@}
@example
proc del*(father꞉ NimNode; idx = 0; n = 1) @{.magic꞉ "NDel", noSideEffect.@}
@end example
  deletes @emph{n} children of @emph{father} starting at index @emph{idx}.

@item kind
  @findex proc kind*(n꞉ NimNode)꞉ NimNodeKind @{.magic꞉ "NKind", noSideEffect.@}
@example
proc kind*(n꞉ NimNode)꞉ NimNodeKind @{.magic꞉ "NKind", noSideEffect.@}
@end example
  returns the @emph{kind} of the node @emph{n}.

@item intVal
  @findex proc intVal*(n꞉ NimNode)꞉ BiggestInt @{.magic꞉ "NIntVal", noSideEffect.@}
@example
proc intVal*(n꞉ NimNode)꞉ BiggestInt @{.magic꞉ "NIntVal", noSideEffect.@}
@end example
  

@item floatVal
  @findex proc floatVal*(n꞉ NimNode)꞉ BiggestFloat @{.magic꞉ "NFloatVal", noSideEffect.@}
@example
proc floatVal*(n꞉ NimNode)꞉ BiggestFloat @{.magic꞉ "NFloatVal", noSideEffect.@}
@end example
  

@item symbol
  @findex proc symbol*(n꞉ NimNode)꞉ NimSym @{.magic꞉ "NSymbol", noSideEffect.@}
@example
proc symbol*(n꞉ NimNode)꞉ NimSym @{.magic꞉ "NSymbol", noSideEffect.@}
@end example
  

@item ident
  @findex proc ident*(n꞉ NimNode)꞉ NimIdent @{.magic꞉ "NIdent", noSideEffect.@}
@example
proc ident*(n꞉ NimNode)꞉ NimIdent @{.magic꞉ "NIdent", noSideEffect.@}
@end example
  

@item getType
  @findex proc getType*(n꞉ NimNode)꞉ NimNode @{.magic꞉ "NGetType", noSideEffect.@}
@example
proc getType*(n꞉ NimNode)꞉ NimNode @{.magic꞉ "NGetType", noSideEffect.@}
@end example
  with 'getType' you can access the node's . A Nim type is mapped to a Nim AST too, so it's slightly confusing but it means the same API can be used to traverse types. Recursive types are flattened for you so there is no danger of infinite recursions during traversal. To resolve recursive types, you have to call 'getType' again. To see what kind of type it is, call @emph{typeKind} on getType's result.

@item getType
  @findex proc getType*(n꞉ typedesc)꞉ NimNode @{.magic꞉ "NGetType", noSideEffect.@}
@example
proc getType*(n꞉ typedesc)꞉ NimNode @{.magic꞉ "NGetType", noSideEffect.@}
@end example
  Returns the Nim type node for given type. This can be used to turn macro typedesc parameter into proper NimNode representing type, since typedesc are an exception in macro calls - they are not mapped implicitly to NimNode like any other arguments.

@item typeKind
  @findex proc typeKind*(n꞉ NimNode)꞉ NimTypeKind @{.magic꞉ "NGetType", noSideEffect.@}
@example
proc typeKind*(n꞉ NimNode)꞉ NimTypeKind @{.magic꞉ "NGetType", noSideEffect.@}
@end example
  Returns the type kind of the node 'n' that should represent a type, that means the node should have been obtained via @emph{getType}.

@item strVal
  @findex proc strVal*(n꞉ NimNode)꞉ string @{.magic꞉ "NStrVal", noSideEffect.@}
@example
proc strVal*(n꞉ NimNode)꞉ string @{.magic꞉ "NStrVal", noSideEffect.@}
@end example
  

@item `intVal=`
  @findex proc `intVal =`*(n꞉ NimNode; val꞉ BiggestInt) @{.magic꞉ "NSetIntVal", noSideEffect.@}
@example
proc `intVal =`*(n꞉ NimNode; val꞉ BiggestInt) @{.magic꞉ "NSetIntVal", noSideEffect.@}
@end example
  

@item `floatVal=`
  @findex proc `floatVal =`*(n꞉ NimNode; val꞉ BiggestFloat) @{.magic꞉ "NSetFloatVal", noSideEffect.@}
@example
proc `floatVal =`*(n꞉ NimNode; val꞉ BiggestFloat) @{.magic꞉ "NSetFloatVal", noSideEffect.@}
@end example
  

@item `symbol=`
  @findex proc `symbol =`*(n꞉ NimNode; val꞉ NimSym) @{.magic꞉ "NSetSymbol", noSideEffect.@}
@example
proc `symbol =`*(n꞉ NimNode; val꞉ NimSym) @{.magic꞉ "NSetSymbol", noSideEffect.@}
@end example
  

@item `ident=`
  @findex proc `ident =`*(n꞉ NimNode; val꞉ NimIdent) @{.magic꞉ "NSetIdent", noSideEffect.@}
@example
proc `ident =`*(n꞉ NimNode; val꞉ NimIdent) @{.magic꞉ "NSetIdent", noSideEffect.@}
@end example
  

@item `strVal=`
  @findex proc `strVal =`*(n꞉ NimNode; val꞉ string) @{.magic꞉ "NSetStrVal", noSideEffect.@}
@example
proc `strVal =`*(n꞉ NimNode; val꞉ string) @{.magic꞉ "NSetStrVal", noSideEffect.@}
@end example
  

@item newNimNode
  @findex proc newNimNode*(kind꞉ NimNodeKind; n꞉ NimNode = nil)꞉ NimNode @{.magic꞉ "NNewNimNode",noSideEffect.@}
@example
proc newNimNode*(kind꞉ NimNodeKind; n꞉ NimNode = nil)꞉ NimNode @{.magic꞉ "NNewNimNode",noSideEffect.@}
@end example
  

@item copyNimNode
  @findex proc copyNimNode*(n꞉ NimNode)꞉ NimNode @{.magic꞉ "NCopyNimNode", noSideEffect.@}
@example
proc copyNimNode*(n꞉ NimNode)꞉ NimNode @{.magic꞉ "NCopyNimNode", noSideEffect.@}
@end example
  

@item copyNimTree
  @findex proc copyNimTree*(n꞉ NimNode)꞉ NimNode @{.magic꞉ "NCopyNimTree", noSideEffect.@}
@example
proc copyNimTree*(n꞉ NimNode)꞉ NimNode @{.magic꞉ "NCopyNimTree", noSideEffect.@}
@end example
  

@item getImpl
  @findex proc getImpl*(s꞉ NimSym)꞉ NimNode @{.magic꞉ "GetImpl", noSideEffect.@}
@example
proc getImpl*(s꞉ NimSym)꞉ NimNode @{.magic꞉ "GetImpl", noSideEffect.@}
@end example
  retrieve the implementation of a symbol @emph{s}. @emph{s} can be a routine or a const.

@item error
  @findex proc error*(msg꞉ string) @{.magic꞉ "NError", benign.@}
@example
proc error*(msg꞉ string) @{.magic꞉ "NError", benign.@}
@end example
  writes an error message at compile time

@item warning
  @findex proc warning*(msg꞉ string) @{.magic꞉ "NWarning", benign.@}
@example
proc warning*(msg꞉ string) @{.magic꞉ "NWarning", benign.@}
@end example
  writes a warning message at compile time

@item hint
  @findex proc hint*(msg꞉ string) @{.magic꞉ "NHint", benign.@}
@example
proc hint*(msg꞉ string) @{.magic꞉ "NHint", benign.@}
@end example
  writes a hint message at compile time

@item newStrLitNode
  @findex proc newStrLitNode*(s꞉ string)꞉ NimNode @{.compileTime, noSideEffect.@}
@example
proc newStrLitNode*(s꞉ string)꞉ NimNode @{.compileTime, noSideEffect.@}
@end example
  creates a string literal node from @emph{s}

@item newIntLitNode
  @findex proc newIntLitNode*(i꞉ BiggestInt)꞉ NimNode @{.compileTime.@}
@example
proc newIntLitNode*(i꞉ BiggestInt)꞉ NimNode @{.compileTime.@}
@end example
  creates a int literal node from @emph{i}

@item newFloatLitNode
  @findex proc newFloatLitNode*(f꞉ BiggestFloat)꞉ NimNode @{.compileTime.@}
@example
proc newFloatLitNode*(f꞉ BiggestFloat)꞉ NimNode @{.compileTime.@}
@end example
  creates a float literal node from @emph{f}

@item newIdentNode
  @findex proc newIdentNode*(i꞉ NimIdent)꞉ NimNode @{.compileTime.@}
@example
proc newIdentNode*(i꞉ NimIdent)꞉ NimNode @{.compileTime.@}
@end example
  creates an identifier node from @emph{i}

@item newIdentNode
  @findex proc newIdentNode*(i꞉ string)꞉ NimNode @{.compileTime.@}
@example
proc newIdentNode*(i꞉ string)꞉ NimNode @{.compileTime.@}
@end example
  creates an identifier node from @emph{i}

@item bindSym
  @findex proc bindSym*(ident꞉ string; rule꞉ BindSymRule = brClosed)꞉ NimNode @{.magic꞉ "NBindSym",noSideEffect.@}
@example
proc bindSym*(ident꞉ string; rule꞉ BindSymRule = brClosed)꞉ NimNode @{.magic꞉ "NBindSym",noSideEffect.@}
@end example
  creates a node that binds @emph{ident} to a symbol node. The bound symbol may be an overloaded symbol. If @code{rule == brClosed} either an @code{nkClosedSymChoice} tree is returned or @code{nkSym} if the symbol is not ambiguous. If @code{rule == brOpen} either an @code{nkOpenSymChoice} tree is returned or @code{nkSym} if the symbol is not ambiguous. If @code{rule == brForceOpen} always an @code{nkOpenSymChoice} tree is returned even if the symbol is not ambiguous.

@item genSym
  @findex proc genSym*(kind꞉ NimSymKind = nskLet; ident = "")꞉ NimNode @{.magic꞉ "NGenSym",noSideEffect.@}
@example
proc genSym*(kind꞉ NimSymKind = nskLet; ident = "")꞉ NimNode @{.magic꞉ "NGenSym",noSideEffect.@}
@end example
  generates a fresh symbol that is guaranteed to be unique. The symbol needs to occur in a declaration context.

@item callsite
  @findex proc callsite*()꞉ NimNode @{.magic꞉ "NCallSite", benign.@}
@example
proc callsite*()꞉ NimNode @{.magic꞉ "NCallSite", benign.@}
@end example
  returns the AST of the invocation expression that invoked this macro.

@item toStrLit
  @findex proc toStrLit*(n꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc toStrLit*(n꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  converts the AST @emph{n} to the concrete Nim code and wraps that in a string literal node

@item lineinfo
  @findex proc lineinfo*(n꞉ NimNode)꞉ string @{.magic꞉ "NLineInfo", noSideEffect.@}
@example
proc lineinfo*(n꞉ NimNode)꞉ string @{.magic꞉ "NLineInfo", noSideEffect.@}
@end example
  returns the position the node appears in the original source file in the form filename(line, col)

@item internalErrorFlag
  @findex proc internalErrorFlag*()꞉ string @{.magic꞉ "NError", noSideEffect.@}
@example
proc internalErrorFlag*()꞉ string @{.magic꞉ "NError", noSideEffect.@}
@end example
  Some builtins set an error flag. This is then turned into a proper exception. @strong{Note}: Ordinary application code should not call this.

@item parseExpr
  @findex proc parseExpr*(s꞉ string)꞉ NimNode @{.noSideEffect, compileTime.@}
@example
proc parseExpr*(s꞉ string)꞉ NimNode @{.noSideEffect, compileTime.@}
@end example
  Compiles the passed string to its AST representation. Expects a single expression. Raises @code{ValueError} for parsing errors.

@item parseStmt
  @findex proc parseStmt*(s꞉ string)꞉ NimNode @{.noSideEffect, compileTime.@}
@example
proc parseStmt*(s꞉ string)꞉ NimNode @{.noSideEffect, compileTime.@}
@end example
  Compiles the passed string to its AST representation. Expects one or more statements. Raises @code{ValueError} for parsing errors.

@item getAst
  @findex proc getAst*(macroOrTemplate꞉ expr)꞉ NimNode @{.magic꞉ "ExpandToAst", noSideEffect.@}
@example
proc getAst*(macroOrTemplate꞉ expr)꞉ NimNode @{.magic꞉ "ExpandToAst", noSideEffect.@}
@end example
  Obtains the AST nodes returned from a macro or template invocation. Example:
@example

macro FooMacro() =
  var ast = getAst(BarTemplate())
@end example

@item quote
  @findex proc quote*(bl꞉ stmt; op = "``")꞉ NimNode @{.magic꞉ "QuoteAst", noSideEffect.@}
@example
proc quote*(bl꞉ stmt; op = "``")꞉ NimNode @{.magic꞉ "QuoteAst", noSideEffect.@}
@end example
  Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression. The original meaning of the interpolation operator may be obtained by escaping it (by prefixing it with itself): e.g. @emph{@@} is escaped as @emph{@@@@}, @emph{@@@@} is escaped as @emph{@@@@@@} and so on.

Example:


@example

macro check(ex: expr): stmt =
  # this is a simplified version of the check macro from the
  # unittest module.
  
  # If there is a failed check, we want to make it easy for
  # the user to jump to the faulty line in the code, so we
  # get the line info here:
  var info = ex.lineinfo
  
  # We will also display the code string of the failed check:
  var expString = ex.toStrLit
  
  # Finally we compose the code to implement the check:
  result = quote do:
    if not `ex`:
      echo `info` & ": Check failed: " & `expString`
@end example

@item expectKind
  @findex proc expectKind*(n꞉ NimNode; k꞉ NimNodeKind) @{.compileTime.@}
@example
proc expectKind*(n꞉ NimNode; k꞉ NimNodeKind) @{.compileTime.@}
@end example
  checks that @emph{n} is of kind @emph{k}. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them.

@item expectMinLen
  @findex proc expectMinLen*(n꞉ NimNode; min꞉ int) @{.compileTime.@}
@example
proc expectMinLen*(n꞉ NimNode; min꞉ int) @{.compileTime.@}
@end example
  checks that @emph{n} has at least @emph{min} children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.

@item expectLen
  @findex proc expectLen*(n꞉ NimNode; len꞉ int) @{.compileTime.@}
@example
proc expectLen*(n꞉ NimNode; len꞉ int) @{.compileTime.@}
@end example
  checks that @emph{n} has exactly @emph{len} children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.

@item newTree
  @findex proc newTree*(kind꞉ NimNodeKind; children꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@example
proc newTree*(kind꞉ NimNodeKind; children꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@end example
  produces a new node with children.

@item newCall
  @findex proc newCall*(theProc꞉ NimNode; args꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@example
proc newCall*(theProc꞉ NimNode; args꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@end example
  produces a new call node. @emph{theProc} is the proc that is called with the arguments @code{args[0..]}.

@item newCall
  @findex proc newCall*(theProc꞉ NimIdent; args꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@example
proc newCall*(theProc꞉ NimIdent; args꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@end example
  produces a new call node. @emph{theProc} is the proc that is called with the arguments @code{args[0..]}.

@item newCall
  @findex proc newCall*(theProc꞉ string; args꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@example
proc newCall*(theProc꞉ string; args꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@end example
  produces a new call node. @emph{theProc} is the proc that is called with the arguments @code{args[0..]}.

@item newLit
  @findex proc newLit*(c꞉ char)꞉ NimNode @{.compileTime.@}
@example
proc newLit*(c꞉ char)꞉ NimNode @{.compileTime.@}
@end example
  produces a new character literal node.

@item newLit
  @findex proc newLit*(i꞉ BiggestInt)꞉ NimNode @{.compileTime.@}
@example
proc newLit*(i꞉ BiggestInt)꞉ NimNode @{.compileTime.@}
@end example
  produces a new integer literal node.

@item newLit
  @findex proc newLit*(b꞉ bool)꞉ NimNode @{.compileTime.@}
@example
proc newLit*(b꞉ bool)꞉ NimNode @{.compileTime.@}
@end example
  produces a new boolean literal node.

@item newLit
  @findex proc newLit*(f꞉ BiggestFloat)꞉ NimNode @{.compileTime.@}
@example
proc newLit*(f꞉ BiggestFloat)꞉ NimNode @{.compileTime.@}
@end example
  produces a new float literal node.

@item newLit
  @findex proc newLit*(s꞉ string)꞉ NimNode @{.compileTime.@}
@example
proc newLit*(s꞉ string)꞉ NimNode @{.compileTime.@}
@end example
  produces a new string literal node.

@item nestList
  @findex proc nestList*(theProc꞉ NimIdent; x꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc nestList*(theProc꞉ NimIdent; x꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  nests the list @emph{x} into a tree of call expressions: @code{[a, b, c]} is transformed into @code{theProc(a, theProc(c, d))}.

@item treeRepr
  @findex proc treeRepr*(n꞉ NimNode)꞉ string @{.compileTime, benign.@}
@example
proc treeRepr*(n꞉ NimNode)꞉ string @{.compileTime, benign.@}
@end example
  Convert the AST @emph{n} to a human-readable tree-like string.

See also @emph{repr} and @emph{lispRepr}.

@item lispRepr
  @findex proc lispRepr*(n꞉ NimNode)꞉ string @{.compileTime, benign.@}
@example
proc lispRepr*(n꞉ NimNode)꞉ string @{.compileTime, benign.@}
@end example
  Convert the AST @emph{n} to a human-readable lisp-like string,

See also @emph{repr} and @emph{treeRepr}.

@item newEmptyNode
  @findex proc newEmptyNode*()꞉ NimNode @{.compileTime, noSideEffect.@}
@example
proc newEmptyNode*()꞉ NimNode @{.compileTime, noSideEffect.@}
@end example
  Create a new empty node

@item newStmtList
  @findex proc newStmtList*(stmts꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@example
proc newStmtList*(stmts꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@end example
  Create a new statement list

@item newPar
  @findex proc newPar*(exprs꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@example
proc newPar*(exprs꞉ varargs[NimNode])꞉ NimNode @{.compileTime.@}
@end example
  Create a new parentheses-enclosed expression

@item newBlockStmt
  @findex proc newBlockStmt*(label, body꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc newBlockStmt*(label, body꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  Create a new block statement with label

@item newBlockStmt
  @findex proc newBlockStmt*(body꞉ NimNode)꞉ NimNode @{.compiletime.@}
@example
proc newBlockStmt*(body꞉ NimNode)꞉ NimNode @{.compiletime.@}
@end example
  Create a new block: stmt

@item newVarStmt
  @findex proc newVarStmt*(name, value꞉ NimNode)꞉ NimNode @{.compiletime.@}
@example
proc newVarStmt*(name, value꞉ NimNode)꞉ NimNode @{.compiletime.@}
@end example
  Create a new var stmt

@item newLetStmt
  @findex proc newLetStmt*(name, value꞉ NimNode)꞉ NimNode @{.compiletime.@}
@example
proc newLetStmt*(name, value꞉ NimNode)꞉ NimNode @{.compiletime.@}
@end example
  Create a new let stmt

@item newConstStmt
  @findex proc newConstStmt*(name, value꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc newConstStmt*(name, value꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  Create a new const stmt

@item newAssignment
  @findex proc newAssignment*(lhs, rhs꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc newAssignment*(lhs, rhs꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  

@item newDotExpr
  @findex proc newDotExpr*(a, b꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc newDotExpr*(a, b꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  Create new dot expression a.dot(b) ->  @emph{a.b}

@item newColonExpr
  @findex proc newColonExpr*(a, b꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc newColonExpr*(a, b꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  Create new colon expression newColonExpr(a, b) ->  @emph{a: b}

@item newIdentDefs
  @findex proc newIdentDefs*(name, kind꞉ NimNode; default = newEmptyNode())꞉ NimNode @{.compileTime.@}
@example
proc newIdentDefs*(name, kind꞉ NimNode; default = newEmptyNode())꞉ NimNode @{.compileTime.@}
@end example
  Creates a new @code{nnkIdentDefs} node of a specific kind and value.

@code{nnkIdentDefs} need to have at least three children, but they can have more: first comes a list of identifiers followed by a type and value nodes. This helper proc creates a three node subtree, the first subnode being a single identifier name. Both the @code{kind} node and @code{default} (value) nodes may be empty depending on where the @code{nnkIdentDefs} appears: tuple or object definitions will have an empty @code{default} node, @code{let} or @code{var} blocks may have an empty @code{kind} node if the identifier is being assigned a value. Example:


@example

var varSection = newNimNode(nnkVarSection).add(
  newIdentDefs(ident("a"), ident("string")),
  newIdentDefs(ident("b"), newEmptyNode(), newLit(3)))
# --> var
#       a: string
#       b = 3
@end example
If you need to create multiple identifiers you need to use the lower level @code{newNimNode}:


@example

result = newNimNode(nnkIdentDefs).add(
  ident("a"), ident("b"), ident("c"), ident("string"),
    newStrLitNode("Hello"))
@end example

@item newNilLit
  @findex proc newNilLit*()꞉ NimNode @{.compileTime.@}
@example
proc newNilLit*()꞉ NimNode @{.compileTime.@}
@end example
  New nil literal shortcut

@item last
  @findex proc last*(node꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc last*(node꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  Return the last item in nodes children. Same as @emph{node[^1]}

@item expectKind
  @findex proc expectKind*(n꞉ NimNode; k꞉ set[NimNodeKind]) @{.compileTime.@}
@example
proc expectKind*(n꞉ NimNode; k꞉ set[NimNodeKind]) @{.compileTime.@}
@end example
  

@item newProc
  @findex proc newProc*(name = newEmptyNode(); params꞉ openArray[NimNode] = [newEmptyNode()];body꞉ NimNode = newStmtList(); procType = nnkProcDef)꞉ NimNode @{.compileTime.@}
@example
proc newProc*(name = newEmptyNode(); params꞉ openArray[NimNode] = [newEmptyNode()];body꞉ NimNode = newStmtList(); procType = nnkProcDef)꞉ NimNode @{.compileTime.@}
@end example
  shortcut for creating a new proc

The @code{params} array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.

@item newIfStmt
  @findex proc newIfStmt*(branches꞉ varargs[tuple[cond, body꞉ NimNode]])꞉ NimNode @{.compiletime.@}
@example
proc newIfStmt*(branches꞉ varargs[tuple[cond, body꞉ NimNode]])꞉ NimNode @{.compiletime.@}
@end example
  Constructor for @code{if} statements.
@example

newIfStmt(
  (Ident, StmtList),
  ...
)
@end example

@item copyChildrenTo
  @findex proc copyChildrenTo*(src, dest꞉ NimNode) @{.compileTime.@}
@example
proc copyChildrenTo*(src, dest꞉ NimNode) @{.compileTime.@}
@end example
  Copy all children from @emph{src} to @emph{dest}

@item name
  @findex proc name*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc name*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  

@item `name=`
  @findex proc `name =`*(someProc꞉ NimNode; val꞉ NimNode) @{.compileTime.@}
@example
proc `name =`*(someProc꞉ NimNode; val꞉ NimNode) @{.compileTime.@}
@end example
  

@item params
  @findex proc params*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc params*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  

@item `params=`
  @findex proc `params =`*(someProc꞉ NimNode; params꞉ NimNode) @{.compileTime.@}
@example
proc `params =`*(someProc꞉ NimNode; params꞉ NimNode) @{.compileTime.@}
@end example
  

@item pragma
  @findex proc pragma*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc pragma*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  Get the pragma of a proc type These will be expanded

@item `pragma=`
  @findex proc `pragma =`*(someProc꞉ NimNode; val꞉ NimNode) @{.compileTime.@}
@example
proc `pragma =`*(someProc꞉ NimNode; val꞉ NimNode) @{.compileTime.@}
@end example
  Set the pragma of a proc type

@item body
  @findex proc body*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc body*(someProc꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  

@item `body=`
  @findex proc `body =`*(someProc꞉ NimNode; val꞉ NimNode) @{.compileTime.@}
@example
proc `body =`*(someProc꞉ NimNode; val꞉ NimNode) @{.compileTime.@}
@end example
  

@item basename
  @findex proc basename*(a꞉ NimNode)꞉ NimNode @{.compiletime, benign.@}
@example
proc basename*(a꞉ NimNode)꞉ NimNode @{.compiletime, benign.@}
@end example
  

@item `$`
  @findex proc `$`*(node꞉ NimNode)꞉ string @{.compileTime.@}
@example
proc `$`*(node꞉ NimNode)꞉ string @{.compileTime.@}
@end example
  Get the string of an identifier node

@item ident
  @findex proc ident*(name꞉ string)꞉ NimNode @{.compileTime, inline.@}
@example
proc ident*(name꞉ string)꞉ NimNode @{.compileTime, inline.@}
@end example
  Create a new ident node from a string

@item insert
  @findex proc insert*(a꞉ NimNode; pos꞉ int; b꞉ NimNode) @{.compileTime.@}
@example
proc insert*(a꞉ NimNode; pos꞉ int; b꞉ NimNode) @{.compileTime.@}
@end example
  Insert node B into A at pos

@item basename
  @findex proc basename*(a꞉ NimNode)꞉ NimNode
@example
proc basename*(a꞉ NimNode)꞉ NimNode
@end example
  Pull an identifier from prefix/postfix expressions

@item `basename=`
  @findex proc `basename =`*(a꞉ NimNode; val꞉ string) @{.compileTime.@}
@example
proc `basename =`*(a꞉ NimNode; val꞉ string) @{.compileTime.@}
@end example
  

@item postfix
  @findex proc postfix*(node꞉ NimNode; op꞉ string)꞉ NimNode @{.compileTime.@}
@example
proc postfix*(node꞉ NimNode; op꞉ string)꞉ NimNode @{.compileTime.@}
@end example
  

@item prefix
  @findex proc prefix*(node꞉ NimNode; op꞉ string)꞉ NimNode @{.compileTime.@}
@example
proc prefix*(node꞉ NimNode; op꞉ string)꞉ NimNode @{.compileTime.@}
@end example
  

@item infix
  @findex proc infix*(a꞉ NimNode; op꞉ string; b꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc infix*(a꞉ NimNode; op꞉ string; b꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  

@item unpackPostfix
  @findex proc unpackPostfix*(node꞉ NimNode)꞉ tuple[node꞉ NimNode, op꞉ string] @{.compileTime.@}
@example
proc unpackPostfix*(node꞉ NimNode)꞉ tuple[node꞉ NimNode, op꞉ string] @{.compileTime.@}
@end example
  

@item unpackPrefix
  @findex proc unpackPrefix*(node꞉ NimNode)꞉ tuple[node꞉ NimNode, op꞉ string] @{.compileTime.@}
@example
proc unpackPrefix*(node꞉ NimNode)꞉ tuple[node꞉ NimNode, op꞉ string] @{.compileTime.@}
@end example
  

@item unpackInfix
  @findex proc unpackInfix*(node꞉ NimNode)꞉ tuple[left꞉ NimNode, op꞉ string, right꞉ NimNode] @{.compileTime.@}
@example
proc unpackInfix*(node꞉ NimNode)꞉ tuple[left꞉ NimNode, op꞉ string, right꞉ NimNode] @{.compileTime.@}
@end example
  

@item copy
  @findex proc copy*(node꞉ NimNode)꞉ NimNode @{.compileTime.@}
@example
proc copy*(node꞉ NimNode)꞉ NimNode @{.compileTime.@}
@end example
  An alias for copyNimTree().

@item eqIdent
  @findex proc eqIdent*(a, b꞉ string)꞉ bool
@example
proc eqIdent*(a, b꞉ string)꞉ bool
@end example
  Check if two idents are identical.

@item hasArgOfName
  @findex proc hasArgOfName*(params꞉ NimNode; name꞉ string)꞉ bool @{.compiletime.@}
@example
proc hasArgOfName*(params꞉ NimNode; name꞉ string)꞉ bool @{.compiletime.@}
@end example
  Search nnkFormalParams for an argument.

@item addIdentIfAbsent
  @findex proc addIdentIfAbsent*(dest꞉ NimNode; ident꞉ string) @{.compiletime.@}
@example
proc addIdentIfAbsent*(dest꞉ NimNode; ident꞉ string) @{.compiletime.@}
@end example
  Add ident to dest if it is not present. This is intended for use with pragmas.

@item boolVal
  @findex proc boolVal*(n꞉ NimNode)꞉ bool @{.compileTime, noSideEffect.@}
@example
proc boolVal*(n꞉ NimNode)꞉ bool @{.compileTime, noSideEffect.@}
@end example
  
@end itemize

@chapter Templates

@itemize


@item findChild
  @findex template findChild*(n꞉ NimNode; cond꞉ expr)꞉ NimNode @{.immediate, dirty.@}
@example
template findChild*(n꞉ NimNode; cond꞉ expr)꞉ NimNode @{.immediate, dirty.@}
@end example
  Find the first child node matching condition (or nil).
@example
var res = findChild(n, it.kind == nnkPostfix and
                       it.basename.ident == !"foo")
@end example

@item emit
  @findex template emit*(e꞉ static[string])꞉ stmt
@example
template emit*(e꞉ static[string])꞉ stmt
@end example
  accepts a single string argument and treats it as nim code that should be inserted verbatim in the program Example:
@example
emit("echo " & '"' & "hello world".toUpper & '"')
@end example
@end itemize

@chapter Macros

@itemize


@item dumpTree
  @findex macro dumpTree*(s꞉ stmt)꞉ stmt @{.immediate.@}
@example
macro dumpTree*(s꞉ stmt)꞉ stmt @{.immediate.@}
@end example
  Accepts a block of nim code and prints the parsed abstract syntax tree using the @emph{toTree} function. Printing is done @emph{at compile time}.

You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.

@item dumpLisp
  @findex macro dumpLisp*(s꞉ stmt)꞉ stmt @{.immediate.@}
@example
macro dumpLisp*(s꞉ stmt)꞉ stmt @{.immediate.@}
@end example
  Accepts a block of nim code and prints the parsed abstract syntax tree using the @emph{toLisp} function. Printing is done @emph{at compile time}.

See @emph{dumpTree}.

@item dumpTreeImm
  @findex macro dumpTreeImm*(s꞉ stmt)꞉ stmt @{.immediate, deprecated.@}
@example
macro dumpTreeImm*(s꞉ stmt)꞉ stmt @{.immediate, deprecated.@}
@end example
  The @code{immediate} version of @emph{dumpTree}.

@item dumpLispImm
  @findex macro dumpLispImm*(s꞉ stmt)꞉ stmt @{.immediate, deprecated.@}
@example
macro dumpLispImm*(s꞉ stmt)꞉ stmt @{.immediate, deprecated.@}
@end example
  The @code{immediate} version of @emph{dumpLisp}.
@end itemize



@chapter Iterators

@itemize


@item items
  @itindex iterator items*(n꞉ NimNode)꞉ NimNode @{.inline.@}
@example
iterator items*(n꞉ NimNode)꞉ NimNode @{.inline.@}
@end example
  Iterates over the children of the NimNode @code{n}.

@item children
  @itindex iterator children*(n꞉ NimNode)꞉ NimNode @{.inline.@}
@example
iterator children*(n꞉ NimNode)꞉ NimNode @{.inline.@}
@end example
  Iterates over the children of the NimNode @code{n}.
@end itemize

@node /windows/winlean, /posix/epoll , /core/macros, Top
@chapter Constant variables

@itemize


@item useWinUnicode
  @vindex useWinUnicode* = not defined(useWinAnsi)
@example
useWinUnicode* = not defined(useWinAnsi)
@end example
  

@item CREATE_NO_WINDOW
  @vindex CREATE_NO_WINDOW* = 0x08000000'i32
@example
CREATE_NO_WINDOW* = 0x08000000'i32
@end example
  

@item MAX_PATH
  @vindex MAX_PATH* = 260
@example
MAX_PATH* = 260
@end example
  

@item WSAEINPROGRESS
  @vindex WSAEINPROGRESS* = 10036
@example
WSAEINPROGRESS* = 10036
@end example
  

@item MAXIMUM_WAIT_OBJECTS
  @vindex MAXIMUM_WAIT_OBJECTS* = 0x00000040
@example
MAXIMUM_WAIT_OBJECTS* = 0x00000040
@end example
  

@item FILE_WRITE_DATA
  @vindex FILE_WRITE_DATA* = 0x00000002
@example
FILE_WRITE_DATA* = 0x00000002
@end example
  

@item ERROR_HANDLE_EOF
  @vindex ERROR_HANDLE_EOF* = 38
@example
ERROR_HANDLE_EOF* = 38
@end example
  

@item ERROR_NETNAME_DELETED
  @vindex ERROR_NETNAME_DELETED* = 64
@example
ERROR_NETNAME_DELETED* = 64
@end example
  

@item IOC_INOUT
  @vindex IOC_INOUT* = IOC_IN or IOC_OUT
@example
IOC_INOUT* = IOC_IN or IOC_OUT
@end example
  

@item AF_INET6
  @vindex AF_INET6* = 23
@example
AF_INET6* = 23
@end example
  
@end itemize


@chapter Variables

@itemize


@item SO_ERROR
  @vindex SO_ERROR* @{.importc, header꞉ "winsock2.h".@}꞉ cint
@example
SO_ERROR* @{.importc, header꞉ "winsock2.h".@}꞉ cint
@end example
  

@item WSAID_GETACCEPTEXSOCKADDRS
  @vindex WSAID_GETACCEPTEXSOCKADDRS*꞉ GUID = GUID(D1꞉ 0xB5367DF2'i32, D2꞉ 0xCBAC'i16,D3꞉ 0x000011CF, D4꞉ [0x95'i8, 0xCA'i8, 0x00'i8,0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])
@example
WSAID_GETACCEPTEXSOCKADDRS*꞉ GUID = GUID(D1꞉ 0xB5367DF2'i32, D2꞉ 0xCBAC'i16,D3꞉ 0x000011CF, D4꞉ [0x95'i8, 0xCA'i8, 0x00'i8,0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])
@end example
  
@end itemize

@chapter Types

@itemize


@item BY_HANDLE_FILE_INFORMATION
  @tindex BY_HANDLE_FILE_INFORMATION* @{.final, pure.@} = object
  dwFileAttributes*: DWORD
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  dwVolumeSerialNumber*: DWORD
  nFileSizeHigh*: DWORD
  nFileSizeLow*: DWORD
  nNumberOfLinks*: DWORD
  nFileIndexHigh*: DWORD
  nFileIndexLow*: DWORD

@example
BY_HANDLE_FILE_INFORMATION* @{.final, pure.@} = object
  dwFileAttributes*: DWORD
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  dwVolumeSerialNumber*: DWORD
  nFileSizeHigh*: DWORD
  nFileSizeLow*: DWORD
  nNumberOfLinks*: DWORD
  nFileIndexHigh*: DWORD
  nFileIndexLow*: DWORD

@end example
  

@item WinChar
  @tindex WinChar* = Utf16Char
@example
WinChar* = Utf16Char
@end example
  

@item WIN32_FIND_DATA
  @tindex WIN32_FIND_DATA* @{.pure.@} = object
  dwFileAttributes*: int32
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  nFileSizeHigh*: int32
  nFileSizeLow*: int32
  dwReserved0: int32
  dwReserved1: int32
  cFileName*: array[0 .. (MAX_PATH) - 1, WinChar]
  cAlternateFileName*: array[0 .. 13, WinChar]

@example
WIN32_FIND_DATA* @{.pure.@} = object
  dwFileAttributes*: int32
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  nFileSizeHigh*: int32
  nFileSizeLow*: int32
  dwReserved0: int32
  dwReserved1: int32
  cFileName*: array[0 .. (MAX_PATH) - 1, WinChar]
  cAlternateFileName*: array[0 .. 13, WinChar]

@end example
  

@item SocketHandle
  @tindex SocketHandle* = distinct int
@example
SocketHandle* = distinct int
@end example
  

@item SockLen
  @tindex SockLen* = cuint
@example
SockLen* = cuint
@end example
  

@item PWOHandleArray
  @tindex PWOHandleArray* = ptr WOHandleArray
@example
PWOHandleArray* = ptr WOHandleArray
@end example
  

@item GUID
  @tindex GUID* @{.final, pure.@} = object
  D1*: int32
  D2*: int16
  D3*: int16
  D4*: array[0 .. 7, int8]

@example
GUID* @{.final, pure.@} = object
  D1*: int32
  D2*: int16
  D3*: int16
  D4*: array[0 .. 7, int8]

@end example
  

@item TWSABuf
  @tindex TWSABuf* @{.importc: "WSABUF", header: "winsock2.h".@} = object
  len*: ULONG
  buf*: cstring

@example
TWSABuf* @{.importc: "WSABUF", header: "winsock2.h".@} = object
  len*: ULONG
  buf*: cstring

@end example
  
@end itemize

@chapter Procedures

@itemize


@item closeHandle
  @findex proc closeHandle*(hObject꞉ Handle)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "CloseHandle".@}
@example
proc closeHandle*(hObject꞉ Handle)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "CloseHandle".@}
@end example
  

@item readFile
  @findex proc readFile*(hFile꞉ Handle; Buffer꞉ pointer; nNumberOfBytesToRead꞉ int32;lpNumberOfBytesRead꞉ ptr int32; lpOverlapped꞉ pointer)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "ReadFile".@}
@example
proc readFile*(hFile꞉ Handle; Buffer꞉ pointer; nNumberOfBytesToRead꞉ int32;lpNumberOfBytesRead꞉ ptr int32; lpOverlapped꞉ pointer)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "ReadFile".@}
@end example
  

@item writeFile
  @findex proc writeFile*(hFile꞉ Handle; Buffer꞉ pointer; nNumberOfBytesToWrite꞉ int32;lpNumberOfBytesWritten꞉ ptr int32; lpOverlapped꞉ pointer)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "WriteFile".@}
@example
proc writeFile*(hFile꞉ Handle; Buffer꞉ pointer; nNumberOfBytesToWrite꞉ int32;lpNumberOfBytesWritten꞉ ptr int32; lpOverlapped꞉ pointer)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "WriteFile".@}
@end example
  

@item createPipe
  @findex proc createPipe*(hReadPipe, hWritePipe꞉ var Handle;lpPipeAttributes꞉ var SECURITY_ATTRIBUTES; nSize꞉ int32)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "CreatePipe".@}
@example
proc createPipe*(hReadPipe, hWritePipe꞉ var Handle;lpPipeAttributes꞉ var SECURITY_ATTRIBUTES; nSize꞉ int32)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "CreatePipe".@}
@end example
  

@item createNamedPipe
  @findex proc createNamedPipe*(lpName: WideCString; dwOpenMode, dwPipeMode, nMaxInstances,
                                        nOutBufferSize, nInBufferSize,
                                        nDefaultTimeOut: int32;
                     lpSecurityAttributes: ptr SECURITY_ATTRIBUTES): Handle @{.
    stdcall, dynlib: "kernel32", importc: "CreateNamedPipeW".@}
@example
proc createNamedPipe*(lpName: WideCString; dwOpenMode, dwPipeMode, nMaxInstances,
                                        nOutBufferSize, nInBufferSize,
                                        nDefaultTimeOut: int32;
                     lpSecurityAttributes: ptr SECURITY_ATTRIBUTES): Handle @{.
    stdcall, dynlib: "kernel32", importc: "CreateNamedPipeW".@}
@end example
  

@item peekNamedPipe
  @findex proc peekNamedPipe*(hNamedPipe: Handle; lpBuffer: pointer = nil;
                   nBufferSize: int32 = 0; lpBytesRead: ptr int32 = nil;
                   lpTotalBytesAvail: ptr int32 = nil;
                   lpBytesLeftThisMessage: ptr int32 = nil): bool @{.stdcall,
    dynlib: "kernel32", importc: "PeekNamedPipe".@}
@example
proc peekNamedPipe*(hNamedPipe: Handle; lpBuffer: pointer = nil;
                   nBufferSize: int32 = 0; lpBytesRead: ptr int32 = nil;
                   lpTotalBytesAvail: ptr int32 = nil;
                   lpBytesLeftThisMessage: ptr int32 = nil): bool @{.stdcall,
    dynlib: "kernel32", importc: "PeekNamedPipe".@}
@end example
  

@item createProcessW
  @findex proc createProcessW*(lpApplicationName, lpCommandLine: WideCString;
                    lpProcessAttributes: ptr SECURITY_ATTRIBUTES;
                    lpThreadAttributes: ptr SECURITY_ATTRIBUTES;
                    bInheritHandles: WINBOOL; dwCreationFlags: int32;
                    lpEnvironment, lpCurrentDirectory: WideCString;
                    lpStartupInfo: var STARTUPINFO;
                    lpProcessInformation: var PROCESS_INFORMATION): WINBOOL @{.
    stdcall, dynlib: "kernel32", importc: "CreateProcessW".@}
@example
proc createProcessW*(lpApplicationName, lpCommandLine: WideCString;
                    lpProcessAttributes: ptr SECURITY_ATTRIBUTES;
                    lpThreadAttributes: ptr SECURITY_ATTRIBUTES;
                    bInheritHandles: WINBOOL; dwCreationFlags: int32;
                    lpEnvironment, lpCurrentDirectory: WideCString;
                    lpStartupInfo: var STARTUPINFO;
                    lpProcessInformation: var PROCESS_INFORMATION): WINBOOL @{.
    stdcall, dynlib: "kernel32", importc: "CreateProcessW".@}
@end example
  

@item suspendThread
  @findex proc suspendThread*(hThread꞉ Handle)꞉ int32 @{.stdcall, dynlib꞉ "kernel32",importc꞉ "SuspendThread".@}
@example
proc suspendThread*(hThread꞉ Handle)꞉ int32 @{.stdcall, dynlib꞉ "kernel32",importc꞉ "SuspendThread".@}
@end example
  

@item resumeThread
  @findex proc resumeThread*(hThread꞉ Handle)꞉ int32 @{.stdcall, dynlib꞉ "kernel32",importc꞉ "ResumeThread".@}
@example
proc resumeThread*(hThread꞉ Handle)꞉ int32 @{.stdcall, dynlib꞉ "kernel32",importc꞉ "ResumeThread".@}
@end example
  

@item waitForSingleObject
  @findex proc waitForSingleObject*(hHandle꞉ Handle; dwMilliseconds꞉ int32)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "WaitForSingleObject".@}
@example
proc waitForSingleObject*(hHandle꞉ Handle; dwMilliseconds꞉ int32)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "WaitForSingleObject".@}
@end example
  

@item terminateProcess
  @findex proc terminateProcess*(hProcess꞉ Handle; uExitCode꞉ int)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "TerminateProcess".@}
@example
proc terminateProcess*(hProcess꞉ Handle; uExitCode꞉ int)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "TerminateProcess".@}
@end example
  

@item getExitCodeProcess
  @findex proc getExitCodeProcess*(hProcess꞉ Handle; lpExitCode꞉ var int32)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetExitCodeProcess".@}
@example
proc getExitCodeProcess*(hProcess꞉ Handle; lpExitCode꞉ var int32)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetExitCodeProcess".@}
@end example
  

@item getStdHandle
  @findex proc getStdHandle*(nStdHandle꞉ int32)꞉ Handle @{.stdcall, dynlib꞉ "kernel32",importc꞉ "GetStdHandle".@}
@example
proc getStdHandle*(nStdHandle꞉ int32)꞉ Handle @{.stdcall, dynlib꞉ "kernel32",importc꞉ "GetStdHandle".@}
@end example
  

@item setStdHandle
  @findex proc setStdHandle*(nStdHandle꞉ int32; hHandle꞉ Handle)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "SetStdHandle".@}
@example
proc setStdHandle*(nStdHandle꞉ int32; hHandle꞉ Handle)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "SetStdHandle".@}
@end example
  

@item flushFileBuffers
  @findex proc flushFileBuffers*(hFile꞉ Handle)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "FlushFileBuffers".@}
@example
proc flushFileBuffers*(hFile꞉ Handle)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "FlushFileBuffers".@}
@end example
  

@item getLastError
  @findex proc getLastError*()꞉ int32 @{.importc꞉ "GetLastError", stdcall, dynlib꞉ "kernel32".@}
@example
proc getLastError*()꞉ int32 @{.importc꞉ "GetLastError", stdcall, dynlib꞉ "kernel32".@}
@end example
  

@item formatMessageW
  @findex proc formatMessageW*(dwFlags: int32; lpSource: pointer;
                    dwMessageId, dwLanguageId: int32; lpBuffer: pointer;
                    nSize: int32; Arguments: pointer): int32 @{.
    importc: "FormatMessageW", stdcall, dynlib: "kernel32".@}
@example
proc formatMessageW*(dwFlags: int32; lpSource: pointer;
                    dwMessageId, dwLanguageId: int32; lpBuffer: pointer;
                    nSize: int32; Arguments: pointer): int32 @{.
    importc: "FormatMessageW", stdcall, dynlib: "kernel32".@}
@end example
  

@item localFree
  @findex proc localFree*(p꞉ pointer) @{.importc꞉ "LocalFree", stdcall, dynlib꞉ "kernel32".@}
@example
proc localFree*(p꞉ pointer) @{.importc꞉ "LocalFree", stdcall, dynlib꞉ "kernel32".@}
@end example
  

@item getCurrentDirectoryW
  @findex proc getCurrentDirectoryW*(nBufferLength꞉ int32; lpBuffer꞉ WideCString)꞉ int32 @{.importc꞉ "GetCurrentDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@example
proc getCurrentDirectoryW*(nBufferLength꞉ int32; lpBuffer꞉ WideCString)꞉ int32 @{.importc꞉ "GetCurrentDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item setCurrentDirectoryW
  @findex proc setCurrentDirectoryW*(lpPathName꞉ WideCString)꞉ int32 @{.importc꞉ "SetCurrentDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@example
proc setCurrentDirectoryW*(lpPathName꞉ WideCString)꞉ int32 @{.importc꞉ "SetCurrentDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item createDirectoryW
  @findex proc createDirectoryW*(pathName꞉ WideCString; security꞉ pointer = nil)꞉ int32 @{.importc꞉ "CreateDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@example
proc createDirectoryW*(pathName꞉ WideCString; security꞉ pointer = nil)꞉ int32 @{.importc꞉ "CreateDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item removeDirectoryW
  @findex proc removeDirectoryW*(lpPathName꞉ WideCString)꞉ int32 @{.importc꞉ "RemoveDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@example
proc removeDirectoryW*(lpPathName꞉ WideCString)꞉ int32 @{.importc꞉ "RemoveDirectoryW", dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item setEnvironmentVariableW
  @findex proc setEnvironmentVariableW*(lpName, lpValue꞉ WideCString)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "SetEnvironmentVariableW".@}
@example
proc setEnvironmentVariableW*(lpName, lpValue꞉ WideCString)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "SetEnvironmentVariableW".@}
@end example
  

@item getModuleFileNameW
  @findex proc getModuleFileNameW*(handle꞉ Handle; buf꞉ WideCString; size꞉ int32)꞉ int32 @{.importc꞉ "GetModuleFileNameW", dynlib꞉ "kernel32", stdcall.@}
@example
proc getModuleFileNameW*(handle꞉ Handle; buf꞉ WideCString; size꞉ int32)꞉ int32 @{.importc꞉ "GetModuleFileNameW", dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item createSymbolicLinkW
  @findex proc createSymbolicLinkW*(lpSymlinkFileName, lpTargetFileName꞉ WideCString;flags꞉ DWORD)꞉ int32 @{.importc꞉ "CreateSymbolicLinkW",dynlib꞉ "kernel32", stdcall.@}
@example
proc createSymbolicLinkW*(lpSymlinkFileName, lpTargetFileName꞉ WideCString;flags꞉ DWORD)꞉ int32 @{.importc꞉ "CreateSymbolicLinkW",dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item createHardLinkW
  @findex proc createHardLinkW*(lpFileName, lpExistingFileName꞉ WideCString;security꞉ pointer = nil)꞉ int32 @{.importc꞉ "CreateHardLinkW",dynlib꞉ "kernel32", stdcall.@}
@example
proc createHardLinkW*(lpFileName, lpExistingFileName꞉ WideCString;security꞉ pointer = nil)꞉ int32 @{.importc꞉ "CreateHardLinkW",dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item findFirstFileW
  @findex proc findFirstFileW*(lpFileName꞉ WideCString; lpFindFileData꞉ var WIN32_FIND_DATA)꞉ Handle @{.stdcall, dynlib꞉ "kernel32", importc꞉ "FindFirstFileW".@}
@example
proc findFirstFileW*(lpFileName꞉ WideCString; lpFindFileData꞉ var WIN32_FIND_DATA)꞉ Handle @{.stdcall, dynlib꞉ "kernel32", importc꞉ "FindFirstFileW".@}
@end example
  

@item findNextFileW
  @findex proc findNextFileW*(hFindFile꞉ Handle; lpFindFileData꞉ var WIN32_FIND_DATA)꞉ int32 @{.stdcall, dynlib꞉ "kernel32", importc꞉ "FindNextFileW".@}
@example
proc findNextFileW*(hFindFile꞉ Handle; lpFindFileData꞉ var WIN32_FIND_DATA)꞉ int32 @{.stdcall, dynlib꞉ "kernel32", importc꞉ "FindNextFileW".@}
@end example
  

@item findClose
  @findex proc findClose*(hFindFile꞉ Handle) @{.stdcall, dynlib꞉ "kernel32", importc꞉ "FindClose".@}
@example
proc findClose*(hFindFile꞉ Handle) @{.stdcall, dynlib꞉ "kernel32", importc꞉ "FindClose".@}
@end example
  

@item getFullPathNameW
  @findex proc getFullPathNameW*(lpFileName꞉ WideCString; nBufferLength꞉ int32;lpBuffer꞉ WideCString; lpFilePart꞉ var WideCString)꞉ int32 @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetFullPathNameW".@}
@example
proc getFullPathNameW*(lpFileName꞉ WideCString; nBufferLength꞉ int32;lpBuffer꞉ WideCString; lpFilePart꞉ var WideCString)꞉ int32 @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetFullPathNameW".@}
@end example
  

@item getFileAttributesW
  @findex proc getFileAttributesW*(lpFileName꞉ WideCString)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetFileAttributesW".@}
@example
proc getFileAttributesW*(lpFileName꞉ WideCString)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetFileAttributesW".@}
@end example
  

@item setFileAttributesW
  @findex proc setFileAttributesW*(lpFileName꞉ WideCString; dwFileAttributes꞉ int32)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "SetFileAttributesW".@}
@example
proc setFileAttributesW*(lpFileName꞉ WideCString; dwFileAttributes꞉ int32)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "SetFileAttributesW".@}
@end example
  

@item copyFileW
  @findex proc copyFileW*(lpExistingFileName, lpNewFileName꞉ WideCString; bFailIfExists꞉ cint)꞉ cint @{.importc꞉ "CopyFileW", stdcall, dynlib꞉ "kernel32".@}
@example
proc copyFileW*(lpExistingFileName, lpNewFileName꞉ WideCString; bFailIfExists꞉ cint)꞉ cint @{.importc꞉ "CopyFileW", stdcall, dynlib꞉ "kernel32".@}
@end example
  

@item moveFileW
  @findex proc moveFileW*(lpExistingFileName, lpNewFileName꞉ WideCString; bFailIfExists꞉ cint)꞉ cint @{.importc꞉ "MoveFileW", stdcall, dynlib꞉ "kernel32".@}
@example
proc moveFileW*(lpExistingFileName, lpNewFileName꞉ WideCString; bFailIfExists꞉ cint)꞉ cint @{.importc꞉ "MoveFileW", stdcall, dynlib꞉ "kernel32".@}
@end example
  

@item getEnvironmentStringsW
  @findex proc getEnvironmentStringsW*()꞉ WideCString @{.stdcall, dynlib꞉ "kernel32",importc꞉ "GetEnvironmentStringsW".@}
@example
proc getEnvironmentStringsW*()꞉ WideCString @{.stdcall, dynlib꞉ "kernel32",importc꞉ "GetEnvironmentStringsW".@}
@end example
  

@item freeEnvironmentStringsW
  @findex proc freeEnvironmentStringsW*(para1꞉ WideCString)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "FreeEnvironmentStringsW".@}
@example
proc freeEnvironmentStringsW*(para1꞉ WideCString)꞉ int32 @{.stdcall,dynlib꞉ "kernel32", importc꞉ "FreeEnvironmentStringsW".@}
@end example
  

@item getCommandLineW
  @findex proc getCommandLineW*()꞉ WideCString @{.importc꞉ "GetCommandLineW", stdcall,dynlib꞉ "kernel32".@}
@example
proc getCommandLineW*()꞉ WideCString @{.importc꞉ "GetCommandLineW", stdcall,dynlib꞉ "kernel32".@}
@end example
  

@item rdFileTime
  @findex proc rdFileTime*(f꞉ FILETIME)꞉ int64
@example
proc rdFileTime*(f꞉ FILETIME)꞉ int64
@end example
  

@item rdFileSize
  @findex proc rdFileSize*(f꞉ WIN32_FIND_DATA)꞉ int64
@example
proc rdFileSize*(f꞉ WIN32_FIND_DATA)꞉ int64
@end example
  

@item getSystemTimeAsFileTime
  @findex proc getSystemTimeAsFileTime*(lpSystemTimeAsFileTime꞉ var FILETIME) @{.importc꞉ "GetSystemTimeAsFileTime", dynlib꞉ "kernel32", stdcall.@}
@example
proc getSystemTimeAsFileTime*(lpSystemTimeAsFileTime꞉ var FILETIME) @{.importc꞉ "GetSystemTimeAsFileTime", dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item sleep
  @findex proc sleep*(dwMilliseconds꞉ int32) @{.stdcall, dynlib꞉ "kernel32", importc꞉ "Sleep".@}
@example
proc sleep*(dwMilliseconds꞉ int32) @{.stdcall, dynlib꞉ "kernel32", importc꞉ "Sleep".@}
@end example
  

@item shellExecuteW
  @findex proc shellExecuteW*(HWND: Handle;
                   lpOperation, lpFile, lpParameters, lpDirectory: WideCString;
                   nShowCmd: int32): Handle @{.stdcall, dynlib: "shell32.dll",
    importc: "ShellExecuteW".@}
@example
proc shellExecuteW*(HWND: Handle;
                   lpOperation, lpFile, lpParameters, lpDirectory: WideCString;
                   nShowCmd: int32): Handle @{.stdcall, dynlib: "shell32.dll",
    importc: "ShellExecuteW".@}
@end example
  

@item getFileInformationByHandle
  @findex proc getFileInformationByHandle*(hFile꞉ Handle; lpFileInformation꞉ ptr BY_HANDLE_FILE_INFORMATION)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetFileInformationByHandle".@}
@example
proc getFileInformationByHandle*(hFile꞉ Handle; lpFileInformation꞉ ptr BY_HANDLE_FILE_INFORMATION)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetFileInformationByHandle".@}
@end example
  

@item wsaGetLastError
  @findex proc wsaGetLastError*()꞉ cint @{.importc꞉ "WSAGetLastError", dynlib꞉ ws2dll.@}
@example
proc wsaGetLastError*()꞉ cint @{.importc꞉ "WSAGetLastError", dynlib꞉ ws2dll.@}
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ SocketHandle)꞉ bool @{.borrow.@}
@example
proc `==`*(x, y꞉ SocketHandle)꞉ bool @{.borrow.@}
@end example
  

@item getservbyname
  @findex proc getservbyname*(name, proto꞉ cstring)꞉ ptr Servent @{.stdcall,importc꞉ "getservbyname", dynlib꞉ ws2dll.@}
@example
proc getservbyname*(name, proto꞉ cstring)꞉ ptr Servent @{.stdcall,importc꞉ "getservbyname", dynlib꞉ ws2dll.@}
@end example
  

@item getservbyport
  @findex proc getservbyport*(port꞉ cint; proto꞉ cstring)꞉ ptr Servent @{.stdcall,importc꞉ "getservbyport", dynlib꞉ ws2dll.@}
@example
proc getservbyport*(port꞉ cint; proto꞉ cstring)꞉ ptr Servent @{.stdcall,importc꞉ "getservbyport", dynlib꞉ ws2dll.@}
@end example
  

@item gethostbyaddr
  @findex proc gethostbyaddr*(ip꞉ ptr InAddr; len꞉ cuint; theType꞉ cint)꞉ ptr Hostent @{.stdcall,importc꞉ "gethostbyaddr", dynlib꞉ ws2dll.@}
@example
proc gethostbyaddr*(ip꞉ ptr InAddr; len꞉ cuint; theType꞉ cint)꞉ ptr Hostent @{.stdcall,importc꞉ "gethostbyaddr", dynlib꞉ ws2dll.@}
@end example
  

@item gethostbyname
  @findex proc gethostbyname*(name꞉ cstring)꞉ ptr Hostent @{.stdcall, importc꞉ "gethostbyname",dynlib꞉ ws2dll.@}
@example
proc gethostbyname*(name꞉ cstring)꞉ ptr Hostent @{.stdcall, importc꞉ "gethostbyname",dynlib꞉ ws2dll.@}
@end example
  

@item socket
  @findex proc socket*(af, typ, protocol꞉ cint)꞉ SocketHandle @{.stdcall, importc꞉ "socket",dynlib꞉ ws2dll.@}
@example
proc socket*(af, typ, protocol꞉ cint)꞉ SocketHandle @{.stdcall, importc꞉ "socket",dynlib꞉ ws2dll.@}
@end example
  

@item closesocket
  @findex proc closesocket*(s꞉ SocketHandle)꞉ cint @{.stdcall, importc꞉ "closesocket",dynlib꞉ ws2dll.@}
@example
proc closesocket*(s꞉ SocketHandle)꞉ cint @{.stdcall, importc꞉ "closesocket",dynlib꞉ ws2dll.@}
@end example
  

@item accept
  @findex proc accept*(s꞉ SocketHandle; a꞉ ptr SockAddr; addrlen꞉ ptr SockLen)꞉ SocketHandle @{.stdcall, importc꞉ "accept", dynlib꞉ ws2dll.@}
@example
proc accept*(s꞉ SocketHandle; a꞉ ptr SockAddr; addrlen꞉ ptr SockLen)꞉ SocketHandle @{.stdcall, importc꞉ "accept", dynlib꞉ ws2dll.@}
@end example
  

@item bindSocket
  @findex proc bindSocket*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ SockLen)꞉ cint @{.stdcall,importc꞉ "bind", dynlib꞉ ws2dll.@}
@example
proc bindSocket*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ SockLen)꞉ cint @{.stdcall,importc꞉ "bind", dynlib꞉ ws2dll.@}
@end example
  

@item connect
  @findex proc connect*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ SockLen)꞉ cint @{.stdcall,importc꞉ "connect", dynlib꞉ ws2dll.@}
@example
proc connect*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ SockLen)꞉ cint @{.stdcall,importc꞉ "connect", dynlib꞉ ws2dll.@}
@end example
  

@item getsockname
  @findex proc getsockname*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ ptr SockLen)꞉ cint @{.stdcall, importc꞉ "getsockname", dynlib꞉ ws2dll.@}
@example
proc getsockname*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ ptr SockLen)꞉ cint @{.stdcall, importc꞉ "getsockname", dynlib꞉ ws2dll.@}
@end example
  

@item getpeername
  @findex proc getpeername*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ ptr SockLen)꞉ cint @{.stdcall, importc, dynlib꞉ ws2dll.@}
@example
proc getpeername*(s꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ ptr SockLen)꞉ cint @{.stdcall, importc, dynlib꞉ ws2dll.@}
@end example
  

@item getsockopt
  @findex proc getsockopt*(s꞉ SocketHandle; level, optname꞉ cint; optval꞉ pointer;optlen꞉ ptr SockLen)꞉ cint @{.stdcall, importc꞉ "getsockopt",dynlib꞉ ws2dll.@}
@example
proc getsockopt*(s꞉ SocketHandle; level, optname꞉ cint; optval꞉ pointer;optlen꞉ ptr SockLen)꞉ cint @{.stdcall, importc꞉ "getsockopt",dynlib꞉ ws2dll.@}
@end example
  

@item setsockopt
  @findex proc setsockopt*(s꞉ SocketHandle; level, optname꞉ cint; optval꞉ pointer; optlen꞉ SockLen)꞉ cint @{.stdcall, importc꞉ "setsockopt", dynlib꞉ ws2dll.@}
@example
proc setsockopt*(s꞉ SocketHandle; level, optname꞉ cint; optval꞉ pointer; optlen꞉ SockLen)꞉ cint @{.stdcall, importc꞉ "setsockopt", dynlib꞉ ws2dll.@}
@end example
  

@item listen
  @findex proc listen*(s꞉ SocketHandle; backlog꞉ cint)꞉ cint @{.stdcall, importc꞉ "listen",dynlib꞉ ws2dll.@}
@example
proc listen*(s꞉ SocketHandle; backlog꞉ cint)꞉ cint @{.stdcall, importc꞉ "listen",dynlib꞉ ws2dll.@}
@end example
  

@item recv
  @findex proc recv*(s꞉ SocketHandle; buf꞉ pointer; len, flags꞉ cint)꞉ cint @{.stdcall,importc꞉ "recv", dynlib꞉ ws2dll.@}
@example
proc recv*(s꞉ SocketHandle; buf꞉ pointer; len, flags꞉ cint)꞉ cint @{.stdcall,importc꞉ "recv", dynlib꞉ ws2dll.@}
@end example
  

@item recvfrom
  @findex proc recvfrom*(s꞉ SocketHandle; buf꞉ cstring; len, flags꞉ cint; fromm꞉ ptr SockAddr;fromlen꞉ ptr SockLen)꞉ cint @{.stdcall, importc꞉ "recvfrom",dynlib꞉ ws2dll.@}
@example
proc recvfrom*(s꞉ SocketHandle; buf꞉ cstring; len, flags꞉ cint; fromm꞉ ptr SockAddr;fromlen꞉ ptr SockLen)꞉ cint @{.stdcall, importc꞉ "recvfrom",dynlib꞉ ws2dll.@}
@end example
  

@item select
  @findex proc select*(nfds꞉ cint; readfds, writefds, exceptfds꞉ ptr TFdSet; timeout꞉ ptr Timeval)꞉ cint @{.stdcall, importc꞉ "select", dynlib꞉ ws2dll.@}
@example
proc select*(nfds꞉ cint; readfds, writefds, exceptfds꞉ ptr TFdSet; timeout꞉ ptr Timeval)꞉ cint @{.stdcall, importc꞉ "select", dynlib꞉ ws2dll.@}
@end example
  

@item send
  @findex proc send*(s꞉ SocketHandle; buf꞉ pointer; len, flags꞉ cint)꞉ cint @{.stdcall,importc꞉ "send", dynlib꞉ ws2dll.@}
@example
proc send*(s꞉ SocketHandle; buf꞉ pointer; len, flags꞉ cint)꞉ cint @{.stdcall,importc꞉ "send", dynlib꞉ ws2dll.@}
@end example
  

@item sendto
  @findex proc sendto*(s꞉ SocketHandle; buf꞉ pointer; len, flags꞉ cint; to꞉ ptr SockAddr;tolen꞉ SockLen)꞉ cint @{.stdcall, importc꞉ "sendto", dynlib꞉ ws2dll.@}
@example
proc sendto*(s꞉ SocketHandle; buf꞉ pointer; len, flags꞉ cint; to꞉ ptr SockAddr;tolen꞉ SockLen)꞉ cint @{.stdcall, importc꞉ "sendto", dynlib꞉ ws2dll.@}
@end example
  

@item shutdown
  @findex proc shutdown*(s꞉ SocketHandle; how꞉ cint)꞉ cint @{.stdcall, importc꞉ "shutdown",dynlib꞉ ws2dll.@}
@example
proc shutdown*(s꞉ SocketHandle; how꞉ cint)꞉ cint @{.stdcall, importc꞉ "shutdown",dynlib꞉ ws2dll.@}
@end example
  

@item getnameinfo
  @findex proc getnameinfo*(a1꞉ ptr SockAddr; a2꞉ SockLen; a3꞉ cstring; a4꞉ SockLen; a5꞉ cstring;a6꞉ SockLen; a7꞉ cint)꞉ cint @{.stdcall, importc꞉ "getnameinfo",dynlib꞉ ws2dll.@}
@example
proc getnameinfo*(a1꞉ ptr SockAddr; a2꞉ SockLen; a3꞉ cstring; a4꞉ SockLen; a5꞉ cstring;a6꞉ SockLen; a7꞉ cint)꞉ cint @{.stdcall, importc꞉ "getnameinfo",dynlib꞉ ws2dll.@}
@end example
  

@item inet_addr
  @findex proc inet_addr*(cp꞉ cstring)꞉ int32 @{.stdcall, importc꞉ "inet_addr", dynlib꞉ ws2dll.@}
@example
proc inet_addr*(cp꞉ cstring)꞉ int32 @{.stdcall, importc꞉ "inet_addr", dynlib꞉ ws2dll.@}
@end example
  

@item FD_ISSET
  @findex proc FD_ISSET*(socket꞉ SocketHandle; set꞉ var TFdSet)꞉ cint
@example
proc FD_ISSET*(socket꞉ SocketHandle; set꞉ var TFdSet)꞉ cint
@end example
  

@item FD_SET
  @findex proc FD_SET*(socket꞉ SocketHandle; s꞉ var TFdSet)
@example
proc FD_SET*(socket꞉ SocketHandle; s꞉ var TFdSet)
@end example
  

@item FD_ZERO
  @findex proc FD_ZERO*(s꞉ var TFdSet)
@example
proc FD_ZERO*(s꞉ var TFdSet)
@end example
  

@item wsaStartup
  @findex proc wsaStartup*(wVersionRequired꞉ int16; WSData꞉ ptr WSAData)꞉ cint @{.stdcall,importc꞉ "WSAStartup", dynlib꞉ ws2dll.@}
@example
proc wsaStartup*(wVersionRequired꞉ int16; WSData꞉ ptr WSAData)꞉ cint @{.stdcall,importc꞉ "WSAStartup", dynlib꞉ ws2dll.@}
@end example
  

@item getaddrinfo
  @findex proc getaddrinfo*(nodename, servname꞉ cstring; hints꞉ ptr AddrInfo;res꞉ var ptr AddrInfo)꞉ cint @{.stdcall, importc꞉ "getaddrinfo",dynlib꞉ ws2dll.@}
@example
proc getaddrinfo*(nodename, servname꞉ cstring; hints꞉ ptr AddrInfo;res꞉ var ptr AddrInfo)꞉ cint @{.stdcall, importc꞉ "getaddrinfo",dynlib꞉ ws2dll.@}
@end example
  

@item freeaddrinfo
  @findex proc freeaddrinfo*(ai꞉ ptr AddrInfo) @{.stdcall, importc꞉ "freeaddrinfo", dynlib꞉ ws2dll.@}
@example
proc freeaddrinfo*(ai꞉ ptr AddrInfo) @{.stdcall, importc꞉ "freeaddrinfo", dynlib꞉ ws2dll.@}
@end example
  

@item inet_ntoa
  @findex proc inet_ntoa*(i꞉ InAddr)꞉ cstring @{.stdcall, importc, dynlib꞉ ws2dll.@}
@example
proc inet_ntoa*(i꞉ InAddr)꞉ cstring @{.stdcall, importc, dynlib꞉ ws2dll.@}
@end example
  

@item inet_ntop
  @findex proc inet_ntop*(family꞉ cint; paddr꞉ pointer; pStringBuffer꞉ cstring;stringBufSize꞉ int32)꞉ cstring @{.stdcall, importc, dynlib꞉ ws2dll.@}
@example
proc inet_ntop*(family꞉ cint; paddr꞉ pointer; pStringBuffer꞉ cstring;stringBufSize꞉ int32)꞉ cstring @{.stdcall, importc, dynlib꞉ ws2dll.@}
@end example
  

@item waitForMultipleObjects
  @findex proc waitForMultipleObjects*(nCount꞉ DWORD; lpHandles꞉ PWOHandleArray;bWaitAll꞉ WINBOOL; dwMilliseconds꞉ DWORD)꞉ DWORD @{.stdcall, dynlib꞉ "kernel32", importc꞉ "WaitForMultipleObjects".@}
@example
proc waitForMultipleObjects*(nCount꞉ DWORD; lpHandles꞉ PWOHandleArray;bWaitAll꞉ WINBOOL; dwMilliseconds꞉ DWORD)꞉ DWORD @{.stdcall, dynlib꞉ "kernel32", importc꞉ "WaitForMultipleObjects".@}
@end example
  

@item duplicateHandle
  @findex proc duplicateHandle*(hSourceProcessHandle: HANDLE; hSourceHandle: HANDLE;
                     hTargetProcessHandle: HANDLE; lpTargetHandle: ptr HANDLE;
                     dwDesiredAccess: DWORD; bInheritHandle: WINBOOL;
                     dwOptions: DWORD): WINBOOL @{.stdcall, dynlib: "kernel32",
    importc: "DuplicateHandle".@}
@example
proc duplicateHandle*(hSourceProcessHandle: HANDLE; hSourceHandle: HANDLE;
                     hTargetProcessHandle: HANDLE; lpTargetHandle: ptr HANDLE;
                     dwDesiredAccess: DWORD; bInheritHandle: WINBOOL;
                     dwOptions: DWORD): WINBOOL @{.stdcall, dynlib: "kernel32",
    importc: "DuplicateHandle".@}
@end example
  

@item getCurrentProcess
  @findex proc getCurrentProcess*()꞉ HANDLE @{.stdcall, dynlib꞉ "kernel32",importc꞉ "GetCurrentProcess".@}
@example
proc getCurrentProcess*()꞉ HANDLE @{.stdcall, dynlib꞉ "kernel32",importc꞉ "GetCurrentProcess".@}
@end example
  

@item createFileW
  @findex proc createFileW*(lpFileName: WideCString; dwDesiredAccess, dwShareMode: DWORD;
                 lpSecurityAttributes: pointer;
                 dwCreationDisposition, dwFlagsAndAttributes: DWORD;
                 hTemplateFile: Handle): Handle @{.stdcall, dynlib: "kernel32",
    importc: "CreateFileW".@}
@example
proc createFileW*(lpFileName: WideCString; dwDesiredAccess, dwShareMode: DWORD;
                 lpSecurityAttributes: pointer;
                 dwCreationDisposition, dwFlagsAndAttributes: DWORD;
                 hTemplateFile: Handle): Handle @{.stdcall, dynlib: "kernel32",
    importc: "CreateFileW".@}
@end example
  

@item deleteFileW
  @findex proc deleteFileW*(pathName꞉ WideCString)꞉ int32 @{.importc꞉ "DeleteFileW",dynlib꞉ "kernel32", stdcall.@}
@example
proc deleteFileW*(pathName꞉ WideCString)꞉ int32 @{.importc꞉ "DeleteFileW",dynlib꞉ "kernel32", stdcall.@}
@end example
  

@item setEndOfFile
  @findex proc setEndOfFile*(hFile꞉ Handle)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "SetEndOfFile".@}
@example
proc setEndOfFile*(hFile꞉ Handle)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "SetEndOfFile".@}
@end example
  

@item setFilePointer
  @findex proc setFilePointer*(hFile꞉ Handle; lDistanceToMove꞉ LONG;lpDistanceToMoveHigh꞉ ptr LONG; dwMoveMethod꞉ DWORD)꞉ DWORD @{.stdcall, dynlib꞉ "kernel32", importc꞉ "SetFilePointer".@}
@example
proc setFilePointer*(hFile꞉ Handle; lDistanceToMove꞉ LONG;lpDistanceToMoveHigh꞉ ptr LONG; dwMoveMethod꞉ DWORD)꞉ DWORD @{.stdcall, dynlib꞉ "kernel32", importc꞉ "SetFilePointer".@}
@end example
  

@item getFileSize
  @findex proc getFileSize*(hFile꞉ Handle; lpFileSizeHigh꞉ ptr DWORD)꞉ DWORD @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetFileSize".@}
@example
proc getFileSize*(hFile꞉ Handle; lpFileSizeHigh꞉ ptr DWORD)꞉ DWORD @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetFileSize".@}
@end example
  

@item mapViewOfFileEx
  @findex proc mapViewOfFileEx*(hFileMappingObject: Handle; dwDesiredAccess: DWORD;
                     dwFileOffsetHigh, dwFileOffsetLow: DWORD;
                     dwNumberOfBytesToMap: DWORD; lpBaseAddress: pointer): pointer @{.
    stdcall, dynlib: "kernel32", importc: "MapViewOfFileEx".@}
@example
proc mapViewOfFileEx*(hFileMappingObject: Handle; dwDesiredAccess: DWORD;
                     dwFileOffsetHigh, dwFileOffsetLow: DWORD;
                     dwNumberOfBytesToMap: DWORD; lpBaseAddress: pointer): pointer @{.
    stdcall, dynlib: "kernel32", importc: "MapViewOfFileEx".@}
@end example
  

@item createFileMappingW
  @findex proc createFileMappingW*(hFile: Handle; lpFileMappingAttributes: pointer;
                        flProtect, dwMaximumSizeHigh: DWORD;
                        dwMaximumSizeLow: DWORD; lpName: pointer): Handle @{.stdcall,
    dynlib: "kernel32", importc: "CreateFileMappingW".@}
@example
proc createFileMappingW*(hFile: Handle; lpFileMappingAttributes: pointer;
                        flProtect, dwMaximumSizeHigh: DWORD;
                        dwMaximumSizeLow: DWORD; lpName: pointer): Handle @{.stdcall,
    dynlib: "kernel32", importc: "CreateFileMappingW".@}
@end example
  

@item createFileMappingA
  @findex proc createFileMappingA*(hFile: THANDLE; lpFileMappingAttributes: pointer;
                        flProtect, dwMaximumSizeHigh: DWORD;
                        dwMaximumSizeLow: DWORD; lpName: cstring): THANDLE @{.stdcall,
    dynlib: "kernel32", importc: "CreateFileMappingA".@}
@example
proc createFileMappingA*(hFile: THANDLE; lpFileMappingAttributes: pointer;
                        flProtect, dwMaximumSizeHigh: DWORD;
                        dwMaximumSizeLow: DWORD; lpName: cstring): THANDLE @{.stdcall,
    dynlib: "kernel32", importc: "CreateFileMappingA".@}
@end example
  

@item unmapViewOfFile
  @findex proc unmapViewOfFile*(lpBaseAddress꞉ pointer)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "UnmapViewOfFile".@}
@example
proc unmapViewOfFile*(lpBaseAddress꞉ pointer)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32",importc꞉ "UnmapViewOfFile".@}
@end example
  

@item createIoCompletionPort
  @findex proc createIoCompletionPort*(FileHandle꞉ Handle; ExistingCompletionPort꞉ Handle;CompletionKey꞉ DWORD; NumberOfConcurrentThreads꞉ DWORD)꞉ Handle @{.stdcall, dynlib꞉ "kernel32", importc꞉ "CreateIoCompletionPort".@}
@example
proc createIoCompletionPort*(FileHandle꞉ Handle; ExistingCompletionPort꞉ Handle;CompletionKey꞉ DWORD; NumberOfConcurrentThreads꞉ DWORD)꞉ Handle @{.stdcall, dynlib꞉ "kernel32", importc꞉ "CreateIoCompletionPort".@}
@end example
  

@item getQueuedCompletionStatus
  @findex proc getQueuedCompletionStatus*(CompletionPort: Handle;
                               lpNumberOfBytesTransferred: PDWORD;
                               lpCompletionKey: PULONG;
                               lpOverlapped: ptr POVERLAPPED; dwMilliseconds: DWORD): WINBOOL @{.
    stdcall, dynlib: "kernel32", importc: "GetQueuedCompletionStatus".@}
@example
proc getQueuedCompletionStatus*(CompletionPort: Handle;
                               lpNumberOfBytesTransferred: PDWORD;
                               lpCompletionKey: PULONG;
                               lpOverlapped: ptr POVERLAPPED; dwMilliseconds: DWORD): WINBOOL @{.
    stdcall, dynlib: "kernel32", importc: "GetQueuedCompletionStatus".@}
@end example
  

@item getOverlappedResult
  @findex proc getOverlappedResult*(hFile꞉ Handle; lpOverlapped꞉ OVERLAPPED;lpNumberOfBytesTransferred꞉ var DWORD; bWait꞉ WINBOOL)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetOverlappedResult".@}
@example
proc getOverlappedResult*(hFile꞉ Handle; lpOverlapped꞉ OVERLAPPED;lpNumberOfBytesTransferred꞉ var DWORD; bWait꞉ WINBOOL)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetOverlappedResult".@}
@end example
  

@item WSAIoctl
  @findex proc WSAIoctl*(s: SocketHandle; dwIoControlCode: DWORD; lpvInBuffer: pointer;
              cbInBuffer: DWORD; lpvOutBuffer: pointer; cbOutBuffer: DWORD;
              lpcbBytesReturned: PDWORD; lpOverlapped: POVERLAPPED;
              lpCompletionRoutine: POVERLAPPED_COMPLETION_ROUTINE): cint @{.stdcall,
    importc: "WSAIoctl", dynlib: "Ws2_32.dll".@}
@example
proc WSAIoctl*(s: SocketHandle; dwIoControlCode: DWORD; lpvInBuffer: pointer;
              cbInBuffer: DWORD; lpvOutBuffer: pointer; cbOutBuffer: DWORD;
              lpcbBytesReturned: PDWORD; lpOverlapped: POVERLAPPED;
              lpCompletionRoutine: POVERLAPPED_COMPLETION_ROUTINE): cint @{.stdcall,
    importc: "WSAIoctl", dynlib: "Ws2_32.dll".@}
@end example
  

@item WSARecv
  @findex proc WSARecv*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
             bytesReceived, flags: PDWORD; lpOverlapped: POVERLAPPED;
             completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint @{.stdcall,
    importc: "WSARecv", dynlib: "Ws2_32.dll".@}
@example
proc WSARecv*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
             bytesReceived, flags: PDWORD; lpOverlapped: POVERLAPPED;
             completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint @{.stdcall,
    importc: "WSARecv", dynlib: "Ws2_32.dll".@}
@end example
  

@item WSASend
  @findex proc WSASend*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; bytesSent: PDWORD;
             flags: DWORD; lpOverlapped: POVERLAPPED;
             completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint @{.stdcall,
    importc: "WSASend", dynlib: "Ws2_32.dll".@}
@example
proc WSASend*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; bytesSent: PDWORD;
             flags: DWORD; lpOverlapped: POVERLAPPED;
             completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint @{.stdcall,
    importc: "WSASend", dynlib: "Ws2_32.dll".@}
@end example
  

@item get_osfhandle
  @findex proc get_osfhandle*(fd꞉ FileHandle)꞉ Handle @{.importc꞉ "_get_osfhandle",header꞉ "<io.h>".@}
@example
proc get_osfhandle*(fd꞉ FileHandle)꞉ Handle @{.importc꞉ "_get_osfhandle",header꞉ "<io.h>".@}
@end example
  

@item getSystemTimes
  @findex proc getSystemTimes*(lpIdleTime, lpKernelTime, lpUserTime꞉ var FILETIME)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetSystemTimes".@}
@example
proc getSystemTimes*(lpIdleTime, lpKernelTime, lpUserTime꞉ var FILETIME)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "GetSystemTimes".@}
@end example
  

@item getProcessTimes
  @findex proc getProcessTimes*(hProcess꞉ Handle; lpCreationTime, lpExitTime, lpKernelTime,lpUserTime꞉ var FILETIME)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetProcessTimes".@}
@example
proc getProcessTimes*(hProcess꞉ Handle; lpCreationTime, lpExitTime, lpKernelTime,lpUserTime꞉ var FILETIME)꞉ WINBOOL @{.stdcall,dynlib꞉ "kernel32", importc꞉ "GetProcessTimes".@}
@end example
  
@end itemize

@chapter Templates

@itemize


@item WSAIORW
  @findex template WSAIORW*(x, y)꞉ expr
@example
template WSAIORW*(x, y)꞉ expr
@end example
  
@end itemize





@node /posix/epoll, /posix/posix , /windows/winlean, Top
@chapter Constant variables

@itemize


@item EPOLLET
  @vindex EPOLLET* = 1 shl 31
@example
EPOLLET* = 1 shl 31
@end example
  

@item EPOLL_CTL_MOD
  @vindex EPOLL_CTL_MOD* = 3
@example
EPOLL_CTL_MOD* = 3
@end example
  
@end itemize



@chapter Types

@itemize


@item epoll_event
  @tindex epoll_event* @{.importc: "struct epoll_event", header: "<sys/epoll.h>", pure, final.@} = object
  events*: uint32
  data*: epoll_data

@example
epoll_event* @{.importc: "struct epoll_event", header: "<sys/epoll.h>", pure, final.@} = object
  events*: uint32
  data*: epoll_data

@end example
  
@end itemize

@chapter Procedures

@itemize


@item epoll_create
  @findex proc epoll_create*(size꞉ cint)꞉ cint @{.importc꞉ "epoll_create",header꞉ "<sys/epoll.h>".@}
@example
proc epoll_create*(size꞉ cint)꞉ cint @{.importc꞉ "epoll_create",header꞉ "<sys/epoll.h>".@}
@end example
  @itemize 
 @item Creates an epoll instance.  Returns an fd for the new instance.: The "size" parameter is a hint specifying the number of file descriptors to be associated with the new instance.  The fd returned by epoll_create() should be closed with close().
 
@end itemize

@item epoll_create1
  @findex proc epoll_create1*(flags꞉ cint)꞉ cint @{.importc꞉ "epoll_create1",header꞉ "<sys/epoll.h>".@}
@example
proc epoll_create1*(flags꞉ cint)꞉ cint @{.importc꞉ "epoll_create1",header꞉ "<sys/epoll.h>".@}
@end example
  @itemize 
 @item Same as epoll_create but with an FLAGS parameter.  The unused SIZE: parameter has been dropped.
 
@end itemize

@item epoll_ctl
  @findex proc epoll_ctl*(epfd꞉ cint; op꞉ cint; fd꞉ cint | SocketHandle; event꞉ ptr epoll_event)꞉ cint @{.importc꞉ "epoll_ctl", header꞉ "<sys/epoll.h>".@}
@example
proc epoll_ctl*(epfd꞉ cint; op꞉ cint; fd꞉ cint | SocketHandle; event꞉ ptr epoll_event)꞉ cint @{.importc꞉ "epoll_ctl", header꞉ "<sys/epoll.h>".@}
@end example
  @itemize 
 @item Manipulate an epoll instance "epfd". Returns 0 in case of success,: 
@itemize 
 @item -1 in case of error ( the "errno" variable will contain the:  
 
 
@end itemize
specific error code ) The "op" parameter is one of the EPOLL_CTL_* constants defined above. The "fd" parameter is the target of the operation. The "event" parameter describes which events the caller is interested in and any associated user data.


 
@end itemize

@item epoll_wait
  @findex proc epoll_wait*(epfd꞉ cint; events꞉ ptr epoll_event; maxevents꞉ cint; timeout꞉ cint)꞉ cint @{.importc꞉ "epoll_wait", header꞉ "<sys/epoll.h>".@}
@example
proc epoll_wait*(epfd꞉ cint; events꞉ ptr epoll_event; maxevents꞉ cint; timeout꞉ cint)꞉ cint @{.importc꞉ "epoll_wait", header꞉ "<sys/epoll.h>".@}
@end example
  @itemize 
 @item Wait for events on an epoll instance "epfd". Returns the number of: triggered events returned in "events" buffer. Or -1 in case of error with the "errno" variable set to the specific error code. The "events" parameter is a buffer that will contain triggered events. The "maxevents" is the maximum number of events to be returned ( usually size of "events" ). The "timeout" parameter specifies the maximum wait time in milliseconds (-1 == infinite).

This function is a cancellation point and therefore not marked with __THROW.


 
@end itemize
@end itemize






@node /posix/posix, /posix/inotify , /posix/epoll, Top
@chapter Constant variables

@itemize


@item DT_WHT
  @vindex DT_WHT* = 14
@example
DT_WHT* = 14
@end example
  

@item MSG_NOSIGNAL
  @vindex MSG_NOSIGNAL* = 0'i32
@example
MSG_NOSIGNAL* = 0'i32
@end example
  

@item POSIX_SPAWN_USEVFORK
  @vindex POSIX_SPAWN_USEVFORK* = cint(0x00000040)
@example
POSIX_SPAWN_USEVFORK* = cint(0x00000040)
@end example
  

@item INVALID_SOCKET
  @vindex INVALID_SOCKET* = SocketHandle(- 1)
@example
INVALID_SOCKET* = SocketHandle(- 1)
@end example
  
@end itemize


@chapter Variables

@itemize


@item timezone
  @vindex timezone* @{.importc, header꞉ "<time.h>".@}꞉ int
@example
timezone* @{.importc, header꞉ "<time.h>".@}꞉ int
@end example
  

@item LIO_WRITE
  @vindex LIO_WRITE* @{.importc, header꞉ "<aio.h>".@}꞉ cint
@example
LIO_WRITE* @{.importc, header꞉ "<aio.h>".@}꞉ cint
@end example
  A lio_listio() element operation option requesting a write.

@item POSIX_FADV_NOREUSE
  @vindex POSIX_FADV_NOREUSE* @{.importc, header꞉ "<fcntl.h>".@}꞉ cint
@example
POSIX_FADV_NOREUSE* @{.importc, header꞉ "<fcntl.h>".@}꞉ cint
@end example
  The application expects to access the specified data once and then not reuse it thereafter.

@item MM_NOCON
  @vindex MM_NOCON* @{.importc, header꞉ "<fmtmsg.h>".@}꞉ cint
@example
MM_NOCON* @{.importc, header꞉ "<fmtmsg.h>".@}꞉ cint
@end example
  The function was unable to generate a console message, but otherwise succeeded.

@item MSG_OOB
  @vindex MSG_OOB* @{.importc, header꞉ "<sys/socket.h>".@}꞉ cint
@example
MSG_OOB* @{.importc, header꞉ "<sys/socket.h>".@}꞉ cint
@end example
  Out-of-band data.

@item MAP_POPULATE
  @vindex MAP_POPULATE* @{.importc, header꞉ "<sys/mman.h>".@}꞉ cint
@example
MAP_POPULATE* @{.importc, header꞉ "<sys/mman.h>".@}꞉ cint
@end example
  Populate (prefault) page tables for a mapping.

@item SO_NOSIGPIPE
  @vindex SO_NOSIGPIPE* @{.importc, header꞉ "<sys/socket.h>".@}꞉ cint
@example
SO_NOSIGPIPE* @{.importc, header꞉ "<sys/socket.h>".@}꞉ cint
@end example
  

@item POLLNVAL
  @vindex POLLNVAL* @{.importc, header꞉ "<poll.h>".@}꞉ cshort
@example
POLLNVAL* @{.importc, header꞉ "<poll.h>".@}꞉ cshort
@end example
  Invalid fd member (revents only).

@item POSIX_SPAWN_SETSIGMASK
  @vindex POSIX_SPAWN_SETSIGMASK* @{.importc, header꞉ "<spawn.h>".@}꞉ cint
@example
POSIX_SPAWN_SETSIGMASK* @{.importc, header꞉ "<spawn.h>".@}꞉ cint
@end example
  

@item in6addr_loopback
  @vindex in6addr_loopback* @{.importc, header꞉ "<netinet/in.h>".@}꞉ In6Addr
@example
in6addr_loopback* @{.importc, header꞉ "<netinet/in.h>".@}꞉ In6Addr
@end example
  
@end itemize

@chapter Types

@itemize


@item DIR
  @tindex DIR* @{.importc꞉ "DIR", header꞉ "<dirent.h>", incompleteStruct.@} = object
@example
DIR* @{.importc꞉ "DIR", header꞉ "<dirent.h>", incompleteStruct.@} = object
@end example
  A type representing a directory stream.

@item SocketHandle
  @tindex SocketHandle* = distinct cint
@example
SocketHandle* = distinct cint
@end example
  

@item Ucontext
  @tindex Ucontext* @{.importc: "ucontext_t", header: "<ucontext.h>", final, pure.@} = object
  uc_link*: ptr Ucontext        ## Pointer to the context that is resumed
                      ## when this context returns.
  uc_sigmask*: Sigset          ## The set of signals that are blocked when this
                    ## context is active.
  uc_stack*: Stack             ## The stack used by this context.
  uc_mcontext*: Mcontext       ## A machine-specific representation of the saved
                       ## context.
  
@example
Ucontext* @{.importc: "ucontext_t", header: "<ucontext.h>", final, pure.@} = object
  uc_link*: ptr Ucontext        ## Pointer to the context that is resumed
                      ## when this context returns.
  uc_sigmask*: Sigset          ## The set of signals that are blocked when this
                    ## context is active.
  uc_stack*: Stack             ## The stack used by this context.
  uc_mcontext*: Mcontext       ## A machine-specific representation of the saved
                       ## context.
  
@end example
  ucontext_t

@item Taiocb
  @tindex Taiocb* @{.importc: "struct aiocb", header: "<aio.h>", final, pure.@} = object
  aio_fildes*: cint            ## File descriptor.
  aio_offset*: Off             ## File offset.
  aio_buf*: pointer            ## Location of buffer.
  aio_nbytes*: int             ## Length of transfer.
  aio_reqprio*: cint           ## Request priority offset.
  aio_sigevent*: SigEvent      ## Signal number and value.
  aio_lio_opcode: cint         ## Operation to be performed.
  
@example
Taiocb* @{.importc: "struct aiocb", header: "<aio.h>", final, pure.@} = object
  aio_fildes*: cint            ## File descriptor.
  aio_offset*: Off             ## File offset.
  aio_buf*: pointer            ## Location of buffer.
  aio_nbytes*: int             ## Length of transfer.
  aio_reqprio*: cint           ## Request priority offset.
  aio_sigevent*: SigEvent      ## Signal number and value.
  aio_lio_opcode: cint         ## Operation to be performed.
  
@end example
  struct aiocb

@item Tposix_spawn_file_actions
  @tindex Tposix_spawn_file_actions* @{.importc꞉ "posix_spawn_file_actions_t",header꞉ "<spawn.h>", final, pure.@} = object
@example
Tposix_spawn_file_actions* @{.importc꞉ "posix_spawn_file_actions_t",header꞉ "<spawn.h>", final, pure.@} = object
@end example
  

@item Tnfds
  @tindex Tnfds* @{.importc꞉ "nfds_t", header꞉ "<poll.h>".@} = cint
@example
Tnfds* @{.importc꞉ "nfds_t", header꞉ "<poll.h>".@} = cint
@end example
  
@end itemize

@chapter Procedures

@itemize


@item WIFCONTINUED
  @findex proc WIFCONTINUED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@example
proc WIFCONTINUED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@end example
  True if child has been continued.

@item WIFEXITED
  @findex proc WIFEXITED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@example
proc WIFEXITED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@end example
  True if child exited normally.

@item WIFSIGNALED
  @findex proc WIFSIGNALED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@example
proc WIFSIGNALED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@end example
  True if child exited due to uncaught signal.

@item WIFSTOPPED
  @findex proc WIFSTOPPED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@example
proc WIFSTOPPED*(s꞉ cint)꞉ bool @{.importc, header꞉ "<sys/wait.h>".@}
@end example
  True if child is currently stopped.

@item aio_cancel
  @findex proc aio_cancel*(a1꞉ cint; a2꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@example
proc aio_cancel*(a1꞉ cint; a2꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@end example
  

@item aio_error
  @findex proc aio_error*(a1꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@example
proc aio_error*(a1꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@end example
  

@item aio_fsync
  @findex proc aio_fsync*(a1꞉ cint; a2꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@example
proc aio_fsync*(a1꞉ cint; a2꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@end example
  

@item aio_read
  @findex proc aio_read*(a1꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@example
proc aio_read*(a1꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@end example
  

@item aio_return
  @findex proc aio_return*(a1꞉ ptr Taiocb)꞉ int @{.importc, header꞉ "<aio.h>".@}
@example
proc aio_return*(a1꞉ ptr Taiocb)꞉ int @{.importc, header꞉ "<aio.h>".@}
@end example
  

@item aio_suspend
  @findex proc aio_suspend*(a1꞉ ptr ptr Taiocb; a2꞉ cint; a3꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<aio.h>".@}
@example
proc aio_suspend*(a1꞉ ptr ptr Taiocb; a2꞉ cint; a3꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<aio.h>".@}
@end example
  

@item aio_write
  @findex proc aio_write*(a1꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@example
proc aio_write*(a1꞉ ptr Taiocb)꞉ cint @{.importc, header꞉ "<aio.h>".@}
@end example
  

@item lio_listio
  @findex proc lio_listio*(a1꞉ cint; a2꞉ ptr ptr Taiocb; a3꞉ cint; a4꞉ ptr SigEvent)꞉ cint @{.importc,header꞉ "<aio.h>".@}
@example
proc lio_listio*(a1꞉ cint; a2꞉ ptr ptr Taiocb; a3꞉ cint; a4꞉ ptr SigEvent)꞉ cint @{.importc,header꞉ "<aio.h>".@}
@end example
  

@item htonl
  @findex proc htonl*(a1꞉ int32)꞉ int32 @{.importc, header꞉ "<arpa/inet.h>".@}
@example
proc htonl*(a1꞉ int32)꞉ int32 @{.importc, header꞉ "<arpa/inet.h>".@}
@end example
  

@item htons
  @findex proc htons*(a1꞉ int16)꞉ int16 @{.importc, header꞉ "<arpa/inet.h>".@}
@example
proc htons*(a1꞉ int16)꞉ int16 @{.importc, header꞉ "<arpa/inet.h>".@}
@end example
  

@item ntohl
  @findex proc ntohl*(a1꞉ int32)꞉ int32 @{.importc, header꞉ "<arpa/inet.h>".@}
@example
proc ntohl*(a1꞉ int32)꞉ int32 @{.importc, header꞉ "<arpa/inet.h>".@}
@end example
  

@item ntohs
  @findex proc ntohs*(a1꞉ int16)꞉ int16 @{.importc, header꞉ "<arpa/inet.h>".@}
@example
proc ntohs*(a1꞉ int16)꞉ int16 @{.importc, header꞉ "<arpa/inet.h>".@}
@end example
  

@item inet_addr
  @findex proc inet_addr*(a1꞉ cstring)꞉ InAddrT @{.importc, header꞉ "<arpa/inet.h>".@}
@example
proc inet_addr*(a1꞉ cstring)꞉ InAddrT @{.importc, header꞉ "<arpa/inet.h>".@}
@end example
  

@item inet_ntoa
  @findex proc inet_ntoa*(a1꞉ InAddr)꞉ cstring @{.importc, header꞉ "<arpa/inet.h>".@}
@example
proc inet_ntoa*(a1꞉ InAddr)꞉ cstring @{.importc, header꞉ "<arpa/inet.h>".@}
@end example
  

@item inet_ntop
  @findex proc inet_ntop*(a1꞉ cint; a2꞉ pointer; a3꞉ cstring; a4꞉ int32)꞉ cstring @{.importc꞉ "(char *)$1", header꞉ "<arpa/inet.h>".@}
@example
proc inet_ntop*(a1꞉ cint; a2꞉ pointer; a3꞉ cstring; a4꞉ int32)꞉ cstring @{.importc꞉ "(char *)$1", header꞉ "<arpa/inet.h>".@}
@end example
  

@item inet_pton
  @findex proc inet_pton*(a1꞉ cint; a2꞉ cstring; a3꞉ pointer)꞉ cint @{.importc,header꞉ "<arpa/inet.h>".@}
@example
proc inet_pton*(a1꞉ cint; a2꞉ cstring; a3꞉ pointer)꞉ cint @{.importc,header꞉ "<arpa/inet.h>".@}
@end example
  

@item IN6ADDR_ANY_INIT
  @findex proc IN6ADDR_ANY_INIT*()꞉ In6Addr @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6ADDR_ANY_INIT*()꞉ In6Addr @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  

@item IN6ADDR_LOOPBACK_INIT
  @findex proc IN6ADDR_LOOPBACK_INIT*()꞉ In6Addr @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6ADDR_LOOPBACK_INIT*()꞉ In6Addr @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  

@item closedir
  @findex proc closedir*(a1꞉ ptr DIR)꞉ cint @{.importc, header꞉ "<dirent.h>".@}
@example
proc closedir*(a1꞉ ptr DIR)꞉ cint @{.importc, header꞉ "<dirent.h>".@}
@end example
  

@item opendir
  @findex proc opendir*(a1꞉ cstring)꞉ ptr DIR @{.importc, header꞉ "<dirent.h>".@}
@example
proc opendir*(a1꞉ cstring)꞉ ptr DIR @{.importc, header꞉ "<dirent.h>".@}
@end example
  

@item readdir
  @findex proc readdir*(a1꞉ ptr DIR)꞉ ptr Dirent @{.importc, header꞉ "<dirent.h>".@}
@example
proc readdir*(a1꞉ ptr DIR)꞉ ptr Dirent @{.importc, header꞉ "<dirent.h>".@}
@end example
  

@item readdir_r
  @findex proc readdir_r*(a1꞉ ptr DIR; a2꞉ ptr Dirent; a3꞉ ptr ptr Dirent)꞉ cint @{.importc,header꞉ "<dirent.h>".@}
@example
proc readdir_r*(a1꞉ ptr DIR; a2꞉ ptr Dirent; a3꞉ ptr ptr Dirent)꞉ cint @{.importc,header꞉ "<dirent.h>".@}
@end example
  

@item rewinddir
  @findex proc rewinddir*(a1꞉ ptr DIR) @{.importc, header꞉ "<dirent.h>".@}
@example
proc rewinddir*(a1꞉ ptr DIR) @{.importc, header꞉ "<dirent.h>".@}
@end example
  

@item seekdir
  @findex proc seekdir*(a1꞉ ptr DIR; a2꞉ int) @{.importc, header꞉ "<dirent.h>".@}
@example
proc seekdir*(a1꞉ ptr DIR; a2꞉ int) @{.importc, header꞉ "<dirent.h>".@}
@end example
  

@item telldir
  @findex proc telldir*(a1꞉ ptr DIR)꞉ int @{.importc, header꞉ "<dirent.h>".@}
@example
proc telldir*(a1꞉ ptr DIR)꞉ int @{.importc, header꞉ "<dirent.h>".@}
@end example
  

@item dlclose
  @findex proc dlclose*(a1꞉ pointer)꞉ cint @{.importc, header꞉ "<dlfcn.h>".@}
@example
proc dlclose*(a1꞉ pointer)꞉ cint @{.importc, header꞉ "<dlfcn.h>".@}
@end example
  

@item dlerror
  @findex proc dlerror*()꞉ cstring @{.importc, header꞉ "<dlfcn.h>".@}
@example
proc dlerror*()꞉ cstring @{.importc, header꞉ "<dlfcn.h>".@}
@end example
  

@item dlopen
  @findex proc dlopen*(a1꞉ cstring; a2꞉ cint)꞉ pointer @{.importc, header꞉ "<dlfcn.h>".@}
@example
proc dlopen*(a1꞉ cstring; a2꞉ cint)꞉ pointer @{.importc, header꞉ "<dlfcn.h>".@}
@end example
  

@item dlsym
  @findex proc dlsym*(a1꞉ pointer; a2꞉ cstring)꞉ pointer @{.importc, header꞉ "<dlfcn.h>".@}
@example
proc dlsym*(a1꞉ pointer; a2꞉ cstring)꞉ pointer @{.importc, header꞉ "<dlfcn.h>".@}
@end example
  

@item creat
  @findex proc creat*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<fcntl.h>".@}
@example
proc creat*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<fcntl.h>".@}
@end example
  

@item fcntl
  @findex proc fcntl*(a1꞉ cint | SocketHandle; a2꞉ cint)꞉ cint @{.varargs, importc,header꞉ "<fcntl.h>".@}
@example
proc fcntl*(a1꞉ cint | SocketHandle; a2꞉ cint)꞉ cint @{.varargs, importc,header꞉ "<fcntl.h>".@}
@end example
  

@item open
  @findex proc open*(a1꞉ cstring; a2꞉ cint)꞉ cint @{.varargs, importc, header꞉ "<fcntl.h>".@}
@example
proc open*(a1꞉ cstring; a2꞉ cint)꞉ cint @{.varargs, importc, header꞉ "<fcntl.h>".@}
@end example
  

@item posix_fadvise
  @findex proc posix_fadvise*(a1꞉ cint; a2, a3꞉ Off; a4꞉ cint)꞉ cint @{.importc, header꞉ "<fcntl.h>".@}
@example
proc posix_fadvise*(a1꞉ cint; a2, a3꞉ Off; a4꞉ cint)꞉ cint @{.importc, header꞉ "<fcntl.h>".@}
@end example
  

@item posix_fallocate
  @findex proc posix_fallocate*(a1꞉ cint; a2, a3꞉ Off)꞉ cint @{.importc, header꞉ "<fcntl.h>".@}
@example
proc posix_fallocate*(a1꞉ cint; a2, a3꞉ Off)꞉ cint @{.importc, header꞉ "<fcntl.h>".@}
@end example
  

@item fmtmsg
  @findex proc fmtmsg*(a1꞉ int; a2꞉ cstring; a3꞉ cint; a4, a5, a6꞉ cstring)꞉ cint @{.importc,header꞉ "<fmtmsg.h>".@}
@example
proc fmtmsg*(a1꞉ int; a2꞉ cstring; a3꞉ cint; a4, a5, a6꞉ cstring)꞉ cint @{.importc,header꞉ "<fmtmsg.h>".@}
@end example
  

@item fnmatch
  @findex proc fnmatch*(a1, a2꞉ cstring; a3꞉ cint)꞉ cint @{.importc, header꞉ "<fnmatch.h>".@}
@example
proc fnmatch*(a1, a2꞉ cstring; a3꞉ cint)꞉ cint @{.importc, header꞉ "<fnmatch.h>".@}
@end example
  

@item ftw
  @findex proc ftw*(a1꞉ cstring;a2꞉ proc (x1꞉ cstring; x2꞉ ptr Stat; x3꞉ cint)꞉ cint @{.noconv.@}; a3꞉ cint)꞉ cint @{.importc, header꞉ "<ftw.h>".@}
@example
proc ftw*(a1꞉ cstring;a2꞉ proc (x1꞉ cstring; x2꞉ ptr Stat; x3꞉ cint)꞉ cint @{.noconv.@}; a3꞉ cint)꞉ cint @{.importc, header꞉ "<ftw.h>".@}
@end example
  

@item nftw
  @findex proc nftw*(a1꞉ cstring; a2꞉ proc (x1꞉ cstring; x2꞉ ptr Stat; x3꞉ cint; x4꞉ ptr FTW)꞉ cint @{.noconv.@}; a3꞉ cint; a4꞉ cint)꞉ cint @{.importc, header꞉ "<ftw.h>".@}
@example
proc nftw*(a1꞉ cstring; a2꞉ proc (x1꞉ cstring; x2꞉ ptr Stat; x3꞉ cint; x4꞉ ptr FTW)꞉ cint @{.noconv.@}; a3꞉ cint; a4꞉ cint)꞉ cint @{.importc, header꞉ "<ftw.h>".@}
@end example
  

@item glob
  @findex proc glob*(a1꞉ cstring; a2꞉ cint; a3꞉ proc (x1꞉ cstring; x2꞉ cint)꞉ cint @{.noconv.@};a4꞉ ptr Glob)꞉ cint @{.importc, header꞉ "<glob.h>".@}
@example
proc glob*(a1꞉ cstring; a2꞉ cint; a3꞉ proc (x1꞉ cstring; x2꞉ cint)꞉ cint @{.noconv.@};a4꞉ ptr Glob)꞉ cint @{.importc, header꞉ "<glob.h>".@}
@end example
  

@item globfree
  @findex proc globfree*(a1꞉ ptr Glob) @{.importc, header꞉ "<glob.h>".@}
@example
proc globfree*(a1꞉ ptr Glob) @{.importc, header꞉ "<glob.h>".@}
@end example
  

@item getgrgid
  @findex proc getgrgid*(a1꞉ Gid)꞉ ptr Group @{.importc, header꞉ "<grp.h>".@}
@example
proc getgrgid*(a1꞉ Gid)꞉ ptr Group @{.importc, header꞉ "<grp.h>".@}
@end example
  

@item getgrnam
  @findex proc getgrnam*(a1꞉ cstring)꞉ ptr Group @{.importc, header꞉ "<grp.h>".@}
@example
proc getgrnam*(a1꞉ cstring)꞉ ptr Group @{.importc, header꞉ "<grp.h>".@}
@end example
  

@item getgrgid_r
  @findex proc getgrgid_r*(a1꞉ Gid; a2꞉ ptr Group; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Group)꞉ cint @{.importc, header꞉ "<grp.h>".@}
@example
proc getgrgid_r*(a1꞉ Gid; a2꞉ ptr Group; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Group)꞉ cint @{.importc, header꞉ "<grp.h>".@}
@end example
  

@item getgrnam_r
  @findex proc getgrnam_r*(a1꞉ cstring; a2꞉ ptr Group; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Group)꞉ cint @{.importc, header꞉ "<grp.h>".@}
@example
proc getgrnam_r*(a1꞉ cstring; a2꞉ ptr Group; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Group)꞉ cint @{.importc, header꞉ "<grp.h>".@}
@end example
  

@item getgrent
  @findex proc getgrent*()꞉ ptr Group @{.importc, header꞉ "<grp.h>".@}
@example
proc getgrent*()꞉ ptr Group @{.importc, header꞉ "<grp.h>".@}
@end example
  

@item endgrent
  @findex proc endgrent*() @{.importc, header꞉ "<grp.h>".@}
@example
proc endgrent*() @{.importc, header꞉ "<grp.h>".@}
@end example
  

@item setgrent
  @findex proc setgrent*() @{.importc, header꞉ "<grp.h>".@}
@example
proc setgrent*() @{.importc, header꞉ "<grp.h>".@}
@end example
  

@item iconv_open
  @findex proc iconv_open*(a1, a2꞉ cstring)꞉ Iconv @{.importc, header꞉ "<iconv.h>".@}
@example
proc iconv_open*(a1, a2꞉ cstring)꞉ Iconv @{.importc, header꞉ "<iconv.h>".@}
@end example
  

@item iconv
  @findex proc iconv*(a1꞉ Iconv; a2꞉ var cstring; a3꞉ var int; a4꞉ var cstring; a5꞉ var int)꞉ int @{.importc, header꞉ "<iconv.h>".@}
@example
proc iconv*(a1꞉ Iconv; a2꞉ var cstring; a3꞉ var int; a4꞉ var cstring; a5꞉ var int)꞉ int @{.importc, header꞉ "<iconv.h>".@}
@end example
  

@item iconv_close
  @findex proc iconv_close*(a1꞉ Iconv)꞉ cint @{.importc, header꞉ "<iconv.h>".@}
@example
proc iconv_close*(a1꞉ Iconv)꞉ cint @{.importc, header꞉ "<iconv.h>".@}
@end example
  

@item nl_langinfo
  @findex proc nl_langinfo*(a1꞉ Nl_item)꞉ cstring @{.importc, header꞉ "<langinfo.h>".@}
@example
proc nl_langinfo*(a1꞉ Nl_item)꞉ cstring @{.importc, header꞉ "<langinfo.h>".@}
@end example
  

@item basename
  @findex proc basename*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<libgen.h>".@}
@example
proc basename*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<libgen.h>".@}
@end example
  

@item dirname
  @findex proc dirname*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<libgen.h>".@}
@example
proc dirname*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<libgen.h>".@}
@end example
  

@item localeconv
  @findex proc localeconv*()꞉ ptr Lconv @{.importc, header꞉ "<locale.h>".@}
@example
proc localeconv*()꞉ ptr Lconv @{.importc, header꞉ "<locale.h>".@}
@end example
  

@item setlocale
  @findex proc setlocale*(a1꞉ cint; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<locale.h>".@}
@example
proc setlocale*(a1꞉ cint; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<locale.h>".@}
@end example
  

@item strfmon
  @findex proc strfmon*(a1꞉ cstring; a2꞉ int; a3꞉ cstring)꞉ int @{.varargs, importc,header꞉ "<monetary.h>".@}
@example
proc strfmon*(a1꞉ cstring; a2꞉ int; a3꞉ cstring)꞉ int @{.varargs, importc,header꞉ "<monetary.h>".@}
@end example
  

@item mq_close
  @findex proc mq_close*(a1꞉ Mqd)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@example
proc mq_close*(a1꞉ Mqd)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@end example
  

@item mq_getattr
  @findex proc mq_getattr*(a1꞉ Mqd; a2꞉ ptr MqAttr)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@example
proc mq_getattr*(a1꞉ Mqd; a2꞉ ptr MqAttr)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@end example
  

@item mq_notify
  @findex proc mq_notify*(a1꞉ Mqd; a2꞉ ptr SigEvent)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@example
proc mq_notify*(a1꞉ Mqd; a2꞉ ptr SigEvent)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@end example
  

@item mq_open
  @findex proc mq_open*(a1꞉ cstring; a2꞉ cint)꞉ Mqd @{.varargs, importc, header꞉ "<mqueue.h>".@}
@example
proc mq_open*(a1꞉ cstring; a2꞉ cint)꞉ Mqd @{.varargs, importc, header꞉ "<mqueue.h>".@}
@end example
  

@item mq_receive
  @findex proc mq_receive*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ var int)꞉ int @{.importc,header꞉ "<mqueue.h>".@}
@example
proc mq_receive*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ var int)꞉ int @{.importc,header꞉ "<mqueue.h>".@}
@end example
  

@item mq_send
  @findex proc mq_send*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ int)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@example
proc mq_send*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ int)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@end example
  

@item mq_setattr
  @findex proc mq_setattr*(a1꞉ Mqd; a2, a3꞉ ptr MqAttr)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@example
proc mq_setattr*(a1꞉ Mqd; a2, a3꞉ ptr MqAttr)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@end example
  

@item mq_timedreceive
  @findex proc mq_timedreceive*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ int; a5꞉ ptr Timespec)꞉ int @{.importc, header꞉ "<mqueue.h>".@}
@example
proc mq_timedreceive*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ int; a5꞉ ptr Timespec)꞉ int @{.importc, header꞉ "<mqueue.h>".@}
@end example
  

@item mq_timedsend
  @findex proc mq_timedsend*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ int; a5꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<mqueue.h>".@}
@example
proc mq_timedsend*(a1꞉ Mqd; a2꞉ cstring; a3꞉ int; a4꞉ int; a5꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<mqueue.h>".@}
@end example
  

@item mq_unlink
  @findex proc mq_unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@example
proc mq_unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<mqueue.h>".@}
@end example
  

@item getpwnam
  @findex proc getpwnam*(a1꞉ cstring)꞉ ptr Passwd @{.importc, header꞉ "<pwd.h>".@}
@example
proc getpwnam*(a1꞉ cstring)꞉ ptr Passwd @{.importc, header꞉ "<pwd.h>".@}
@end example
  

@item getpwuid
  @findex proc getpwuid*(a1꞉ Uid)꞉ ptr Passwd @{.importc, header꞉ "<pwd.h>".@}
@example
proc getpwuid*(a1꞉ Uid)꞉ ptr Passwd @{.importc, header꞉ "<pwd.h>".@}
@end example
  

@item getpwnam_r
  @findex proc getpwnam_r*(a1꞉ cstring; a2꞉ ptr Passwd; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Passwd)꞉ cint @{.importc, header꞉ "<pwd.h>".@}
@example
proc getpwnam_r*(a1꞉ cstring; a2꞉ ptr Passwd; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Passwd)꞉ cint @{.importc, header꞉ "<pwd.h>".@}
@end example
  

@item getpwuid_r
  @findex proc getpwuid_r*(a1꞉ Uid; a2꞉ ptr Passwd; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Passwd)꞉ cint @{.importc, header꞉ "<pwd.h>".@}
@example
proc getpwuid_r*(a1꞉ Uid; a2꞉ ptr Passwd; a3꞉ cstring; a4꞉ int; a5꞉ ptr ptr Passwd)꞉ cint @{.importc, header꞉ "<pwd.h>".@}
@end example
  

@item endpwent
  @findex proc endpwent*() @{.importc, header꞉ "<pwd.h>".@}
@example
proc endpwent*() @{.importc, header꞉ "<pwd.h>".@}
@end example
  

@item getpwent
  @findex proc getpwent*()꞉ ptr Passwd @{.importc, header꞉ "<pwd.h>".@}
@example
proc getpwent*()꞉ ptr Passwd @{.importc, header꞉ "<pwd.h>".@}
@end example
  

@item setpwent
  @findex proc setpwent*() @{.importc, header꞉ "<pwd.h>".@}
@example
proc setpwent*() @{.importc, header꞉ "<pwd.h>".@}
@end example
  

@item uname
  @findex proc uname*(a1꞉ var Utsname)꞉ cint @{.importc, header꞉ "<sys/utsname.h>".@}
@example
proc uname*(a1꞉ var Utsname)꞉ cint @{.importc, header꞉ "<sys/utsname.h>".@}
@end example
  

@item pthread_atfork
  @findex proc pthread_atfork*(a1, a2, a3꞉ proc () @{.noconv.@})꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_atfork*(a1, a2, a3꞉ proc () @{.noconv.@})꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_destroy
  @findex proc pthread_attr_destroy*(a1꞉ ptr PthreadAttr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_attr_destroy*(a1꞉ ptr PthreadAttr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getdetachstate
  @findex proc pthread_attr_getdetachstate*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getdetachstate*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getguardsize
  @findex proc pthread_attr_getguardsize*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getguardsize*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getinheritsched
  @findex proc pthread_attr_getinheritsched*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getinheritsched*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getschedparam
  @findex proc pthread_attr_getschedparam*(a1꞉ ptr PthreadAttr; a2꞉ ptr Sched_param)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getschedparam*(a1꞉ ptr PthreadAttr; a2꞉ ptr Sched_param)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getschedpolicy
  @findex proc pthread_attr_getschedpolicy*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getschedpolicy*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getscope
  @findex proc pthread_attr_getscope*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getscope*(a1꞉ ptr PthreadAttr; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getstack
  @findex proc pthread_attr_getstack*(a1꞉ ptr PthreadAttr; a2꞉ var pointer; a3꞉ var int)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getstack*(a1꞉ ptr PthreadAttr; a2꞉ var pointer; a3꞉ var int)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getstackaddr
  @findex proc pthread_attr_getstackaddr*(a1꞉ ptr PthreadAttr; a2꞉ var pointer)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getstackaddr*(a1꞉ ptr PthreadAttr; a2꞉ var pointer)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_getstacksize
  @findex proc pthread_attr_getstacksize*(a1꞉ ptr PthreadAttr; a2꞉ var int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_getstacksize*(a1꞉ ptr PthreadAttr; a2꞉ var int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_init
  @findex proc pthread_attr_init*(a1꞉ ptr PthreadAttr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_attr_init*(a1꞉ ptr PthreadAttr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setdetachstate
  @findex proc pthread_attr_setdetachstate*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setdetachstate*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setguardsize
  @findex proc pthread_attr_setguardsize*(a1꞉ ptr PthreadAttr; a2꞉ int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setguardsize*(a1꞉ ptr PthreadAttr; a2꞉ int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setinheritsched
  @findex proc pthread_attr_setinheritsched*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setinheritsched*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setschedparam
  @findex proc pthread_attr_setschedparam*(a1꞉ ptr PthreadAttr; a2꞉ ptr Sched_param)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setschedparam*(a1꞉ ptr PthreadAttr; a2꞉ ptr Sched_param)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setschedpolicy
  @findex proc pthread_attr_setschedpolicy*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setschedpolicy*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setscope
  @findex proc pthread_attr_setscope*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setscope*(a1꞉ ptr PthreadAttr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setstack
  @findex proc pthread_attr_setstack*(a1꞉ ptr PthreadAttr; a2꞉ pointer; a3꞉ int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setstack*(a1꞉ ptr PthreadAttr; a2꞉ pointer; a3꞉ int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setstackaddr
  @findex proc pthread_attr_setstackaddr*(a1꞉ ptr PthreadAttr; a2꞉ pointer)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setstackaddr*(a1꞉ ptr PthreadAttr; a2꞉ pointer)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_attr_setstacksize
  @findex proc pthread_attr_setstacksize*(a1꞉ ptr PthreadAttr; a2꞉ int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_attr_setstacksize*(a1꞉ ptr PthreadAttr; a2꞉ int)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_barrier_destroy
  @findex proc pthread_barrier_destroy*(a1꞉ ptr Pthread_barrier)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_barrier_destroy*(a1꞉ ptr Pthread_barrier)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_barrier_init
  @findex proc pthread_barrier_init*(a1꞉ ptr Pthread_barrier; a2꞉ ptr Pthread_barrierattr;a3꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_barrier_init*(a1꞉ ptr Pthread_barrier; a2꞉ ptr Pthread_barrierattr;a3꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_barrier_wait
  @findex proc pthread_barrier_wait*(a1꞉ ptr Pthread_barrier)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_barrier_wait*(a1꞉ ptr Pthread_barrier)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_barrierattr_destroy
  @findex proc pthread_barrierattr_destroy*(a1꞉ ptr Pthread_barrierattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_barrierattr_destroy*(a1꞉ ptr Pthread_barrierattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_barrierattr_getpshared
  @findex proc pthread_barrierattr_getpshared*(a1꞉ ptr Pthread_barrierattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_barrierattr_getpshared*(a1꞉ ptr Pthread_barrierattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_barrierattr_init
  @findex proc pthread_barrierattr_init*(a1꞉ ptr Pthread_barrierattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_barrierattr_init*(a1꞉ ptr Pthread_barrierattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_barrierattr_setpshared
  @findex proc pthread_barrierattr_setpshared*(a1꞉ ptr Pthread_barrierattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_barrierattr_setpshared*(a1꞉ ptr Pthread_barrierattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cancel
  @findex proc pthread_cancel*(a1꞉ Pthread)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_cancel*(a1꞉ Pthread)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cleanup_push
  @findex proc pthread_cleanup_push*(a1꞉ proc (x꞉ pointer) @{.noconv.@}; a2꞉ pointer) @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_cleanup_push*(a1꞉ proc (x꞉ pointer) @{.noconv.@}; a2꞉ pointer) @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cleanup_pop
  @findex proc pthread_cleanup_pop*(a1꞉ cint) @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_cleanup_pop*(a1꞉ cint) @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cond_broadcast
  @findex proc pthread_cond_broadcast*(a1꞉ ptr Pthread_cond)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_cond_broadcast*(a1꞉ ptr Pthread_cond)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cond_destroy
  @findex proc pthread_cond_destroy*(a1꞉ ptr Pthread_cond)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_cond_destroy*(a1꞉ ptr Pthread_cond)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cond_init
  @findex proc pthread_cond_init*(a1꞉ ptr Pthread_cond; a2꞉ ptr Pthread_condattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_cond_init*(a1꞉ ptr Pthread_cond; a2꞉ ptr Pthread_condattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cond_signal
  @findex proc pthread_cond_signal*(a1꞉ ptr Pthread_cond)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_cond_signal*(a1꞉ ptr Pthread_cond)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cond_timedwait
  @findex proc pthread_cond_timedwait*(a1꞉ ptr Pthread_cond; a2꞉ ptr Pthread_mutex;a3꞉ ptr Timespec)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_cond_timedwait*(a1꞉ ptr Pthread_cond; a2꞉ ptr Pthread_mutex;a3꞉ ptr Timespec)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_cond_wait
  @findex proc pthread_cond_wait*(a1꞉ ptr Pthread_cond; a2꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_cond_wait*(a1꞉ ptr Pthread_cond; a2꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_condattr_destroy
  @findex proc pthread_condattr_destroy*(a1꞉ ptr Pthread_condattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_condattr_destroy*(a1꞉ ptr Pthread_condattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_condattr_getclock
  @findex proc pthread_condattr_getclock*(a1꞉ ptr Pthread_condattr; a2꞉ var ClockId)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_condattr_getclock*(a1꞉ ptr Pthread_condattr; a2꞉ var ClockId)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_condattr_getpshared
  @findex proc pthread_condattr_getpshared*(a1꞉ ptr Pthread_condattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_condattr_getpshared*(a1꞉ ptr Pthread_condattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_condattr_init
  @findex proc pthread_condattr_init*(a1꞉ ptr Pthread_condattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_condattr_init*(a1꞉ ptr Pthread_condattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_condattr_setclock
  @findex proc pthread_condattr_setclock*(a1꞉ ptr Pthread_condattr; a2꞉ ClockId)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_condattr_setclock*(a1꞉ ptr Pthread_condattr; a2꞉ ClockId)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_condattr_setpshared
  @findex proc pthread_condattr_setpshared*(a1꞉ ptr Pthread_condattr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_condattr_setpshared*(a1꞉ ptr Pthread_condattr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_create
  @findex proc pthread_create*(a1꞉ ptr Pthread; a2꞉ ptr PthreadAttr;a3꞉ proc (x꞉ pointer)꞉ pointer @{.noconv.@}; a4꞉ pointer)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_create*(a1꞉ ptr Pthread; a2꞉ ptr PthreadAttr;a3꞉ proc (x꞉ pointer)꞉ pointer @{.noconv.@}; a4꞉ pointer)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_detach
  @findex proc pthread_detach*(a1꞉ Pthread)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_detach*(a1꞉ Pthread)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_equal
  @findex proc pthread_equal*(a1, a2꞉ Pthread)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_equal*(a1, a2꞉ Pthread)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_exit
  @findex proc pthread_exit*(a1꞉ pointer) @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_exit*(a1꞉ pointer) @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_getconcurrency
  @findex proc pthread_getconcurrency*()꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_getconcurrency*()꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_getcpuclockid
  @findex proc pthread_getcpuclockid*(a1꞉ Pthread; a2꞉ var ClockId)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_getcpuclockid*(a1꞉ Pthread; a2꞉ var ClockId)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_getschedparam
  @findex proc pthread_getschedparam*(a1꞉ Pthread; a2꞉ var cint; a3꞉ ptr Sched_param)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_getschedparam*(a1꞉ Pthread; a2꞉ var cint; a3꞉ ptr Sched_param)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_getspecific
  @findex proc pthread_getspecific*(a1꞉ Pthread_key)꞉ pointer @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_getspecific*(a1꞉ Pthread_key)꞉ pointer @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_join
  @findex proc pthread_join*(a1꞉ Pthread; a2꞉ ptr pointer)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_join*(a1꞉ Pthread; a2꞉ ptr pointer)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_key_create
  @findex proc pthread_key_create*(a1꞉ ptr Pthread_key; a2꞉ proc (x꞉ pointer) @{.noconv.@})꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_key_create*(a1꞉ ptr Pthread_key; a2꞉ proc (x꞉ pointer) @{.noconv.@})꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_key_delete
  @findex proc pthread_key_delete*(a1꞉ Pthread_key)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_key_delete*(a1꞉ Pthread_key)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_destroy
  @findex proc pthread_mutex_destroy*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_destroy*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_getprioceiling
  @findex proc pthread_mutex_getprioceiling*(a1꞉ ptr Pthread_mutex; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_getprioceiling*(a1꞉ ptr Pthread_mutex; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_init
  @findex proc pthread_mutex_init*(a1꞉ ptr Pthread_mutex; a2꞉ ptr Pthread_mutexattr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_init*(a1꞉ ptr Pthread_mutex; a2꞉ ptr Pthread_mutexattr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_lock
  @findex proc pthread_mutex_lock*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_lock*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_setprioceiling
  @findex proc pthread_mutex_setprioceiling*(a1꞉ ptr Pthread_mutex; a2꞉ cint; a3꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_setprioceiling*(a1꞉ ptr Pthread_mutex; a2꞉ cint; a3꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_timedlock
  @findex proc pthread_mutex_timedlock*(a1꞉ ptr Pthread_mutex; a2꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_timedlock*(a1꞉ ptr Pthread_mutex; a2꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_trylock
  @findex proc pthread_mutex_trylock*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_trylock*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutex_unlock
  @findex proc pthread_mutex_unlock*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutex_unlock*(a1꞉ ptr Pthread_mutex)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_destroy
  @findex proc pthread_mutexattr_destroy*(a1꞉ ptr Pthread_mutexattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_destroy*(a1꞉ ptr Pthread_mutexattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_getprioceiling
  @findex proc pthread_mutexattr_getprioceiling*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_getprioceiling*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_getprotocol
  @findex proc pthread_mutexattr_getprotocol*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_getprotocol*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_getpshared
  @findex proc pthread_mutexattr_getpshared*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_getpshared*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_gettype
  @findex proc pthread_mutexattr_gettype*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_gettype*(a1꞉ ptr Pthread_mutexattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_init
  @findex proc pthread_mutexattr_init*(a1꞉ ptr Pthread_mutexattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_init*(a1꞉ ptr Pthread_mutexattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_setprioceiling
  @findex proc pthread_mutexattr_setprioceiling*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_setprioceiling*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_setprotocol
  @findex proc pthread_mutexattr_setprotocol*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_setprotocol*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_setpshared
  @findex proc pthread_mutexattr_setpshared*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_setpshared*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_mutexattr_settype
  @findex proc pthread_mutexattr_settype*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_mutexattr_settype*(a1꞉ ptr Pthread_mutexattr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_once
  @findex proc pthread_once*(a1꞉ ptr Pthread_once; a2꞉ proc () @{.noconv.@})꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_once*(a1꞉ ptr Pthread_once; a2꞉ proc () @{.noconv.@})꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_destroy
  @findex proc pthread_rwlock_destroy*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_destroy*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_init
  @findex proc pthread_rwlock_init*(a1꞉ ptr Pthread_rwlock; a2꞉ ptr Pthread_rwlockattr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_init*(a1꞉ ptr Pthread_rwlock; a2꞉ ptr Pthread_rwlockattr)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_rdlock
  @findex proc pthread_rwlock_rdlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_rdlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_timedrdlock
  @findex proc pthread_rwlock_timedrdlock*(a1꞉ ptr Pthread_rwlock; a2꞉ ptr Timespec)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_timedrdlock*(a1꞉ ptr Pthread_rwlock; a2꞉ ptr Timespec)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_timedwrlock
  @findex proc pthread_rwlock_timedwrlock*(a1꞉ ptr Pthread_rwlock; a2꞉ ptr Timespec)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_timedwrlock*(a1꞉ ptr Pthread_rwlock; a2꞉ ptr Timespec)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_tryrdlock
  @findex proc pthread_rwlock_tryrdlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_tryrdlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_trywrlock
  @findex proc pthread_rwlock_trywrlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_trywrlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_unlock
  @findex proc pthread_rwlock_unlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_unlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlock_wrlock
  @findex proc pthread_rwlock_wrlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlock_wrlock*(a1꞉ ptr Pthread_rwlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlockattr_destroy
  @findex proc pthread_rwlockattr_destroy*(a1꞉ ptr Pthread_rwlockattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlockattr_destroy*(a1꞉ ptr Pthread_rwlockattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlockattr_getpshared
  @findex proc pthread_rwlockattr_getpshared*(a1꞉ ptr Pthread_rwlockattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_rwlockattr_getpshared*(a1꞉ ptr Pthread_rwlockattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlockattr_init
  @findex proc pthread_rwlockattr_init*(a1꞉ ptr Pthread_rwlockattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_rwlockattr_init*(a1꞉ ptr Pthread_rwlockattr)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_rwlockattr_setpshared
  @findex proc pthread_rwlockattr_setpshared*(a1꞉ ptr Pthread_rwlockattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_rwlockattr_setpshared*(a1꞉ ptr Pthread_rwlockattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_self
  @findex proc pthread_self*()꞉ Pthread @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_self*()꞉ Pthread @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_setcancelstate
  @findex proc pthread_setcancelstate*(a1꞉ cint; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_setcancelstate*(a1꞉ cint; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_setcanceltype
  @findex proc pthread_setcanceltype*(a1꞉ cint; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_setcanceltype*(a1꞉ cint; a2꞉ var cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_setconcurrency
  @findex proc pthread_setconcurrency*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_setconcurrency*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item pthread_setschedparam
  @findex proc pthread_setschedparam*(a1꞉ Pthread; a2꞉ cint; a3꞉ ptr Sched_param)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_setschedparam*(a1꞉ Pthread; a2꞉ cint; a3꞉ ptr Sched_param)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_setschedprio
  @findex proc pthread_setschedprio*(a1꞉ Pthread; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_setschedprio*(a1꞉ Pthread; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_setspecific
  @findex proc pthread_setspecific*(a1꞉ Pthread_key; a2꞉ pointer)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_setspecific*(a1꞉ Pthread_key; a2꞉ pointer)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_spin_destroy
  @findex proc pthread_spin_destroy*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_spin_destroy*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_spin_init
  @findex proc pthread_spin_init*(a1꞉ ptr Pthread_spinlock; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_spin_init*(a1꞉ ptr Pthread_spinlock; a2꞉ cint)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_spin_lock
  @findex proc pthread_spin_lock*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_spin_lock*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_spin_trylock
  @findex proc pthread_spin_trylock*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_spin_trylock*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_spin_unlock
  @findex proc pthread_spin_unlock*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@example
proc pthread_spin_unlock*(a1꞉ ptr Pthread_spinlock)꞉ cint @{.importc,header꞉ "<pthread.h>".@}
@end example
  

@item pthread_testcancel
  @findex proc pthread_testcancel*() @{.importc, header꞉ "<pthread.h>".@}
@example
proc pthread_testcancel*() @{.importc, header꞉ "<pthread.h>".@}
@end example
  

@item exitnow
  @findex proc exitnow*(code꞉ int)꞉ void @{.importc꞉ "_exit", header꞉ "<unistd.h>".@}
@example
proc exitnow*(code꞉ int)꞉ void @{.importc꞉ "_exit", header꞉ "<unistd.h>".@}
@end example
  

@item access
  @findex proc access*(a1꞉ cstring; a2꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc access*(a1꞉ cstring; a2꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item alarm
  @findex proc alarm*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc alarm*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item chdir
  @findex proc chdir*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc chdir*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item chown
  @findex proc chown*(a1꞉ cstring; a2꞉ Uid; a3꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc chown*(a1꞉ cstring; a2꞉ Uid; a3꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item close
  @findex proc close*(a1꞉ cint | SocketHandle)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc close*(a1꞉ cint | SocketHandle)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item confstr
  @findex proc confstr*(a1꞉ cint; a2꞉ cstring; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc confstr*(a1꞉ cint; a2꞉ cstring; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item crypt
  @findex proc crypt*(a1, a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@example
proc crypt*(a1, a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item ctermid
  @findex proc ctermid*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@example
proc ctermid*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item dup
  @findex proc dup*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc dup*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item dup2
  @findex proc dup2*(a1, a2꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc dup2*(a1, a2꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item encrypt
  @findex proc encrypt*(a1꞉ array[0 .. 63, char]; a2꞉ cint) @{.importc, header꞉ "<unistd.h>".@}
@example
proc encrypt*(a1꞉ array[0 .. 63, char]; a2꞉ cint) @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item execl
  @findex proc execl*(a1, a2꞉ cstring)꞉ cint @{.varargs, importc, header꞉ "<unistd.h>".@}
@example
proc execl*(a1, a2꞉ cstring)꞉ cint @{.varargs, importc, header꞉ "<unistd.h>".@}
@end example
  

@item execle
  @findex proc execle*(a1, a2꞉ cstring)꞉ cint @{.varargs, importc, header꞉ "<unistd.h>".@}
@example
proc execle*(a1, a2꞉ cstring)꞉ cint @{.varargs, importc, header꞉ "<unistd.h>".@}
@end example
  

@item execlp
  @findex proc execlp*(a1, a2꞉ cstring)꞉ cint @{.varargs, importc, header꞉ "<unistd.h>".@}
@example
proc execlp*(a1, a2꞉ cstring)꞉ cint @{.varargs, importc, header꞉ "<unistd.h>".@}
@end example
  

@item execv
  @findex proc execv*(a1꞉ cstring; a2꞉ cstringArray)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc execv*(a1꞉ cstring; a2꞉ cstringArray)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item execve
  @findex proc execve*(a1꞉ cstring; a2, a3꞉ cstringArray)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc execve*(a1꞉ cstring; a2, a3꞉ cstringArray)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item execvp
  @findex proc execvp*(a1꞉ cstring; a2꞉ cstringArray)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc execvp*(a1꞉ cstring; a2꞉ cstringArray)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item execvpe
  @findex proc execvpe*(a1꞉ cstring; a2꞉ cstringArray; a3꞉ cstringArray)꞉ cint @{.importc,header꞉ "<unistd.h>".@}
@example
proc execvpe*(a1꞉ cstring; a2꞉ cstringArray; a3꞉ cstringArray)꞉ cint @{.importc,header꞉ "<unistd.h>".@}
@end example
  

@item fchown
  @findex proc fchown*(a1꞉ cint; a2꞉ Uid; a3꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc fchown*(a1꞉ cint; a2꞉ Uid; a3꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item fchdir
  @findex proc fchdir*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc fchdir*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item fdatasync
  @findex proc fdatasync*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc fdatasync*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item fork
  @findex proc fork*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc fork*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item fpathconf
  @findex proc fpathconf*(a1, a2꞉ cint)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc fpathconf*(a1, a2꞉ cint)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item fsync
  @findex proc fsync*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc fsync*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item ftruncate
  @findex proc ftruncate*(a1꞉ cint; a2꞉ Off)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc ftruncate*(a1꞉ cint; a2꞉ Off)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getcwd
  @findex proc getcwd*(a1꞉ cstring; a2꞉ int)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@example
proc getcwd*(a1꞉ cstring; a2꞉ int)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getegid
  @findex proc getegid*()꞉ Gid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getegid*()꞉ Gid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item geteuid
  @findex proc geteuid*()꞉ Uid @{.importc, header꞉ "<unistd.h>".@}
@example
proc geteuid*()꞉ Uid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getgid
  @findex proc getgid*()꞉ Gid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getgid*()꞉ Gid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getgroups
  @findex proc getgroups*(a1꞉ cint; a2꞉ ptr array[0 .. 255, Gid])꞉ cint @{.importc,header꞉ "<unistd.h>".@}
@example
proc getgroups*(a1꞉ cint; a2꞉ ptr array[0 .. 255, Gid])꞉ cint @{.importc,header꞉ "<unistd.h>".@}
@end example
  

@item gethostid
  @findex proc gethostid*()꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc gethostid*()꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item gethostname
  @findex proc gethostname*(a1꞉ cstring; a2꞉ int)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc gethostname*(a1꞉ cstring; a2꞉ int)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getlogin
  @findex proc getlogin*()꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@example
proc getlogin*()꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getlogin_r
  @findex proc getlogin_r*(a1꞉ cstring; a2꞉ int)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc getlogin_r*(a1꞉ cstring; a2꞉ int)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getopt
  @findex proc getopt*(a1꞉ cint; a2꞉ cstringArray; a3꞉ cstring)꞉ cint @{.importc,header꞉ "<unistd.h>".@}
@example
proc getopt*(a1꞉ cint; a2꞉ cstringArray; a3꞉ cstring)꞉ cint @{.importc,header꞉ "<unistd.h>".@}
@end example
  

@item getpgid
  @findex proc getpgid*(a1꞉ Pid)꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getpgid*(a1꞉ Pid)꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getpgrp
  @findex proc getpgrp*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getpgrp*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getpid
  @findex proc getpid*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getpid*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getppid
  @findex proc getppid*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getppid*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getsid
  @findex proc getsid*(a1꞉ Pid)꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getsid*(a1꞉ Pid)꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getuid
  @findex proc getuid*()꞉ Uid @{.importc, header꞉ "<unistd.h>".@}
@example
proc getuid*()꞉ Uid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item getwd
  @findex proc getwd*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@example
proc getwd*(a1꞉ cstring)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item isatty
  @findex proc isatty*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc isatty*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item lchown
  @findex proc lchown*(a1꞉ cstring; a2꞉ Uid; a3꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc lchown*(a1꞉ cstring; a2꞉ Uid; a3꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item link
  @findex proc link*(a1, a2꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc link*(a1, a2꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item lockf
  @findex proc lockf*(a1, a2꞉ cint; a3꞉ Off)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc lockf*(a1, a2꞉ cint; a3꞉ Off)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item lseek
  @findex proc lseek*(a1꞉ cint; a2꞉ Off; a3꞉ cint)꞉ Off @{.importc, header꞉ "<unistd.h>".@}
@example
proc lseek*(a1꞉ cint; a2꞉ Off; a3꞉ cint)꞉ Off @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item nice
  @findex proc nice*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc nice*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item pathconf
  @findex proc pathconf*(a1꞉ cstring; a2꞉ cint)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc pathconf*(a1꞉ cstring; a2꞉ cint)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item pause
  @findex proc pause*()꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc pause*()꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item pclose
  @findex proc pclose*(a꞉ File)꞉ cint @{.importc, header꞉ "<stdio.h>".@}
@example
proc pclose*(a꞉ File)꞉ cint @{.importc, header꞉ "<stdio.h>".@}
@end example
  

@item pipe
  @findex proc pipe*(a꞉ array[0 .. 1, cint])꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc pipe*(a꞉ array[0 .. 1, cint])꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item popen
  @findex proc popen*(a1, a2꞉ cstring)꞉ File @{.importc, header꞉ "<stdio.h>".@}
@example
proc popen*(a1, a2꞉ cstring)꞉ File @{.importc, header꞉ "<stdio.h>".@}
@end example
  

@item pread
  @findex proc pread*(a1꞉ cint; a2꞉ pointer; a3꞉ int; a4꞉ Off)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc pread*(a1꞉ cint; a2꞉ pointer; a3꞉ int; a4꞉ Off)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item pwrite
  @findex proc pwrite*(a1꞉ cint; a2꞉ pointer; a3꞉ int; a4꞉ Off)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc pwrite*(a1꞉ cint; a2꞉ pointer; a3꞉ int; a4꞉ Off)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item read
  @findex proc read*(a1꞉ cint; a2꞉ pointer; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc read*(a1꞉ cint; a2꞉ pointer; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item readlink
  @findex proc readlink*(a1, a2꞉ cstring; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc readlink*(a1, a2꞉ cstring; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item ioctl
  @findex proc ioctl*(f꞉ FileHandle; device꞉ uint)꞉ int @{.importc꞉ "ioctl",header꞉ "<sys/ioctl.h>", varargs, tags꞉ [WriteIOEffect].@}
@example
proc ioctl*(f꞉ FileHandle; device꞉ uint)꞉ int @{.importc꞉ "ioctl",header꞉ "<sys/ioctl.h>", varargs, tags꞉ [WriteIOEffect].@}
@end example
  A system call for device-specific input/output operations and other operations which cannot be expressed by regular system calls

@item rmdir
  @findex proc rmdir*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc rmdir*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setegid
  @findex proc setegid*(a1꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc setegid*(a1꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item seteuid
  @findex proc seteuid*(a1꞉ Uid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc seteuid*(a1꞉ Uid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setgid
  @findex proc setgid*(a1꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc setgid*(a1꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setpgid
  @findex proc setpgid*(a1, a2꞉ Pid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc setpgid*(a1, a2꞉ Pid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setpgrp
  @findex proc setpgrp*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc setpgrp*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setregid
  @findex proc setregid*(a1, a2꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc setregid*(a1, a2꞉ Gid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setreuid
  @findex proc setreuid*(a1, a2꞉ Uid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc setreuid*(a1, a2꞉ Uid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setsid
  @findex proc setsid*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc setsid*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item setuid
  @findex proc setuid*(a1꞉ Uid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc setuid*(a1꞉ Uid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item sleep
  @findex proc sleep*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc sleep*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item swab
  @findex proc swab*(a1, a2꞉ pointer; a3꞉ int) @{.importc, header꞉ "<unistd.h>".@}
@example
proc swab*(a1, a2꞉ pointer; a3꞉ int) @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item symlink
  @findex proc symlink*(a1, a2꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc symlink*(a1, a2꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item sync
  @findex proc sync*() @{.importc, header꞉ "<unistd.h>".@}
@example
proc sync*() @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item sysconf
  @findex proc sysconf*(a1꞉ cint)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc sysconf*(a1꞉ cint)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item tcgetpgrp
  @findex proc tcgetpgrp*(a1꞉ cint)꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc tcgetpgrp*(a1꞉ cint)꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item tcsetpgrp
  @findex proc tcsetpgrp*(a1꞉ cint; a2꞉ Pid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc tcsetpgrp*(a1꞉ cint; a2꞉ Pid)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item truncate
  @findex proc truncate*(a1꞉ cstring; a2꞉ Off)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc truncate*(a1꞉ cstring; a2꞉ Off)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item ttyname
  @findex proc ttyname*(a1꞉ cint)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@example
proc ttyname*(a1꞉ cint)꞉ cstring @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item ttyname_r
  @findex proc ttyname_r*(a1꞉ cint; a2꞉ cstring; a3꞉ int)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc ttyname_r*(a1꞉ cint; a2꞉ cstring; a3꞉ int)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item ualarm
  @findex proc ualarm*(a1, a2꞉ Useconds)꞉ Useconds @{.importc, header꞉ "<unistd.h>".@}
@example
proc ualarm*(a1, a2꞉ Useconds)꞉ Useconds @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item unlink
  @findex proc unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item usleep
  @findex proc usleep*(a1꞉ Useconds)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@example
proc usleep*(a1꞉ Useconds)꞉ cint @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item vfork
  @findex proc vfork*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@example
proc vfork*()꞉ Pid @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item write
  @findex proc write*(a1꞉ cint; a2꞉ pointer; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@example
proc write*(a1꞉ cint; a2꞉ pointer; a3꞉ int)꞉ int @{.importc, header꞉ "<unistd.h>".@}
@end example
  

@item sem_close
  @findex proc sem_close*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_close*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item sem_destroy
  @findex proc sem_destroy*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_destroy*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item sem_getvalue
  @findex proc sem_getvalue*(a1꞉ ptr Sem; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_getvalue*(a1꞉ ptr Sem; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item sem_init
  @findex proc sem_init*(a1꞉ ptr Sem; a2꞉ cint; a3꞉ cint)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_init*(a1꞉ ptr Sem; a2꞉ cint; a3꞉ cint)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item sem_open
  @findex proc sem_open*(a1꞉ cstring; a2꞉ cint)꞉ ptr Sem @{.varargs, importc,header꞉ "<semaphore.h>".@}
@example
proc sem_open*(a1꞉ cstring; a2꞉ cint)꞉ ptr Sem @{.varargs, importc,header꞉ "<semaphore.h>".@}
@end example
  

@item sem_post
  @findex proc sem_post*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_post*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item sem_timedwait
  @findex proc sem_timedwait*(a1꞉ ptr Sem; a2꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<semaphore.h>".@}
@example
proc sem_timedwait*(a1꞉ ptr Sem; a2꞉ ptr Timespec)꞉ cint @{.importc,header꞉ "<semaphore.h>".@}
@end example
  

@item sem_trywait
  @findex proc sem_trywait*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_trywait*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item sem_unlink
  @findex proc sem_unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item sem_wait
  @findex proc sem_wait*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@example
proc sem_wait*(a1꞉ ptr Sem)꞉ cint @{.importc, header꞉ "<semaphore.h>".@}
@end example
  

@item ftok
  @findex proc ftok*(a1꞉ cstring; a2꞉ cint)꞉ Key @{.importc, header꞉ "<sys/ipc.h>".@}
@example
proc ftok*(a1꞉ cstring; a2꞉ cint)꞉ Key @{.importc, header꞉ "<sys/ipc.h>".@}
@end example
  

@item statvfs
  @findex proc statvfs*(a1꞉ cstring; a2꞉ var Statvfs)꞉ cint @{.importc, header꞉ "<sys/statvfs.h>".@}
@example
proc statvfs*(a1꞉ cstring; a2꞉ var Statvfs)꞉ cint @{.importc, header꞉ "<sys/statvfs.h>".@}
@end example
  

@item fstatvfs
  @findex proc fstatvfs*(a1꞉ cint; a2꞉ var Statvfs)꞉ cint @{.importc, header꞉ "<sys/statvfs.h>".@}
@example
proc fstatvfs*(a1꞉ cint; a2꞉ var Statvfs)꞉ cint @{.importc, header꞉ "<sys/statvfs.h>".@}
@end example
  

@item chmod
  @findex proc chmod*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc chmod*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item fchmod
  @findex proc fchmod*(a1꞉ cint; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc fchmod*(a1꞉ cint; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item fstat
  @findex proc fstat*(a1꞉ cint; a2꞉ var Stat)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc fstat*(a1꞉ cint; a2꞉ var Stat)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item lstat
  @findex proc lstat*(a1꞉ cstring; a2꞉ var Stat)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc lstat*(a1꞉ cstring; a2꞉ var Stat)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item mkdir
  @findex proc mkdir*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc mkdir*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item mkfifo
  @findex proc mkfifo*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc mkfifo*(a1꞉ cstring; a2꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item mknod
  @findex proc mknod*(a1꞉ cstring; a2꞉ Mode; a3꞉ Dev)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc mknod*(a1꞉ cstring; a2꞉ Mode; a3꞉ Dev)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item stat
  @findex proc stat*(a1꞉ cstring; a2꞉ var Stat)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc stat*(a1꞉ cstring; a2꞉ var Stat)꞉ cint @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item umask
  @findex proc umask*(a1꞉ Mode)꞉ Mode @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc umask*(a1꞉ Mode)꞉ Mode @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  

@item S_ISBLK
  @findex proc S_ISBLK*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_ISBLK*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a block special file.

@item S_ISCHR
  @findex proc S_ISCHR*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_ISCHR*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a character special file.

@item S_ISDIR
  @findex proc S_ISDIR*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_ISDIR*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a directory.

@item S_ISFIFO
  @findex proc S_ISFIFO*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_ISFIFO*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a pipe or FIFO special file.

@item S_ISREG
  @findex proc S_ISREG*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_ISREG*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a regular file.

@item S_ISLNK
  @findex proc S_ISLNK*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_ISLNK*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a symbolic link.

@item S_ISSOCK
  @findex proc S_ISSOCK*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_ISSOCK*(m꞉ Mode)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a socket.

@item S_TYPEISMQ
  @findex proc S_TYPEISMQ*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_TYPEISMQ*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a message queue.

@item S_TYPEISSEM
  @findex proc S_TYPEISSEM*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_TYPEISSEM*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a semaphore.

@item S_TYPEISSHM
  @findex proc S_TYPEISSHM*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_TYPEISSHM*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test for a shared memory object.

@item S_TYPEISTMO
  @findex proc S_TYPEISTMO*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@example
proc S_TYPEISTMO*(buf꞉ var Stat)꞉ bool @{.importc, header꞉ "<sys/stat.h>".@}
@end example
  Test macro for a typed memory object.

@item mlock
  @findex proc mlock*(a1꞉ pointer; a2꞉ int)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc mlock*(a1꞉ pointer; a2꞉ int)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item mlockall
  @findex proc mlockall*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc mlockall*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item mmap
  @findex proc mmap*(a1꞉ pointer; a2꞉ int; a3, a4, a5꞉ cint; a6꞉ Off)꞉ pointer @{.importc,header꞉ "<sys/mman.h>".@}
@example
proc mmap*(a1꞉ pointer; a2꞉ int; a3, a4, a5꞉ cint; a6꞉ Off)꞉ pointer @{.importc,header꞉ "<sys/mman.h>".@}
@end example
  

@item mprotect
  @findex proc mprotect*(a1꞉ pointer; a2꞉ int; a3꞉ cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc mprotect*(a1꞉ pointer; a2꞉ int; a3꞉ cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item msync
  @findex proc msync*(a1꞉ pointer; a2꞉ int; a3꞉ cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc msync*(a1꞉ pointer; a2꞉ int; a3꞉ cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item munlock
  @findex proc munlock*(a1꞉ pointer; a2꞉ int)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc munlock*(a1꞉ pointer; a2꞉ int)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item munlockall
  @findex proc munlockall*()꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc munlockall*()꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item munmap
  @findex proc munmap*(a1꞉ pointer; a2꞉ int)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc munmap*(a1꞉ pointer; a2꞉ int)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item posix_madvise
  @findex proc posix_madvise*(a1꞉ pointer; a2꞉ int; a3꞉ cint)꞉ cint @{.importc,header꞉ "<sys/mman.h>".@}
@example
proc posix_madvise*(a1꞉ pointer; a2꞉ int; a3꞉ cint)꞉ cint @{.importc,header꞉ "<sys/mman.h>".@}
@end example
  

@item posix_mem_offset
  @findex proc posix_mem_offset*(a1꞉ pointer; a2꞉ int; a3꞉ var Off; a4꞉ var int; a5꞉ var cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc posix_mem_offset*(a1꞉ pointer; a2꞉ int; a3꞉ var Off; a4꞉ var int; a5꞉ var cint)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item posix_typed_mem_get_info
  @findex proc posix_typed_mem_get_info*(a1꞉ cint; a2꞉ var Posix_typed_mem_info)꞉ cint @{.importc,header꞉ "<sys/mman.h>".@}
@example
proc posix_typed_mem_get_info*(a1꞉ cint; a2꞉ var Posix_typed_mem_info)꞉ cint @{.importc,header꞉ "<sys/mman.h>".@}
@end example
  

@item posix_typed_mem_open
  @findex proc posix_typed_mem_open*(a1꞉ cstring; a2, a3꞉ cint)꞉ cint @{.importc,header꞉ "<sys/mman.h>".@}
@example
proc posix_typed_mem_open*(a1꞉ cstring; a2, a3꞉ cint)꞉ cint @{.importc,header꞉ "<sys/mman.h>".@}
@end example
  

@item shm_open
  @findex proc shm_open*(a1꞉ cstring; a2꞉ cint; a3꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc shm_open*(a1꞉ cstring; a2꞉ cint; a3꞉ Mode)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item shm_unlink
  @findex proc shm_unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@example
proc shm_unlink*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<sys/mman.h>".@}
@end example
  

@item asctime
  @findex proc asctime*(a1꞉ var Tm)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@example
proc asctime*(a1꞉ var Tm)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@end example
  

@item asctime_r
  @findex proc asctime_r*(a1꞉ var Tm; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@example
proc asctime_r*(a1꞉ var Tm; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@end example
  

@item clock
  @findex proc clock*()꞉ Clock @{.importc, header꞉ "<time.h>".@}
@example
proc clock*()꞉ Clock @{.importc, header꞉ "<time.h>".@}
@end example
  

@item clock_getcpuclockid
  @findex proc clock_getcpuclockid*(a1꞉ Pid; a2꞉ var ClockId)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc clock_getcpuclockid*(a1꞉ Pid; a2꞉ var ClockId)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item clock_getres
  @findex proc clock_getres*(a1꞉ ClockId; a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc clock_getres*(a1꞉ ClockId; a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item clock_gettime
  @findex proc clock_gettime*(a1꞉ ClockId; a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc clock_gettime*(a1꞉ ClockId; a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item clock_nanosleep
  @findex proc clock_nanosleep*(a1꞉ ClockId; a2꞉ cint; a3꞉ var Timespec; a4꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc clock_nanosleep*(a1꞉ ClockId; a2꞉ cint; a3꞉ var Timespec; a4꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item clock_settime
  @findex proc clock_settime*(a1꞉ ClockId; a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc clock_settime*(a1꞉ ClockId; a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item ctime
  @findex proc ctime*(a1꞉ var Time)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@example
proc ctime*(a1꞉ var Time)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@end example
  

@item ctime_r
  @findex proc ctime_r*(a1꞉ var Time; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@example
proc ctime_r*(a1꞉ var Time; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@end example
  

@item difftime
  @findex proc difftime*(a1, a2꞉ Time)꞉ cdouble @{.importc, header꞉ "<time.h>".@}
@example
proc difftime*(a1, a2꞉ Time)꞉ cdouble @{.importc, header꞉ "<time.h>".@}
@end example
  

@item getdate
  @findex proc getdate*(a1꞉ cstring)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@example
proc getdate*(a1꞉ cstring)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@end example
  

@item gmtime
  @findex proc gmtime*(a1꞉ var Time)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@example
proc gmtime*(a1꞉ var Time)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@end example
  

@item gmtime_r
  @findex proc gmtime_r*(a1꞉ var Time; a2꞉ var Tm)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@example
proc gmtime_r*(a1꞉ var Time; a2꞉ var Tm)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@end example
  

@item localtime
  @findex proc localtime*(a1꞉ var Time)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@example
proc localtime*(a1꞉ var Time)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@end example
  

@item localtime_r
  @findex proc localtime_r*(a1꞉ var Time; a2꞉ var Tm)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@example
proc localtime_r*(a1꞉ var Time; a2꞉ var Tm)꞉ ptr Tm @{.importc, header꞉ "<time.h>".@}
@end example
  

@item mktime
  @findex proc mktime*(a1꞉ var Tm)꞉ Time @{.importc, header꞉ "<time.h>".@}
@example
proc mktime*(a1꞉ var Tm)꞉ Time @{.importc, header꞉ "<time.h>".@}
@end example
  

@item timegm
  @findex proc timegm*(a1꞉ var Tm)꞉ Time @{.importc, header꞉ "<time.h>".@}
@example
proc timegm*(a1꞉ var Tm)꞉ Time @{.importc, header꞉ "<time.h>".@}
@end example
  

@item nanosleep
  @findex proc nanosleep*(a1, a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc nanosleep*(a1, a2꞉ var Timespec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item strftime
  @findex proc strftime*(a1꞉ cstring; a2꞉ int; a3꞉ cstring; a4꞉ var Tm)꞉ int @{.importc,header꞉ "<time.h>".@}
@example
proc strftime*(a1꞉ cstring; a2꞉ int; a3꞉ cstring; a4꞉ var Tm)꞉ int @{.importc,header꞉ "<time.h>".@}
@end example
  

@item strptime
  @findex proc strptime*(a1, a2꞉ cstring; a3꞉ var Tm)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@example
proc strptime*(a1, a2꞉ cstring; a3꞉ var Tm)꞉ cstring @{.importc, header꞉ "<time.h>".@}
@end example
  

@item time
  @findex proc time*(a1꞉ var Time)꞉ Time @{.importc, header꞉ "<time.h>".@}
@example
proc time*(a1꞉ var Time)꞉ Time @{.importc, header꞉ "<time.h>".@}
@end example
  

@item timer_create
  @findex proc timer_create*(a1꞉ var ClockId; a2꞉ var SigEvent; a3꞉ var Timer)꞉ cint @{.importc,header꞉ "<time.h>".@}
@example
proc timer_create*(a1꞉ var ClockId; a2꞉ var SigEvent; a3꞉ var Timer)꞉ cint @{.importc,header꞉ "<time.h>".@}
@end example
  

@item timer_delete
  @findex proc timer_delete*(a1꞉ var Timer)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc timer_delete*(a1꞉ var Timer)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item timer_gettime
  @findex proc timer_gettime*(a1꞉ Timer; a2꞉ var Itimerspec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc timer_gettime*(a1꞉ Timer; a2꞉ var Itimerspec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item timer_getoverrun
  @findex proc timer_getoverrun*(a1꞉ Timer)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc timer_getoverrun*(a1꞉ Timer)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item timer_settime
  @findex proc timer_settime*(a1꞉ Timer; a2꞉ cint; a3꞉ var Itimerspec; a4꞉ var Itimerspec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@example
proc timer_settime*(a1꞉ Timer; a2꞉ cint; a3꞉ var Itimerspec; a4꞉ var Itimerspec)꞉ cint @{.importc, header꞉ "<time.h>".@}
@end example
  

@item tzset
  @findex proc tzset*() @{.importc, header꞉ "<time.h>".@}
@example
proc tzset*() @{.importc, header꞉ "<time.h>".@}
@end example
  

@item wait
  @findex proc wait*(a1꞉ ptr cint)꞉ Pid @{.importc, discardable, header꞉ "<sys/wait.h>".@}
@example
proc wait*(a1꞉ ptr cint)꞉ Pid @{.importc, discardable, header꞉ "<sys/wait.h>".@}
@end example
  

@item waitid
  @findex proc waitid*(a1꞉ cint; a2꞉ Id; a3꞉ var SigInfo; a4꞉ cint)꞉ cint @{.importc,header꞉ "<sys/wait.h>".@}
@example
proc waitid*(a1꞉ cint; a2꞉ Id; a3꞉ var SigInfo; a4꞉ cint)꞉ cint @{.importc,header꞉ "<sys/wait.h>".@}
@end example
  

@item waitpid
  @findex proc waitpid*(a1꞉ Pid; a2꞉ var cint; a3꞉ cint)꞉ Pid @{.importc, header꞉ "<sys/wait.h>".@}
@example
proc waitpid*(a1꞉ Pid; a2꞉ var cint; a3꞉ cint)꞉ Pid @{.importc, header꞉ "<sys/wait.h>".@}
@end example
  

@item bsd_signal
  @findex proc bsd_signal*(a1꞉ cint; a2꞉ proc (x꞉ pointer) @{.noconv.@}) @{.importc,header꞉ "<signal.h>".@}
@example
proc bsd_signal*(a1꞉ cint; a2꞉ proc (x꞉ pointer) @{.noconv.@}) @{.importc,header꞉ "<signal.h>".@}
@end example
  

@item kill
  @findex proc kill*(a1꞉ Pid; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc kill*(a1꞉ Pid; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item killpg
  @findex proc killpg*(a1꞉ Pid; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc killpg*(a1꞉ Pid; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item pthread_kill
  @findex proc pthread_kill*(a1꞉ Pthread; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc pthread_kill*(a1꞉ Pthread; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item pthread_sigmask
  @findex proc pthread_sigmask*(a1꞉ cint; a2, a3꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc pthread_sigmask*(a1꞉ cint; a2, a3꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item `raise`
  @findex proc `raise`*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc `raise`*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigaction
  @findex proc sigaction*(a1꞉ cint; a2, a3꞉ var Sigaction)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigaction*(a1꞉ cint; a2, a3꞉ var Sigaction)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigaddset
  @findex proc sigaddset*(a1꞉ var Sigset; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigaddset*(a1꞉ var Sigset; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigaltstack
  @findex proc sigaltstack*(a1, a2꞉ var Stack)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigaltstack*(a1, a2꞉ var Stack)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigdelset
  @findex proc sigdelset*(a1꞉ var Sigset; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigdelset*(a1꞉ var Sigset; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigemptyset
  @findex proc sigemptyset*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigemptyset*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigfillset
  @findex proc sigfillset*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigfillset*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sighold
  @findex proc sighold*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sighold*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigignore
  @findex proc sigignore*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigignore*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item siginterrupt
  @findex proc siginterrupt*(a1, a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc siginterrupt*(a1, a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigismember
  @findex proc sigismember*(a1꞉ var Sigset; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigismember*(a1꞉ var Sigset; a2꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item signal
  @findex proc signal*(a1꞉ cint; a2꞉ proc (x꞉ cint) @{.noconv.@}) @{.importc, header꞉ "<signal.h>".@}
@example
proc signal*(a1꞉ cint; a2꞉ proc (x꞉ cint) @{.noconv.@}) @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigpause
  @findex proc sigpause*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigpause*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigpending
  @findex proc sigpending*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigpending*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigprocmask
  @findex proc sigprocmask*(a1꞉ cint; a2, a3꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigprocmask*(a1꞉ cint; a2, a3꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigqueue
  @findex proc sigqueue*(a1꞉ Pid; a2꞉ cint; a3꞉ SigVal)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigqueue*(a1꞉ Pid; a2꞉ cint; a3꞉ SigVal)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigrelse
  @findex proc sigrelse*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigrelse*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigset
  @findex proc sigset*(a1꞉ int; a2꞉ proc (x꞉ cint) @{.noconv.@}) @{.importc, header꞉ "<signal.h>".@}
@example
proc sigset*(a1꞉ int; a2꞉ proc (x꞉ cint) @{.noconv.@}) @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigsuspend
  @findex proc sigsuspend*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigsuspend*(a1꞉ var Sigset)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigtimedwait
  @findex proc sigtimedwait*(a1꞉ var Sigset; a2꞉ var SigInfo; a3꞉ var Timespec)꞉ cint @{.importc,header꞉ "<signal.h>".@}
@example
proc sigtimedwait*(a1꞉ var Sigset; a2꞉ var SigInfo; a3꞉ var Timespec)꞉ cint @{.importc,header꞉ "<signal.h>".@}
@end example
  

@item sigwait
  @findex proc sigwait*(a1꞉ var Sigset; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigwait*(a1꞉ var Sigset; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item sigwaitinfo
  @findex proc sigwaitinfo*(a1꞉ var Sigset; a2꞉ var SigInfo)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@example
proc sigwaitinfo*(a1꞉ var Sigset; a2꞉ var SigInfo)꞉ cint @{.importc, header꞉ "<signal.h>".@}
@end example
  

@item catclose
  @findex proc catclose*(a1꞉ Nl_catd)꞉ cint @{.importc, header꞉ "<nl_types.h>".@}
@example
proc catclose*(a1꞉ Nl_catd)꞉ cint @{.importc, header꞉ "<nl_types.h>".@}
@end example
  

@item catgets
  @findex proc catgets*(a1꞉ Nl_catd; a2, a3꞉ cint; a4꞉ cstring)꞉ cstring @{.importc,header꞉ "<nl_types.h>".@}
@example
proc catgets*(a1꞉ Nl_catd; a2, a3꞉ cint; a4꞉ cstring)꞉ cstring @{.importc,header꞉ "<nl_types.h>".@}
@end example
  

@item catopen
  @findex proc catopen*(a1꞉ cstring; a2꞉ cint)꞉ Nl_catd @{.importc, header꞉ "<nl_types.h>".@}
@example
proc catopen*(a1꞉ cstring; a2꞉ cint)꞉ Nl_catd @{.importc, header꞉ "<nl_types.h>".@}
@end example
  

@item sched_get_priority_max
  @findex proc sched_get_priority_max*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@example
proc sched_get_priority_max*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@end example
  

@item sched_get_priority_min
  @findex proc sched_get_priority_min*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@example
proc sched_get_priority_min*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@end example
  

@item sched_getparam
  @findex proc sched_getparam*(a1꞉ Pid; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@example
proc sched_getparam*(a1꞉ Pid; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@end example
  

@item sched_getscheduler
  @findex proc sched_getscheduler*(a1꞉ Pid)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@example
proc sched_getscheduler*(a1꞉ Pid)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@end example
  

@item sched_rr_get_interval
  @findex proc sched_rr_get_interval*(a1꞉ Pid; a2꞉ var Timespec)꞉ cint @{.importc,header꞉ "<sched.h>".@}
@example
proc sched_rr_get_interval*(a1꞉ Pid; a2꞉ var Timespec)꞉ cint @{.importc,header꞉ "<sched.h>".@}
@end example
  

@item sched_setparam
  @findex proc sched_setparam*(a1꞉ Pid; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@example
proc sched_setparam*(a1꞉ Pid; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@end example
  

@item sched_setscheduler
  @findex proc sched_setscheduler*(a1꞉ Pid; a2꞉ cint; a3꞉ var Sched_param)꞉ cint @{.importc,header꞉ "<sched.h>".@}
@example
proc sched_setscheduler*(a1꞉ Pid; a2꞉ cint; a3꞉ var Sched_param)꞉ cint @{.importc,header꞉ "<sched.h>".@}
@end example
  

@item sched_yield
  @findex proc sched_yield*()꞉ cint @{.importc, header꞉ "<sched.h>".@}
@example
proc sched_yield*()꞉ cint @{.importc, header꞉ "<sched.h>".@}
@end example
  

@item strerror
  @findex proc strerror*(errnum꞉ cint)꞉ cstring @{.importc, header꞉ "<string.h>".@}
@example
proc strerror*(errnum꞉ cint)꞉ cstring @{.importc, header꞉ "<string.h>".@}
@end example
  

@item hstrerror
  @findex proc hstrerror*(herrnum꞉ cint)꞉ cstring @{.importc꞉ "(char *)$1", header꞉ "<netdb.h>".@}
@example
proc hstrerror*(herrnum꞉ cint)꞉ cstring @{.importc꞉ "(char *)$1", header꞉ "<netdb.h>".@}
@end example
  

@item FD_CLR
  @findex proc FD_CLR*(a1꞉ cint; a2꞉ var TFdSet) @{.importc, header꞉ "<sys/select.h>".@}
@example
proc FD_CLR*(a1꞉ cint; a2꞉ var TFdSet) @{.importc, header꞉ "<sys/select.h>".@}
@end example
  

@item FD_ISSET
  @findex proc FD_ISSET*(a1꞉ cint | SocketHandle; a2꞉ var TFdSet)꞉ cint @{.importc,header꞉ "<sys/select.h>".@}
@example
proc FD_ISSET*(a1꞉ cint | SocketHandle; a2꞉ var TFdSet)꞉ cint @{.importc,header꞉ "<sys/select.h>".@}
@end example
  

@item FD_SET
  @findex proc FD_SET*(a1꞉ cint | SocketHandle; a2꞉ var TFdSet) @{.importc꞉ "FD_SET",header꞉ "<sys/select.h>".@}
@example
proc FD_SET*(a1꞉ cint | SocketHandle; a2꞉ var TFdSet) @{.importc꞉ "FD_SET",header꞉ "<sys/select.h>".@}
@end example
  

@item FD_ZERO
  @findex proc FD_ZERO*(a1꞉ var TFdSet) @{.importc, header꞉ "<sys/select.h>".@}
@example
proc FD_ZERO*(a1꞉ var TFdSet) @{.importc, header꞉ "<sys/select.h>".@}
@end example
  

@item pselect
  @findex proc pselect*(a1꞉ cint; a2, a3, a4꞉ ptr TFdSet; a5꞉ ptr Timespec; a6꞉ var Sigset)꞉ cint @{.importc, header꞉ "<sys/select.h>".@}
@example
proc pselect*(a1꞉ cint; a2, a3, a4꞉ ptr TFdSet; a5꞉ ptr Timespec; a6꞉ var Sigset)꞉ cint @{.importc, header꞉ "<sys/select.h>".@}
@end example
  

@item select
  @findex proc select*(a1꞉ cint | SocketHandle; a2, a3, a4꞉ ptr TFdSet; a5꞉ ptr Timeval)꞉ cint @{.importc, header꞉ "<sys/select.h>".@}
@example
proc select*(a1꞉ cint | SocketHandle; a2, a3, a4꞉ ptr TFdSet; a5꞉ ptr Timeval)꞉ cint @{.importc, header꞉ "<sys/select.h>".@}
@end example
  

@item posix_spawn
  @findex proc posix_spawn*(a1꞉ var Pid; a2꞉ cstring; a3꞉ var Tposix_spawn_file_actions;a4꞉ var Tposix_spawnattr; a5, a6꞉ cstringArray)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawn*(a1꞉ var Pid; a2꞉ cstring; a3꞉ var Tposix_spawn_file_actions;a4꞉ var Tposix_spawnattr; a5, a6꞉ cstringArray)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawn_file_actions_addclose
  @findex proc posix_spawn_file_actions_addclose*(a1꞉ var Tposix_spawn_file_actions; a2꞉ cint)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawn_file_actions_addclose*(a1꞉ var Tposix_spawn_file_actions; a2꞉ cint)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawn_file_actions_adddup2
  @findex proc posix_spawn_file_actions_adddup2*(a1꞉ var Tposix_spawn_file_actions;a2, a3꞉ cint)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawn_file_actions_adddup2*(a1꞉ var Tposix_spawn_file_actions;a2, a3꞉ cint)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawn_file_actions_addopen
  @findex proc posix_spawn_file_actions_addopen*(a1꞉ var Tposix_spawn_file_actions; a2꞉ cint;a3꞉ cstring; a4꞉ cint; a5꞉ Mode)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawn_file_actions_addopen*(a1꞉ var Tposix_spawn_file_actions; a2꞉ cint;a3꞉ cstring; a4꞉ cint; a5꞉ Mode)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawn_file_actions_destroy
  @findex proc posix_spawn_file_actions_destroy*(a1꞉ var Tposix_spawn_file_actions)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawn_file_actions_destroy*(a1꞉ var Tposix_spawn_file_actions)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawn_file_actions_init
  @findex proc posix_spawn_file_actions_init*(a1꞉ var Tposix_spawn_file_actions)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawn_file_actions_init*(a1꞉ var Tposix_spawn_file_actions)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_destroy
  @findex proc posix_spawnattr_destroy*(a1꞉ var Tposix_spawnattr)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_destroy*(a1꞉ var Tposix_spawnattr)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_getsigdefault
  @findex proc posix_spawnattr_getsigdefault*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_getsigdefault*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_getflags
  @findex proc posix_spawnattr_getflags*(a1꞉ var Tposix_spawnattr; a2꞉ var cshort)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_getflags*(a1꞉ var Tposix_spawnattr; a2꞉ var cshort)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_getpgroup
  @findex proc posix_spawnattr_getpgroup*(a1꞉ var Tposix_spawnattr; a2꞉ var Pid)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_getpgroup*(a1꞉ var Tposix_spawnattr; a2꞉ var Pid)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_getschedparam
  @findex proc posix_spawnattr_getschedparam*(a1꞉ var Tposix_spawnattr; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_getschedparam*(a1꞉ var Tposix_spawnattr; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_getschedpolicy
  @findex proc posix_spawnattr_getschedpolicy*(a1꞉ var Tposix_spawnattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_getschedpolicy*(a1꞉ var Tposix_spawnattr; a2꞉ var cint)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_getsigmask
  @findex proc posix_spawnattr_getsigmask*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_getsigmask*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_init
  @findex proc posix_spawnattr_init*(a1꞉ var Tposix_spawnattr)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_init*(a1꞉ var Tposix_spawnattr)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_setsigdefault
  @findex proc posix_spawnattr_setsigdefault*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_setsigdefault*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_setflags
  @findex proc posix_spawnattr_setflags*(a1꞉ var Tposix_spawnattr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_setflags*(a1꞉ var Tposix_spawnattr; a2꞉ cint)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_setpgroup
  @findex proc posix_spawnattr_setpgroup*(a1꞉ var Tposix_spawnattr; a2꞉ Pid)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_setpgroup*(a1꞉ var Tposix_spawnattr; a2꞉ Pid)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_setschedparam
  @findex proc posix_spawnattr_setschedparam*(a1꞉ var Tposix_spawnattr; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_setschedparam*(a1꞉ var Tposix_spawnattr; a2꞉ var Sched_param)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_setschedpolicy
  @findex proc posix_spawnattr_setschedpolicy*(a1꞉ var Tposix_spawnattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_setschedpolicy*(a1꞉ var Tposix_spawnattr; a2꞉ cint)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnattr_setsigmask
  @findex proc posix_spawnattr_setsigmask*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@example
proc posix_spawnattr_setsigmask*(a1꞉ var Tposix_spawnattr; a2꞉ var Sigset)꞉ cint @{.importc, header꞉ "<spawn.h>".@}
@end example
  

@item posix_spawnp
  @findex proc posix_spawnp*(a1꞉ var Pid; a2꞉ cstring; a3꞉ var Tposix_spawn_file_actions;a4꞉ var Tposix_spawnattr; a5, a6꞉ cstringArray)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@example
proc posix_spawnp*(a1꞉ var Pid; a2꞉ cstring; a3꞉ var Tposix_spawn_file_actions;a4꞉ var Tposix_spawnattr; a5, a6꞉ cstringArray)꞉ cint @{.importc,header꞉ "<spawn.h>".@}
@end example
  

@item getcontext
  @findex proc getcontext*(a1꞉ var Ucontext)꞉ cint @{.importc, header꞉ "<ucontext.h>".@}
@example
proc getcontext*(a1꞉ var Ucontext)꞉ cint @{.importc, header꞉ "<ucontext.h>".@}
@end example
  

@item makecontext
  @findex proc makecontext*(a1꞉ var Ucontext; a4꞉ proc () @{.noconv.@}; a3꞉ cint) @{.varargs, importc,header꞉ "<ucontext.h>".@}
@example
proc makecontext*(a1꞉ var Ucontext; a4꞉ proc () @{.noconv.@}; a3꞉ cint) @{.varargs, importc,header꞉ "<ucontext.h>".@}
@end example
  

@item setcontext
  @findex proc setcontext*(a1꞉ var Ucontext)꞉ cint @{.importc, header꞉ "<ucontext.h>".@}
@example
proc setcontext*(a1꞉ var Ucontext)꞉ cint @{.importc, header꞉ "<ucontext.h>".@}
@end example
  

@item swapcontext
  @findex proc swapcontext*(a1, a2꞉ var Ucontext)꞉ cint @{.importc, header꞉ "<ucontext.h>".@}
@example
proc swapcontext*(a1, a2꞉ var Ucontext)꞉ cint @{.importc, header꞉ "<ucontext.h>".@}
@end example
  

@item readv
  @findex proc readv*(a1꞉ cint; a2꞉ ptr IOVec; a3꞉ cint)꞉ int @{.importc, header꞉ "<sys/uio.h>".@}
@example
proc readv*(a1꞉ cint; a2꞉ ptr IOVec; a3꞉ cint)꞉ int @{.importc, header꞉ "<sys/uio.h>".@}
@end example
  

@item writev
  @findex proc writev*(a1꞉ cint; a2꞉ ptr IOVec; a3꞉ cint)꞉ int @{.importc, header꞉ "<sys/uio.h>".@}
@example
proc writev*(a1꞉ cint; a2꞉ ptr IOVec; a3꞉ cint)꞉ int @{.importc, header꞉ "<sys/uio.h>".@}
@end example
  

@item CMSG_DATA
  @findex proc CMSG_DATA*(cmsg꞉ ptr Tcmsghdr)꞉ cstring @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc CMSG_DATA*(cmsg꞉ ptr Tcmsghdr)꞉ cstring @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item CMSG_NXTHDR
  @findex proc CMSG_NXTHDR*(mhdr꞉ ptr Tmsghdr; cmsg꞉ ptr Tcmsghdr)꞉ ptr Tcmsghdr @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc CMSG_NXTHDR*(mhdr꞉ ptr Tmsghdr; cmsg꞉ ptr Tcmsghdr)꞉ ptr Tcmsghdr @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item CMSG_FIRSTHDR
  @findex proc CMSG_FIRSTHDR*(mhdr꞉ ptr Tmsghdr)꞉ ptr Tcmsghdr @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc CMSG_FIRSTHDR*(mhdr꞉ ptr Tmsghdr)꞉ ptr Tcmsghdr @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ SocketHandle)꞉ bool @{.borrow.@}
@example
proc `==`*(x, y꞉ SocketHandle)꞉ bool @{.borrow.@}
@end example
  

@item accept
  @findex proc accept*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ ptr Socklen)꞉ SocketHandle @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc accept*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ ptr Socklen)꞉ SocketHandle @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item bindSocket
  @findex proc bindSocket*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ Socklen)꞉ cint @{.importc꞉ "bind", header꞉ "<sys/socket.h>".@}
@example
proc bindSocket*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ Socklen)꞉ cint @{.importc꞉ "bind", header꞉ "<sys/socket.h>".@}
@end example
  is Posix's @code{bind}, because @code{bind} is a reserved word

@item connect
  @findex proc connect*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc connect*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item getpeername
  @findex proc getpeername*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ ptr Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc getpeername*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ ptr Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item getsockname
  @findex proc getsockname*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ ptr Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc getsockname*(a1꞉ SocketHandle; a2꞉ ptr SockAddr; a3꞉ ptr Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item getsockopt
  @findex proc getsockopt*(a1꞉ SocketHandle; a2, a3꞉ cint; a4꞉ pointer; a5꞉ ptr Socklen)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc getsockopt*(a1꞉ SocketHandle; a2, a3꞉ cint; a4꞉ pointer; a5꞉ ptr Socklen)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item listen
  @findex proc listen*(a1꞉ SocketHandle; a2꞉ cint)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc listen*(a1꞉ SocketHandle; a2꞉ cint)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item recv
  @findex proc recv*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc recv*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item recvfrom
  @findex proc recvfrom*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint; a5꞉ ptr SockAddr;a6꞉ ptr Socklen)꞉ int @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc recvfrom*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint; a5꞉ ptr SockAddr;a6꞉ ptr Socklen)꞉ int @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item recvmsg
  @findex proc recvmsg*(a1꞉ SocketHandle; a2꞉ ptr Tmsghdr; a3꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc recvmsg*(a1꞉ SocketHandle; a2꞉ ptr Tmsghdr; a3꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item send
  @findex proc send*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc send*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item sendmsg
  @findex proc sendmsg*(a1꞉ SocketHandle; a2꞉ ptr Tmsghdr; a3꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc sendmsg*(a1꞉ SocketHandle; a2꞉ ptr Tmsghdr; a3꞉ cint)꞉ int @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item sendto
  @findex proc sendto*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint; a5꞉ ptr SockAddr; a6꞉ Socklen)꞉ int @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc sendto*(a1꞉ SocketHandle; a2꞉ pointer; a3꞉ int; a4꞉ cint; a5꞉ ptr SockAddr; a6꞉ Socklen)꞉ int @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item setsockopt
  @findex proc setsockopt*(a1꞉ SocketHandle; a2, a3꞉ cint; a4꞉ pointer; a5꞉ Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc setsockopt*(a1꞉ SocketHandle; a2, a3꞉ cint; a4꞉ pointer; a5꞉ Socklen)꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item shutdown
  @findex proc shutdown*(a1꞉ SocketHandle; a2꞉ cint)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc shutdown*(a1꞉ SocketHandle; a2꞉ cint)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item socket
  @findex proc socket*(a1, a2, a3꞉ cint)꞉ SocketHandle @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc socket*(a1, a2, a3꞉ cint)꞉ SocketHandle @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item sockatmark
  @findex proc sockatmark*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@example
proc sockatmark*(a1꞉ cint)꞉ cint @{.importc, header꞉ "<sys/socket.h>".@}
@end example
  

@item socketpair
  @findex proc socketpair*(a1, a2, a3꞉ cint; a4꞉ var array[0 .. 1, cint])꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@example
proc socketpair*(a1, a2, a3꞉ cint; a4꞉ var array[0 .. 1, cint])꞉ cint @{.importc,header꞉ "<sys/socket.h>".@}
@end example
  

@item if_nametoindex
  @findex proc if_nametoindex*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<net/if.h>".@}
@example
proc if_nametoindex*(a1꞉ cstring)꞉ cint @{.importc, header꞉ "<net/if.h>".@}
@end example
  

@item if_indextoname
  @findex proc if_indextoname*(a1꞉ cint; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<net/if.h>".@}
@example
proc if_indextoname*(a1꞉ cint; a2꞉ cstring)꞉ cstring @{.importc, header꞉ "<net/if.h>".@}
@end example
  

@item if_nameindex
  @findex proc if_nameindex*()꞉ ptr Tif_nameindex @{.importc, header꞉ "<net/if.h>".@}
@example
proc if_nameindex*()꞉ ptr Tif_nameindex @{.importc, header꞉ "<net/if.h>".@}
@end example
  

@item if_freenameindex
  @findex proc if_freenameindex*(a1꞉ ptr Tif_nameindex) @{.importc, header꞉ "<net/if.h>".@}
@example
proc if_freenameindex*(a1꞉ ptr Tif_nameindex) @{.importc, header꞉ "<net/if.h>".@}
@end example
  

@item IN6_IS_ADDR_UNSPECIFIED
  @findex proc IN6_IS_ADDR_UNSPECIFIED*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_UNSPECIFIED*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@end example
  Unspecified address.

@item IN6_IS_ADDR_LOOPBACK
  @findex proc IN6_IS_ADDR_LOOPBACK*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_LOOPBACK*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  Loopback address.

@item IN6_IS_ADDR_MULTICAST
  @findex proc IN6_IS_ADDR_MULTICAST*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_MULTICAST*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  Multicast address.

@item IN6_IS_ADDR_LINKLOCAL
  @findex proc IN6_IS_ADDR_LINKLOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_LINKLOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  Unicast link-local address.

@item IN6_IS_ADDR_SITELOCAL
  @findex proc IN6_IS_ADDR_SITELOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_SITELOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  Unicast site-local address.

@item IN6_IS_ADDR_V4MAPPED
  @findex proc IN6_IS_ADDR_V4MAPPED*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_V4MAPPED*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  IPv4 mapped address.

@item IN6_IS_ADDR_V4COMPAT
  @findex proc IN6_IS_ADDR_V4COMPAT*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_V4COMPAT*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  IPv4-compatible address.

@item IN6_IS_ADDR_MC_NODELOCAL
  @findex proc IN6_IS_ADDR_MC_NODELOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_MC_NODELOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@end example
  Multicast node-local address.

@item IN6_IS_ADDR_MC_LINKLOCAL
  @findex proc IN6_IS_ADDR_MC_LINKLOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_MC_LINKLOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@end example
  Multicast link-local address.

@item IN6_IS_ADDR_MC_SITELOCAL
  @findex proc IN6_IS_ADDR_MC_SITELOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_MC_SITELOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@end example
  Multicast site-local address.

@item IN6_IS_ADDR_MC_ORGLOCAL
  @findex proc IN6_IS_ADDR_MC_ORGLOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_MC_ORGLOCAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc,header꞉ "<netinet/in.h>".@}
@end example
  Multicast organization-local address.

@item IN6_IS_ADDR_MC_GLOBAL
  @findex proc IN6_IS_ADDR_MC_GLOBAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@example
proc IN6_IS_ADDR_MC_GLOBAL*(a1꞉ ptr In6Addr)꞉ cint @{.importc, header꞉ "<netinet/in.h>".@}
@end example
  Multicast global address.

@item endhostent
  @findex proc endhostent*() @{.importc, header꞉ "<netdb.h>".@}
@example
proc endhostent*() @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item endnetent
  @findex proc endnetent*() @{.importc, header꞉ "<netdb.h>".@}
@example
proc endnetent*() @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item endprotoent
  @findex proc endprotoent*() @{.importc, header꞉ "<netdb.h>".@}
@example
proc endprotoent*() @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item endservent
  @findex proc endservent*() @{.importc, header꞉ "<netdb.h>".@}
@example
proc endservent*() @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item freeaddrinfo
  @findex proc freeaddrinfo*(a1꞉ ptr AddrInfo) @{.importc, header꞉ "<netdb.h>".@}
@example
proc freeaddrinfo*(a1꞉ ptr AddrInfo) @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item gai_strerror
  @findex proc gai_strerror*(a1꞉ cint)꞉ cstring @{.importc꞉ "(char *)$1", header꞉ "<netdb.h>".@}
@example
proc gai_strerror*(a1꞉ cint)꞉ cstring @{.importc꞉ "(char *)$1", header꞉ "<netdb.h>".@}
@end example
  

@item getaddrinfo
  @findex proc getaddrinfo*(a1, a2꞉ cstring; a3꞉ ptr AddrInfo; a4꞉ var ptr AddrInfo)꞉ cint @{.importc,header꞉ "<netdb.h>".@}
@example
proc getaddrinfo*(a1, a2꞉ cstring; a3꞉ ptr AddrInfo; a4꞉ var ptr AddrInfo)꞉ cint @{.importc,header꞉ "<netdb.h>".@}
@end example
  

@item gethostbyaddr
  @findex proc gethostbyaddr*(a1꞉ pointer; a2꞉ Socklen; a3꞉ cint)꞉ ptr Hostent @{.importc,header꞉ "<netdb.h>".@}
@example
proc gethostbyaddr*(a1꞉ pointer; a2꞉ Socklen; a3꞉ cint)꞉ ptr Hostent @{.importc,header꞉ "<netdb.h>".@}
@end example
  

@item gethostbyname
  @findex proc gethostbyname*(a1꞉ cstring)꞉ ptr Hostent @{.importc, header꞉ "<netdb.h>".@}
@example
proc gethostbyname*(a1꞉ cstring)꞉ ptr Hostent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item gethostent
  @findex proc gethostent*()꞉ ptr Hostent @{.importc, header꞉ "<netdb.h>".@}
@example
proc gethostent*()꞉ ptr Hostent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getnameinfo
  @findex proc getnameinfo*(a1꞉ ptr SockAddr; a2꞉ Socklen; a3꞉ cstring; a4꞉ Socklen; a5꞉ cstring;a6꞉ Socklen; a7꞉ cint)꞉ cint @{.importc, header꞉ "<netdb.h>".@}
@example
proc getnameinfo*(a1꞉ ptr SockAddr; a2꞉ Socklen; a3꞉ cstring; a4꞉ Socklen; a5꞉ cstring;a6꞉ Socklen; a7꞉ cint)꞉ cint @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getnetbyaddr
  @findex proc getnetbyaddr*(a1꞉ int32; a2꞉ cint)꞉ ptr Tnetent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getnetbyaddr*(a1꞉ int32; a2꞉ cint)꞉ ptr Tnetent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getnetbyname
  @findex proc getnetbyname*(a1꞉ cstring)꞉ ptr Tnetent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getnetbyname*(a1꞉ cstring)꞉ ptr Tnetent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getnetent
  @findex proc getnetent*()꞉ ptr Tnetent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getnetent*()꞉ ptr Tnetent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getprotobyname
  @findex proc getprotobyname*(a1꞉ cstring)꞉ ptr Protoent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getprotobyname*(a1꞉ cstring)꞉ ptr Protoent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getprotobynumber
  @findex proc getprotobynumber*(a1꞉ cint)꞉ ptr Protoent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getprotobynumber*(a1꞉ cint)꞉ ptr Protoent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getprotoent
  @findex proc getprotoent*()꞉ ptr Protoent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getprotoent*()꞉ ptr Protoent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getservbyname
  @findex proc getservbyname*(a1, a2꞉ cstring)꞉ ptr Servent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getservbyname*(a1, a2꞉ cstring)꞉ ptr Servent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getservbyport
  @findex proc getservbyport*(a1꞉ cint; a2꞉ cstring)꞉ ptr Servent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getservbyport*(a1꞉ cint; a2꞉ cstring)꞉ ptr Servent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item getservent
  @findex proc getservent*()꞉ ptr Servent @{.importc, header꞉ "<netdb.h>".@}
@example
proc getservent*()꞉ ptr Servent @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item sethostent
  @findex proc sethostent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@example
proc sethostent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item setnetent
  @findex proc setnetent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@example
proc setnetent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item setprotoent
  @findex proc setprotoent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@example
proc setprotoent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item setservent
  @findex proc setservent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@example
proc setservent*(a1꞉ cint) @{.importc, header꞉ "<netdb.h>".@}
@end example
  

@item poll
  @findex proc poll*(a1꞉ ptr TPollfd; a2꞉ Tnfds; a3꞉ int)꞉ cint @{.importc, header꞉ "<poll.h>".@}
@example
proc poll*(a1꞉ ptr TPollfd; a2꞉ Tnfds; a3꞉ int)꞉ cint @{.importc, header꞉ "<poll.h>".@}
@end example
  

@item realpath
  @findex proc realpath*(name, resolved꞉ cstring)꞉ cstring @{.importc꞉ "realpath",header꞉ "<stdlib.h>".@}
@example
proc realpath*(name, resolved꞉ cstring)꞉ cstring @{.importc꞉ "realpath",header꞉ "<stdlib.h>".@}
@end example
  

@item utimes
  @findex proc utimes*(path꞉ cstring; times꞉ ptr array[2, Timeval])꞉ int @{.importc꞉ "utimes",header꞉ "<sys/time.h>".@}
@example
proc utimes*(path꞉ cstring; times꞉ ptr array[2, Timeval])꞉ int @{.importc꞉ "utimes",header꞉ "<sys/time.h>".@}
@end example
  Sets file access and modification times.

Pass the filename and an array of times to set the access and modification times respectively. If you pass nil as the array both attributes will be set to the current time.

Returns zero on success.

For more information read @uref{http://www.unix.com/man-page/posix/3/utimes/, http://www.unix.com/man-page/posix/3/utimes/}.
@end itemize






@node /posix/inotify, /posix/termios , /posix/posix, Top
@chapter Constant variables

@itemize


@item IN_MOVE_SELF
  @vindex IN_MOVE_SELF* = 0x00000800
@example
IN_MOVE_SELF* = 0x00000800
@end example
  

@item IN_IGNORED
  @vindex IN_IGNORED* = 0x00008000
@example
IN_IGNORED* = 0x00008000
@end example
  

@item IN_ONESHOT
  @vindex IN_ONESHOT* = 0x0000000080000000'i64
@example
IN_ONESHOT* = 0x0000000080000000'i64
@end example
  

@item IN_ALL_EVENTS
  @vindex IN_ALL_EVENTS* = (IN_ACCESS or IN_MODIFY or IN_ATTRIB or IN_CLOSE_WRITE orIN_CLOSE_NOWRITE or IN_OPEN or IN_MOVED_FROM or IN_MOVED_TO or IN_CREATE orIN_DELETE or IN_DELETE_SELF or IN_MOVE_SELF)
@example
IN_ALL_EVENTS* = (IN_ACCESS or IN_MODIFY or IN_ATTRIB or IN_CLOSE_WRITE orIN_CLOSE_NOWRITE or IN_OPEN or IN_MOVED_FROM or IN_MOVED_TO or IN_CREATE orIN_DELETE or IN_DELETE_SELF or IN_MOVE_SELF)
@end example
  
@end itemize



@chapter Types

@itemize


@item InotifyEvent
  @tindex InotifyEvent* @{.pure, final, importc: "struct inotify_event",
               header: "<sys/inotify.h>".@} = object
  wd* @{.importc: "wd".@}: cint
  mask* @{.importc: "mask".@}: uint32
  cookie* @{.importc: "cookie".@}: uint32
  len* @{.importc: "len".@}: uint32
  name* @{.importc: "name".@}: char

@example
InotifyEvent* @{.pure, final, importc: "struct inotify_event",
               header: "<sys/inotify.h>".@} = object
  wd* @{.importc: "wd".@}: cint
  mask* @{.importc: "mask".@}: uint32
  cookie* @{.importc: "cookie".@}: uint32
  len* @{.importc: "len".@}: uint32
  name* @{.importc: "name".@}: char

@end example
  
@end itemize

@chapter Procedures

@itemize


@item inotify_init
  @findex proc inotify_init*()꞉ cint @{.cdecl, importc꞉ "inotify_init", header꞉ "<sys/inotify.h>".@}
@example
proc inotify_init*()꞉ cint @{.cdecl, importc꞉ "inotify_init", header꞉ "<sys/inotify.h>".@}
@end example
  

@item inotify_init1
  @findex proc inotify_init1*(flags꞉ cint)꞉ cint @{.cdecl, importc꞉ "inotify_init1",header꞉ "<sys/inotify.h>".@}
@example
proc inotify_init1*(flags꞉ cint)꞉ cint @{.cdecl, importc꞉ "inotify_init1",header꞉ "<sys/inotify.h>".@}
@end example
  

@item inotify_add_watch
  @findex proc inotify_add_watch*(fd꞉ cint; name꞉ cstring; mask꞉ uint32)꞉ cint @{.cdecl,importc꞉ "inotify_add_watch", header꞉ "<sys/inotify.h>".@}
@example
proc inotify_add_watch*(fd꞉ cint; name꞉ cstring; mask꞉ uint32)꞉ cint @{.cdecl,importc꞉ "inotify_add_watch", header꞉ "<sys/inotify.h>".@}
@end example
  

@item inotify_rm_watch
  @findex proc inotify_rm_watch*(fd꞉ cint; wd꞉ cint)꞉ cint @{.cdecl, importc꞉ "inotify_rm_watch",header꞉ "<sys/inotify.h>".@}
@example
proc inotify_rm_watch*(fd꞉ cint; wd꞉ cint)꞉ cint @{.cdecl, importc꞉ "inotify_rm_watch",header꞉ "<sys/inotify.h>".@}
@end example
  
@end itemize






@node /posix/termios, /posix/kqueue , /posix/inotify, Top
@chapter Constant variables

@itemize


@item NCCS
  @vindex NCCS* = 32
@example
NCCS* = 32
@end example
  

@item VEOL2
  @vindex VEOL2* = 16
@example
VEOL2* = 16
@end example
  

@item IUTF8
  @vindex IUTF8* = 40000
@example
IUTF8* = 40000
@end example
  

@item XTABS
  @vindex XTABS* = 14000
@example
XTABS* = 14000
@end example
  

@item CRTSCTS
  @vindex CRTSCTS* = 0o000000000000020000000000'i64
@example
CRTSCTS* = 0o000000000000020000000000'i64
@end example
  

@item EXTPROC
  @vindex EXTPROC* = 0o000000200000
@example
EXTPROC* = 0o000000200000
@end example
  

@item TCION
  @vindex TCION* = 3
@example
TCION* = 3
@end example
  

@item TCIOFLUSH
  @vindex TCIOFLUSH* = 2
@example
TCIOFLUSH* = 2
@end example
  

@item TCSAFLUSH
  @vindex TCSAFLUSH* = 2
@example
TCSAFLUSH* = 2
@end example
  
@end itemize



@chapter Types

@itemize


@item Cflag
  @tindex Cflag* = cuint
@example
Cflag* = cuint
@end example
  

@item Termios
  @tindex Termios* @{.importc: "struct termios", header: "<termios.h>".@} = object
  c_iflag*: Cflag
  c_oflag*: Cflag
  c_cflag*: Cflag
  c_lflag*: Cflag
  c_cc*: array[NCCS, cuchar]

@example
Termios* @{.importc: "struct termios", header: "<termios.h>".@} = object
  c_iflag*: Cflag
  c_oflag*: Cflag
  c_cflag*: Cflag
  c_lflag*: Cflag
  c_cc*: array[NCCS, cuchar]

@end example
  
@end itemize

@chapter Procedures

@itemize


@item cfGetOspeed
  @findex proc cfGetOspeed*(termios꞉ ptr Termios)꞉ Speed @{.importc꞉ "cfgetospeed",header꞉ "<termios.h>".@}
@example
proc cfGetOspeed*(termios꞉ ptr Termios)꞉ Speed @{.importc꞉ "cfgetospeed",header꞉ "<termios.h>".@}
@end example
  

@item cfGetIspeed
  @findex proc cfGetIspeed*(termios꞉ ptr Termios)꞉ Speed @{.importc꞉ "cfgetispeed",header꞉ "<termios.h>".@}
@example
proc cfGetIspeed*(termios꞉ ptr Termios)꞉ Speed @{.importc꞉ "cfgetispeed",header꞉ "<termios.h>".@}
@end example
  

@item cfSetOspeed
  @findex proc cfSetOspeed*(termios꞉ ptr Termios; speed꞉ Speed)꞉ cint @{.importc꞉ "cfsetospeed",header꞉ "<termios.h>".@}
@example
proc cfSetOspeed*(termios꞉ ptr Termios; speed꞉ Speed)꞉ cint @{.importc꞉ "cfsetospeed",header꞉ "<termios.h>".@}
@end example
  

@item cfSetIspeed
  @findex proc cfSetIspeed*(termios꞉ ptr Termios; speed꞉ Speed)꞉ cint @{.importc꞉ "cfsetispeed",header꞉ "<termios.h>".@}
@example
proc cfSetIspeed*(termios꞉ ptr Termios; speed꞉ Speed)꞉ cint @{.importc꞉ "cfsetispeed",header꞉ "<termios.h>".@}
@end example
  

@item cfSetSpeed
  @findex proc cfSetSpeed*(termios꞉ ptr Termios; speed꞉ Speed)꞉ cint @{.importc꞉ "cfsetspeed",header꞉ "<termios.h>".@}
@example
proc cfSetSpeed*(termios꞉ ptr Termios; speed꞉ Speed)꞉ cint @{.importc꞉ "cfsetspeed",header꞉ "<termios.h>".@}
@end example
  

@item tcGetAttr
  @findex proc tcGetAttr*(fd꞉ cint; termios꞉ ptr Termios)꞉ cint @{.importc꞉ "tcgetattr",header꞉ "<termios.h>".@}
@example
proc tcGetAttr*(fd꞉ cint; termios꞉ ptr Termios)꞉ cint @{.importc꞉ "tcgetattr",header꞉ "<termios.h>".@}
@end example
  

@item tcSetAttr
  @findex proc tcSetAttr*(fd꞉ cint; optional_actions꞉ cint; termios꞉ ptr Termios)꞉ cint @{.importc꞉ "tcsetattr", header꞉ "<termios.h>".@}
@example
proc tcSetAttr*(fd꞉ cint; optional_actions꞉ cint; termios꞉ ptr Termios)꞉ cint @{.importc꞉ "tcsetattr", header꞉ "<termios.h>".@}
@end example
  

@item cfMakeRaw
  @findex proc cfMakeRaw*(termios꞉ ptr Termios) @{.importc꞉ "cfmakeraw", header꞉ "<termios.h>".@}
@example
proc cfMakeRaw*(termios꞉ ptr Termios) @{.importc꞉ "cfmakeraw", header꞉ "<termios.h>".@}
@end example
  

@item tcSendBreak
  @findex proc tcSendBreak*(fd꞉ cint; duration꞉ cint)꞉ cint @{.importc꞉ "tcsendbreak",header꞉ "<termios.h>".@}
@example
proc tcSendBreak*(fd꞉ cint; duration꞉ cint)꞉ cint @{.importc꞉ "tcsendbreak",header꞉ "<termios.h>".@}
@end example
  

@item tcDrain
  @findex proc tcDrain*(fd꞉ cint)꞉ cint @{.importc꞉ "tcdrain", header꞉ "<termios.h>".@}
@example
proc tcDrain*(fd꞉ cint)꞉ cint @{.importc꞉ "tcdrain", header꞉ "<termios.h>".@}
@end example
  

@item tcFlush
  @findex proc tcFlush*(fd꞉ cint; queue_selector꞉ cint)꞉ cint @{.importc꞉ "tcflush",header꞉ "<termios.h>".@}
@example
proc tcFlush*(fd꞉ cint; queue_selector꞉ cint)꞉ cint @{.importc꞉ "tcflush",header꞉ "<termios.h>".@}
@end example
  

@item tcFlow
  @findex proc tcFlow*(fd꞉ cint; action꞉ cint)꞉ cint @{.importc꞉ "tcflow", header꞉ "<termios.h>".@}
@example
proc tcFlow*(fd꞉ cint; action꞉ cint)꞉ cint @{.importc꞉ "tcflow", header꞉ "<termios.h>".@}
@end example
  

@item tcGetSid
  @findex proc tcGetSid*(fd꞉ cint)꞉ Pid @{.importc꞉ "tcgetsid", header꞉ "<termios.h>".@}
@example
proc tcGetSid*(fd꞉ cint)꞉ Pid @{.importc꞉ "tcgetsid", header꞉ "<termios.h>".@}
@end example
  
@end itemize

@chapter Templates

@itemize


@item cceq
  @findex template cceq*(val, c꞉ expr)꞉ expr
@example
template cceq*(val, c꞉ expr)꞉ expr
@end example
  
@end itemize





@node /posix/kqueue, /posix/linux , /posix/termios, Top
@chapter Constant variables

@itemize


@item EVFILT_VM
  @vindex EVFILT_VM* = - 12
@example
EVFILT_VM* = - 12
@end example
  

@item EV_DISABLE
  @vindex EV_DISABLE* = 0x00000008
@example
EV_DISABLE* = 0x00000008
@end example
  Disable event (not reported).

@item EV_DISPATCH
  @vindex EV_DISPATCH* = 0x00000080
@example
EV_DISPATCH* = 0x00000080
@end example
  Disable event after reporting.

@item EV_ERROR
  @vindex EV_ERROR* = 0x00004000
@example
EV_ERROR* = 0x00004000
@end example
  Error, data contains errno
@end itemize



@chapter Types

@itemize


@item KEvent
  @tindex KEvent* @{.importc: "struct kevent", header: "<sys/event.h>", pure, final.@} = object
  ident*: cuint
  filter*: cshort              ## filter for event
  flags*: cushort              ## general flags
  fflags*: cuint               ## filter-specific flags
  data*: cuint                 ## filter-specific data  (intptr_t)
  
@example
KEvent* @{.importc: "struct kevent", header: "<sys/event.h>", pure, final.@} = object
  ident*: cuint
  filter*: cshort              ## filter for event
  flags*: cushort              ## general flags
  fflags*: cuint               ## filter-specific flags
  data*: cuint                 ## filter-specific data  (intptr_t)
  
@end example
  identifier for this event  (uintptr_t)
@end itemize

@chapter Procedures

@itemize


@item kqueue
  @findex proc kqueue*()꞉ cint @{.importc꞉ "kqueue", header꞉ "<sys/event.h>".@}
@example
proc kqueue*()꞉ cint @{.importc꞉ "kqueue", header꞉ "<sys/event.h>".@}
@end example
  Creates new queue and returns its descriptor.

@item kevent
  @findex proc kevent*(kqFD꞉ cint; changelist꞉ ptr KEvent; nchanges꞉ cint; eventlist꞉ ptr KEvent;nevents꞉ cint; timeout꞉ ptr Timespec)꞉ cint @{.importc꞉ "kevent",header꞉ "<sys/event.h>".@}
@example
proc kevent*(kqFD꞉ cint; changelist꞉ ptr KEvent; nchanges꞉ cint; eventlist꞉ ptr KEvent;nevents꞉ cint; timeout꞉ ptr Timespec)꞉ cint @{.importc꞉ "kevent",header꞉ "<sys/event.h>".@}
@end example
  Manipulates queue for given @code{kqFD} descriptor.

@item EV_SET
  @findex proc EV_SET*(event꞉ ptr KEvent; ident꞉ cuint; filter꞉ cshort; flags꞉ cushort;fflags꞉ cuint; data꞉ cuint; udata꞉ ptr void) @{.importc꞉ "EV_SET",header꞉ "<sys/event.h>".@}
@example
proc EV_SET*(event꞉ ptr KEvent; ident꞉ cuint; filter꞉ cshort; flags꞉ cushort;fflags꞉ cuint; data꞉ cuint; udata꞉ ptr void) @{.importc꞉ "EV_SET",header꞉ "<sys/event.h>".@}
@end example
  Fills event with given data.
@end itemize






@node /posix/linux, /packages/docutils/rstast , /posix/kqueue, Top
@chapter Constant variables

@itemize


@item CLONE_STOPPED
  @vindex CLONE_STOPPED* = 0x02000000
@example
CLONE_STOPPED* = 0x02000000
@end example
  
@end itemize




@chapter Procedures

@itemize


@item clone
  @findex proc clone*(fn꞉ pointer; child_stack꞉ pointer; flags꞉ cint; arg꞉ pointer; ptid꞉ ptr Pid;tls꞉ pointer; ctid꞉ ptr Pid)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@example
proc clone*(fn꞉ pointer; child_stack꞉ pointer; flags꞉ cint; arg꞉ pointer; ptid꞉ ptr Pid;tls꞉ pointer; ctid꞉ ptr Pid)꞉ cint @{.importc, header꞉ "<sched.h>".@}
@end example
  
@end itemize






@node /packages/docutils/rstast, /packages/docutils/highlite , /posix/linux, Top



@chapter Types

@itemize


@item RstNode
  @tindex RstNode* @{.acyclic, final.@} = object
  kind*: RstNodeKind           ## the node's kind
  text*: string                ## valid for leafs in the AST; and the title of
              ## the document or the section
  level*: int                  ## valid for some node kinds
  sons*: RstNodeSeq            ## the node's sons
  
@example
RstNode* @{.acyclic, final.@} = object
  kind*: RstNodeKind           ## the node's kind
  text*: string                ## valid for leafs in the AST; and the title of
              ## the document or the section
  level*: int                  ## valid for some node kinds
  sons*: RstNodeSeq            ## the node's sons
  
@end example
  an RST node's description
@end itemize

@chapter Procedures

@itemize


@item len
  @findex proc len*(n꞉ PRstNode)꞉ int
@example
proc len*(n꞉ PRstNode)꞉ int
@end example
  

@item newRstNode
  @findex proc newRstNode*(kind꞉ RstNodeKind)꞉ PRstNode
@example
proc newRstNode*(kind꞉ RstNodeKind)꞉ PRstNode
@end example
  

@item newRstNode
  @findex proc newRstNode*(kind꞉ RstNodeKind; s꞉ string)꞉ PRstNode
@example
proc newRstNode*(kind꞉ RstNodeKind; s꞉ string)꞉ PRstNode
@end example
  

@item lastSon
  @findex proc lastSon*(n꞉ PRstNode)꞉ PRstNode
@example
proc lastSon*(n꞉ PRstNode)꞉ PRstNode
@end example
  

@item add
  @findex proc add*(father, son꞉ PRstNode)
@example
proc add*(father, son꞉ PRstNode)
@end example
  

@item addIfNotNil
  @findex proc addIfNotNil*(father, son꞉ PRstNode)
@example
proc addIfNotNil*(father, son꞉ PRstNode)
@end example
  

@item renderRstToRst
  @findex proc renderRstToRst*(n꞉ PRstNode; result꞉ var string)
@example
proc renderRstToRst*(n꞉ PRstNode; result꞉ var string)
@end example
  renders @emph{n} into its string representation and appends to @emph{result}.

@item renderRstToJson
  @findex proc renderRstToJson*(node꞉ PRstNode)꞉ string
@example
proc renderRstToJson*(node꞉ PRstNode)꞉ string
@end example
  Writes the given RST node as JSON that is in the form
@verbatim
@{
  "kind":string node.kind,
  "text":optional string node.text,
  "level":optional int node.level,
  "sons":optional node array
@}
@end verbatim
@end itemize






@node /packages/docutils/highlite, /packages/docutils/rst , /packages/docutils/rstast, Top



@chapter Types

@itemize


@item SourceLanguage
  @tindex SourceLanguage* = enumlangNone, langNim, langNimrod, langCpp, langCsharp, langC, langJava
@example
SourceLanguage* = enumlangNone, langNim, langNimrod, langCpp, langCsharp, langC, langJava
@end example
  
@end itemize

@chapter Procedures

@itemize


@item getSourceLanguage
  @findex proc getSourceLanguage*(name꞉ string)꞉ SourceLanguage
@example
proc getSourceLanguage*(name꞉ string)꞉ SourceLanguage
@end example
  

@item initGeneralTokenizer
  @findex proc initGeneralTokenizer*(g꞉ var GeneralTokenizer; buf꞉ cstring)
@example
proc initGeneralTokenizer*(g꞉ var GeneralTokenizer; buf꞉ cstring)
@end example
  

@item initGeneralTokenizer
  @findex proc initGeneralTokenizer*(g꞉ var GeneralTokenizer; buf꞉ string)
@example
proc initGeneralTokenizer*(g꞉ var GeneralTokenizer; buf꞉ string)
@end example
  

@item deinitGeneralTokenizer
  @findex proc deinitGeneralTokenizer*(g꞉ var GeneralTokenizer)
@example
proc deinitGeneralTokenizer*(g꞉ var GeneralTokenizer)
@end example
  

@item getNextToken
  @findex proc getNextToken*(g꞉ var GeneralTokenizer; lang꞉ SourceLanguage)
@example
proc getNextToken*(g꞉ var GeneralTokenizer; lang꞉ SourceLanguage)
@end example
  
@end itemize






@node /packages/docutils/rst, /packages/docutils/rstgen , /packages/docutils/highlite, Top



@chapter Types

@itemize


@item FindFileHandler
  @tindex FindFileHandler* = proc (filename꞉ string)꞉ string @{.nimcall.@}
@example
FindFileHandler* = proc (filename꞉ string)꞉ string @{.nimcall.@}
@end example
  

@item EParseError
  @tindex EParseError* = object of ValueError
@example
EParseError* = object of ValueError
@end example
  
@end itemize

@chapter Procedures

@itemize


@item rstnodeToRefname
  @findex proc rstnodeToRefname*(n꞉ PRstNode)꞉ string
@example
proc rstnodeToRefname*(n꞉ PRstNode)꞉ string
@end example
  

@item addNodes
  @findex proc addNodes*(n꞉ PRstNode)꞉ string
@example
proc addNodes*(n꞉ PRstNode)꞉ string
@end example
  

@item getFieldValue
  @findex proc getFieldValue*(n꞉ PRstNode; fieldname꞉ string)꞉ string
@example
proc getFieldValue*(n꞉ PRstNode; fieldname꞉ string)꞉ string
@end example
  

@item getArgument
  @findex proc getArgument*(n꞉ PRstNode)꞉ string
@example
proc getArgument*(n꞉ PRstNode)꞉ string
@end example
  

@item whichMsgClass
  @findex proc whichMsgClass*(k꞉ MsgKind)꞉ MsgClass
@example
proc whichMsgClass*(k꞉ MsgKind)꞉ MsgClass
@end example
  returns which message class @emph{k} belongs to.

@item defaultMsgHandler
  @findex proc defaultMsgHandler*(filename꞉ string; line, col꞉ int; msgkind꞉ MsgKind; arg꞉ string) @{.procvar.@}
@example
proc defaultMsgHandler*(filename꞉ string; line, col꞉ int; msgkind꞉ MsgKind; arg꞉ string) @{.procvar.@}
@end example
  

@item defaultFindFile
  @findex proc defaultFindFile*(filename꞉ string)꞉ string @{.procvar.@}
@example
proc defaultFindFile*(filename꞉ string)꞉ string @{.procvar.@}
@end example
  

@item getFieldValue
  @findex proc getFieldValue*(n꞉ PRstNode)꞉ string
@example
proc getFieldValue*(n꞉ PRstNode)꞉ string
@end example
  Returns the value of a specific @code{rnField} node.

This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.

@item rstParse
  @findex proc rstParse*(text, filename꞉ string; line, column꞉ int; hasToc꞉ var bool;options꞉ RstParseOptions; findFile꞉ FindFileHandler = nil;msgHandler꞉ MsgHandler = nil)꞉ PRstNode
@example
proc rstParse*(text, filename꞉ string; line, column꞉ int; hasToc꞉ var bool;options꞉ RstParseOptions; findFile꞉ FindFileHandler = nil;msgHandler꞉ MsgHandler = nil)꞉ PRstNode
@end example
  
@end itemize






@node /packages/docutils/rstgen, /pure/asyncnet , /packages/docutils/rst, Top
@chapter Constant variables

@itemize


@item IndexExt
  @vindex IndexExt* = ".idx"
@example
IndexExt* = ".idx"
@end example
  
@end itemize


@chapter Variables

@itemize


@item splitter
  @vindex splitter*꞉ string = "<wbr />"
@example
splitter*꞉ string = "<wbr />"
@end example
  
@end itemize


@chapter Procedures

@itemize


@item initRstGenerator
  @findex proc initRstGenerator*(g: var RstGenerator; target: OutputTarget;
                      config: StringTableRef; filename: string;
                      options: RstParseOptions; findFile: FindFileHandler = nil;
                      msgHandler: MsgHandler = nil)
@example
proc initRstGenerator*(g: var RstGenerator; target: OutputTarget;
                      config: StringTableRef; filename: string;
                      options: RstParseOptions; findFile: FindFileHandler = nil;
                      msgHandler: MsgHandler = nil)
@end example
  Initializes a @code{RstGenerator}.

You need to call this before using a @code{RstGenerator} with any other procs in this module. Pass a non @code{nil} @code{StringTableRef} value as @emph{config} with parameters used by the HTML output generator.  If you don't know what to use, pass the results of the @emph{defaultConfig() <#defaultConfig>_} proc.

The @emph{filename} parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If @emph{filename} ends with the @code{.nim} extension, the title for the document will be set by default to @code{Module filename}.  This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.

The @code{RstParseOptions}, @code{FindFileHandler} and @code{MsgHandler} types are defined in the the @uref{rst.html, packages/docutils/rst module}. @code{options} selects the behaviour of the rst parser.

@code{findFile} is a proc used by the rst @code{include} directive among others. The purpose of this proc is to mangle or filter paths. It receives paths specified in the rst document and has to return a valid path to existing files or the empty string otherwise.  If you pass @code{nil}, a default proc will be used which given a path returns the input path only if the file exists. One use for this proc is to transform relative paths found in the document to absolute path, useful if the rst file and the resources it references are not in the same directory as the current working directory.

The @code{msgHandler} is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass @code{nil}, a default message handler will be used which writes the messages to the standard output.

Example:


@example

import packages/docutils/rstgen

var gen: RstGenerator
gen.initRstGenerator(outHtml, defaultConfig(), "filename", @{@})
@end example

@item writeIndexFile
  @findex proc writeIndexFile*(g꞉ var RstGenerator; outfile꞉ string)
@example
proc writeIndexFile*(g꞉ var RstGenerator; outfile꞉ string)
@end example
  Writes the current index buffer to the specified output file.

You previously need to add entries to the index with the @uref{#setIndexTerm, setIndexTerm()} proc. If the index is empty the file won't be created.

@item escChar
  @findex proc escChar*(target꞉ OutputTarget; dest꞉ var string; c꞉ char) @{.inline.@}
@example
proc escChar*(target꞉ OutputTarget; dest꞉ var string; c꞉ char) @{.inline.@}
@end example
  

@item nextSplitPoint
  @findex proc nextSplitPoint*(s꞉ string; start꞉ int)꞉ int
@example
proc nextSplitPoint*(s꞉ string; start꞉ int)꞉ int
@end example
  

@item esc
  @findex proc esc*(target꞉ OutputTarget; s꞉ string; splitAfter = - 1)꞉ string
@example
proc esc*(target꞉ OutputTarget; s꞉ string; splitAfter = - 1)꞉ string
@end example
  

@item renderRstToOut
  @findex proc renderRstToOut*(d꞉ var RstGenerator; n꞉ PRstNode; result꞉ var string)
@example
proc renderRstToOut*(d꞉ var RstGenerator; n꞉ PRstNode; result꞉ var string)
@end example
  Writes into @code{result} the rst ast @code{n} using the @code{d} configuration.

Before using this proc you need to initialise a @code{RstGenerator} with @code{initRstGenerator} and parse a rst file with @code{rstParse} from the @uref{rst.html, packages/docutils/rst module}. Example:


@example

# ...configure gen and rst vars...
var generatedHTML = ""
renderRstToOut(gen, rst, generatedHTML)
echo generatedHTML
@end example

@item setIndexTerm
  @findex proc setIndexTerm*(d꞉ var RstGenerator; id, term꞉ string; linkTitle, linkDesc = "")
@example
proc setIndexTerm*(d꞉ var RstGenerator; id, term꞉ string; linkTitle, linkDesc = "")
@end example
  Adds a @emph{term} to the index using the specified hyperlink identifier.

A new entry will be added to the index using the format @code{term<tab>file#id}. The file part will come from the @emph{filename} parameter used in a previous call to the @uref{#initRstGenerator, initRstGenerator()} proc.

The @emph{id} will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty @emph{id} value for the title of standalone rst documents (they are special for the @uref{#mergeIndexes, mergeIndexes()} proc, see @uref{docgen.html#index-idx-file-format, Index (idx) file format} for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.

If @emph{linkTitle} or @emph{linkDesc} are not the empty string, two additional columns with their contents will be added.

The index won't be written to disk unless you call @uref{#writeIndexFile, writeIndexFile()}. The purpose of the index is documented in the @uref{docgen.html#index-switch, docgen tools guide}.

@item renderIndexTerm
  @findex proc renderIndexTerm*(d꞉ PDoc; n꞉ PRstNode; result꞉ var string)
@example
proc renderIndexTerm*(d꞉ PDoc; n꞉ PRstNode; result꞉ var string)
@end example
  Renders the string decorated within `foobar`:idx: markers.

Additionally adds the encosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.

@item mergeIndexes
  @findex proc mergeIndexes*(dir꞉ string)꞉ string
@example
proc mergeIndexes*(dir꞉ string)꞉ string
@end example
  Merges all index files in @emph{dir} and returns the generated index as HTML.

This proc will first scan @emph{dir} for index files with the @code{.idx} extension previously created by commands like @code{nim doc|rst2html} which use the @code{--index:on} switch. These index files are the result of calls to @uref{#setIndexTerm, setIndexTerm()} and @uref{#writeIndexFile, writeIndexFile()}, so they are simple tab separated files.

As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.

To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered @emph{documentation}, since this hash-less entry is the explicit title of the document.  Indices without this explicit entry will be considered @emph{generated API} extracted out of a source @code{.nim} file.

Returns the merged and sorted indices into a single HTML block which can be further embedded into nimdoc templates.

@item renderTocEntries
  @findex proc renderTocEntries*(d꞉ var RstGenerator; j꞉ var int; lvl꞉ int; result꞉ var string)
@example
proc renderTocEntries*(d꞉ var RstGenerator; j꞉ var int; lvl꞉ int; result꞉ var string)
@end example
  

@item formatNamedVars
  @findex proc formatNamedVars*(frmt꞉ string; varnames꞉ openArray[string];varvalues꞉ openArray[string])꞉ string
@example
proc formatNamedVars*(frmt꞉ string; varnames꞉ openArray[string];varvalues꞉ openArray[string])꞉ string
@end example
  

@item defaultConfig
  @findex proc defaultConfig*()꞉ StringTableRef
@example
proc defaultConfig*()꞉ StringTableRef
@end example
  Returns a default configuration for embedded HTML generation.

The returned @code{StringTableRef} contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file @code{config/nimdoc.cfg} bundled with the compiler.

The only difference between the contents of that file and the values provided by this proc is the @code{doc.file} variable. The @code{doc.file} variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like @code{rstToHtml} to generate the bare minimum HTML.

@item rstToHtml
  @findex proc rstToHtml*(s꞉ string; options꞉ RstParseOptions; config꞉ StringTableRef)꞉ string
@example
proc rstToHtml*(s꞉ string; options꞉ RstParseOptions; config꞉ StringTableRef)꞉ string
@end example
  Converts an input rst string into embeddable HTML.

This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in @emph{online} environments without access to a meaningful filesystem, and therefore rst @code{include} like directives won't work. For an explanation of the @code{config} parameter see the @code{initRstGenerator} proc. Example:


@example
import packages/docutils/rstgen, strtabs

echo rstToHtml("*Hello* **world**!", @{@},
  newStringTable(modeStyleInsensitive))
# --> <em>Hello</em> <strong>world</strong>!
@end example
If you need to allow the rst @code{include} directive or tweak the generated output you have to create your own @code{RstGenerator} with @code{initRstGenerator} and related procs.
@end itemize






@node /pure/asyncnet, /pure/nimprof , /packages/docutils/rstgen, Top



@chapter Types

@itemize


@item AsyncSocket
  @tindex AsyncSocket* = ref AsyncSocketDesc
@example
AsyncSocket* = ref AsyncSocketDesc
@end example
  
@end itemize

@chapter Procedures

@itemize


@item newAsyncSocket
  @findex proc newAsyncSocket*(fd꞉ AsyncFD; domain꞉ Domain = AF_INET;sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ AsyncSocket
@example
proc newAsyncSocket*(fd꞉ AsyncFD; domain꞉ Domain = AF_INET;sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ AsyncSocket
@end example
  Creates a new @code{AsyncSocket} based on the supplied params.

@item newAsyncSocket
  @findex proc newAsyncSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ AsyncSocket
@example
proc newAsyncSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ AsyncSocket
@end example
  Creates a new asynchronous socket.

This procedure will also create a brand new file descriptor for this socket.

@item newAsyncSocket
  @findex proc newAsyncSocket*(domain, sockType, protocol꞉ cint; buffered = true)꞉ AsyncSocket
@example
proc newAsyncSocket*(domain, sockType, protocol꞉ cint; buffered = true)꞉ AsyncSocket
@end example
  Creates a new asynchronous socket.

This procedure will also create a brand new file descriptor for this socket.

@item connect
  @findex proc connect*(socket꞉ AsyncSocket; address꞉ string; port꞉ Port) @{.async.@}
@example
proc connect*(socket꞉ AsyncSocket; address꞉ string; port꞉ Port) @{.async.@}
@end example
  Connects @code{socket} to server at @code{address:port}.

Returns a @code{Future} which will complete when the connection succeeds or an error occurs.

@item recv
  @findex proc recv*(socket꞉ AsyncSocket; size꞉ int; flags = @{SocketFlag.SafeDisconn@})꞉ Future[string] @{.async.@}
@example
proc recv*(socket꞉ AsyncSocket; size꞉ int; flags = @{SocketFlag.SafeDisconn@})꞉ Future[string] @{.async.@}
@end example
  Reads @strong{up to} @code{size} bytes from @code{socket}.

For buffered sockets this function will attempt to read all the requested data. It will read this data in @code{BufferSize} chunks.

For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.

If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.

If socket is disconnected and no data is available to be read then the future will complete with a value of @code{""}.

@item send
  @findex proc send*(socket꞉ AsyncSocket; data꞉ string; flags = @{SocketFlag.SafeDisconn@}) @{.async.@}
@example
proc send*(socket꞉ AsyncSocket; data꞉ string; flags = @{SocketFlag.SafeDisconn@}) @{.async.@}
@end example
  Sends @code{data} to @code{socket}. The returned future will complete once all data has been sent.

@item acceptAddr
  @findex proc acceptAddr*(socket꞉ AsyncSocket; flags = @{SocketFlag.SafeDisconn@})꞉ Future[tuple[address꞉ string, client꞉ AsyncSocket]]
@example
proc acceptAddr*(socket꞉ AsyncSocket; flags = @{SocketFlag.SafeDisconn@})꞉ Future[tuple[address꞉ string, client꞉ AsyncSocket]]
@end example
  Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.

@item accept
  @findex proc accept*(socket꞉ AsyncSocket; flags = @{SocketFlag.SafeDisconn@})꞉ Future[AsyncSocket]
@example
proc accept*(socket꞉ AsyncSocket; flags = @{SocketFlag.SafeDisconn@})꞉ Future[AsyncSocket]
@end example
  Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted.

@item recvLineInto
  @findex proc recvLineInto*(socket꞉ AsyncSocket; resString꞉ FutureVar[string];flags = @{SocketFlag.SafeDisconn@}) @{.async.@}
@example
proc recvLineInto*(socket꞉ AsyncSocket; resString꞉ FutureVar[string];flags = @{SocketFlag.SafeDisconn@}) @{.async.@}
@end example
  Reads a line of data from @code{socket} into @code{resString}.

If a full line is read @code{\r\L} is not added to @code{line}, however if solely @code{\r\L} is read then @code{line} will be set to it.

If the socket is disconnected, @code{line} will be set to @code{""}.

If the socket is disconnected in the middle of a line (before @code{\r\L} is read) then line will be set to @code{""}. The partial line @strong{will be lost}.

@strong{Warning}: The @code{Peek} flag is not yet implemented.

@strong{Warning}: @code{recvLineInto} on unbuffered sockets assumes that the protocol uses @code{\r\L} to delimit a new line.

@strong{Warning}: @code{recvLineInto} currently uses a raw pointer to a string for performance reasons. This will likely change soon to use FutureVars.

@item recvLine
  @findex proc recvLine*(socket꞉ AsyncSocket; flags = @{SocketFlag.SafeDisconn@})꞉ Future[string] @{.async.@}
@example
proc recvLine*(socket꞉ AsyncSocket; flags = @{SocketFlag.SafeDisconn@})꞉ Future[string] @{.async.@}
@end example
  Reads a line of data from @code{socket}. Returned future will complete once a full line is read or an error occurs.

If a full line is read @code{\r\L} is not added to @code{line}, however if solely @code{\r\L} is read then @code{line} will be set to it.

If the socket is disconnected, @code{line} will be set to @code{""}.

If the socket is disconnected in the middle of a line (before @code{\r\L} is read) then line will be set to @code{""}. The partial line @strong{will be lost}.

@strong{Warning}: The @code{Peek} flag is not yet implemented.

@strong{Warning}: @code{recvLine} on unbuffered sockets assumes that the protocol uses @code{\r\L} to delimit a new line.

@item listen
  @findex proc listen*(socket꞉ AsyncSocket; backlog = SOMAXCONN) @{.tags꞉ [ReadIOEffect].@}
@example
proc listen*(socket꞉ AsyncSocket; backlog = SOMAXCONN) @{.tags꞉ [ReadIOEffect].@}
@end example
  Marks @code{socket} as accepting connections. @code{Backlog} specifies the maximum length of the queue of pending connections.

Raises an EOS error upon failure.

@item bindAddr
  @findex proc bindAddr*(socket꞉ AsyncSocket; port = Port(0); address = "") @{.tags꞉ [ReadIOEffect].@}
@example
proc bindAddr*(socket꞉ AsyncSocket; port = Port(0); address = "") @{.tags꞉ [ReadIOEffect].@}
@end example
  Binds @code{address}:@code{port} to the socket.

If @code{address} is "" then ADDR_ANY will be bound.

@item close
  @findex proc close*(socket꞉ AsyncSocket)
@example
proc close*(socket꞉ AsyncSocket)
@end example
  Closes the socket.

@item wrapSocket
  @findex proc wrapSocket*(ctx꞉ SslContext; socket꞉ AsyncSocket)
@example
proc wrapSocket*(ctx꞉ SslContext; socket꞉ AsyncSocket)
@end example
  Wraps a socket in an SSL context. This function effectively turns @code{socket} into an SSL socket.

@strong{Disclaimer}: This code is not well tested, may be very unsafe and prone to security vulnerabilities.

@item wrapConnectedSocket
  @findex proc wrapConnectedSocket*(ctx꞉ SslContext; socket꞉ AsyncSocket;handshake꞉ SslHandshakeType)
@example
proc wrapConnectedSocket*(ctx꞉ SslContext; socket꞉ AsyncSocket;handshake꞉ SslHandshakeType)
@end example
  Wraps a connected socket in an SSL context. This function effectively turns @code{socket} into an SSL socket.

This should be called on a connected socket, and will perform an SSL handshake immediately.

@strong{Disclaimer}: This code is not well tested, may be very unsafe and prone to security vulnerabilities.

@item getSockOpt
  @findex proc getSockOpt*(socket꞉ AsyncSocket; opt꞉ SOBool; level = SOL_SOCKET)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@example
proc getSockOpt*(socket꞉ AsyncSocket; opt꞉ SOBool; level = SOL_SOCKET)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@end example
  Retrieves option @code{opt} as a boolean value.

@item setSockOpt
  @findex proc setSockOpt*(socket꞉ AsyncSocket; opt꞉ SOBool; value꞉ bool; level = SOL_SOCKET) @{.tags꞉ [WriteIOEffect].@}
@example
proc setSockOpt*(socket꞉ AsyncSocket; opt꞉ SOBool; value꞉ bool; level = SOL_SOCKET) @{.tags꞉ [WriteIOEffect].@}
@end example
  Sets option @code{opt} to a boolean value specified by @code{value}.

@item isSsl
  @findex proc isSsl*(socket꞉ AsyncSocket)꞉ bool
@example
proc isSsl*(socket꞉ AsyncSocket)꞉ bool
@end example
  Determines whether @code{socket} is a SSL socket.

@item getFd
  @findex proc getFd*(socket꞉ AsyncSocket)꞉ SocketHandle
@example
proc getFd*(socket꞉ AsyncSocket)꞉ SocketHandle
@end example
  Returns the socket's file descriptor.

@item isClosed
  @findex proc isClosed*(socket꞉ AsyncSocket)꞉ bool
@example
proc isClosed*(socket꞉ AsyncSocket)꞉ bool
@end example
  Determines whether the socket has been closed.
@end itemize






@node /pure/nimprof, /pure/future , /pure/asyncnet, Top




@chapter Procedures

@itemize


@item setSamplingFrequency
  @findex proc setSamplingFrequency*(intervalInUs꞉ int)
@example
proc setSamplingFrequency*(intervalInUs꞉ int)
@end example
  set this to change the sampling frequency. Default value is 5ms. Set it to 0 to disable time based profiling; it uses an imprecise instruction count measure instead then.

@item disableProfiling
  @findex proc disableProfiling*()
@example
proc disableProfiling*()
@end example
  

@item enableProfiling
  @findex proc enableProfiling*()
@example
proc enableProfiling*()
@end example
  
@end itemize






@node /pure/future, /pure/parsecsv , /pure/nimprof, Top


@chapter Variables

@itemize


@item lc
  @vindex lc*꞉ ListComprehension
@example
lc*꞉ ListComprehension
@end example
  
@end itemize




@chapter Macros

@itemize


@item `=>`
  @findex macro `=>`*(p, b꞉ expr)꞉ expr @{.immediate.@}
@example
macro `=>`*(p, b꞉ expr)꞉ expr @{.immediate.@}
@end example
  Syntax sugar for anonymous procedures.
@example

proc passTwoAndTwo(f: (int, int) -> int): int =
  f(2, 2)

passTwoAndTwo((x, y) => x + y) # 4
@end example

@item `->`
  @findex macro `->`*(p, b꞉ expr)꞉ expr @{.immediate.@}
@example
macro `->`*(p, b꞉ expr)꞉ expr @{.immediate.@}
@end example
  Syntax sugar for procedure types.
@example

proc pass2(f: (float, float) -> float): float =
  f(2, 2)

# is the same as:

proc pass2(f: proc (x, y: float): float): float =
  f(2, 2)
@end example

@item `[]`
  @findex macro `[]`*(lc꞉ ListComprehension; comp, typ꞉ expr)꞉ expr
@example
macro `[]`*(lc꞉ ListComprehension; comp, typ꞉ expr)꞉ expr
@end example
  List comprehension, returns a sequence. @emph{comp} is the actual list comprehension, for example @code{x | (x <- 1..10, x mod 2 == 0)}. @emph{typ} is the type that will be stored inside the result seq.
@example

echo lc[x | (x <- 1..10, x mod 2 == 0), int]

const n = 20
echo lc[(x,y,z) | (x <- 1..n, y <- x..n, z <- y..n, x*x + y*y == z*z),
        tuple[a,b,c: int]]
@end example
@end itemize




@node /pure/parsecsv, /pure/options , /pure/future, Top



@chapter Types

@itemize


@item CsvError
  @tindex CsvError* = object of IOError
@example
CsvError* = object of IOError
@end example
  exception that is raised if a parsing error occurs
@end itemize

@chapter Procedures

@itemize


@item open
  @findex proc open*(my꞉ var CsvParser; input꞉ Stream; filename꞉ string; separator = ',';quote = '\"'; escape = '\0'; skipInitialSpace = false)
@example
proc open*(my꞉ var CsvParser; input꞉ Stream; filename꞉ string; separator = ',';quote = '\"'; escape = '\0'; skipInitialSpace = false)
@end example
  initializes the parser with an input stream. @emph{Filename} is only used for nice error messages. The parser's behaviour can be controlled by the diverse optional parameters:
@itemize 
 @item @emph{separator}: character used to separate fields
@item @emph{quote}: Used to quote fields containing special characters like @emph{separator}, @emph{quote} or new-line characters. '0' disables the parsing of quotes.
@item @emph{escape}: removes any special meaning from the following character; '0' disables escaping; if escaping is disabled and @emph{quote} is not '0', two @emph{quote} characters are parsed one literal @emph{quote} character.
@item @emph{skipInitialSpace}: If true, whitespace immediately following the @emph{separator} is ignored.
 
@end itemize

@item processedRows
  @findex proc processedRows*(my꞉ var CsvParser)꞉ int
@example
proc processedRows*(my꞉ var CsvParser)꞉ int
@end example
  returns number of the processed rows

@item readRow
  @findex proc readRow*(my꞉ var CsvParser; columns = 0)꞉ bool
@example
proc readRow*(my꞉ var CsvParser; columns = 0)꞉ bool
@end example
  reads the next row; if @emph{columns} > 0, it expects the row to have exactly this many columns. Returns false if the end of the file has been encountered else true.

@item close
  @findex proc close*(my꞉ var CsvParser) @{.inline.@}
@example
proc close*(my꞉ var CsvParser) @{.inline.@}
@end example
  closes the parser @emph{my} and its associated input stream.
@end itemize






@node /pure/options, /pure/asyncfile , /pure/parsecsv, Top



@chapter Types

@itemize


@item UnpackError
  @tindex UnpackError* = ref object of ValueError
@example
UnpackError* = ref object of ValueError
@end example
  
@end itemize

@chapter Procedures

@itemize


@item some
  @findex proc some*[T](val꞉ T)꞉ Option[T]
@example
proc some*[T](val꞉ T)꞉ Option[T]
@end example
  Returns a @code{Option} that has this value.

@item none
  @findex proc none*(T꞉ typedesc)꞉ Option[T]
@example
proc none*(T꞉ typedesc)꞉ Option[T]
@end example
  Returns a @code{Option} for this type that has no value.

@item isSome
  @findex proc isSome*[T](self꞉ Option[T])꞉ bool
@example
proc isSome*[T](self꞉ Option[T])꞉ bool
@end example
  

@item isNone
  @findex proc isNone*[T](self꞉ Option[T])꞉ bool
@example
proc isNone*[T](self꞉ Option[T])꞉ bool
@end example
  

@item unsafeGet
  @findex proc unsafeGet*[T](self꞉ Option[T])꞉ T
@example
proc unsafeGet*[T](self꞉ Option[T])꞉ T
@end example
  Returns the value of a @code{some}. Behavior is undefined for @code{none}.

@item get
  @findex proc get*[T](self꞉ Option[T])꞉ T
@example
proc get*[T](self꞉ Option[T])꞉ T
@end example
  Returns contents of the Option. If it is none, then an exception is thrown.

@item get
  @findex proc get*[T](self꞉ Option[T]; otherwise꞉ T)꞉ T
@example
proc get*[T](self꞉ Option[T]; otherwise꞉ T)꞉ T
@end example
  Returns the contents of this option or @emph{otherwise} if the option is none.

@item map
  @findex proc map*[T](self꞉ Option[T]; callback꞉ proc (input꞉ T))
@example
proc map*[T](self꞉ Option[T]; callback꞉ proc (input꞉ T))
@end example
  Applies a callback to the value in this Option

@item map
  @findex proc map*[T, R](self꞉ Option[T]; callback꞉ proc (input꞉ T)꞉ R)꞉ Option[R]
@example
proc map*[T, R](self꞉ Option[T]; callback꞉ proc (input꞉ T)꞉ R)꞉ Option[R]
@end example
  Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned

@item filter
  @findex proc filter*[T](self꞉ Option[T]; callback꞉ proc (input꞉ T)꞉ bool)꞉ Option[T]
@example
proc filter*[T](self꞉ Option[T]; callback꞉ proc (input꞉ T)꞉ bool)꞉ Option[T]
@end example
  Applies a callback to the value in this Option. If the callback returns @emph{true}, the option is returned as a Some. If it returns false, it is returned as a None.

@item `==`
  @findex proc `==`*(a, b꞉ Option)꞉ bool
@example
proc `==`*(a, b꞉ Option)꞉ bool
@end example
  Returns @code{true} if both @code{Option``s are ``none}, or if they have equal values

@item `$`
  @findex proc `$`*[T](self꞉ Option[T])꞉ string
@example
proc `$`*[T](self꞉ Option[T])꞉ string
@end example
  Returns the contents of this option or @emph{otherwise} if the option is none.
@end itemize






@node /pure/asyncfile, /pure/htmlparser , /pure/options, Top



@chapter Types

@itemize


@item AsyncFile
  @tindex AsyncFile* = ref object
  fd: AsyncFd
  offset: int64

@example
AsyncFile* = ref object
  fd: AsyncFd
  offset: int64

@end example
  
@end itemize

@chapter Procedures

@itemize


@item openAsync
  @findex proc openAsync*(filename꞉ string; mode = fmRead)꞉ AsyncFile
@example
proc openAsync*(filename꞉ string; mode = fmRead)꞉ AsyncFile
@end example
  Opens a file specified by the path in @code{filename} using the specified @code{mode} asynchronously.

@item read
  @findex proc read*(f꞉ AsyncFile; size꞉ int)꞉ Future[string]
@example
proc read*(f꞉ AsyncFile; size꞉ int)꞉ Future[string]
@end example
  Read @code{size} bytes from the specified file asynchronously starting at the current position of the file pointer.

If the file pointer is past the end of the file then an empty string is returned.

@item readLine
  @findex proc readLine*(f꞉ AsyncFile)꞉ Future[string] @{.async.@}
@example
proc readLine*(f꞉ AsyncFile)꞉ Future[string] @{.async.@}
@end example
  Reads a single line from the specified file asynchronously.

@item getFilePos
  @findex proc getFilePos*(f꞉ AsyncFile)꞉ int64
@example
proc getFilePos*(f꞉ AsyncFile)꞉ int64
@end example
  Retrieves the current position of the file pointer that is used to read from the specified file. The file's first byte has the index zero.

@item setFilePos
  @findex proc setFilePos*(f꞉ AsyncFile; pos꞉ int64)
@example
proc setFilePos*(f꞉ AsyncFile; pos꞉ int64)
@end example
  Sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero.

@item readAll
  @findex proc readAll*(f꞉ AsyncFile)꞉ Future[string] @{.async.@}
@example
proc readAll*(f꞉ AsyncFile)꞉ Future[string] @{.async.@}
@end example
  Reads all data from the specified file.

@item write
  @findex proc write*(f꞉ AsyncFile; data꞉ string)꞉ Future[void]
@example
proc write*(f꞉ AsyncFile; data꞉ string)꞉ Future[void]
@end example
  Writes @code{data} to the file specified asynchronously.

The returned Future will complete once all data has been written to the specified file.

@item close
  @findex proc close*(f꞉ AsyncFile)
@example
proc close*(f꞉ AsyncFile)
@end example
  Closes the file specified.
@end itemize






@node /pure/htmlparser, /pure/basic3d , /pure/asyncfile, Top



@chapter Types

@itemize


@item HtmlTag
  @tindex HtmlTag* = enum
  tagUnknown,                 ## unknown HTML element
  tagA,                       ## the HTML ``a`` element
  tagAbbr,                    ## the deprecated HTML ``abbr`` element
  tagAcronym,                 ## the HTML ``acronym`` element
  tagAddress,                 ## the HTML ``address`` element
  tagApplet,                  ## the deprecated HTML ``applet`` element
  tagArea,                    ## the HTML ``area`` element
  tagArticle,                 ## the HTML ``article`` element
  tagAside,                   ## the HTML ``aside`` element
  tagAudio,                   ## the HTML ``audio`` element
  tagB,                       ## the HTML ``b`` element
  tagBase,                    ## the HTML ``base`` element
  tagBdi,                     ## the HTML ``bdi`` element
  tagBdo,                     ## the deprecated HTML ``dbo`` element
  tagBasefont,                ## the deprecated HTML ``basefont`` element
  tagBig,                     ## the HTML ``big`` element
  tagBlockquote,              ## the HTML ``blockquote`` element
  tagBody,                    ## the HTML ``body`` element
  tagBr,                      ## the HTML ``br`` element
  tagButton,                  ## the HTML ``button`` element
  tagCanvas,                  ## the HTML ``canvas`` element
  tagCaption,                 ## the HTML ``caption`` element
  tagCenter,                  ## the deprecated HTML ``center`` element
  tagCite,                    ## the HTML ``cite`` element
  tagCode,                    ## the HTML ``code`` element
  tagCol,                     ## the HTML ``col`` element
  tagColgroup,                ## the HTML ``colgroup`` element
  tagCommand,                 ## the HTML ``command`` element
  tagDatalist,                ## the HTML ``datalist`` element
  tagDd,                      ## the HTML ``dd`` element
  tagDel,                     ## the HTML ``del`` element
  tagDetails,                 ## the HTML ``details`` element
  tagDfn,                     ## the HTML ``dfn`` element
  tagDialog,                  ## the HTML ``dialog`` element
  tagDiv,                     ## the HTML ``div`` element
  tagDir,                     ## the deprecated HTLM ``dir`` element
  tagDl,                      ## the HTML ``dl`` element
  tagDt,                      ## the HTML ``dt`` element
  tagEm,                      ## the HTML ``em`` element
  tagEmbed,                   ## the HTML ``embed`` element
  tagFieldset,                ## the HTML ``fieldset`` element
  tagFigcaption,              ## the HTML ``figcaption`` element
  tagFigure,                  ## the HTML ``figure`` element
  tagFont,                    ## the deprecated HTML ``font`` element
  tagFooter,                  ## the HTML ``footer`` element
  tagForm,                    ## the HTML ``form`` element
  tagFrame,                   ## the HTML ``frame`` element
  tagFrameset,                ## the deprecated HTML ``frameset`` element
  tagH1,                      ## the HTML ``h1`` element
  tagH2,                      ## the HTML ``h2`` element
  tagH3,                      ## the HTML ``h3`` element
  tagH4,                      ## the HTML ``h4`` element
  tagH5,                      ## the HTML ``h5`` element
  tagH6,                      ## the HTML ``h6`` element
  tagHead,                    ## the HTML ``head`` element
  tagHeader,                  ## the HTML ``header`` element
  tagHgroup,                  ## the HTML ``hgroup`` element
  tagHtml,                    ## the HTML ``html`` element
  tagHr,                      ## the HTML ``hr`` element
  tagI,                       ## the HTML ``i`` element
  tagIframe,                  ## the deprecated HTML ``iframe`` element
  tagImg,                     ## the HTML ``img`` element
  tagInput,                   ## the HTML ``input`` element
  tagIns,                     ## the HTML ``ins`` element
  tagIsindex,                 ## the deprecated HTML ``isindex`` element
  tagKbd,                     ## the HTML ``kbd`` element
  tagKeygen,                  ## the HTML ``keygen`` element
  tagLabel,                   ## the HTML ``label`` element
  tagLegend,                  ## the HTML ``legend`` element
  tagLi,                      ## the HTML ``li`` element
  tagLink,                    ## the HTML ``link`` element
  tagMap,                     ## the HTML ``map`` element
  tagMark,                    ## the HTML ``mark`` element
  tagMenu,                    ## the deprecated HTML ``menu`` element
  tagMeta,                    ## the HTML ``meta`` element
  tagMeter,                   ## the HTML ``meter`` element
  tagNav,                     ## the HTML ``nav`` element
  tagNobr,                    ## the deprecated HTML ``nobr`` element
  tagNoframes,                ## the deprecated HTML ``noframes`` element
  tagNoscript,                ## the HTML ``noscript`` element
  tagObject,                  ## the HTML ``object`` element
  tagOl,                      ## the HTML ``ol`` element
  tagOptgroup,                ## the HTML ``optgroup`` element
  tagOption,                  ## the HTML ``option`` element
  tagOutput,                  ## the HTML ``output`` element
  tagP,                       ## the HTML ``p`` element
  tagParam,                   ## the HTML ``param`` element
  tagPre,                     ## the HTML ``pre`` element
  tagProgress,                ## the HTML ``progress`` element
  tagQ,                       ## the HTML ``q`` element
  tagRp,                      ## the HTML ``rp`` element
  tagRt,                      ## the HTML ``rt`` element
  tagRuby,                    ## the HTML ``ruby`` element
  tagS,                       ## the deprecated HTML ``s`` element
  tagSamp,                    ## the HTML ``samp`` element
  tagScript,                  ## the HTML ``script`` element
  tagSection,                 ## the HTML ``section`` element
  tagSelect,                  ## the HTML ``select`` element
  tagSmall,                   ## the HTML ``small`` element
  tagSource,                  ## the HTML ``source`` element
  tagSpan,                    ## the HTML ``span`` element
  tagStrike,                  ## the deprecated HTML ``strike`` element
  tagStrong,                  ## the HTML ``strong`` element
  tagStyle,                   ## the HTML ``style`` element
  tagSub,                     ## the HTML ``sub`` element
  tagSummary,                 ## the HTML ``summary`` element
  tagSup,                     ## the HTML ``sup`` element
  tagTable,                   ## the HTML ``table`` element
  tagTbody,                   ## the HTML ``tbody`` element
  tagTd,                      ## the HTML ``td`` element
  tagTextarea,                ## the HTML ``textarea`` element
  tagTfoot,                   ## the HTML ``tfoot`` element
  tagTh,                      ## the HTML ``th`` element
  tagThead,                   ## the HTML ``thead`` element
  tagTime,                    ## the HTML ``time`` element
  tagTitle,                   ## the HTML ``title`` element
  tagTr,                      ## the HTML ``tr`` element
  tagTrack,                   ## the HTML ``track`` element
  tagTt,                      ## the HTML ``tt`` element
  tagU,                       ## the deprecated HTML ``u`` element
  tagUl,                      ## the HTML ``ul`` element
  tagVar,                     ## the HTML ``var`` element
  tagVideo,                   ## the HTML ``video`` element
  tagWbr                      ## the HTML ``wbr`` element
@example
HtmlTag* = enum
  tagUnknown,                 ## unknown HTML element
  tagA,                       ## the HTML ``a`` element
  tagAbbr,                    ## the deprecated HTML ``abbr`` element
  tagAcronym,                 ## the HTML ``acronym`` element
  tagAddress,                 ## the HTML ``address`` element
  tagApplet,                  ## the deprecated HTML ``applet`` element
  tagArea,                    ## the HTML ``area`` element
  tagArticle,                 ## the HTML ``article`` element
  tagAside,                   ## the HTML ``aside`` element
  tagAudio,                   ## the HTML ``audio`` element
  tagB,                       ## the HTML ``b`` element
  tagBase,                    ## the HTML ``base`` element
  tagBdi,                     ## the HTML ``bdi`` element
  tagBdo,                     ## the deprecated HTML ``dbo`` element
  tagBasefont,                ## the deprecated HTML ``basefont`` element
  tagBig,                     ## the HTML ``big`` element
  tagBlockquote,              ## the HTML ``blockquote`` element
  tagBody,                    ## the HTML ``body`` element
  tagBr,                      ## the HTML ``br`` element
  tagButton,                  ## the HTML ``button`` element
  tagCanvas,                  ## the HTML ``canvas`` element
  tagCaption,                 ## the HTML ``caption`` element
  tagCenter,                  ## the deprecated HTML ``center`` element
  tagCite,                    ## the HTML ``cite`` element
  tagCode,                    ## the HTML ``code`` element
  tagCol,                     ## the HTML ``col`` element
  tagColgroup,                ## the HTML ``colgroup`` element
  tagCommand,                 ## the HTML ``command`` element
  tagDatalist,                ## the HTML ``datalist`` element
  tagDd,                      ## the HTML ``dd`` element
  tagDel,                     ## the HTML ``del`` element
  tagDetails,                 ## the HTML ``details`` element
  tagDfn,                     ## the HTML ``dfn`` element
  tagDialog,                  ## the HTML ``dialog`` element
  tagDiv,                     ## the HTML ``div`` element
  tagDir,                     ## the deprecated HTLM ``dir`` element
  tagDl,                      ## the HTML ``dl`` element
  tagDt,                      ## the HTML ``dt`` element
  tagEm,                      ## the HTML ``em`` element
  tagEmbed,                   ## the HTML ``embed`` element
  tagFieldset,                ## the HTML ``fieldset`` element
  tagFigcaption,              ## the HTML ``figcaption`` element
  tagFigure,                  ## the HTML ``figure`` element
  tagFont,                    ## the deprecated HTML ``font`` element
  tagFooter,                  ## the HTML ``footer`` element
  tagForm,                    ## the HTML ``form`` element
  tagFrame,                   ## the HTML ``frame`` element
  tagFrameset,                ## the deprecated HTML ``frameset`` element
  tagH1,                      ## the HTML ``h1`` element
  tagH2,                      ## the HTML ``h2`` element
  tagH3,                      ## the HTML ``h3`` element
  tagH4,                      ## the HTML ``h4`` element
  tagH5,                      ## the HTML ``h5`` element
  tagH6,                      ## the HTML ``h6`` element
  tagHead,                    ## the HTML ``head`` element
  tagHeader,                  ## the HTML ``header`` element
  tagHgroup,                  ## the HTML ``hgroup`` element
  tagHtml,                    ## the HTML ``html`` element
  tagHr,                      ## the HTML ``hr`` element
  tagI,                       ## the HTML ``i`` element
  tagIframe,                  ## the deprecated HTML ``iframe`` element
  tagImg,                     ## the HTML ``img`` element
  tagInput,                   ## the HTML ``input`` element
  tagIns,                     ## the HTML ``ins`` element
  tagIsindex,                 ## the deprecated HTML ``isindex`` element
  tagKbd,                     ## the HTML ``kbd`` element
  tagKeygen,                  ## the HTML ``keygen`` element
  tagLabel,                   ## the HTML ``label`` element
  tagLegend,                  ## the HTML ``legend`` element
  tagLi,                      ## the HTML ``li`` element
  tagLink,                    ## the HTML ``link`` element
  tagMap,                     ## the HTML ``map`` element
  tagMark,                    ## the HTML ``mark`` element
  tagMenu,                    ## the deprecated HTML ``menu`` element
  tagMeta,                    ## the HTML ``meta`` element
  tagMeter,                   ## the HTML ``meter`` element
  tagNav,                     ## the HTML ``nav`` element
  tagNobr,                    ## the deprecated HTML ``nobr`` element
  tagNoframes,                ## the deprecated HTML ``noframes`` element
  tagNoscript,                ## the HTML ``noscript`` element
  tagObject,                  ## the HTML ``object`` element
  tagOl,                      ## the HTML ``ol`` element
  tagOptgroup,                ## the HTML ``optgroup`` element
  tagOption,                  ## the HTML ``option`` element
  tagOutput,                  ## the HTML ``output`` element
  tagP,                       ## the HTML ``p`` element
  tagParam,                   ## the HTML ``param`` element
  tagPre,                     ## the HTML ``pre`` element
  tagProgress,                ## the HTML ``progress`` element
  tagQ,                       ## the HTML ``q`` element
  tagRp,                      ## the HTML ``rp`` element
  tagRt,                      ## the HTML ``rt`` element
  tagRuby,                    ## the HTML ``ruby`` element
  tagS,                       ## the deprecated HTML ``s`` element
  tagSamp,                    ## the HTML ``samp`` element
  tagScript,                  ## the HTML ``script`` element
  tagSection,                 ## the HTML ``section`` element
  tagSelect,                  ## the HTML ``select`` element
  tagSmall,                   ## the HTML ``small`` element
  tagSource,                  ## the HTML ``source`` element
  tagSpan,                    ## the HTML ``span`` element
  tagStrike,                  ## the deprecated HTML ``strike`` element
  tagStrong,                  ## the HTML ``strong`` element
  tagStyle,                   ## the HTML ``style`` element
  tagSub,                     ## the HTML ``sub`` element
  tagSummary,                 ## the HTML ``summary`` element
  tagSup,                     ## the HTML ``sup`` element
  tagTable,                   ## the HTML ``table`` element
  tagTbody,                   ## the HTML ``tbody`` element
  tagTd,                      ## the HTML ``td`` element
  tagTextarea,                ## the HTML ``textarea`` element
  tagTfoot,                   ## the HTML ``tfoot`` element
  tagTh,                      ## the HTML ``th`` element
  tagThead,                   ## the HTML ``thead`` element
  tagTime,                    ## the HTML ``time`` element
  tagTitle,                   ## the HTML ``title`` element
  tagTr,                      ## the HTML ``tr`` element
  tagTrack,                   ## the HTML ``track`` element
  tagTt,                      ## the HTML ``tt`` element
  tagU,                       ## the deprecated HTML ``u`` element
  tagUl,                      ## the HTML ``ul`` element
  tagVar,                     ## the HTML ``var`` element
  tagVideo,                   ## the HTML ``video`` element
  tagWbr                      ## the HTML ``wbr`` element
@end example
  list of all supported HTML tags; order will always be alphabetically
@end itemize

@chapter Procedures

@itemize


@item htmlTag
  @findex proc htmlTag*(n꞉ XmlNode)꞉ HtmlTag
@example
proc htmlTag*(n꞉ XmlNode)꞉ HtmlTag
@end example
  gets @emph{n}'s tag as a @code{HtmlTag}.

@item htmlTag
  @findex proc htmlTag*(s꞉ string)꞉ HtmlTag
@example
proc htmlTag*(s꞉ string)꞉ HtmlTag
@end example
  converts @emph{s} to a @code{HtmlTag}. If @emph{s} is no HTML tag, @code{tagUnknown} is returned.

@item entityToUtf8
  @findex proc entityToUtf8*(entity꞉ string)꞉ string
@example
proc entityToUtf8*(entity꞉ string)꞉ string
@end example
  converts an HTML entity name like @code{&Uuml;} to its UTF-8 equivalent. "" is returned if the entity name is unknown. The HTML parser already converts entities to UTF-8.

@item parseHtml
  @findex proc parseHtml*(s꞉ Stream; filename꞉ string; errors꞉ var seq[string])꞉ XmlNode
@example
proc parseHtml*(s꞉ Stream; filename꞉ string; errors꞉ var seq[string])꞉ XmlNode
@end example
  parses the XML from stream @emph{s} and returns a @code{PXmlNode}. Every occurred parsing error is added to the @emph{errors} sequence.

@item parseHtml
  @findex proc parseHtml*(s꞉ Stream)꞉ XmlNode
@example
proc parseHtml*(s꞉ Stream)꞉ XmlNode
@end example
  parses the XTML from stream @emph{s} and returns a @code{PXmlNode}. All parsing errors are ignored.

@item loadHtml
  @findex proc loadHtml*(path꞉ string; errors꞉ var seq[string])꞉ XmlNode
@example
proc loadHtml*(path꞉ string; errors꞉ var seq[string])꞉ XmlNode
@end example
  Loads and parses HTML from file specified by @code{path}, and returns a @code{PXmlNode}.  Every occurred parsing error is added to the @emph{errors} sequence.

@item loadHtml
  @findex proc loadHtml*(path꞉ string)꞉ XmlNode
@example
proc loadHtml*(path꞉ string)꞉ XmlNode
@end example
  Loads and parses HTML from file specified by @code{path}, and returns a @code{PXmlNode}. All parsing errors are ignored.
@end itemize






@node /pure/basic3d, /pure/smtp , /pure/htmlparser, Top

@chapter Let variable

@itemize


@item ZAXIS
  @vindex ZAXIS*꞉ Vector3d = vector3d(0.0'f64, 0.0'f64, 1.0'f64)
@example
ZAXIS*꞉ Vector3d = vector3d(0.0'f64, 0.0'f64, 1.0'f64)
@end example
  Quick access to an 3d z-axis unit vector
@end itemize


@chapter Types

@itemize


@item Vector3d
  @tindex Vector3d* = objectx*, y*, z*꞉ float
@example
Vector3d* = objectx*, y*, z*꞉ float
@end example
  Implements a 3d @strong{direction vector} stored as an @emph{x} , @emph{y} and @emph{z} coordinate. Direction vector means, that when transforming a vector with a matrix, the translational part of the matrix is ignored.
@end itemize

@chapter Procedures

@itemize


@item matrix3d
  @findex proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw꞉ float)꞉ Matrix3d @{.noInit.@}
@example
proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw꞉ float)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a new 4x4 3d transformation matrix. @emph{ax} , @emph{ay} , @emph{az} is the local x axis. @emph{bx} , @emph{by} , @emph{bz} is the local y axis. @emph{cx} , @emph{cy} , @emph{cz} is the local z axis. @emph{tx} , @emph{ty} , @emph{tz} is the translation.

@item vector3d
  @findex proc vector3d*(x, y, z꞉ float)꞉ Vector3d @{.noInit, inline.@}
@example
proc vector3d*(x, y, z꞉ float)꞉ Vector3d @{.noInit, inline.@}
@end example
  Returns a new 3d vector (@emph{x},`y`,`z`)

@item point3d
  @findex proc point3d*(x, y, z꞉ float)꞉ Point3d @{.noInit, inline.@}
@example
proc point3d*(x, y, z꞉ float)꞉ Point3d @{.noInit, inline.@}
@end example
  Returns a new 4d point (@emph{x},`y`,`z`)

@item tryNormalize
  @findex proc tryNormalize*(v꞉ var Vector3d)꞉ bool
@example
proc tryNormalize*(v꞉ var Vector3d)꞉ bool
@end example
  Modifies @emph{v} to have a length of 1.0, keeping its angle. If @emph{v} has zero length (and thus no angle), it is left unmodified and false is returned, otherwise true is returned.

@item setElements
  @findex proc setElements*(t꞉ var Matrix3d; ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw꞉ float) @{.inline.@}
@example
proc setElements*(t꞉ var Matrix3d; ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw꞉ float) @{.inline.@}
@end example
  Sets arbitrary elements in an exisitng matrix.

@item matrix3d
  @findex proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw꞉ float)꞉ Matrix3d
@example
proc matrix3d*(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw꞉ float)꞉ Matrix3d
@end example
  

@item `&`
  @findex proc `&`*(a, b꞉ Matrix3d)꞉ Matrix3d @{.noinit.@}
@example
proc `&`*(a, b꞉ Matrix3d)꞉ Matrix3d @{.noinit.@}
@end example
  Concatenates matrices returning a new matrix.

@item scale
  @findex proc scale*(s꞉ float)꞉ Matrix3d @{.noInit.@}
@example
proc scale*(s꞉ float)꞉ Matrix3d @{.noInit.@}
@end example
  Returns a new scaling matrix.

@item scale
  @findex proc scale*(s꞉ float; org꞉ Point3d)꞉ Matrix3d @{.noInit.@}
@example
proc scale*(s꞉ float; org꞉ Point3d)꞉ Matrix3d @{.noInit.@}
@end example
  Returns a new scaling matrix using, @emph{org} as scale origin.

@item stretch
  @findex proc stretch*(sx, sy, sz꞉ float)꞉ Matrix3d @{.noInit.@}
@example
proc stretch*(sx, sy, sz꞉ float)꞉ Matrix3d @{.noInit.@}
@end example
  Returns new a stretch matrix, which is a scale matrix with non uniform scale in x,y and z.

@item stretch
  @findex proc stretch*(sx, sy, sz꞉ float; org꞉ Point3d)꞉ Matrix3d @{.noInit.@}
@example
proc stretch*(sx, sy, sz꞉ float; org꞉ Point3d)꞉ Matrix3d @{.noInit.@}
@end example
  Returns a new stretch matrix, which is a scale matrix with non uniform scale in x,y and z. @emph{org} is used as stretch origin.

@item move
  @findex proc move*(dx, dy, dz꞉ float)꞉ Matrix3d @{.noInit.@}
@example
proc move*(dx, dy, dz꞉ float)꞉ Matrix3d @{.noInit.@}
@end example
  Returns a new translation matrix.

@item move
  @findex proc move*(v꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@example
proc move*(v꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@end example
  Returns a new translation matrix from a vector.

@item rotate
  @findex proc rotate*(angle꞉ float; axis꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@example
proc rotate*(angle꞉ float; axis꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a rotation matrix that rotates @emph{angle} radians over @emph{axis}, which passes through origo.

@item rotate
  @findex proc rotate*(angle꞉ float; org꞉ Point3d; axis꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@example
proc rotate*(angle꞉ float; org꞉ Point3d; axis꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a rotation matrix that rotates @emph{angle} radians over @emph{axis}, which passes through @emph{org}.

@item rotateX
  @findex proc rotateX*(angle꞉ float)꞉ Matrix3d @{.noInit.@}
@example
proc rotateX*(angle꞉ float)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a matrix that rotates around the x-axis with @emph{angle} radians, which is also called a 'roll' matrix.

@item rotateY
  @findex proc rotateY*(angle꞉ float)꞉ Matrix3d @{.noInit.@}
@example
proc rotateY*(angle꞉ float)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a matrix that rotates around the y-axis with @emph{angle} radians, which is also called a 'pitch' matrix.

@item rotateZ
  @findex proc rotateZ*(angle꞉ float)꞉ Matrix3d @{.noInit.@}
@example
proc rotateZ*(angle꞉ float)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a matrix that rotates around the z-axis with @emph{angle} radians, which is also called a 'yaw' matrix.

@item isUniform
  @findex proc isUniform*(m꞉ Matrix3d; tol = 1e-06'f64)꞉ bool
@example
proc isUniform*(m꞉ Matrix3d; tol = 1e-06'f64)꞉ bool
@end example
  Checks if the transform is uniform, that is perpendicular axes of equal length, which means (for example) it cannot transform a sphere into an ellipsoid. @emph{tol} is used as tolerance for both equal length comparison and perpendicular comparison.

@item mirror
  @findex proc mirror*(planeperp꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@example
proc mirror*(planeperp꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a matrix that mirrors over the plane that has @emph{planeperp} as normal, and passes through origo. @emph{planeperp} does not need to be normalized.

@item mirror
  @findex proc mirror*(org꞉ Point3d; planeperp꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@example
proc mirror*(org꞉ Point3d; planeperp꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@end example
  Creates a matrix that mirrors over the plane that has @emph{planeperp} as normal, and passes through @emph{org}. @emph{planeperp} does not need to be normalized.

@item determinant
  @findex proc determinant*(m꞉ Matrix3d)꞉ float
@example
proc determinant*(m꞉ Matrix3d)꞉ float
@end example
  Computes the determinant of matrix @emph{m}.

@item inverse
  @findex proc inverse*(m꞉ Matrix3d)꞉ Matrix3d @{.noInit.@}
@example
proc inverse*(m꞉ Matrix3d)꞉ Matrix3d @{.noInit.@}
@end example
  Computes the inverse of matrix @emph{m}. If the matrix determinant is zero, thus not invertible, a EDivByZero will be raised.

@item equals
  @findex proc equals*(m1꞉ Matrix3d; m2꞉ Matrix3d; tol = 1e-06'f64)꞉ bool
@example
proc equals*(m1꞉ Matrix3d; m2꞉ Matrix3d; tol = 1e-06'f64)꞉ bool
@end example
  Checks if all elements of @emph{m1`and `m2} is equal within a given tolerance @emph{tol}.

@item `=~`
  @findex proc `=~`*(m1, m2꞉ Matrix3d)꞉ bool
@example
proc `=~`*(m1, m2꞉ Matrix3d)꞉ bool
@end example
  Checks if @emph{m1} and @emph{m2} is approximately equal, using a tolerance of 1e-6.

@item transpose
  @findex proc transpose*(m꞉ Matrix3d)꞉ Matrix3d @{.noInit.@}
@example
proc transpose*(m꞉ Matrix3d)꞉ Matrix3d @{.noInit.@}
@end example
  Returns the transpose of @emph{m}

@item getXAxis
  @findex proc getXAxis*(m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@example
proc getXAxis*(m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@end example
  Gets the local x axis of @emph{m}

@item getYAxis
  @findex proc getYAxis*(m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@example
proc getYAxis*(m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@end example
  Gets the local y axis of @emph{m}

@item getZAxis
  @findex proc getZAxis*(m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@example
proc getZAxis*(m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@end example
  Gets the local y axis of @emph{m}

@item `$`
  @findex proc `$`*(m꞉ Matrix3d)꞉ string
@example
proc `$`*(m꞉ Matrix3d)꞉ string
@end example
  String representation of @emph{m}

@item apply
  @findex proc apply*(m꞉ Matrix3d; x, y, z꞉ var float; translate = false)
@example
proc apply*(m꞉ Matrix3d; x, y, z꞉ var float; translate = false)
@end example
  Applies transformation @emph{m} onto @emph{x} , @emph{y} , @emph{z} , optionally using the translation part of the matrix.

@item vector3d
  @findex proc vector3d*(x, y, z꞉ float)꞉ Vector3d
@example
proc vector3d*(x, y, z꞉ float)꞉ Vector3d
@end example
  

@item len
  @findex proc len*(v꞉ Vector3d)꞉ float
@example
proc len*(v꞉ Vector3d)꞉ float
@end example
  Returns the length of the vector @emph{v}.

@item `len=`
  @findex proc `len =`*(v꞉ var Vector3d; newlen꞉ float) @{.noInit.@}
@example
proc `len =`*(v꞉ var Vector3d; newlen꞉ float) @{.noInit.@}
@end example
  Sets the length of the vector, keeping its direction. If the vector has zero length before changing it's length, an arbitrary vector of the requested length is returned.

@item sqrLen
  @findex proc sqrLen*(v꞉ Vector3d)꞉ float @{.inline.@}
@example
proc sqrLen*(v꞉ Vector3d)꞉ float @{.inline.@}
@end example
  Computes the squared length of the vector, which is faster than computing the absolute length.

@item `$`
  @findex proc `$`*(v꞉ Vector3d)꞉ string
@example
proc `$`*(v꞉ Vector3d)꞉ string
@end example
  String representation of @emph{v}

@item `&`
  @findex proc `&`*(v꞉ Vector3d; m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@example
proc `&`*(v꞉ Vector3d; m꞉ Matrix3d)꞉ Vector3d @{.noInit.@}
@end example
  Concatenate vector @emph{v} with a transformation matrix. Transforming a vector ignores the translational part of the matrix.

@item `&=`
  @findex proc `&=`*(v꞉ var Vector3d; m꞉ Matrix3d) @{.noInit.@}
@example
proc `&=`*(v꞉ var Vector3d; m꞉ Matrix3d) @{.noInit.@}
@end example
  Applies transformation @emph{m} onto @emph{v} in place. Transforming a vector ignores the translational part of the matrix.

@item transformNorm
  @findex proc transformNorm*(v꞉ var Vector3d; m꞉ Matrix3d)
@example
proc transformNorm*(v꞉ var Vector3d; m꞉ Matrix3d)
@end example
  Applies a normal direction transformation @emph{m} onto @emph{v} in place. The resulting vector is @emph{not} normalized.  Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.

@item transformInv
  @findex proc transformInv*(v꞉ var Vector3d; m꞉ Matrix3d)
@example
proc transformInv*(v꞉ var Vector3d; m꞉ Matrix3d)
@end example
  Applies the inverse of @emph{m} on vector @emph{v}. Transforming a vector ignores the translational part of the matrix.  Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.

@item transformNormInv
  @findex proc transformNormInv*(vec꞉ var Vector3d; m꞉ Matrix3d)
@example
proc transformNormInv*(vec꞉ var Vector3d; m꞉ Matrix3d)
@end example
  Applies an inverse normal direction transformation @emph{m} onto @emph{v} in place. This is faster than creating an inverse matrix and transformNorm(...) it. Transforming a vector ignores the translational part of the matrix.

@item tryNormalize
  @findex proc tryNormalize*(v꞉ var Vector3d)꞉ bool
@example
proc tryNormalize*(v꞉ var Vector3d)꞉ bool
@end example
  Modifies @emph{v} to have a length of 1.0, keeping its angle. If @emph{v} has zero length (and thus no angle), it is left unmodified and false is returned, otherwise true is returned.

@item normalize
  @findex proc normalize*(v꞉ var Vector3d) @{.inline.@}
@example
proc normalize*(v꞉ var Vector3d) @{.inline.@}
@end example
  Modifies @emph{v} to have a length of 1.0, keeping its angle. If  @emph{v} has zero length, an EDivByZero will be raised.

@item rotate
  @findex proc rotate*(vec꞉ var Vector3d; angle꞉ float; axis꞉ Vector3d)
@example
proc rotate*(vec꞉ var Vector3d; angle꞉ float; axis꞉ Vector3d)
@end example
  Rotates @emph{vec} in place, with @emph{angle} radians over @emph{axis}, which passes through origo.

@item scale
  @findex proc scale*(v꞉ var Vector3d; s꞉ float)
@example
proc scale*(v꞉ var Vector3d; s꞉ float)
@end example
  Scales the vector in place with factor @emph{s}

@item stretch
  @findex proc stretch*(v꞉ var Vector3d; sx, sy, sz꞉ float)
@example
proc stretch*(v꞉ var Vector3d; sx, sy, sz꞉ float)
@end example
  Scales the vector non uniformly with factors @emph{sx} , @emph{sy} , @emph{sz}

@item mirror
  @findex proc mirror*(v꞉ var Vector3d; planeperp꞉ Vector3d)
@example
proc mirror*(v꞉ var Vector3d; planeperp꞉ Vector3d)
@end example
  Computes the mirrored vector of @emph{v} over the plane that has @emph{planeperp} as normal direction. @emph{planeperp} does not need to be normalized.

@item `-`
  @findex proc `-`*(v꞉ Vector3d)꞉ Vector3d
@example
proc `-`*(v꞉ Vector3d)꞉ Vector3d
@end example
  Negates a vector

@item dot
  @findex proc dot*(v1, v2꞉ Vector3d)꞉ float @{.inline.@}
@example
proc dot*(v1, v2꞉ Vector3d)꞉ float @{.inline.@}
@end example
  Computes the dot product of two vectors. Returns 0.0 if the vectors are perpendicular.

@item cross
  @findex proc cross*(v1, v2꞉ Vector3d)꞉ Vector3d @{.inline.@}
@example
proc cross*(v1, v2꞉ Vector3d)꞉ Vector3d @{.inline.@}
@end example
  Computes the cross product of two vectors. The result is a vector which is perpendicular to the plane of @emph{v1} and @emph{v2}, which means cross(xaxis,yaxis)=zaxis. The magnitude of the result is zero if the vectors are colinear.

@item equals
  @findex proc equals*(v1, v2꞉ Vector3d; tol = 1e-06'f64)꞉ bool
@example
proc equals*(v1, v2꞉ Vector3d; tol = 1e-06'f64)꞉ bool
@end example
  Checks if two vectors approximately equals with a tolerance.

@item `=~`
  @findex proc `=~`*(v1, v2꞉ Vector3d)꞉ bool
@example
proc `=~`*(v1, v2꞉ Vector3d)꞉ bool
@end example
  Checks if two vectors approximately equals with a hardcoded tolerance 1e-6

@item angleTo
  @findex proc angleTo*(v1, v2꞉ Vector3d)꞉ float
@example
proc angleTo*(v1, v2꞉ Vector3d)꞉ float
@end example
  Returns the smallest angle between v1 and v2, which is in range 0-PI

@item arbitraryAxis
  @findex proc arbitraryAxis*(norm꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@example
proc arbitraryAxis*(norm꞉ Vector3d)꞉ Matrix3d @{.noInit.@}
@end example
  Computes the rotation matrix that would transform world z vector into @emph{norm}. The inverse of this matrix is useful to transform a planar 3d object to 2d space. This is the same algorithm used to interpret DXF and DWG files.

@item bisect
  @findex proc bisect*(v1, v2꞉ Vector3d)꞉ Vector3d @{.noInit.@}
@example
proc bisect*(v1, v2꞉ Vector3d)꞉ Vector3d @{.noInit.@}
@end example
  Computes the bisector between v1 and v2 as a normalized vector. If one of the input vectors has zero length, a normalized version of the other is returned. If both input vectors has zero length, an arbitrary normalized vector @emph{v1} is returned.

@item point3d
  @findex proc point3d*(x, y, z꞉ float)꞉ Point3d
@example
proc point3d*(x, y, z꞉ float)꞉ Point3d
@end example
  

@item sqrDist
  @findex proc sqrDist*(a, b꞉ Point3d)꞉ float
@example
proc sqrDist*(a, b꞉ Point3d)꞉ float
@end example
  Computes the squared distance between @emph{a`and `b}

@item dist
  @findex proc dist*(a, b꞉ Point3d)꞉ float @{.inline.@}
@example
proc dist*(a, b꞉ Point3d)꞉ float @{.inline.@}
@end example
  Computes the absolute distance between @emph{a`and `b}

@item `$`
  @findex proc `$`*(p꞉ Point3d)꞉ string
@example
proc `$`*(p꞉ Point3d)꞉ string
@end example
  String representation of @emph{p}

@item `&`
  @findex proc `&`*(p꞉ Point3d; m꞉ Matrix3d)꞉ Point3d
@example
proc `&`*(p꞉ Point3d; m꞉ Matrix3d)꞉ Point3d
@end example
  Concatenates a point @emph{p} with a transform @emph{m}, resulting in a new, transformed point.

@item `&=`
  @findex proc `&=`*(p꞉ var Point3d; m꞉ Matrix3d)
@example
proc `&=`*(p꞉ var Point3d; m꞉ Matrix3d)
@end example
  Applies transformation @emph{m} onto @emph{p} in place.

@item transformInv
  @findex proc transformInv*(p꞉ var Point3d; m꞉ Matrix3d)
@example
proc transformInv*(p꞉ var Point3d; m꞉ Matrix3d)
@end example
  Applies the inverse of transformation @emph{m} onto @emph{p} in place. If the matrix is not invertable (determinant=0) , EDivByZero will be raised.

@item `+`
  @findex proc `+`*(p꞉ Point3d; v꞉ Vector3d)꞉ Point3d @{.noInit, inline.@}
@example
proc `+`*(p꞉ Point3d; v꞉ Vector3d)꞉ Point3d @{.noInit, inline.@}
@end example
  Adds a vector @emph{v} to a point @emph{p}, resulting in a new point.

@item `+=`
  @findex proc `+=`*(p꞉ var Point3d; v꞉ Vector3d) @{.noInit, inline.@}
@example
proc `+=`*(p꞉ var Point3d; v꞉ Vector3d) @{.noInit, inline.@}
@end example
  Adds a vector @emph{v} to a point @emph{p} in place.

@item `-`
  @findex proc `-`*(p꞉ Point3d; v꞉ Vector3d)꞉ Point3d @{.noInit, inline.@}
@example
proc `-`*(p꞉ Point3d; v꞉ Vector3d)꞉ Point3d @{.noInit, inline.@}
@end example
  Subtracts a vector @emph{v} from a point @emph{p}, resulting in a new point.

@item `-`
  @findex proc `-`*(p1, p2꞉ Point3d)꞉ Vector3d @{.noInit, inline.@}
@example
proc `-`*(p1, p2꞉ Point3d)꞉ Vector3d @{.noInit, inline.@}
@end example
  Subtracts @emph{p2`from `p1} resulting in a difference vector.

@item `-=`
  @findex proc `-=`*(p꞉ var Point3d; v꞉ Vector3d) @{.noInit, inline.@}
@example
proc `-=`*(p꞉ var Point3d; v꞉ Vector3d) @{.noInit, inline.@}
@end example
  Subtracts a vector @emph{v} from a point @emph{p} in place.

@item `=~`
  @findex proc `=~`*(p1, p2꞉ Point3d)꞉ bool @{.inline.@}
@example
proc `=~`*(p1, p2꞉ Point3d)꞉ bool @{.inline.@}
@end example
  Checks if two vectors approximately equals with a hardcoded tolerance 1e-6

@item rotate
  @findex proc rotate*(p꞉ var Point3d; rad꞉ float; axis꞉ Vector3d)
@example
proc rotate*(p꞉ var Point3d; rad꞉ float; axis꞉ Vector3d)
@end example
  Rotates point @emph{p} in place @emph{rad} radians about an axis passing through origo.

@item rotate
  @findex proc rotate*(p꞉ var Point3d; angle꞉ float; org꞉ Point3d; axis꞉ Vector3d)
@example
proc rotate*(p꞉ var Point3d; angle꞉ float; org꞉ Point3d; axis꞉ Vector3d)
@end example
  Rotates point @emph{p} in place @emph{rad} radians about an axis passing through @emph{org}

@item scale
  @findex proc scale*(p꞉ var Point3d; fac꞉ float) @{.inline.@}
@example
proc scale*(p꞉ var Point3d; fac꞉ float) @{.inline.@}
@end example
  Scales a point in place @emph{fac} times with world origo as origin.

@item scale
  @findex proc scale*(p꞉ var Point3d; fac꞉ float; org꞉ Point3d) @{.inline.@}
@example
proc scale*(p꞉ var Point3d; fac꞉ float; org꞉ Point3d) @{.inline.@}
@end example
  Scales the point in place @emph{fac} times with @emph{org} as origin.

@item stretch
  @findex proc stretch*(p꞉ var Point3d; facx, facy, facz꞉ float) @{.inline.@}
@example
proc stretch*(p꞉ var Point3d; facx, facy, facz꞉ float) @{.inline.@}
@end example
  Scales a point in place non uniformly @emph{facx} , @emph{facy} , @emph{facz} times with world origo as origin.

@item stretch
  @findex proc stretch*(p꞉ var Point3d; facx, facy, facz꞉ float; org꞉ Point3d) @{.inline.@}
@example
proc stretch*(p꞉ var Point3d; facx, facy, facz꞉ float; org꞉ Point3d) @{.inline.@}
@end example
  Scales the point in place non uniformly @emph{facx} , @emph{facy} , @emph{facz} times with @emph{org} as origin.

@item move
  @findex proc move*(p꞉ var Point3d; dx, dy, dz꞉ float) @{.inline.@}
@example
proc move*(p꞉ var Point3d; dx, dy, dz꞉ float) @{.inline.@}
@end example
  Translates a point @emph{dx} , @emph{dy} , @emph{dz} in place.

@item move
  @findex proc move*(p꞉ var Point3d; v꞉ Vector3d) @{.inline.@}
@example
proc move*(p꞉ var Point3d; v꞉ Vector3d) @{.inline.@}
@end example
  Translates a point with vector @emph{v} in place.

@item area
  @findex proc area*(a, b, c꞉ Point3d)꞉ float @{.inline.@}
@example
proc area*(a, b, c꞉ Point3d)꞉ float @{.inline.@}
@end example
  Computes the area of the triangle thru points @emph{a} , @emph{b} and @emph{c}
@end itemize






@node /pure/smtp, /pure/selectors , /pure/basic3d, Top



@chapter Types

@itemize


@item AsyncSmtp
  @tindex AsyncSmtp* = ref object
  sock: AsyncSocket
  address: string
  port: Port
  useSsl: bool
  debug: bool

@example
AsyncSmtp* = ref object
  sock: AsyncSocket
  address: string
  port: Port
  useSsl: bool
  debug: bool

@end example
  
@end itemize

@chapter Procedures

@itemize


@item connect
  @findex proc connect*(address꞉ string; port = Port(25); ssl = false; debug = false;sslContext = defaultSSLContext)꞉ Smtp
@example
proc connect*(address꞉ string; port = Port(25); ssl = false; debug = false;sslContext = defaultSSLContext)꞉ Smtp
@end example
  Establishes a connection with a SMTP server. May fail with ReplyError or with a socket error.

@item auth
  @findex proc auth*(smtp꞉ var Smtp; username, password꞉ string)
@example
proc auth*(smtp꞉ var Smtp; username, password꞉ string)
@end example
  Sends an AUTH command to the server to login as the @emph{username} using @emph{password}. May fail with ReplyError.

@item sendmail
  @findex proc sendmail*(smtp꞉ var Smtp; fromaddr꞉ string; toaddrs꞉ seq[string]; msg꞉ string)
@example
proc sendmail*(smtp꞉ var Smtp; fromaddr꞉ string; toaddrs꞉ seq[string]; msg꞉ string)
@end example
  Sends @emph{msg} from @emph{fromaddr} to @emph{toaddr}. Messages may be formed using @code{createMessage} by converting the Message into a string.

@item close
  @findex proc close*(smtp꞉ Smtp)
@example
proc close*(smtp꞉ Smtp)
@end example
  Disconnects from the SMTP server and closes the socket.

@item createMessage
  @findex proc createMessage*(mSubject, mBody꞉ string; mTo, mCc꞉ seq[string];otherHeaders꞉ openarray[tuple[name, value꞉ string]])꞉ Message
@example
proc createMessage*(mSubject, mBody꞉ string; mTo, mCc꞉ seq[string];otherHeaders꞉ openarray[tuple[name, value꞉ string]])꞉ Message
@end example
  Creates a new MIME compliant message.

@item createMessage
  @findex proc createMessage*(mSubject, mBody꞉ string; mTo, mCc꞉ seq[string] = @@ [])꞉ Message
@example
proc createMessage*(mSubject, mBody꞉ string; mTo, mCc꞉ seq[string] = @@ [])꞉ Message
@end example
  Alternate version of the above.

@item `$`
  @findex proc `$`*(msg꞉ Message)꞉ string
@example
proc `$`*(msg꞉ Message)꞉ string
@end example
  stringify for @code{Message}.

@item newAsyncSmtp
  @findex proc newAsyncSmtp*(address꞉ string; port꞉ Port; useSsl = false;sslContext = defaultSslContext)꞉ AsyncSmtp
@example
proc newAsyncSmtp*(address꞉ string; port꞉ Port; useSsl = false;sslContext = defaultSslContext)꞉ AsyncSmtp
@end example
  Creates a new @code{AsyncSmtp} instance.

@item connect
  @findex proc connect*(smtp꞉ AsyncSmtp) @{.async.@}
@example
proc connect*(smtp꞉ AsyncSmtp) @{.async.@}
@end example
  Establishes a connection with a SMTP server. May fail with ReplyError or with a socket error.

@item auth
  @findex proc auth*(smtp꞉ AsyncSmtp; username, password꞉ string) @{.async.@}
@example
proc auth*(smtp꞉ AsyncSmtp; username, password꞉ string) @{.async.@}
@end example
  Sends an AUTH command to the server to login as the @emph{username} using @emph{password}. May fail with ReplyError.

@item sendMail
  @findex proc sendMail*(smtp꞉ AsyncSmtp; fromAddr꞉ string; toAddrs꞉ seq[string]; msg꞉ string) @{.async.@}
@example
proc sendMail*(smtp꞉ AsyncSmtp; fromAddr꞉ string; toAddrs꞉ seq[string]; msg꞉ string) @{.async.@}
@end example
  Sends @code{msg} from @code{fromAddr} to the addresses specified in @code{toAddrs}. Messages may be formed using @code{createMessage} by converting the Message into a string.

@item close
  @findex proc close*(smtp꞉ AsyncSmtp) @{.async.@}
@example
proc close*(smtp꞉ AsyncSmtp) @{.async.@}
@end example
  Disconnects from the SMTP server and closes the socket.
@end itemize






@node /pure/selectors, /pure/scgi , /pure/smtp, Top



@chapter Types

@itemize


@item ReadyInfo
  @tindex ReadyInfo* = tuple[key꞉ SelectorKey, events꞉ set[Event]]
@example
ReadyInfo* = tuple[key꞉ SelectorKey, events꞉ set[Event]]
@end example
  

@item Selector
  @tindex Selector* = ref object
@example
Selector* = ref object
@end example
  An object which holds file descriptors to be checked for read/write status.
@end itemize

@chapter Procedures

@itemize


@item hash
  @findex proc hash*(x꞉ SocketHandle)꞉ Hash @{.borrow.@}
@example
proc hash*(x꞉ SocketHandle)꞉ Hash @{.borrow.@}
@end example
  

@item `$`
  @findex proc `$`*(x꞉ SocketHandle)꞉ string @{.borrow.@}
@example
proc `$`*(x꞉ SocketHandle)꞉ string @{.borrow.@}
@end example
  

@item register
  @findex proc register*(s꞉ Selector; fd꞉ SocketHandle; events꞉ set[Event]; data꞉ SelectorData)꞉ SelectorKey @{.discardable.@}
@example
proc register*(s꞉ Selector; fd꞉ SocketHandle; events꞉ set[Event]; data꞉ SelectorData)꞉ SelectorKey @{.discardable.@}
@end example
  Registers file descriptor @code{fd} to selector @code{s} with a set of Event @code{events}.

@item update
  @findex proc update*(s꞉ Selector; fd꞉ SocketHandle; events꞉ set[Event])꞉ SelectorKey @{.discardable.@}
@example
proc update*(s꞉ Selector; fd꞉ SocketHandle; events꞉ set[Event])꞉ SelectorKey @{.discardable.@}
@end example
  Updates the events which @code{fd} wants notifications for.

@item unregister
  @findex proc unregister*(s꞉ Selector; fd꞉ SocketHandle)꞉ SelectorKey @{.discardable.@}
@example
proc unregister*(s꞉ Selector; fd꞉ SocketHandle)꞉ SelectorKey @{.discardable.@}
@end example
  Unregisters file descriptor @code{fd} from selector @code{s}.

@item close
  @findex proc close*(s꞉ Selector)
@example
proc close*(s꞉ Selector)
@end example
  Closes the selector

@item select
  @findex proc select*(s꞉ Selector; timeout꞉ int)꞉ seq[ReadyInfo]
@example
proc select*(s꞉ Selector; timeout꞉ int)꞉ seq[ReadyInfo]
@end example
  The @code{events} field of the returned @code{key} contains the original events for which the @code{fd} was bound. This is contrary to the @code{events} field of the @code{ReadyInfo} tuple which determines which events are ready on the @code{fd}.

@item newSelector
  @findex proc newSelector*()꞉ Selector
@example
proc newSelector*()꞉ Selector
@end example
  Creates a new selector

@item contains
  @findex proc contains*(s꞉ Selector; fd꞉ SocketHandle)꞉ bool
@example
proc contains*(s꞉ Selector; fd꞉ SocketHandle)꞉ bool
@end example
  Determines whether selector contains a file descriptor.

@item `[]`
  @findex proc `[]`*(s꞉ Selector; fd꞉ SocketHandle)꞉ SelectorKey
@example
proc `[]`*(s꞉ Selector; fd꞉ SocketHandle)꞉ SelectorKey
@end example
  Retrieves the selector key for @code{fd}.

@item contains
  @findex proc contains*(s꞉ Selector; key꞉ SelectorKey)꞉ bool
@example
proc contains*(s꞉ Selector; key꞉ SelectorKey)꞉ bool
@end example
  Determines whether selector contains this selector key. More accurate than checking if the file descriptor is in the selector because it ensures that the keys are equal. File descriptors may not always be unique especially when an fd is closed and then a new one is opened, the new one may have the same value.
@end itemize






@node /pure/scgi, /pure/parsexml , /pure/selectors, Top



@chapter Types

@itemize


@item ScgiError
  @tindex ScgiError* = object of IOError
@example
ScgiError* = object of IOError
@end example
  the exception that is raised, if a SCGI error occurs

@item AsyncScgiState
  @tindex AsyncScgiState* = ref AsyncScgiStateObj
@example
AsyncScgiState* = ref AsyncScgiStateObj
@end example
  
@end itemize

@chapter Procedures

@itemize


@item raiseScgiError
  @findex proc raiseScgiError*(msg꞉ string) @{.noreturn.@}
@example
proc raiseScgiError*(msg꞉ string) @{.noreturn.@}
@end example
  raises an ScgiError exception with message @emph{msg}.

@item open
  @findex proc open*(s꞉ var ScgiState; port = Port(4000); address = "127.0.0.1"; reuseAddr = false)
@example
proc open*(s꞉ var ScgiState; port = Port(4000); address = "127.0.0.1"; reuseAddr = false)
@end example
  opens a connection.

@item close
  @findex proc close*(s꞉ var ScgiState)
@example
proc close*(s꞉ var ScgiState)
@end example
  closes the connection.

@item next
  @findex proc next*(s꞉ var ScgiState; timeout꞉ int = - 1)꞉ bool
@example
proc next*(s꞉ var ScgiState; timeout꞉ int = - 1)꞉ bool
@end example
  proceed to the first/next request. Waits @code{timeout} milliseconds for a request, if @code{timeout} is @emph{-1} then this function will never time out. Returns @emph{true} if a new request has been processed.

@item writeStatusOkTextContent
  @findex proc writeStatusOkTextContent*(c꞉ Socket; contentType = "text/html")
@example
proc writeStatusOkTextContent*(c꞉ Socket; contentType = "text/html")
@end example
  sends the following string to the socket @emph{c}:
@verbatim

Status: 200 OK\r\LContent-Type: text/html\r\L\r\L
@end verbatim


You should send this before sending your HTML page, for example.

@item run
  @findex proc run*(handleRequest꞉ proc (client꞉ Socket; input꞉ string; headers꞉ StringTableRef)꞉ bool @{.nimcall, gcsafe.@}; port = Port(4000))
@example
proc run*(handleRequest꞉ proc (client꞉ Socket; input꞉ string; headers꞉ StringTableRef)꞉ bool @{.nimcall, gcsafe.@}; port = Port(4000))
@end example
  encapsulates the SCGI object and main loop.

@item open
  @findex proc open*(handleRequest꞉ proc (client꞉ AsyncSocket; input꞉ string;headers꞉ StringTableRef) @{.closure, gcsafe.@};port = Port(4000); address = "127.0.0.1"; reuseAddr = false)꞉ AsyncScgiState
@example
proc open*(handleRequest꞉ proc (client꞉ AsyncSocket; input꞉ string;headers꞉ StringTableRef) @{.closure, gcsafe.@};port = Port(4000); address = "127.0.0.1"; reuseAddr = false)꞉ AsyncScgiState
@end example
  Creates an @code{AsyncScgiState} object which serves as a SCGI server.

After the execution of @code{handleRequest} the client socket will be closed automatically unless it has already been closed.

@item register
  @findex proc register*(d꞉ Dispatcher; s꞉ AsyncScgiState)꞉ Delegate @{.discardable.@}
@example
proc register*(d꞉ Dispatcher; s꞉ AsyncScgiState)꞉ Delegate @{.discardable.@}
@end example
  Registers @code{s} with dispatcher @code{d}.

@item close
  @findex proc close*(s꞉ AsyncScgiState)
@example
proc close*(s꞉ AsyncScgiState)
@end example
  Closes the @code{AsyncScgiState}.
@end itemize






@node /pure/parsexml, /pure/lexbase , /pure/scgi, Top



@chapter Types

@itemize


@item XmlParser
  @tindex XmlParser* = object of BaseLexer
  a, b, c: string
  kind: XmlEventKind
  err: XmlErrorKind
  state: ParserState
  filename: string
  options: set[XmlParseOption]

@example
XmlParser* = object of BaseLexer
  a, b, c: string
  kind: XmlEventKind
  err: XmlErrorKind
  state: ParserState
  filename: string
  options: set[XmlParseOption]

@end example
  the parser object.
@end itemize

@chapter Procedures

@itemize


@item open
  @findex proc open*(my꞉ var XmlParser; input꞉ Stream; filename꞉ string;options꞉ set[XmlParseOption] = @{@})
@example
proc open*(my꞉ var XmlParser; input꞉ Stream; filename꞉ string;options꞉ set[XmlParseOption] = @{@})
@end example
  initializes the parser with an input stream. @emph{Filename} is only used for nice error messages. The parser's behaviour can be controlled by the @emph{options} parameter: If @emph{options} contains @code{reportWhitespace} a whitespace token is reported as an @code{xmlWhitespace} event. If @emph{options} contains @code{reportComments} a comment token is reported as an @code{xmlComment} event.

@item close
  @findex proc close*(my꞉ var XmlParser) @{.inline.@}
@example
proc close*(my꞉ var XmlParser) @{.inline.@}
@end example
  closes the parser @emph{my} and its associated input stream.

@item kind
  @findex proc kind*(my꞉ XmlParser)꞉ XmlEventKind @{.inline.@}
@example
proc kind*(my꞉ XmlParser)꞉ XmlEventKind @{.inline.@}
@end example
  returns the current event type for the XML parser

@item rawData
  @findex proc rawData*(my꞉ XmlParser)꞉ string @{.inline.@}
@example
proc rawData*(my꞉ XmlParser)꞉ string @{.inline.@}
@end example
  returns the underlying 'data' string by reference. This is only used for speed hacks.

@item rawData2
  @findex proc rawData2*(my꞉ XmlParser)꞉ string @{.inline.@}
@example
proc rawData2*(my꞉ XmlParser)꞉ string @{.inline.@}
@end example
  returns the underlying second 'data' string by reference. This is only used for speed hacks.

@item getColumn
  @findex proc getColumn*(my꞉ XmlParser)꞉ int @{.inline.@}
@example
proc getColumn*(my꞉ XmlParser)꞉ int @{.inline.@}
@end example
  get the current column the parser has arrived at.

@item getLine
  @findex proc getLine*(my꞉ XmlParser)꞉ int @{.inline.@}
@example
proc getLine*(my꞉ XmlParser)꞉ int @{.inline.@}
@end example
  get the current line the parser has arrived at.

@item getFilename
  @findex proc getFilename*(my꞉ XmlParser)꞉ string @{.inline.@}
@example
proc getFilename*(my꞉ XmlParser)꞉ string @{.inline.@}
@end example
  get the filename of the file that the parser processes.

@item errorMsg
  @findex proc errorMsg*(my꞉ XmlParser)꞉ string
@example
proc errorMsg*(my꞉ XmlParser)꞉ string
@end example
  returns a helpful error message for the event @code{xmlError}

@item errorMsgExpected
  @findex proc errorMsgExpected*(my꞉ XmlParser; tag꞉ string)꞉ string
@example
proc errorMsgExpected*(my꞉ XmlParser; tag꞉ string)꞉ string
@end example
  returns an error message "<tag> expected" in the same format as the other error messages

@item errorMsg
  @findex proc errorMsg*(my꞉ XmlParser; msg꞉ string)꞉ string
@example
proc errorMsg*(my꞉ XmlParser; msg꞉ string)꞉ string
@end example
  returns an error message with text @emph{msg} in the same format as the other error messages

@item next
  @findex proc next*(my꞉ var XmlParser)
@example
proc next*(my꞉ var XmlParser)
@end example
  retrieves the first/next event. This controls the parser.
@end itemize

@chapter Templates

@itemize


@item charData
  @findex template charData*(my꞉ XmlParser)꞉ string
@example
template charData*(my꞉ XmlParser)꞉ string
@end example
  returns the character data for the events: @code{xmlCharData}, @code{xmlWhitespace}, @code{xmlComment}, @code{xmlCData}, @code{xmlSpecial}

@item elementName
  @findex template elementName*(my꞉ XmlParser)꞉ string
@example
template elementName*(my꞉ XmlParser)꞉ string
@end example
  returns the element name for the events: @code{xmlElementStart}, @code{xmlElementEnd}, @code{xmlElementOpen}

@item entityName
  @findex template entityName*(my꞉ XmlParser)꞉ string
@example
template entityName*(my꞉ XmlParser)꞉ string
@end example
  returns the entity name for the event: @code{xmlEntity}

@item attrKey
  @findex template attrKey*(my꞉ XmlParser)꞉ string
@example
template attrKey*(my꞉ XmlParser)꞉ string
@end example
  returns the attribute key for the event @code{xmlAttribute}

@item attrValue
  @findex template attrValue*(my꞉ XmlParser)꞉ string
@example
template attrValue*(my꞉ XmlParser)꞉ string
@end example
  returns the attribute value for the event @code{xmlAttribute}

@item piName
  @findex template piName*(my꞉ XmlParser)꞉ string
@example
template piName*(my꞉ XmlParser)꞉ string
@end example
  returns the processing instruction name for the event @code{xmlPI}

@item piRest
  @findex template piRest*(my꞉ XmlParser)꞉ string
@example
template piRest*(my꞉ XmlParser)꞉ string
@end example
  returns the rest of the processing instruction for the event @code{xmlPI}
@end itemize





@node /pure/lexbase, /pure/browsers , /pure/parsexml, Top
@chapter Constant variables

@itemize


@item NewLines
  @vindex NewLines* = @{'\x0D', '\x0A'@}
@example
NewLines* = @{'\x0D', '\x0A'@}
@end example
  
@end itemize



@chapter Types

@itemize


@item BaseLexer
  @tindex BaseLexer* = object of RootObj
  bufpos*: int                 ## the current position within the buffer
  when defined(js):
      buf*: string

  else:
      buf*: cstring

  bufLen*: int                 ## length of buffer in characters
  input: Stream                ## the input stream
  lineNumber*: int             ## the current line number
  sentinel: int
  lineStart: int
  refillChars: set[char]

@example
BaseLexer* = object of RootObj
  bufpos*: int                 ## the current position within the buffer
  when defined(js):
      buf*: string

  else:
      buf*: cstring

  bufLen*: int                 ## length of buffer in characters
  input: Stream                ## the input stream
  lineNumber*: int             ## the current line number
  sentinel: int
  lineStart: int
  refillChars: set[char]

@end example
  the base lexer. Inherit your lexer from this object.
@end itemize

@chapter Procedures

@itemize


@item close
  @findex proc close*(L꞉ var BaseLexer)
@example
proc close*(L꞉ var BaseLexer)
@end example
  closes the base lexer. This closes @emph{L}'s associated stream too.

@item handleCR
  @findex proc handleCR*(L꞉ var BaseLexer; pos꞉ int)꞉ int
@example
proc handleCR*(L꞉ var BaseLexer; pos꞉ int)꞉ int
@end example
  Call this if you scanned over 'c' in the buffer; it returns the the position to continue the scanning from. @emph{pos} must be the position of the 'c'.

@item handleLF
  @findex proc handleLF*(L꞉ var BaseLexer; pos꞉ int)꞉ int
@example
proc handleLF*(L꞉ var BaseLexer; pos꞉ int)꞉ int
@end example
  Call this if you scanned over 'L' in the buffer; it returns the the position to continue the scanning from. @emph{pos} must be the position of the 'L'.

@item handleRefillChar
  @findex proc handleRefillChar*(L꞉ var BaseLexer; pos꞉ int)꞉ int
@example
proc handleRefillChar*(L꞉ var BaseLexer; pos꞉ int)꞉ int
@end example
  To be documented.

@item open
  @findex proc open*(L꞉ var BaseLexer; input꞉ Stream; bufLen꞉ int = 8192;refillChars꞉ set[char] = NewLines)
@example
proc open*(L꞉ var BaseLexer; input꞉ Stream; bufLen꞉ int = 8192;refillChars꞉ set[char] = NewLines)
@end example
  inits the BaseLexer with a stream to read from.

@item getColNumber
  @findex proc getColNumber*(L꞉ BaseLexer; pos꞉ int)꞉ int
@example
proc getColNumber*(L꞉ BaseLexer; pos꞉ int)꞉ int
@end example
  retrieves the current column.

@item getCurrentLine
  @findex proc getCurrentLine*(L꞉ BaseLexer; marker꞉ bool = true)꞉ string
@example
proc getCurrentLine*(L꞉ BaseLexer; marker꞉ bool = true)꞉ string
@end example
  retrieves the current line.
@end itemize






@node /pure/browsers, /pure/memfiles , /pure/lexbase, Top




@chapter Procedures

@itemize


@item openDefaultBrowser
  @findex proc openDefaultBrowser*(url꞉ string)
@example
proc openDefaultBrowser*(url꞉ string)
@end example
  opens @emph{url} with the user's default browser. This does not block.

Under Windows, @code{ShellExecute} is used. Under Mac OS X the @code{open} command is used. Under Unix, it is checked if @code{gnome-open} exists and used if it does. Next attempt is @code{kde-open}, then @code{xdg-open}. Otherwise the environment variable @code{BROWSER} is used to determine the default browser to use.
@end itemize






@node /pure/memfiles, /pure/parsecfg , /pure/browsers, Top



@chapter Types

@itemize


@item MemFile
  @tindex MemFile* = object
  mem*: pointer                ## a pointer to the memory mapped file. The pointer
              ## can be used directly to change the contents of the
              ## file, if it was opened with write access.
  size*: int                   ## size of the memory mapped file
  when defined(windows):
      fHandle: Handle
      mapHandle: Handle
      wasOpened: bool          ## only close if wasOpened
    
  else:
      handle: cint

  
@example
MemFile* = object
  mem*: pointer                ## a pointer to the memory mapped file. The pointer
              ## can be used directly to change the contents of the
              ## file, if it was opened with write access.
  size*: int                   ## size of the memory mapped file
  when defined(windows):
      fHandle: Handle
      mapHandle: Handle
      wasOpened: bool          ## only close if wasOpened
    
  else:
      handle: cint

  
@end example
  represents a memory mapped file

@item MemSlice
  @tindex MemSlice* = object
  data*: pointer
  size*: int

@example
MemSlice* = object
  data*: pointer
  size*: int

@end example
  represent slice of a MemFile for iteration over delimited lines/records
@end itemize

@chapter Procedures

@itemize


@item mapMem
  @findex proc mapMem*(m꞉ var MemFile; mode꞉ FileMode = fmRead; mappedSize = - 1; offset = 0)꞉ pointer
@example
proc mapMem*(m꞉ var MemFile; mode꞉ FileMode = fmRead; mappedSize = - 1; offset = 0)꞉ pointer
@end example
  

@item unmapMem
  @findex proc unmapMem*(f꞉ var MemFile; p꞉ pointer; size꞉ int)
@example
proc unmapMem*(f꞉ var MemFile; p꞉ pointer; size꞉ int)
@end example
  unmaps the memory region @code{(p, <p+size)} of the mapped file @emph{f}. All changes are written back to the file system, if @emph{f} was opened with write access. @code{size} must be of exactly the size that was requested via @code{mapMem}.

@item open
  @findex proc open*(filename꞉ string; mode꞉ FileMode = fmRead; mappedSize = - 1; offset = 0;newFileSize = - 1)꞉ MemFile
@example
proc open*(filename꞉ string; mode꞉ FileMode = fmRead; mappedSize = - 1; offset = 0;newFileSize = - 1)꞉ MemFile
@end example
  opens a memory mapped file. If this fails, @code{EOS} is raised. @emph{newFileSize} can only be set if the file does not exist and is opened with write access (e.g., with fmReadWrite). @emph{mappedSize} and @emph{offset} can be used to map only a slice of the file. Example:
@example
var
  mm, mm_full, mm_half: MemFile

mm = memfiles.open("/tmp/test.mmap", mode = fmWrite, newFileSize = 1024)    # Create a new file
mm.close()

# Read the whole file, would fail if newFileSize was set
mm_full = memfiles.open("/tmp/test.mmap", mode = fmReadWrite, mappedSize = -1)

# Read the first 512 bytes
mm_half = memfiles.open("/tmp/test.mmap", mode = fmReadWrite, mappedSize = 512)
@end example

@item close
  @findex proc close*(f꞉ var MemFile)
@example
proc close*(f꞉ var MemFile)
@end example
  closes the memory mapped file @emph{f}. All changes are written back to the file system, if @emph{f} was opened with write access.

@item `$`
  @findex proc `$`*(ms꞉ MemSlice)꞉ string @{.inline.@}
@example
proc `$`*(ms꞉ MemSlice)꞉ string @{.inline.@}
@end example
  Return a Nim string built from a MemSlice.
@end itemize





@chapter Iterators

@itemize


@item memSlices
  @itindex iterator memSlices*(mfile꞉ MemFile; delim = '\x0A'; eat = '\x0D')꞉ MemSlice @{.inline.@}
@example
iterator memSlices*(mfile꞉ MemFile; delim = '\x0A'; eat = '\x0D')꞉ MemSlice @{.inline.@}
@end example
  Iterates over [optional @emph{eat}] @emph{delim}-delimited slices in MemFile @emph{mfile}.

Default parameters parse lines ending in either Unix(\l) or Windows(\r\l) style on on a line-by-line basis.  I.e., not every line needs the same ending. Unlike readLine(File) & lines(File), archaic MacOS9 \r-delimited lines are not supported as a third option for each line.  Such archaic MacOS9 files can be handled by passing delim='\r', eat='\0', though.

Delimiters are not part of the returned slice.  A final, unterminated line or record is returned just like any other.

Non-default delimiters can be passed to allow iteration over other sorts of "line-like" variable length records.  Pass eat='\0' to be strictly @emph{delim}-delimited. (Eating an optional prefix equal to '\0' is not supported.)

This zero copy, memchr-limited interface is probably the fastest way to iterate over line-like records in a file.  However, returned (data,size) objects are not Nim strings, bounds checked Nim arrays, or even terminated C strings.  So, care is required to access the data (e.g., think C mem* functions, not str* functions).  Example:


@example
var count = 0
for slice in memSlices(memfiles.open("foo")):
  if slice.size > 0 and cast[cstring](slice.data)[0] != '#':
    inc(count)
echo count
@end example

@item lines
  @itindex iterator lines*(mfile꞉ MemFile; buf꞉ var TaintedString; delim = '\x0A'; eat = '\x0D')꞉ TaintedString @{.inline.@}
@example
iterator lines*(mfile꞉ MemFile; buf꞉ var TaintedString; delim = '\x0A'; eat = '\x0D')꞉ TaintedString @{.inline.@}
@end example
  Replace contents of passed buffer with each new line, like @uref{system.html#readLine,File,TaintedString, readLine(File)}. @emph{delim}, @emph{eat}, and delimiting logic is exactly as for @uref{#memSlices, memSlices}, but Nim strings are returned.  Example:
@example
var buffer: TaintedString = ""
for line in lines(memfiles.open("foo"), buffer):
  echo line
@end example

@item lines
  @itindex iterator lines*(mfile꞉ MemFile; delim = '\x0A'; eat = '\x0D')꞉ TaintedString @{.inline.@}
@example
iterator lines*(mfile꞉ MemFile; delim = '\x0A'; eat = '\x0D')꞉ TaintedString @{.inline.@}
@end example
  Return each line in a file as a Nim string, like @uref{system.html#lines.i,File, lines(File)}. @emph{delim}, @emph{eat}, and delimiting logic is exactly as for @uref{#memSlices, memSlices}, but Nim strings are returned.  Example:
@example
for line in lines(memfiles.open("foo")):
  echo line
@end example
@end itemize

@node /pure/parsecfg, /pure/base64 , /pure/memfiles, Top



@chapter Types

@itemize


@item CfgParser
  @tindex CfgParser* = object of BaseLexer
  tok: Token
  filename: string

@example
CfgParser* = object of BaseLexer
  tok: Token
  filename: string

@end example
  the parser object.
@end itemize

@chapter Procedures

@itemize


@item open
  @findex proc open*(c꞉ var CfgParser; input꞉ Stream; filename꞉ string; lineOffset = 0) @{.rtl,extern꞉ "npc$1".@}
@example
proc open*(c꞉ var CfgParser; input꞉ Stream; filename꞉ string; lineOffset = 0) @{.rtl,extern꞉ "npc$1".@}
@end example
  initializes the parser with an input stream. @emph{Filename} is only used for nice error messages. @emph{lineOffset} can be used to influence the line number information in the generated error messages.

@item close
  @findex proc close*(c꞉ var CfgParser) @{.rtl, extern꞉ "npc$1".@}
@example
proc close*(c꞉ var CfgParser) @{.rtl, extern꞉ "npc$1".@}
@end example
  closes the parser @emph{c} and its associated input stream.

@item getColumn
  @findex proc getColumn*(c꞉ CfgParser)꞉ int @{.rtl, extern꞉ "npc$1".@}
@example
proc getColumn*(c꞉ CfgParser)꞉ int @{.rtl, extern꞉ "npc$1".@}
@end example
  get the current column the parser has arrived at.

@item getLine
  @findex proc getLine*(c꞉ CfgParser)꞉ int @{.rtl, extern꞉ "npc$1".@}
@example
proc getLine*(c꞉ CfgParser)꞉ int @{.rtl, extern꞉ "npc$1".@}
@end example
  get the current line the parser has arrived at.

@item getFilename
  @findex proc getFilename*(c꞉ CfgParser)꞉ string @{.rtl, extern꞉ "npc$1".@}
@example
proc getFilename*(c꞉ CfgParser)꞉ string @{.rtl, extern꞉ "npc$1".@}
@end example
  get the filename of the file that the parser processes.

@item errorStr
  @findex proc errorStr*(c꞉ CfgParser; msg꞉ string)꞉ string @{.rtl, extern꞉ "npc$1".@}
@example
proc errorStr*(c꞉ CfgParser; msg꞉ string)꞉ string @{.rtl, extern꞉ "npc$1".@}
@end example
  returns a properly formated error message containing current line and column information.

@item warningStr
  @findex proc warningStr*(c꞉ CfgParser; msg꞉ string)꞉ string @{.rtl, extern꞉ "npc$1".@}
@example
proc warningStr*(c꞉ CfgParser; msg꞉ string)꞉ string @{.rtl, extern꞉ "npc$1".@}
@end example
  returns a properly formated warning message containing current line and column information.

@item ignoreMsg
  @findex proc ignoreMsg*(c꞉ CfgParser; e꞉ CfgEvent)꞉ string @{.rtl, extern꞉ "npc$1".@}
@example
proc ignoreMsg*(c꞉ CfgParser; e꞉ CfgEvent)꞉ string @{.rtl, extern꞉ "npc$1".@}
@end example
  returns a properly formated warning message containing that an entry is ignored.

@item next
  @findex proc next*(c꞉ var CfgParser)꞉ CfgEvent @{.rtl, extern꞉ "npc$1".@}
@example
proc next*(c꞉ var CfgParser)꞉ CfgEvent @{.rtl, extern꞉ "npc$1".@}
@end example
  retrieves the first/next event. This controls the parser.
@end itemize






@node /pure/base64, /pure/cgi , /pure/parsecfg, Top




@chapter Procedures

@itemize


@item encode
  @findex proc encode*[T꞉ SomeInteger | char](s꞉ openarray[T]; lineLen = 75; newLine = "\x0D\x0A")꞉ string
@example
proc encode*[T꞉ SomeInteger | char](s꞉ openarray[T]; lineLen = 75; newLine = "\x0D\x0A")꞉ string
@end example
  encodes @emph{s} into base64 representation. After @emph{lineLen} characters, a @emph{newline} is added.

This procedure encodes an openarray (array or sequence) of either integers or characters.

@item encode
  @findex proc encode*(s꞉ string; lineLen = 75; newLine = "\x0D\x0A")꞉ string
@example
proc encode*(s꞉ string; lineLen = 75; newLine = "\x0D\x0A")꞉ string
@end example
  encodes @emph{s} into base64 representation. After @emph{lineLen} characters, a @emph{newline} is added.

This procedure encodes a string.

@item decode
  @findex proc decode*(s꞉ string)꞉ string
@example
proc decode*(s꞉ string)꞉ string
@end example
  decodes a string in base64 representation back into its original form. Whitespace is skipped.
@end itemize






@node /pure/cgi, /pure/logging , /pure/base64, Top



@chapter Types

@itemize


@item RequestMethod
  @tindex RequestMethod* = enum
  methodNone,                 ## no REQUEST_METHOD environment variable
  methodPost,                 ## query uses the POST method
  methodGet                   ## query uses the GET method
@example
RequestMethod* = enum
  methodNone,                 ## no REQUEST_METHOD environment variable
  methodPost,                 ## query uses the POST method
  methodGet                   ## query uses the GET method
@end example
  the used request method
@end itemize

@chapter Procedures

@itemize


@item encodeUrl
  @findex proc encodeUrl*(s꞉ string)꞉ string
@example
proc encodeUrl*(s꞉ string)꞉ string
@end example
  Encodes a value to be HTTP safe: This means that characters in the set @code{@{'A'..'Z', 'a'..'z', '0'..'9', '_'@}} are carried over to the result, a space is converted to @code{'+'} and every other character is encoded as @code{'%xx'} where @code{xx} denotes its hexadecimal value.

@item decodeUrl
  @findex proc decodeUrl*(s꞉ string)꞉ string
@example
proc decodeUrl*(s꞉ string)꞉ string
@end example
  Decodes a value from its HTTP representation: This means that a @code{'+'} is converted to a space, @code{'%xx'} (where @code{xx} denotes a hexadecimal value) is converted to the character with ordinal number @code{xx}, and and every other character is carried over.

@item xmlEncode
  @findex proc xmlEncode*(s꞉ string)꞉ string
@example
proc xmlEncode*(s꞉ string)꞉ string
@end example
  Encodes a value to be XML safe:
@itemize 
 @item @code{"} is replaced by @code{&quot;}
@item @code{<} is replaced by @code{&lt;}
@item @code{>} is replaced by @code{&gt;}
@item @code{&} is replaced by @code{&amp;}
@item every other character is carried over.
 
@end itemize

@item cgiError
  @findex proc cgiError*(msg꞉ string) @{.noreturn.@}
@example
proc cgiError*(msg꞉ string) @{.noreturn.@}
@end example
  raises an ECgi exception with message @emph{msg}.

@item readData
  @findex proc readData*(allowedMethods꞉ set[RequestMethod] = @{methodNone, methodPost, methodGet@})꞉ StringTableRef
@example
proc readData*(allowedMethods꞉ set[RequestMethod] = @{methodNone, methodPost, methodGet@})꞉ StringTableRef
@end example
  Read CGI data. If the client does not use a method listed in the @emph{allowedMethods} set, an @emph{ECgi} exception is raised.

@item validateData
  @findex proc validateData*(data꞉ StringTableRef; validKeys꞉ varargs[string])
@example
proc validateData*(data꞉ StringTableRef; validKeys꞉ varargs[string])
@end example
  validates data; raises @emph{ECgi} if this fails. This checks that each variable name of the CGI @emph{data} occurs in the @emph{validKeys} array.

@item getContentLength
  @findex proc getContentLength*()꞉ string
@example
proc getContentLength*()꞉ string
@end example
  returns contents of the @code{CONTENT_LENGTH} environment variable

@item getContentType
  @findex proc getContentType*()꞉ string
@example
proc getContentType*()꞉ string
@end example
  returns contents of the @code{CONTENT_TYPE} environment variable

@item getDocumentRoot
  @findex proc getDocumentRoot*()꞉ string
@example
proc getDocumentRoot*()꞉ string
@end example
  returns contents of the @code{DOCUMENT_ROOT} environment variable

@item getGatewayInterface
  @findex proc getGatewayInterface*()꞉ string
@example
proc getGatewayInterface*()꞉ string
@end example
  returns contents of the @code{GATEWAY_INTERFACE} environment variable

@item getHttpAccept
  @findex proc getHttpAccept*()꞉ string
@example
proc getHttpAccept*()꞉ string
@end example
  returns contents of the @code{HTTP_ACCEPT} environment variable

@item getHttpAcceptCharset
  @findex proc getHttpAcceptCharset*()꞉ string
@example
proc getHttpAcceptCharset*()꞉ string
@end example
  returns contents of the @code{HTTP_ACCEPT_CHARSET} environment variable

@item getHttpAcceptEncoding
  @findex proc getHttpAcceptEncoding*()꞉ string
@example
proc getHttpAcceptEncoding*()꞉ string
@end example
  returns contents of the @code{HTTP_ACCEPT_ENCODING} environment variable

@item getHttpAcceptLanguage
  @findex proc getHttpAcceptLanguage*()꞉ string
@example
proc getHttpAcceptLanguage*()꞉ string
@end example
  returns contents of the @code{HTTP_ACCEPT_LANGUAGE} environment variable

@item getHttpConnection
  @findex proc getHttpConnection*()꞉ string
@example
proc getHttpConnection*()꞉ string
@end example
  returns contents of the @code{HTTP_CONNECTION} environment variable

@item getHttpCookie
  @findex proc getHttpCookie*()꞉ string
@example
proc getHttpCookie*()꞉ string
@end example
  returns contents of the @code{HTTP_COOKIE} environment variable

@item getHttpHost
  @findex proc getHttpHost*()꞉ string
@example
proc getHttpHost*()꞉ string
@end example
  returns contents of the @code{HTTP_HOST} environment variable

@item getHttpReferer
  @findex proc getHttpReferer*()꞉ string
@example
proc getHttpReferer*()꞉ string
@end example
  returns contents of the @code{HTTP_REFERER} environment variable

@item getHttpUserAgent
  @findex proc getHttpUserAgent*()꞉ string
@example
proc getHttpUserAgent*()꞉ string
@end example
  returns contents of the @code{HTTP_USER_AGENT} environment variable

@item getPathInfo
  @findex proc getPathInfo*()꞉ string
@example
proc getPathInfo*()꞉ string
@end example
  returns contents of the @code{PATH_INFO} environment variable

@item getPathTranslated
  @findex proc getPathTranslated*()꞉ string
@example
proc getPathTranslated*()꞉ string
@end example
  returns contents of the @code{PATH_TRANSLATED} environment variable

@item getQueryString
  @findex proc getQueryString*()꞉ string
@example
proc getQueryString*()꞉ string
@end example
  returns contents of the @code{QUERY_STRING} environment variable

@item getRemoteAddr
  @findex proc getRemoteAddr*()꞉ string
@example
proc getRemoteAddr*()꞉ string
@end example
  returns contents of the @code{REMOTE_ADDR} environment variable

@item getRemoteHost
  @findex proc getRemoteHost*()꞉ string
@example
proc getRemoteHost*()꞉ string
@end example
  returns contents of the @code{REMOTE_HOST} environment variable

@item getRemoteIdent
  @findex proc getRemoteIdent*()꞉ string
@example
proc getRemoteIdent*()꞉ string
@end example
  returns contents of the @code{REMOTE_IDENT} environment variable

@item getRemotePort
  @findex proc getRemotePort*()꞉ string
@example
proc getRemotePort*()꞉ string
@end example
  returns contents of the @code{REMOTE_PORT} environment variable

@item getRemoteUser
  @findex proc getRemoteUser*()꞉ string
@example
proc getRemoteUser*()꞉ string
@end example
  returns contents of the @code{REMOTE_USER} environment variable

@item getRequestMethod
  @findex proc getRequestMethod*()꞉ string
@example
proc getRequestMethod*()꞉ string
@end example
  returns contents of the @code{REQUEST_METHOD} environment variable

@item getRequestURI
  @findex proc getRequestURI*()꞉ string
@example
proc getRequestURI*()꞉ string
@end example
  returns contents of the @code{REQUEST_URI} environment variable

@item getScriptFilename
  @findex proc getScriptFilename*()꞉ string
@example
proc getScriptFilename*()꞉ string
@end example
  returns contents of the @code{SCRIPT_FILENAME} environment variable

@item getScriptName
  @findex proc getScriptName*()꞉ string
@example
proc getScriptName*()꞉ string
@end example
  returns contents of the @code{SCRIPT_NAME} environment variable

@item getServerAddr
  @findex proc getServerAddr*()꞉ string
@example
proc getServerAddr*()꞉ string
@end example
  returns contents of the @code{SERVER_ADDR} environment variable

@item getServerAdmin
  @findex proc getServerAdmin*()꞉ string
@example
proc getServerAdmin*()꞉ string
@end example
  returns contents of the @code{SERVER_ADMIN} environment variable

@item getServerName
  @findex proc getServerName*()꞉ string
@example
proc getServerName*()꞉ string
@end example
  returns contents of the @code{SERVER_NAME} environment variable

@item getServerPort
  @findex proc getServerPort*()꞉ string
@example
proc getServerPort*()꞉ string
@end example
  returns contents of the @code{SERVER_PORT} environment variable

@item getServerProtocol
  @findex proc getServerProtocol*()꞉ string
@example
proc getServerProtocol*()꞉ string
@end example
  returns contents of the @code{SERVER_PROTOCOL} environment variable

@item getServerSignature
  @findex proc getServerSignature*()꞉ string
@example
proc getServerSignature*()꞉ string
@end example
  returns contents of the @code{SERVER_SIGNATURE} environment variable

@item getServerSoftware
  @findex proc getServerSoftware*()꞉ string
@example
proc getServerSoftware*()꞉ string
@end example
  returns contents of the @code{SERVER_SOFTWARE} environment variable

@item setTestData
  @findex proc setTestData*(keysvalues꞉ varargs[string])
@example
proc setTestData*(keysvalues꞉ varargs[string])
@end example
  fills the appropriate environment variables to test your CGI application. This can only simulate the 'GET' request method. @emph{keysvalues} should provide embedded (name, value)-pairs. Example:
@example
setTestData("name", "Hanz", "password", "12345")
@end example

@item writeContentType
  @findex proc writeContentType*()
@example
proc writeContentType*()
@end example
  call this before starting to send your HTML data to @emph{stdout}. This implements this part of the CGI protocol:
@example
write(stdout, "Content-type: text/html\n\n")
@end example

@item writeErrorMessage
  @findex proc writeErrorMessage*(data꞉ string)
@example
proc writeErrorMessage*(data꞉ string)
@end example
  Tries to reset browser state and writes @emph{data} to stdout in <plaintext> tag.

@item setStackTraceStdout
  @findex proc setStackTraceStdout*()
@example
proc setStackTraceStdout*()
@end example
  Makes Nim output stacktraces to stdout, instead of server log.

@item setStackTraceNewLine
  @findex proc setStackTraceNewLine*() @{.deprecated.@}
@example
proc setStackTraceNewLine*() @{.deprecated.@}
@end example
  Makes Nim output stacktraces to stdout, instead of server log. Depracated alias for setStackTraceStdout.

@item setCookie
  @findex proc setCookie*(name, value꞉ string)
@example
proc setCookie*(name, value꞉ string)
@end example
  Sets a cookie.

@item getCookie
  @findex proc getCookie*(name꞉ string)꞉ TaintedString
@example
proc getCookie*(name꞉ string)꞉ TaintedString
@end example
  Gets a cookie. If no cookie of @emph{name} exists, "" is returned.

@item existsCookie
  @findex proc existsCookie*(name꞉ string)꞉ bool
@example
proc existsCookie*(name꞉ string)꞉ bool
@end example
  Checks if a cookie of @emph{name} exists.
@end itemize





@chapter Iterators

@itemize


@item decodeData
  @itindex iterator decodeData*(data꞉ string)꞉ tuple[key, value꞉ TaintedString]
@example
iterator decodeData*(data꞉ string)꞉ tuple[key, value꞉ TaintedString]
@end example
  Reads and decodes CGI data and yields the (name, value) pairs the data consists of.

@item decodeData
  @itindex iterator decodeData*(allowedMethods꞉ set[RequestMethod] = @{methodNone, methodPost,methodGet@})꞉ tuple[key, value꞉ TaintedString]
@example
iterator decodeData*(allowedMethods꞉ set[RequestMethod] = @{methodNone, methodPost,methodGet@})꞉ tuple[key, value꞉ TaintedString]
@end example
  Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the @emph{allowedMethods} set, an @emph{ECgi} exception is raised.
@end itemize

@node /pure/logging, /pure/subexes , /pure/cgi, Top
@chapter Constant variables

@itemize


@item verboseFmtStr
  @vindex verboseFmtStr* = "$levelid, [$datetime] -- $appname꞉ "
@example
verboseFmtStr* = "$levelid, [$datetime] -- $appname꞉ "
@end example
  
@end itemize



@chapter Types

@itemize


@item Level
  @tindex Level* = enum
  lvlAll,                     ## all levels active
  lvlDebug,                   ## debug level (and any above) active
  lvlInfo,                    ## info level (and any above) active
  lvlWarn,                    ## warn level (and any above) active
  lvlError,                   ## error level (and any above) active
  lvlFatal,                   ## fatal level (and any above) active
  lvlNone                     ## no levels active
@example
Level* = enum
  lvlAll,                     ## all levels active
  lvlDebug,                   ## debug level (and any above) active
  lvlInfo,                    ## info level (and any above) active
  lvlWarn,                    ## warn level (and any above) active
  lvlError,                   ## error level (and any above) active
  lvlFatal,                   ## fatal level (and any above) active
  lvlNone                     ## no levels active
@end example
  logging level

@item RollingFileLogger
  @tindex RollingFileLogger* = ref object of FileLogger
  maxLines: int
  curLine: int
  baseName: string
  baseMode: FileMode
  logFiles: int
  bufSize: int

@example
RollingFileLogger* = ref object of FileLogger
  maxLines: int
  curLine: int
  baseName: string
  baseMode: FileMode
  logFiles: int
  bufSize: int

@end example
  logger that writes the messages to a file and performs log rotation
@end itemize

@chapter Procedures

@itemize


@item substituteLog
  @findex proc substituteLog*(frmt꞉ string; level꞉ Level; args꞉ varargs[string, `$`])꞉ string
@example
proc substituteLog*(frmt꞉ string; level꞉ Level; args꞉ varargs[string, `$`])꞉ string
@end example
  Format a log message using the @code{frmt} format string, @code{level} and varargs. See the module documentation for the format string syntax.

@item defaultFilename
  @findex proc defaultFilename*()꞉ string
@example
proc defaultFilename*()꞉ string
@end example
  Returns the default filename for a logger.

@item newConsoleLogger
  @findex proc newConsoleLogger*(levelThreshold = lvlAll; fmtStr = defaultFmtStr)꞉ ConsoleLogger
@example
proc newConsoleLogger*(levelThreshold = lvlAll; fmtStr = defaultFmtStr)꞉ ConsoleLogger
@end example
  Creates a new console logger. This logger logs to the console.

@item newFileLogger
  @findex proc newFileLogger*(filename = defaultFilename(); mode꞉ FileMode = fmAppend;levelThreshold = lvlAll; fmtStr = defaultFmtStr; bufSize꞉ int = - 1)꞉ FileLogger
@example
proc newFileLogger*(filename = defaultFilename(); mode꞉ FileMode = fmAppend;levelThreshold = lvlAll; fmtStr = defaultFmtStr; bufSize꞉ int = - 1)꞉ FileLogger
@end example
  Creates a new file logger. This logger logs to a file. Use @code{bufSize} as size of the output buffer when writing the file (-1: use system defaults, 0: unbuffered, >0: fixed buffer size).

@item newRollingFileLogger
  @findex proc newRollingFileLogger*(filename = defaultFilename();mode꞉ FileMode = fmReadWrite; levelThreshold = lvlAll;fmtStr = defaultFmtStr; maxLines = 1000; bufSize꞉ int = - 1)꞉ RollingFileLogger
@example
proc newRollingFileLogger*(filename = defaultFilename();mode꞉ FileMode = fmReadWrite; levelThreshold = lvlAll;fmtStr = defaultFmtStr; maxLines = 1000; bufSize꞉ int = - 1)꞉ RollingFileLogger
@end example
  Creates a new rolling file logger. Once a file reaches @code{maxLines} lines a new log file will be started and the old will be renamed. Use @code{bufSize} as size of the output buffer when writing the file (-1: use system defaults, 0: unbuffered, >0: fixed buffer size).

@item addHandler
  @findex proc addHandler*(handler꞉ Logger)
@example
proc addHandler*(handler꞉ Logger)
@end example
  Adds @code{handler} to the list of handlers.

@item getHandlers
  @findex proc getHandlers*()꞉ seq[Logger]
@example
proc getHandlers*()꞉ seq[Logger]
@end example
  Returns a list of all the registered handlers.

@item setLogFilter
  @findex proc setLogFilter*(lvl꞉ Level)
@example
proc setLogFilter*(lvl꞉ Level)
@end example
  Sets the global log filter.

@item getLogFilter
  @findex proc getLogFilter*()꞉ Level
@example
proc getLogFilter*()꞉ Level
@end example
  Gets the global log filter.
@end itemize

@chapter Templates

@itemize


@item log
  @findex template log*(level꞉ Level; args꞉ varargs[string, `$`])
@example
template log*(level꞉ Level; args꞉ varargs[string, `$`])
@end example
  Logs a message to all registered handlers at the given level.

@item debug
  @findex template debug*(args꞉ varargs[string, `$`])
@example
template debug*(args꞉ varargs[string, `$`])
@end example
  Logs a debug message to all registered handlers.

@item info
  @findex template info*(args꞉ varargs[string, `$`])
@example
template info*(args꞉ varargs[string, `$`])
@end example
  Logs an info message to all registered handlers.

@item warn
  @findex template warn*(args꞉ varargs[string, `$`])
@example
template warn*(args꞉ varargs[string, `$`])
@end example
  Logs a warning message to all registered handlers.

@item error
  @findex template error*(args꞉ varargs[string, `$`])
@example
template error*(args꞉ varargs[string, `$`])
@end example
  Logs an error message to all registered handlers.

@item fatal
  @findex template fatal*(args꞉ varargs[string, `$`])
@example
template fatal*(args꞉ varargs[string, `$`])
@end example
  Logs a fatal error message to all registered handlers.
@end itemize



@chapter Methods

@itemize


@item log
  @findex method log*(logger꞉ Logger; level꞉ Level; args꞉ varargs[string, `$`]) @{.raises꞉ [Exception], tags꞉ [TimeEffect, WriteIOEffect, ReadIOEffect], base.@}
@example
method log*(logger꞉ Logger; level꞉ Level; args꞉ varargs[string, `$`]) @{.raises꞉ [Exception], tags꞉ [TimeEffect, WriteIOEffect, ReadIOEffect], base.@}
@end example
  Override this method in custom loggers. Default implementation does nothing.

@item log
  @findex method log*(logger꞉ ConsoleLogger; level꞉ Level; args꞉ varargs[string, `$`])
@example
method log*(logger꞉ ConsoleLogger; level꞉ Level; args꞉ varargs[string, `$`])
@end example
  Logs to the console using @code{logger} only.

@item log
  @findex method log*(logger꞉ FileLogger; level꞉ Level; args꞉ varargs[string, `$`])
@example
method log*(logger꞉ FileLogger; level꞉ Level; args꞉ varargs[string, `$`])
@end example
  Logs to a file using @code{logger} only.

@item log
  @findex method log*(logger꞉ RollingFileLogger; level꞉ Level; args꞉ varargs[string, `$`])
@example
method log*(logger꞉ RollingFileLogger; level꞉ Level; args꞉ varargs[string, `$`])
@end example
  Logs to a file using rolling @code{logger} only.
@end itemize


@node /pure/subexes, /pure/mimetypes , /pure/logging, Top



@chapter Types

@itemize


@item SubexError
  @tindex SubexError* = object of ValueError
@example
SubexError* = object of ValueError
@end example
  exception that is raised for an invalid subex

@item Subex
  @tindex Subex* = distinct string
@example
Subex* = distinct string
@end example
  string that contains a substitution expression
@end itemize

@chapter Procedures

@itemize


@item subex
  @findex proc subex*(s꞉ string)꞉ Subex
@example
proc subex*(s꞉ string)꞉ Subex
@end example
  constructs a @emph{substitution expression} from @emph{s}. Currently this performs no syntax checking but this may change in later versions.

@item addf
  @findex proc addf*(s꞉ var string; formatstr꞉ Subex; a꞉ varargs[string, `$`]) @{.noSideEffect, rtl,extern꞉ "nfrmtAddf".@}
@example
proc addf*(s꞉ var string; formatstr꞉ Subex; a꞉ varargs[string, `$`]) @{.noSideEffect, rtl,extern꞉ "nfrmtAddf".@}
@end example
  The same as @code{add(s, formatstr % a)}, but more efficient.

@item `%`
  @findex proc `%`*(formatstr꞉ Subex; a꞉ openarray[string])꞉ string @{.noSideEffect, rtl,extern꞉ "nfrmtFormatOpenArray".@}
@example
proc `%`*(formatstr꞉ Subex; a꞉ openarray[string])꞉ string @{.noSideEffect, rtl,extern꞉ "nfrmtFormatOpenArray".@}
@end example
  The  operator performs string substitutions in @emph{formatstr} and returns a modified @emph{formatstr}. This is often called .

@item `%`
  @findex proc `%`*(formatstr꞉ Subex; a꞉ string)꞉ string @{.noSideEffect, rtl,extern꞉ "nfrmtFormatSingleElem".@}
@example
proc `%`*(formatstr꞉ Subex; a꞉ string)꞉ string @{.noSideEffect, rtl,extern꞉ "nfrmtFormatSingleElem".@}
@end example
  This is the same as @code{formatstr % [a]}.

@item format
  @findex proc format*(formatstr꞉ Subex; a꞉ varargs[string, `$`])꞉ string @{.noSideEffect, rtl,extern꞉ "nfrmtFormatVarargs".@}
@example
proc format*(formatstr꞉ Subex; a꞉ varargs[string, `$`])꞉ string @{.noSideEffect, rtl,extern꞉ "nfrmtFormatVarargs".@}
@end example
  The  operator performs string substitutions in @emph{formatstr} and returns a modified @emph{formatstr}. This is often called .
@end itemize






@node /pure/mimetypes, /pure/poly , /pure/subexes, Top
@chapter Constant variables

@itemize


@item mimes
  @vindex mimes* = @{"ez": "application/andrew-inset", "anx": "application/annodex",
        "atom": "application/atom+xml", "atomcat": "application/atomcat+xml",
        "atomsrv": "application/atomserv+xml", "lin": "application/bbolin",
        "cap": "application/cap", "pcap": "application/cap",
        "cu": "application/cu-seeme", "davmount": "application/davmount+xml",
        "tsp": "application/dsptype", "es": "application/ecmascript",
        "spl": "application/futuresplash", "hta": "application/hta",
        "jar": "application/java-archive",
        "ser": "application/java-serialized-object",
        "class": "application/java-vm", "js": "application/javascript",
        "m3g": "application/m3g", "hqx": "application/mac-binhex40",
        "cpt": "application/mac-compactpro", "nb": "application/mathematica",
        "nbp": "application/mathematica", "mdb": "application/msaccess",
        "doc": "application/msword", "dot": "application/msword",
        "mxf": "application/mxf", "bin": "application/octet-stream",
        "oda": "application/oda", "ogx": "application/ogg",
        "pdf": "application/pdf", "key": "application/pgp-keys",
        "pgp": "application/pgp-signature", "prf": "application/pics-rules",
        "ps": "application/postscript", "ai": "application/postscript",
        "eps": "application/postscript", "epsi": "application/postscript",
        "epsf": "application/postscript", "eps2": "application/postscript",
        "eps3": "application/postscript", "rar": "application/rar",
        "rdf": "application/rdf+xml", "rss": "application/rss+xml",
        "rtf": "application/rtf", "smi": "application/smil",
        "smil": "application/smil", "xhtml": "application/xhtml+xml",
        "xht": "application/xhtml+xml", "xml": "application/xml",
        "xsl": "application/xml", "xsd": "application/xml",
        "xspf": "application/xspf+xml", "zip": "application/zip",
        "apk": "application/vnd.android.package-archive",
        "cdy": "application/vnd.cinderella",
        "kml": "application/vnd.google-earth.kml+xml",
        "kmz": "application/vnd.google-earth.kmz",
        "xul": "application/vnd.mozilla.xul+xml",
        "xls": "application/vnd.ms-excel", "xlb": "application/vnd.ms-excel",
        "xlt": "application/vnd.ms-excel", "cat": "application/vnd.ms-pki.seccat",
        "stl": "application/vnd.ms-pki.stl",
        "ppt": "application/vnd.ms-powerpoint",
        "pps": "application/vnd.ms-powerpoint", "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation", "ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "potx": "application/vnd.openxmlformats-officedocument.presentationml.template", "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "cod": "application/vnd.rim.cod", "mmf": "application/vnd.smaf",
        "sis": "application/vnd.symbian.install", "vsd": "application/vnd.visio",
        "wbxml": "application/vnd.wap.wbxml", "wmlc": "application/vnd.wap.wmlc",
        "wmlsc": "application/vnd.wap.wmlscriptc",
        "wpd": "application/vnd.wordperfect",
        "wp5": "application/vnd.wordperfect5.1", "wk": "application/x-123",
        "7z": "application/x-7z-compressed", "abw": "application/x-abiword",
        "dmg": "application/x-apple-diskimage", "bcpio": "application/x-bcpio",
        "torrent": "application/x-bittorrent", "cab": "application/x-cab",
        "cbr": "application/x-cbr", "cbz": "application/x-cbz",
        "cdf": "application/x-cdf", "cda": "application/x-cdf",
        "vcd": "application/x-cdlink", "pgn": "application/x-chess-pgn",
        "cpio": "application/x-cpio", "csh": "application/x-csh",
        "deb": "application/x-debian-package",
        "udeb": "application/x-debian-package", "dcr": "application/x-director",
        "dir": "application/x-director", "dxr": "application/x-director",
        "dms": "application/x-dms", "wad": "application/x-doom",
        "dvi": "application/x-dvi", "rhtml": "application/x-httpd-eruby",
        "pfa": "application/x-font", "pfb": "application/x-font",
        "gsf": "application/x-font", "pcf": "application/x-font",
        "pcf.Z": "application/x-font", "mm": "application/x-freemind",
        "spl": "application/x-futuresplash", "gnumeric": "application/x-gnumeric",
        "sgf": "application/x-go-sgf", "gcf": "application/x-graphing-calculator",
        "gtar": "application/x-gtar", "tgz": "application/x-gtar",
        "taz": "application/x-gtar", "hdf": "application/x-hdf",
        "phtml": "application/x-httpd-php", "pht": "application/x-httpd-php",
        "php": "application/x-httpd-php",
        "phps": "application/x-httpd-php-source",
        "php3": "application/x-httpd-php3",
        "php3p": "application/x-httpd-php3-preprocessed",
        "php4": "application/x-httpd-php4", "php5": "application/x-httpd-php5",
        "ica": "application/x-ica", "info": "application/x-info",
        "ins": "application/x-internet-signup",
        "isp": "application/x-internet-signup", "iii": "application/x-iphone",
        "iso": "application/x-iso9660-image", "jam": "application/x-jam",
        "jnlp": "application/x-java-jnlp-file", "jmz": "application/x-jmol",
        "chrt": "application/x-kchart", "kil": "application/x-killustrator",
        "skp": "application/x-koan", "skd": "application/x-koan",
        "skt": "application/x-koan", "skm": "application/x-koan",
        "kpr": "application/x-kpresenter", "kpt": "application/x-kpresenter",
        "ksp": "application/x-kspread", "kwd": "application/x-kword",
        "kwt": "application/x-kword", "latex": "application/x-latex",
        "lha": "application/x-lha", "lyx": "application/x-lyx",
        "lzh": "application/x-lzh", "lzx": "application/x-lzx",
        "frm": "application/x-maker", "maker": "application/x-maker",
        "frame": "application/x-maker", "fm": "application/x-maker",
        "fb": "application/x-maker", "book": "application/x-maker",
        "fbdoc": "application/x-maker", "mif": "application/x-mif",
        "wmd": "application/x-ms-wmd", "wmz": "application/x-ms-wmz",
        "com": "application/x-msdos-program",
        "exe": "application/x-msdos-program",
        "bat": "application/x-msdos-program",
        "dll": "application/x-msdos-program", "msi": "application/x-msi",
        "nc": "application/x-netcdf", "pac": "application/x-ns-proxy-autoconfig",
        "dat": "application/x-ns-proxy-autoconfig", "nwc": "application/x-nwc",
        "o": "application/x-object", "oza": "application/x-oz-application",
        "p7r": "application/x-pkcs7-certreqresp",
        "crl": "application/x-pkcs7-crl", "pyc": "application/x-python-code",
        "pyo": "application/x-python-code", "qgs": "application/x-qgis",
        "shp": "application/x-qgis", "shx": "application/x-qgis",
        "qtl": "application/x-quicktimeplayer",
        "rpm": "application/x-redhat-package-manager", "rb": "application/x-ruby",
        "sh": "application/x-sh", "shar": "application/x-shar",
        "swf": "application/x-shockwave-flash",
        "swfl": "application/x-shockwave-flash",
        "scr": "application/x-silverlight", "sit": "application/x-stuffit",
        "sitx": "application/x-stuffit", "sv4cpio": "application/x-sv4cpio",
        "sv4crc": "application/x-sv4crc", "tar": "application/x-tar",
        "tcl": "application/x-tcl", "gf": "application/x-tex-gf",
        "pk": "application/x-tex-pk", "texinfo": "application/x-texinfo",
        "texi": "application/x-texinfo", "~": "application/x-trash",
        "%": "application/x-trash", "bak": "application/x-trash",
        "old": "application/x-trash", "sik": "application/x-trash",
        "t": "application/x-troff", "tr": "application/x-troff",
        "roff": "application/x-troff", "man": "application/x-troff-man",
        "me": "application/x-troff-me", "ms": "application/x-troff-ms",
        "ustar": "application/x-ustar", "src": "application/x-wais-source",
        "wz": "application/x-wingz", "crt": "application/x-x509-ca-cert",
        "xcf": "application/x-xcf", "fig": "application/x-xfig",
        "xpi": "application/x-xpinstall", "amr": "audio/amr", "awb": "audio/amr-wb",
        "amr": "audio/amr", "awb": "audio/amr-wb", "axa": "audio/annodex",
        "au": "audio/basic", "snd": "audio/basic", "flac": "audio/flac",
        "mid": "audio/midi", "midi": "audio/midi", "kar": "audio/midi",
        "mpga": "audio/mpeg", "mpega": "audio/mpeg", "mp2": "audio/mpeg",
        "mp3": "audio/mpeg", "m4a": "audio/mpeg", "m3u": "audio/mpegurl",
        "oga": "audio/ogg", "ogg": "audio/ogg", "spx": "audio/ogg",
        "sid": "audio/prs.sid", "aif": "audio/x-aiff", "aiff": "audio/x-aiff",
        "aifc": "audio/x-aiff", "gsm": "audio/x-gsm", "m3u": "audio/x-mpegurl",
        "wma": "audio/x-ms-wma", "wax": "audio/x-ms-wax",
        "ra": "audio/x-pn-realaudio", "rm": "audio/x-pn-realaudio",
        "ram": "audio/x-pn-realaudio", "ra": "audio/x-realaudio",
        "pls": "audio/x-scpls", "sd2": "audio/x-sd2", "wav": "audio/x-wav",
        "alc": "chemical/x-alchemy", "cac": "chemical/x-cache",
        "cache": "chemical/x-cache", "csf": "chemical/x-cache-csf",
        "cbin": "chemical/x-cactvs-binary", "cascii": "chemical/x-cactvs-binary",
        "ctab": "chemical/x-cactvs-binary", "cdx": "chemical/x-cdx",
        "cer": "chemical/x-cerius", "c3d": "chemical/x-chem3d",
        "chm": "chemical/x-chemdraw", "cif": "chemical/x-cif",
        "cmdf": "chemical/x-cmdf", "cml": "chemical/x-cml",
        "cpa": "chemical/x-compass", "bsd": "chemical/x-crossfire",
        "csml": "chemical/x-csml", "csm": "chemical/x-csml",
        "ctx": "chemical/x-ctx", "cxf": "chemical/x-cxf", "cef": "chemical/x-cxf",
        "smi": "#chemical/x-daylight-smiles",
        "emb": "chemical/x-embl-dl-nucleotide",
        "embl": "chemical/x-embl-dl-nucleotide", "spc": "chemical/x-galactic-spc",
        "inp": "chemical/x-gamess-input", "gam": "chemical/x-gamess-input",
        "gamin": "chemical/x-gamess-input",
        "fch": "chemical/x-gaussian-checkpoint",
        "fchk": "chemical/x-gaussian-checkpoint",
        "cub": "chemical/x-gaussian-cube", "gau": "chemical/x-gaussian-input",
        "gjc": "chemical/x-gaussian-input", "gjf": "chemical/x-gaussian-input",
        "gal": "chemical/x-gaussian-log", "gcg": "chemical/x-gcg8-sequence",
        "gen": "chemical/x-genbank", "hin": "chemical/x-hin",
        "istr": "chemical/x-isostar", "ist": "chemical/x-isostar",
        "jdx": "chemical/x-jcamp-dx", "dx": "chemical/x-jcamp-dx",
        "kin": "chemical/x-kinemage", "mcm": "chemical/x-macmolecule",
        "mmd": "chemical/x-macromodel-input",
        "mmod": "chemical/x-macromodel-input", "mol": "chemical/x-mdl-molfile",
        "rd": "chemical/x-mdl-rdfile", "rxn": "chemical/x-mdl-rxnfile",
        "sd": "chemical/x-mdl-sdfile", "sdf": "chemical/x-mdl-sdfile",
        "tgf": "chemical/x-mdl-tgf", "mif": "#chemical/x-mif",
        "mcif": "chemical/x-mmcif", "mol2": "chemical/x-mol2",
        "b": "chemical/x-molconn-Z", "gpt": "chemical/x-mopac-graph",
        "mop": "chemical/x-mopac-input", "mopcrt": "chemical/x-mopac-input",
        "mpc": "chemical/x-mopac-input", "zmt": "chemical/x-mopac-input",
        "moo": "chemical/x-mopac-out", "mvb": "chemical/x-mopac-vib",
        "asn": "chemical/x-ncbi-asn1", "prt": "chemical/x-ncbi-asn1-ascii",
        "ent": "chemical/x-ncbi-asn1-ascii", "val": "chemical/x-ncbi-asn1-binary",
        "aso": "chemical/x-ncbi-asn1-binary", "asn": "chemical/x-ncbi-asn1-spec",
        "pdb": "chemical/x-pdb", "ent": "chemical/x-pdb",
        "ros": "chemical/x-rosdal", "sw": "chemical/x-swissprot",
        "vms": "chemical/x-vamas-iso14976", "vmd": "chemical/x-vmd",
        "xtel": "chemical/x-xtel", "xyz": "chemical/x-xyz", "gif": "image/gif",
        "ief": "image/ief", "jpeg": "image/jpeg", "jpg": "image/jpeg",
        "jpe": "image/jpeg", "pcx": "image/pcx", "png": "image/png",
        "svg": "image/svg+xml", "svgz": "image/svg+xml", "tiff": "image/tiff",
        "tif": "image/tiff", "djvu": "image/vnd.djvu", "djv": "image/vnd.djvu",
        "wbmp": "image/vnd.wap.wbmp", "cr2": "image/x-canon-cr2",
        "crw": "image/x-canon-crw", "ras": "image/x-cmu-raster",
        "cdr": "image/x-coreldraw", "pat": "image/x-coreldrawpattern",
        "cdt": "image/x-coreldrawtemplate", "cpt": "image/x-corelphotopaint",
        "erf": "image/x-epson-erf", "ico": "image/x-icon", "art": "image/x-jg",
        "jng": "image/x-jng", "bmp": "image/x-ms-bmp", "nef": "image/x-nikon-nef",
        "orf": "image/x-olympus-orf", "psd": "image/x-photoshop",
        "pnm": "image/x-portable-anymap", "pbm": "image/x-portable-bitmap",
        "pgm": "image/x-portable-graymap", "ppm": "image/x-portable-pixmap",
        "rgb": "image/x-rgb", "xbm": "image/x-xbitmap", "xpm": "image/x-xpixmap",
        "xwd": "image/x-xwindowdump", "eml": "message/rfc822", "igs": "model/iges",
        "iges": "model/iges", "msh": "model/mesh", "mesh": "model/mesh",
        "silo": "model/mesh", "wrl": "model/vrml", "vrml": "model/vrml",
        "x3dv": "model/x3d+vrml", "x3d": "model/x3d+xml",
        "x3db": "model/x3d+binary", "manifest": "text/cache-manifest",
        "ics": "text/calendar", "icz": "text/calendar", "css": "text/css",
        "csv": "text/csv", "323": "text/h323", "html": "text/html",
        "htm": "text/html", "shtml": "text/html", "uls": "text/iuls",
        "mml": "text/mathml", "asc": "text/plain", "txt": "text/plain",
        "text": "text/plain", "pot": "text/plain", "brf": "text/plain",
        "rtx": "text/richtext", "sct": "text/scriptlet", "wsc": "text/scriptlet",
        "tm": "text/texmacs", "ts": "text/texmacs",
        "tsv": "text/tab-separated-values",
        "jad": "text/vnd.sun.j2me.app-descriptor", "wml": "text/vnd.wap.wml",
        "wmls": "text/vnd.wap.wmlscript", "bib": "text/x-bibtex",
        "boo": "text/x-boo", "h++": "text/x-c++hdr", "hpp": "text/x-c++hdr",
        "hxx": "text/x-c++hdr", "hh": "text/x-c++hdr", "c++": "text/x-c++src",
        "cpp": "text/x-c++src", "cxx": "text/x-c++src", "cc": "text/x-c++src",
        "h": "text/x-chdr", "htc": "text/x-component", "csh": "text/x-csh",
        "c": "text/x-csrc", "d": "text/x-dsrc", "diff": "text/x-diff",
        "patch": "text/x-diff", "hs": "text/x-haskell", "java": "text/x-java",
        "lhs": "text/x-literate-haskell", "moc": "text/x-moc", "p": "text/x-pascal",
        "pas": "text/x-pascal", "gcd": "text/x-pcs-gcd", "pl": "text/x-perl",
        "pm": "text/x-perl", "py": "text/x-python", "scala": "text/x-scala",
        "etx": "text/x-setext", "sh": "text/x-sh", "tcl": "text/x-tcl",
        "tk": "text/x-tcl", "tex": "text/x-tex", "ltx": "text/x-tex",
        "sty": "text/x-tex", "cls": "text/x-tex", "vcs": "text/x-vcalendar",
        "vcf": "text/x-vcard", "3gp": "video/3gpp", "axv": "video/annodex",
        "dl": "video/dl", "dif": "video/dv", "dv": "video/dv", "fli": "video/fli",
        "gl": "video/gl", "mpeg": "video/mpeg", "mpg": "video/mpeg",
        "mpe": "video/mpeg", "mp4": "video/mp4", "qt": "video/quicktime",
        "mov": "video/quicktime", "ogv": "video/ogg", "mxu": "video/vnd.mpegurl",
        "flv": "video/x-flv", "lsf": "video/x-la-asf", "lsx": "video/x-la-asf",
        "mng": "video/x-mng", "asf": "video/x-ms-asf", "asx": "video/x-ms-asf",
        "wm": "video/x-ms-wm", "wmv": "video/x-ms-wmv", "wmx": "video/x-ms-wmx",
        "wvx": "video/x-ms-wvx", "avi": "video/x-msvideo",
        "movie": "video/x-sgi-movie", "mpv": "video/x-matroska",
        "mkv": "video/x-matroska", "ice": "x-conference/x-cooltalk",
        "sisx": "x-epoc/x-sisx-app", "vrm": "x-world/x-vrml",
        "vrml": "x-world/x-vrml", "wrl": "x-world/x-vrml"@}
@example
mimes* = @{"ez": "application/andrew-inset", "anx": "application/annodex",
        "atom": "application/atom+xml", "atomcat": "application/atomcat+xml",
        "atomsrv": "application/atomserv+xml", "lin": "application/bbolin",
        "cap": "application/cap", "pcap": "application/cap",
        "cu": "application/cu-seeme", "davmount": "application/davmount+xml",
        "tsp": "application/dsptype", "es": "application/ecmascript",
        "spl": "application/futuresplash", "hta": "application/hta",
        "jar": "application/java-archive",
        "ser": "application/java-serialized-object",
        "class": "application/java-vm", "js": "application/javascript",
        "m3g": "application/m3g", "hqx": "application/mac-binhex40",
        "cpt": "application/mac-compactpro", "nb": "application/mathematica",
        "nbp": "application/mathematica", "mdb": "application/msaccess",
        "doc": "application/msword", "dot": "application/msword",
        "mxf": "application/mxf", "bin": "application/octet-stream",
        "oda": "application/oda", "ogx": "application/ogg",
        "pdf": "application/pdf", "key": "application/pgp-keys",
        "pgp": "application/pgp-signature", "prf": "application/pics-rules",
        "ps": "application/postscript", "ai": "application/postscript",
        "eps": "application/postscript", "epsi": "application/postscript",
        "epsf": "application/postscript", "eps2": "application/postscript",
        "eps3": "application/postscript", "rar": "application/rar",
        "rdf": "application/rdf+xml", "rss": "application/rss+xml",
        "rtf": "application/rtf", "smi": "application/smil",
        "smil": "application/smil", "xhtml": "application/xhtml+xml",
        "xht": "application/xhtml+xml", "xml": "application/xml",
        "xsl": "application/xml", "xsd": "application/xml",
        "xspf": "application/xspf+xml", "zip": "application/zip",
        "apk": "application/vnd.android.package-archive",
        "cdy": "application/vnd.cinderella",
        "kml": "application/vnd.google-earth.kml+xml",
        "kmz": "application/vnd.google-earth.kmz",
        "xul": "application/vnd.mozilla.xul+xml",
        "xls": "application/vnd.ms-excel", "xlb": "application/vnd.ms-excel",
        "xlt": "application/vnd.ms-excel", "cat": "application/vnd.ms-pki.seccat",
        "stl": "application/vnd.ms-pki.stl",
        "ppt": "application/vnd.ms-powerpoint",
        "pps": "application/vnd.ms-powerpoint", "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation", "ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "potx": "application/vnd.openxmlformats-officedocument.presentationml.template", "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "cod": "application/vnd.rim.cod", "mmf": "application/vnd.smaf",
        "sis": "application/vnd.symbian.install", "vsd": "application/vnd.visio",
        "wbxml": "application/vnd.wap.wbxml", "wmlc": "application/vnd.wap.wmlc",
        "wmlsc": "application/vnd.wap.wmlscriptc",
        "wpd": "application/vnd.wordperfect",
        "wp5": "application/vnd.wordperfect5.1", "wk": "application/x-123",
        "7z": "application/x-7z-compressed", "abw": "application/x-abiword",
        "dmg": "application/x-apple-diskimage", "bcpio": "application/x-bcpio",
        "torrent": "application/x-bittorrent", "cab": "application/x-cab",
        "cbr": "application/x-cbr", "cbz": "application/x-cbz",
        "cdf": "application/x-cdf", "cda": "application/x-cdf",
        "vcd": "application/x-cdlink", "pgn": "application/x-chess-pgn",
        "cpio": "application/x-cpio", "csh": "application/x-csh",
        "deb": "application/x-debian-package",
        "udeb": "application/x-debian-package", "dcr": "application/x-director",
        "dir": "application/x-director", "dxr": "application/x-director",
        "dms": "application/x-dms", "wad": "application/x-doom",
        "dvi": "application/x-dvi", "rhtml": "application/x-httpd-eruby",
        "pfa": "application/x-font", "pfb": "application/x-font",
        "gsf": "application/x-font", "pcf": "application/x-font",
        "pcf.Z": "application/x-font", "mm": "application/x-freemind",
        "spl": "application/x-futuresplash", "gnumeric": "application/x-gnumeric",
        "sgf": "application/x-go-sgf", "gcf": "application/x-graphing-calculator",
        "gtar": "application/x-gtar", "tgz": "application/x-gtar",
        "taz": "application/x-gtar", "hdf": "application/x-hdf",
        "phtml": "application/x-httpd-php", "pht": "application/x-httpd-php",
        "php": "application/x-httpd-php",
        "phps": "application/x-httpd-php-source",
        "php3": "application/x-httpd-php3",
        "php3p": "application/x-httpd-php3-preprocessed",
        "php4": "application/x-httpd-php4", "php5": "application/x-httpd-php5",
        "ica": "application/x-ica", "info": "application/x-info",
        "ins": "application/x-internet-signup",
        "isp": "application/x-internet-signup", "iii": "application/x-iphone",
        "iso": "application/x-iso9660-image", "jam": "application/x-jam",
        "jnlp": "application/x-java-jnlp-file", "jmz": "application/x-jmol",
        "chrt": "application/x-kchart", "kil": "application/x-killustrator",
        "skp": "application/x-koan", "skd": "application/x-koan",
        "skt": "application/x-koan", "skm": "application/x-koan",
        "kpr": "application/x-kpresenter", "kpt": "application/x-kpresenter",
        "ksp": "application/x-kspread", "kwd": "application/x-kword",
        "kwt": "application/x-kword", "latex": "application/x-latex",
        "lha": "application/x-lha", "lyx": "application/x-lyx",
        "lzh": "application/x-lzh", "lzx": "application/x-lzx",
        "frm": "application/x-maker", "maker": "application/x-maker",
        "frame": "application/x-maker", "fm": "application/x-maker",
        "fb": "application/x-maker", "book": "application/x-maker",
        "fbdoc": "application/x-maker", "mif": "application/x-mif",
        "wmd": "application/x-ms-wmd", "wmz": "application/x-ms-wmz",
        "com": "application/x-msdos-program",
        "exe": "application/x-msdos-program",
        "bat": "application/x-msdos-program",
        "dll": "application/x-msdos-program", "msi": "application/x-msi",
        "nc": "application/x-netcdf", "pac": "application/x-ns-proxy-autoconfig",
        "dat": "application/x-ns-proxy-autoconfig", "nwc": "application/x-nwc",
        "o": "application/x-object", "oza": "application/x-oz-application",
        "p7r": "application/x-pkcs7-certreqresp",
        "crl": "application/x-pkcs7-crl", "pyc": "application/x-python-code",
        "pyo": "application/x-python-code", "qgs": "application/x-qgis",
        "shp": "application/x-qgis", "shx": "application/x-qgis",
        "qtl": "application/x-quicktimeplayer",
        "rpm": "application/x-redhat-package-manager", "rb": "application/x-ruby",
        "sh": "application/x-sh", "shar": "application/x-shar",
        "swf": "application/x-shockwave-flash",
        "swfl": "application/x-shockwave-flash",
        "scr": "application/x-silverlight", "sit": "application/x-stuffit",
        "sitx": "application/x-stuffit", "sv4cpio": "application/x-sv4cpio",
        "sv4crc": "application/x-sv4crc", "tar": "application/x-tar",
        "tcl": "application/x-tcl", "gf": "application/x-tex-gf",
        "pk": "application/x-tex-pk", "texinfo": "application/x-texinfo",
        "texi": "application/x-texinfo", "~": "application/x-trash",
        "%": "application/x-trash", "bak": "application/x-trash",
        "old": "application/x-trash", "sik": "application/x-trash",
        "t": "application/x-troff", "tr": "application/x-troff",
        "roff": "application/x-troff", "man": "application/x-troff-man",
        "me": "application/x-troff-me", "ms": "application/x-troff-ms",
        "ustar": "application/x-ustar", "src": "application/x-wais-source",
        "wz": "application/x-wingz", "crt": "application/x-x509-ca-cert",
        "xcf": "application/x-xcf", "fig": "application/x-xfig",
        "xpi": "application/x-xpinstall", "amr": "audio/amr", "awb": "audio/amr-wb",
        "amr": "audio/amr", "awb": "audio/amr-wb", "axa": "audio/annodex",
        "au": "audio/basic", "snd": "audio/basic", "flac": "audio/flac",
        "mid": "audio/midi", "midi": "audio/midi", "kar": "audio/midi",
        "mpga": "audio/mpeg", "mpega": "audio/mpeg", "mp2": "audio/mpeg",
        "mp3": "audio/mpeg", "m4a": "audio/mpeg", "m3u": "audio/mpegurl",
        "oga": "audio/ogg", "ogg": "audio/ogg", "spx": "audio/ogg",
        "sid": "audio/prs.sid", "aif": "audio/x-aiff", "aiff": "audio/x-aiff",
        "aifc": "audio/x-aiff", "gsm": "audio/x-gsm", "m3u": "audio/x-mpegurl",
        "wma": "audio/x-ms-wma", "wax": "audio/x-ms-wax",
        "ra": "audio/x-pn-realaudio", "rm": "audio/x-pn-realaudio",
        "ram": "audio/x-pn-realaudio", "ra": "audio/x-realaudio",
        "pls": "audio/x-scpls", "sd2": "audio/x-sd2", "wav": "audio/x-wav",
        "alc": "chemical/x-alchemy", "cac": "chemical/x-cache",
        "cache": "chemical/x-cache", "csf": "chemical/x-cache-csf",
        "cbin": "chemical/x-cactvs-binary", "cascii": "chemical/x-cactvs-binary",
        "ctab": "chemical/x-cactvs-binary", "cdx": "chemical/x-cdx",
        "cer": "chemical/x-cerius", "c3d": "chemical/x-chem3d",
        "chm": "chemical/x-chemdraw", "cif": "chemical/x-cif",
        "cmdf": "chemical/x-cmdf", "cml": "chemical/x-cml",
        "cpa": "chemical/x-compass", "bsd": "chemical/x-crossfire",
        "csml": "chemical/x-csml", "csm": "chemical/x-csml",
        "ctx": "chemical/x-ctx", "cxf": "chemical/x-cxf", "cef": "chemical/x-cxf",
        "smi": "#chemical/x-daylight-smiles",
        "emb": "chemical/x-embl-dl-nucleotide",
        "embl": "chemical/x-embl-dl-nucleotide", "spc": "chemical/x-galactic-spc",
        "inp": "chemical/x-gamess-input", "gam": "chemical/x-gamess-input",
        "gamin": "chemical/x-gamess-input",
        "fch": "chemical/x-gaussian-checkpoint",
        "fchk": "chemical/x-gaussian-checkpoint",
        "cub": "chemical/x-gaussian-cube", "gau": "chemical/x-gaussian-input",
        "gjc": "chemical/x-gaussian-input", "gjf": "chemical/x-gaussian-input",
        "gal": "chemical/x-gaussian-log", "gcg": "chemical/x-gcg8-sequence",
        "gen": "chemical/x-genbank", "hin": "chemical/x-hin",
        "istr": "chemical/x-isostar", "ist": "chemical/x-isostar",
        "jdx": "chemical/x-jcamp-dx", "dx": "chemical/x-jcamp-dx",
        "kin": "chemical/x-kinemage", "mcm": "chemical/x-macmolecule",
        "mmd": "chemical/x-macromodel-input",
        "mmod": "chemical/x-macromodel-input", "mol": "chemical/x-mdl-molfile",
        "rd": "chemical/x-mdl-rdfile", "rxn": "chemical/x-mdl-rxnfile",
        "sd": "chemical/x-mdl-sdfile", "sdf": "chemical/x-mdl-sdfile",
        "tgf": "chemical/x-mdl-tgf", "mif": "#chemical/x-mif",
        "mcif": "chemical/x-mmcif", "mol2": "chemical/x-mol2",
        "b": "chemical/x-molconn-Z", "gpt": "chemical/x-mopac-graph",
        "mop": "chemical/x-mopac-input", "mopcrt": "chemical/x-mopac-input",
        "mpc": "chemical/x-mopac-input", "zmt": "chemical/x-mopac-input",
        "moo": "chemical/x-mopac-out", "mvb": "chemical/x-mopac-vib",
        "asn": "chemical/x-ncbi-asn1", "prt": "chemical/x-ncbi-asn1-ascii",
        "ent": "chemical/x-ncbi-asn1-ascii", "val": "chemical/x-ncbi-asn1-binary",
        "aso": "chemical/x-ncbi-asn1-binary", "asn": "chemical/x-ncbi-asn1-spec",
        "pdb": "chemical/x-pdb", "ent": "chemical/x-pdb",
        "ros": "chemical/x-rosdal", "sw": "chemical/x-swissprot",
        "vms": "chemical/x-vamas-iso14976", "vmd": "chemical/x-vmd",
        "xtel": "chemical/x-xtel", "xyz": "chemical/x-xyz", "gif": "image/gif",
        "ief": "image/ief", "jpeg": "image/jpeg", "jpg": "image/jpeg",
        "jpe": "image/jpeg", "pcx": "image/pcx", "png": "image/png",
        "svg": "image/svg+xml", "svgz": "image/svg+xml", "tiff": "image/tiff",
        "tif": "image/tiff", "djvu": "image/vnd.djvu", "djv": "image/vnd.djvu",
        "wbmp": "image/vnd.wap.wbmp", "cr2": "image/x-canon-cr2",
        "crw": "image/x-canon-crw", "ras": "image/x-cmu-raster",
        "cdr": "image/x-coreldraw", "pat": "image/x-coreldrawpattern",
        "cdt": "image/x-coreldrawtemplate", "cpt": "image/x-corelphotopaint",
        "erf": "image/x-epson-erf", "ico": "image/x-icon", "art": "image/x-jg",
        "jng": "image/x-jng", "bmp": "image/x-ms-bmp", "nef": "image/x-nikon-nef",
        "orf": "image/x-olympus-orf", "psd": "image/x-photoshop",
        "pnm": "image/x-portable-anymap", "pbm": "image/x-portable-bitmap",
        "pgm": "image/x-portable-graymap", "ppm": "image/x-portable-pixmap",
        "rgb": "image/x-rgb", "xbm": "image/x-xbitmap", "xpm": "image/x-xpixmap",
        "xwd": "image/x-xwindowdump", "eml": "message/rfc822", "igs": "model/iges",
        "iges": "model/iges", "msh": "model/mesh", "mesh": "model/mesh",
        "silo": "model/mesh", "wrl": "model/vrml", "vrml": "model/vrml",
        "x3dv": "model/x3d+vrml", "x3d": "model/x3d+xml",
        "x3db": "model/x3d+binary", "manifest": "text/cache-manifest",
        "ics": "text/calendar", "icz": "text/calendar", "css": "text/css",
        "csv": "text/csv", "323": "text/h323", "html": "text/html",
        "htm": "text/html", "shtml": "text/html", "uls": "text/iuls",
        "mml": "text/mathml", "asc": "text/plain", "txt": "text/plain",
        "text": "text/plain", "pot": "text/plain", "brf": "text/plain",
        "rtx": "text/richtext", "sct": "text/scriptlet", "wsc": "text/scriptlet",
        "tm": "text/texmacs", "ts": "text/texmacs",
        "tsv": "text/tab-separated-values",
        "jad": "text/vnd.sun.j2me.app-descriptor", "wml": "text/vnd.wap.wml",
        "wmls": "text/vnd.wap.wmlscript", "bib": "text/x-bibtex",
        "boo": "text/x-boo", "h++": "text/x-c++hdr", "hpp": "text/x-c++hdr",
        "hxx": "text/x-c++hdr", "hh": "text/x-c++hdr", "c++": "text/x-c++src",
        "cpp": "text/x-c++src", "cxx": "text/x-c++src", "cc": "text/x-c++src",
        "h": "text/x-chdr", "htc": "text/x-component", "csh": "text/x-csh",
        "c": "text/x-csrc", "d": "text/x-dsrc", "diff": "text/x-diff",
        "patch": "text/x-diff", "hs": "text/x-haskell", "java": "text/x-java",
        "lhs": "text/x-literate-haskell", "moc": "text/x-moc", "p": "text/x-pascal",
        "pas": "text/x-pascal", "gcd": "text/x-pcs-gcd", "pl": "text/x-perl",
        "pm": "text/x-perl", "py": "text/x-python", "scala": "text/x-scala",
        "etx": "text/x-setext", "sh": "text/x-sh", "tcl": "text/x-tcl",
        "tk": "text/x-tcl", "tex": "text/x-tex", "ltx": "text/x-tex",
        "sty": "text/x-tex", "cls": "text/x-tex", "vcs": "text/x-vcalendar",
        "vcf": "text/x-vcard", "3gp": "video/3gpp", "axv": "video/annodex",
        "dl": "video/dl", "dif": "video/dv", "dv": "video/dv", "fli": "video/fli",
        "gl": "video/gl", "mpeg": "video/mpeg", "mpg": "video/mpeg",
        "mpe": "video/mpeg", "mp4": "video/mp4", "qt": "video/quicktime",
        "mov": "video/quicktime", "ogv": "video/ogg", "mxu": "video/vnd.mpegurl",
        "flv": "video/x-flv", "lsf": "video/x-la-asf", "lsx": "video/x-la-asf",
        "mng": "video/x-mng", "asf": "video/x-ms-asf", "asx": "video/x-ms-asf",
        "wm": "video/x-ms-wm", "wmv": "video/x-ms-wmv", "wmx": "video/x-ms-wmx",
        "wvx": "video/x-ms-wvx", "avi": "video/x-msvideo",
        "movie": "video/x-sgi-movie", "mpv": "video/x-matroska",
        "mkv": "video/x-matroska", "ice": "x-conference/x-cooltalk",
        "sisx": "x-epoc/x-sisx-app", "vrm": "x-world/x-vrml",
        "vrml": "x-world/x-vrml", "wrl": "x-world/x-vrml"@}
@end example
  
@end itemize



@chapter Types

@itemize


@item MimeDB
  @tindex MimeDB* = objectmimes꞉ StringTableRef
@example
MimeDB* = objectmimes꞉ StringTableRef
@end example
  
@end itemize

@chapter Procedures

@itemize


@item newMimetypes
  @findex proc newMimetypes*()꞉ MimeDB
@example
proc newMimetypes*()꞉ MimeDB
@end example
  Creates a new Mimetypes database. The database will contain the most common mimetypes.

@item getMimetype
  @findex proc getMimetype*(mimedb꞉ MimeDB; ext꞉ string; default = "text/plain")꞉ string
@example
proc getMimetype*(mimedb꞉ MimeDB; ext꞉ string; default = "text/plain")꞉ string
@end example
  Gets mimetype which corresponds to @code{ext}. Returns @code{default} if @code{ext} could not be found.

@item getExt
  @findex proc getExt*(mimedb꞉ MimeDB; mimetype꞉ string; default = "txt")꞉ string
@example
proc getExt*(mimedb꞉ MimeDB; mimetype꞉ string; default = "txt")꞉ string
@end example
  Gets extension which corresponds to @code{mimetype}. Returns @code{default} if @code{mimetype} could not be found. Extensions are returned without the leading dot.

@item register
  @findex proc register*(mimedb꞉ var MimeDB; ext꞉ string; mimetype꞉ string)
@example
proc register*(mimedb꞉ var MimeDB; ext꞉ string; mimetype꞉ string)
@end example
  Adds @code{mimetype} to the @code{mimedb}.
@end itemize






@node /pure/poly, /pure/events , /pure/mimetypes, Top



@chapter Types

@itemize


@item Poly
  @tindex Poly* = objectcofs꞉ seq[float]
@example
Poly* = objectcofs꞉ seq[float]
@end example
  
@end itemize

@chapter Procedures

@itemize


@item degree
  @findex proc degree*(p꞉ Poly)꞉ int
@example
proc degree*(p꞉ Poly)꞉ int
@end example
  Returns the degree of the polynomial, that is the number of coefficients-1

@item eval
  @findex proc eval*(p꞉ Poly; x꞉ float)꞉ float
@example
proc eval*(p꞉ Poly; x꞉ float)꞉ float
@end example
  Evaluates a polynomial function value for @emph{x} quickly using Horners method

@item `[]`
  @findex proc `[]`*(p꞉ Poly; idx꞉ int)꞉ float
@example
proc `[]`*(p꞉ Poly; idx꞉ int)꞉ float
@end example
  Gets a coefficient of the polynomial. p[2] will returns the quadric term, p[3] the cubic etc. Out of bounds index will return 0.0.

@item `[]=`
  @findex proc `[]=`*(p꞉ var Poly; idx꞉ int; v꞉ float)
@example
proc `[]=`*(p꞉ var Poly; idx꞉ int; v꞉ float)
@end example
  Sets an coefficient of the polynomial by index. p[2] set the quadric term, p[3] the cubic etc. If index is out of range for the coefficients, the polynomial grows to the smallest needed degree.

@item clean
  @findex proc clean*(p꞉ var Poly; zerotol = 0.0'f64)
@example
proc clean*(p꞉ var Poly; zerotol = 0.0'f64)
@end example
  Removes leading zero coefficients of the polynomial. An optional tolerance can be given for what's considered zero.

@item `$`
  @findex proc `$`*(p꞉ Poly)꞉ string
@example
proc `$`*(p꞉ Poly)꞉ string
@end example
  Gets a somewhat reasonable string representation of the polynomial The format should be compatible with most online function plotters, for example directly in google search

@item derivative
  @findex proc derivative*(p꞉ Poly)꞉ Poly
@example
proc derivative*(p꞉ Poly)꞉ Poly
@end example
  Returns a new polynomial, which is the derivative of @emph{p}

@item diff
  @findex proc diff*(p꞉ Poly; x꞉ float)꞉ float
@example
proc diff*(p꞉ Poly; x꞉ float)꞉ float
@end example
  Evaluates the differentiation of a polynomial with respect to @emph{x} quickly using a modifed Horners method

@item integral
  @findex proc integral*(p꞉ Poly)꞉ Poly
@example
proc integral*(p꞉ Poly)꞉ Poly
@end example
  Returns a new polynomial which is the indefinite integral of @emph{p}. The constant term is set to 0.0

@item integrate
  @findex proc integrate*(p꞉ Poly; xmin, xmax꞉ float)꞉ float
@example
proc integrate*(p꞉ Poly; xmin, xmax꞉ float)꞉ float
@end example
  Computes the definite integral of @emph{p} between @emph{xmin} and @emph{xmax} quickly using a modified version of Horners method

@item initPoly
  @findex proc initPoly*(cofs꞉ varargs[float])꞉ Poly
@example
proc initPoly*(cofs꞉ varargs[float])꞉ Poly
@end example
  Initializes a polynomial with given coefficients. The most significant coefficient is first, so to create x^2-2x+3: intiPoly(1.0,-2.0,3.0)

@item divMod
  @findex proc divMod*(p, d꞉ Poly; q, r꞉ var Poly)
@example
proc divMod*(p, d꞉ Poly; q, r꞉ var Poly)
@end example
  Divides @emph{p} with @emph{d}, and stores the quotinent in @emph{q} and the remainder in @emph{d}

@item `+`
  @findex proc `+`*(p1꞉ Poly; p2꞉ Poly)꞉ Poly
@example
proc `+`*(p1꞉ Poly; p2꞉ Poly)꞉ Poly
@end example
  Adds two polynomials

@item `*`
  @findex proc `*`*(p1꞉ Poly; p2꞉ Poly)꞉ Poly
@example
proc `*`*(p1꞉ Poly; p2꞉ Poly)꞉ Poly
@end example
  Multiplies the polynomial @emph{p1} with @emph{p2}

@item `*`
  @findex proc `*`*(p꞉ Poly; f꞉ float)꞉ Poly
@example
proc `*`*(p꞉ Poly; f꞉ float)꞉ Poly
@end example
  Multiplies the polynomial @emph{p} with a real number

@item `*`
  @findex proc `*`*(f꞉ float; p꞉ Poly)꞉ Poly
@example
proc `*`*(f꞉ float; p꞉ Poly)꞉ Poly
@end example
  Multiplies a real number with a polynomial

@item `-`
  @findex proc `-`*(p꞉ Poly)꞉ Poly
@example
proc `-`*(p꞉ Poly)꞉ Poly
@end example
  Negates a polynomial

@item `-`
  @findex proc `-`*(p1꞉ Poly; p2꞉ Poly)꞉ Poly
@example
proc `-`*(p1꞉ Poly; p2꞉ Poly)꞉ Poly
@end example
  Subtract @emph{p1} with @emph{p2}

@item `/`
  @findex proc `/`*(p꞉ Poly; f꞉ float)꞉ Poly
@example
proc `/`*(p꞉ Poly; f꞉ float)꞉ Poly
@end example
  Divides polynomial @emph{p} with a real number @emph{f}

@item `/`
  @findex proc `/`*(p, q꞉ Poly)꞉ Poly
@example
proc `/`*(p, q꞉ Poly)꞉ Poly
@end example
  Divides polynomial @emph{p} with polynomial @emph{q}

@item `mod`
  @findex proc `mod`*(p, q꞉ Poly)꞉ Poly
@example
proc `mod`*(p, q꞉ Poly)꞉ Poly
@end example
  Computes the polynomial modulo operation, that is the remainder of @emph{p}/@emph{q}

@item normalize
  @findex proc normalize*(p꞉ var Poly)
@example
proc normalize*(p꞉ var Poly)
@end example
  Multiplies the polynomial inplace by a term so that the leading term is 1.0. This might lead to an unstable polynomial if the leading term is zero.

@item solveQuadric
  @findex proc solveQuadric*(a, b, c꞉ float; zerotol = 0.0'f64)꞉ seq[float]
@example
proc solveQuadric*(a, b, c꞉ float; zerotol = 0.0'f64)꞉ seq[float]
@end example
  Solves the quadric equation @emph{ax^2+bx+c}, with a possible tolerance @emph{zerotol} to find roots of curves just 'touching' the x axis. Returns sequence with 0,1 or 2 solutions.

@item roots
  @findex proc roots*(p꞉ Poly; tol = 1e-09'f64; zerotol = 1e-06'f64; mergetol = 1e-12'f64;maxiter = 1000)꞉ seq[float]
@example
proc roots*(p꞉ Poly; tol = 1e-09'f64; zerotol = 1e-06'f64; mergetol = 1e-12'f64;maxiter = 1000)꞉ seq[float]
@end example
  Computes the real roots of the polynomial @emph{p} @emph{tol} is the tolerance used to break searching for each root when reached. @emph{zerotol} is the tolerance, which is 'close enough' to zero to be considered a root and is used to find roots for curves that only 'touch' the x-axis. @emph{mergetol} is the tolerance, of which two x-values are considered beeing the same root. @emph{maxiter} can be used to limit the number of iterations for each root. Returns a (possibly empty) sorted sequence with the solutions.
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*(p꞉ Poly)꞉ float
@example
iterator items*(p꞉ Poly)꞉ float
@end example
  Iterates through the coefficients of the polynomial.
@end itemize

@node /pure/events, /pure/fenv , /pure/poly, Top



@chapter Types

@itemize


@item EventHandler
  @tindex EventHandler* = tuple[name꞉ string, handlers꞉ seq[proc (e꞉ EventArgs) @{.closure.@}]]
@example
EventHandler* = tuple[name꞉ string, handlers꞉ seq[proc (e꞉ EventArgs) @{.closure.@}]]
@end example
  An eventhandler for an event.

@item EventError
  @tindex EventError* = object of ValueError
@example
EventError* = object of ValueError
@end example
  
@end itemize

@chapter Procedures

@itemize


@item initEventHandler
  @findex proc initEventHandler*(name꞉ string)꞉ EventHandler
@example
proc initEventHandler*(name꞉ string)꞉ EventHandler
@end example
  Initializes an EventHandler with the specified name and returns it.

@item addHandler
  @findex proc addHandler*(handler꞉ var EventHandler; fn꞉ proc (e꞉ EventArgs) @{.closure.@})
@example
proc addHandler*(handler꞉ var EventHandler; fn꞉ proc (e꞉ EventArgs) @{.closure.@})
@end example
  Adds the callback to the specified event handler.

@item removeHandler
  @findex proc removeHandler*(handler꞉ var EventHandler; fn꞉ proc (e꞉ EventArgs) @{.closure.@})
@example
proc removeHandler*(handler꞉ var EventHandler; fn꞉ proc (e꞉ EventArgs) @{.closure.@})
@end example
  Removes the callback from the specified event handler.

@item containsHandler
  @findex proc containsHandler*(handler꞉ var EventHandler; fn꞉ proc (e꞉ EventArgs) @{.closure.@})꞉ bool
@example
proc containsHandler*(handler꞉ var EventHandler; fn꞉ proc (e꞉ EventArgs) @{.closure.@})꞉ bool
@end example
  Checks if a callback is registered to this event handler.

@item clearHandlers
  @findex proc clearHandlers*(handler꞉ var EventHandler)
@example
proc clearHandlers*(handler꞉ var EventHandler)
@end example
  Clears all of the callbacks from the event handler.

@item on
  @findex proc on*(emitter꞉ var EventEmitter; event꞉ string; fn꞉ proc (e꞉ EventArgs) @{.closure.@})
@example
proc on*(emitter꞉ var EventEmitter; event꞉ string; fn꞉ proc (e꞉ EventArgs) @{.closure.@})
@end example
  Assigns a event handler with the specified callback. If the event doesn't exist, it will be created.

@item emit
  @findex proc emit*(emitter꞉ var EventEmitter; eventhandler꞉ var EventHandler; args꞉ EventArgs)
@example
proc emit*(emitter꞉ var EventEmitter; eventhandler꞉ var EventHandler; args꞉ EventArgs)
@end example
  Fires an event handler with specified event arguments.

@item emit
  @findex proc emit*(emitter꞉ var EventEmitter; event꞉ string; args꞉ EventArgs)
@example
proc emit*(emitter꞉ var EventEmitter; event꞉ string; args꞉ EventArgs)
@end example
  Fires an event handler with specified event arguments.

@item initEventEmitter
  @findex proc initEventEmitter*()꞉ EventEmitter
@example
proc initEventEmitter*()꞉ EventEmitter
@end example
  Creates and returns a new EventEmitter.
@end itemize






@node /pure/fenv, /pure/httpclient , /pure/events, Top


@chapter Variables

@itemize


@item FE_DFL_ENV
  @vindex FE_DFL_ENV* @{.importc, header꞉ "<fenv.h>".@}꞉ cint
@example
FE_DFL_ENV* @{.importc, header꞉ "<fenv.h>".@}꞉ cint
@end example
  macro of type pointer to fenv_t to be used as the argument to functions taking an argument of type fenv_t; in this case the default environment will be used
@end itemize

@chapter Types

@itemize


@item Tfexcept
  @tindex Tfexcept* @{.importc꞉ "fexcept_t", header꞉ "<fenv.h>", final, pure.@} = object
@example
Tfexcept* @{.importc꞉ "fexcept_t", header꞉ "<fenv.h>", final, pure.@} = object
@end example
  Represents the floating-point status flags collectively, including any status the implementation associates with the flags. A floating-point status flag is a system variable whose value is set (but never cleared) when a floating-point exception is raised, which occurs as a side effect of exceptional floating-point arithmetic to provide auxiliary information. A floating-point control mode is a system variable whose value may be set by the user to affect the subsequent behavior of floating-point arithmetic.
@end itemize

@chapter Procedures

@itemize


@item feclearexcept
  @findex proc feclearexcept*(excepts꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc feclearexcept*(excepts꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Clear the supported exceptions represented by @emph{excepts}.

@item fegetexceptflag
  @findex proc fegetexceptflag*(flagp꞉ ptr Tfexcept; excepts꞉ cint)꞉ cint @{.importc,header꞉ "<fenv.h>".@}
@example
proc fegetexceptflag*(flagp꞉ ptr Tfexcept; excepts꞉ cint)꞉ cint @{.importc,header꞉ "<fenv.h>".@}
@end example
  Store implementation-defined representation of the exception flags indicated by @emph{excepts} in the object pointed to by @emph{flagp}.

@item feraiseexcept
  @findex proc feraiseexcept*(excepts꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc feraiseexcept*(excepts꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Raise the supported exceptions represented by @emph{excepts}.

@item fesetexceptflag
  @findex proc fesetexceptflag*(flagp꞉ ptr Tfexcept; excepts꞉ cint)꞉ cint @{.importc,header꞉ "<fenv.h>".@}
@example
proc fesetexceptflag*(flagp꞉ ptr Tfexcept; excepts꞉ cint)꞉ cint @{.importc,header꞉ "<fenv.h>".@}
@end example
  Set complete status for exceptions indicated by @emph{excepts} according to the representation in the object pointed to by @emph{flagp}.

@item fetestexcept
  @findex proc fetestexcept*(excepts꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc fetestexcept*(excepts꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Determine which of subset of the exceptions specified by @emph{excepts} are currently set.

@item fegetround
  @findex proc fegetround*()꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc fegetround*()꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Get current rounding direction.

@item fesetround
  @findex proc fesetround*(roundingDirection꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc fesetround*(roundingDirection꞉ cint)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Establish the rounding direction represented by @emph{roundingDirection}.

@item fegetenv
  @findex proc fegetenv*(envp꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc fegetenv*(envp꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Store the current floating-point environment in the object pointed to by @emph{envp}.

@item feholdexcept
  @findex proc feholdexcept*(envp꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc feholdexcept*(envp꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Save the current environment in the object pointed to by @emph{envp}, clear exception flags and install a non-stop mode (if available) for all exceptions.

@item fesetenv
  @findex proc fesetenv*(a1꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc fesetenv*(a1꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Establish the floating-point environment represented by the object pointed to by @emph{envp}.

@item feupdateenv
  @findex proc feupdateenv*(envp꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@example
proc feupdateenv*(envp꞉ ptr Tfenv)꞉ cint @{.importc, header꞉ "<fenv.h>".@}
@end example
  Save current exceptions in temporary storage, install environment represented by object pointed to by @emph{envp} and raise exceptions according to saved exceptions.
@end itemize

@chapter Templates

@itemize


@item fpRadix
  @findex template fpRadix*()꞉ int
@example
template fpRadix*()꞉ int
@end example
  The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.

@item mantissaDigits
  @findex template mantissaDigits*(T꞉ typedesc[float32])꞉ int
@example
template mantissaDigits*(T꞉ typedesc[float32])꞉ int
@end example
  Number of digits (in base @code{floatingPointRadix}) in the mantissa of 32-bit floating-point numbers.

@item digits
  @findex template digits*(T꞉ typedesc[float32])꞉ int
@example
template digits*(T꞉ typedesc[float32])꞉ int
@end example
  Number of decimal digits that can be represented in a 32-bit floating-point type without losing precision.

@item minExponent
  @findex template minExponent*(T꞉ typedesc[float32])꞉ int
@example
template minExponent*(T꞉ typedesc[float32])꞉ int
@end example
  Minimum (negative) exponent for 32-bit floating-point numbers.

@item maxExponent
  @findex template maxExponent*(T꞉ typedesc[float32])꞉ int
@example
template maxExponent*(T꞉ typedesc[float32])꞉ int
@end example
  Maximum (positive) exponent for 32-bit floating-point numbers.

@item min10Exponent
  @findex template min10Exponent*(T꞉ typedesc[float32])꞉ int
@example
template min10Exponent*(T꞉ typedesc[float32])꞉ int
@end example
  Minimum (negative) exponent in base 10 for 32-bit floating-point numbers.

@item max10Exponent
  @findex template max10Exponent*(T꞉ typedesc[float32])꞉ int
@example
template max10Exponent*(T꞉ typedesc[float32])꞉ int
@end example
  Maximum (positive) exponent in base 10 for 32-bit floating-point numbers.

@item minimumPositiveValue
  @findex template minimumPositiveValue*(T꞉ typedesc[float32])꞉ float32
@example
template minimumPositiveValue*(T꞉ typedesc[float32])꞉ float32
@end example
  The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.

@item maximumPositiveValue
  @findex template maximumPositiveValue*(T꞉ typedesc[float32])꞉ float32
@example
template maximumPositiveValue*(T꞉ typedesc[float32])꞉ float32
@end example
  The largest positive number that can be represented in a 32-bit floating-point type.

@item epsilon
  @findex template epsilon*(T꞉ typedesc[float32])꞉ float32
@example
template epsilon*(T꞉ typedesc[float32])꞉ float32
@end example
  The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.

@item mantissaDigits
  @findex template mantissaDigits*(T꞉ typedesc[float64])꞉ int
@example
template mantissaDigits*(T꞉ typedesc[float64])꞉ int
@end example
  Number of digits (in base @code{floatingPointRadix}) in the mantissa of 64-bit floating-point numbers.

@item digits
  @findex template digits*(T꞉ typedesc[float64])꞉ int
@example
template digits*(T꞉ typedesc[float64])꞉ int
@end example
  Number of decimal digits that can be represented in a 64-bit floating-point type without losing precision.

@item minExponent
  @findex template minExponent*(T꞉ typedesc[float64])꞉ int
@example
template minExponent*(T꞉ typedesc[float64])꞉ int
@end example
  Minimum (negative) exponent for 64-bit floating-point numbers.

@item maxExponent
  @findex template maxExponent*(T꞉ typedesc[float64])꞉ int
@example
template maxExponent*(T꞉ typedesc[float64])꞉ int
@end example
  Maximum (positive) exponent for 64-bit floating-point numbers.

@item min10Exponent
  @findex template min10Exponent*(T꞉ typedesc[float64])꞉ int
@example
template min10Exponent*(T꞉ typedesc[float64])꞉ int
@end example
  Minimum (negative) exponent in base 10 for 64-bit floating-point numbers.

@item max10Exponent
  @findex template max10Exponent*(T꞉ typedesc[float64])꞉ int
@example
template max10Exponent*(T꞉ typedesc[float64])꞉ int
@end example
  Maximum (positive) exponent in base 10 for 64-bit floating-point numbers.

@item minimumPositiveValue
  @findex template minimumPositiveValue*(T꞉ typedesc[float64])꞉ float64
@example
template minimumPositiveValue*(T꞉ typedesc[float64])꞉ float64
@end example
  The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.

@item maximumPositiveValue
  @findex template maximumPositiveValue*(T꞉ typedesc[float64])꞉ float64
@example
template maximumPositiveValue*(T꞉ typedesc[float64])꞉ float64
@end example
  The largest positive number that can be represented in a 64-bit floating-point type.

@item epsilon
  @findex template epsilon*(T꞉ typedesc[float64])꞉ float64
@example
template epsilon*(T꞉ typedesc[float64])꞉ float64
@end example
  The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.
@end itemize





@node /pure/httpclient, /pure/asyncftpclient , /pure/fenv, Top
@chapter Constant variables

@itemize


@item defUserAgent
  @vindex defUserAgent* = "Nim httpclient/" & NimVersion
@example
defUserAgent* = "Nim httpclient/" & NimVersion
@end example
  
@end itemize



@chapter Types

@itemize


@item HttpRequestError
  @tindex HttpRequestError* = object of IOError
@example
HttpRequestError* = object of IOError
@end example
  Thrown in the @code{getContent} proc and @code{postContent} proc, when the server returns an error

@item HttpMethod
  @tindex HttpMethod* = enum
  httpHEAD, ## Asks for the response identical to the one that would
           ## correspond to a GET request, but without the response
           ## body.
  httpGET,                    ## Retrieves the specified resource.
  httpPOST,                   ## Submits data to be processed to the identified
           ## resource. The data is included in the body of the
           ## request.
  httpPUT,                    ## Uploads a representation of the specified resource.
  httpDELETE,                 ## Deletes the specified resource.
  httpTRACE,                  ## Echoes back the received request, so that a client
            ## can see what intermediate servers are adding or
            ## changing in the request.
  httpOPTIONS,                ## Returns the HTTP methods that the server supports
              ## for specified address.
  httpCONNECT                 ## Converts the request connection to a transparent
             ## TCP/IP tunnel, usually used for proxies.
@example
HttpMethod* = enum
  httpHEAD, ## Asks for the response identical to the one that would
           ## correspond to a GET request, but without the response
           ## body.
  httpGET,                    ## Retrieves the specified resource.
  httpPOST,                   ## Submits data to be processed to the identified
           ## resource. The data is included in the body of the
           ## request.
  httpPUT,                    ## Uploads a representation of the specified resource.
  httpDELETE,                 ## Deletes the specified resource.
  httpTRACE,                  ## Echoes back the received request, so that a client
            ## can see what intermediate servers are adding or
            ## changing in the request.
  httpOPTIONS,                ## Returns the HTTP methods that the server supports
              ## for specified address.
  httpCONNECT                 ## Converts the request connection to a transparent
             ## TCP/IP tunnel, usually used for proxies.
@end example
  the requested HttpMethod

@item AsyncHttpClient
  @tindex AsyncHttpClient* = ref object
  socket: AsyncSocket
  connected: bool
  currentURL: Uri
  headers*: StringTableRef
  maxRedirects: int
  userAgent: string
  when defined(ssl):
      sslContext: net.SslContext

  
@example
AsyncHttpClient* = ref object
  socket: AsyncSocket
  connected: bool
  currentURL: Uri
  headers*: StringTableRef
  maxRedirects: int
  userAgent: string
  when defined(ssl):
      sslContext: net.SslContext

  
@end example
  Where we are currently connected.
@end itemize

@chapter Procedures

@itemize


@item newProxy
  @findex proc newProxy*(url꞉ string; auth = "")꞉ Proxy
@example
proc newProxy*(url꞉ string; auth = "")꞉ Proxy
@end example
  Constructs a new @code{TProxy} object.

@item newMultipartData
  @findex proc newMultipartData*()꞉ MultipartData
@example
proc newMultipartData*()꞉ MultipartData
@end example
  Constructs a new @code{MultipartData} object.

@item add
  @findex proc add*(p꞉ var MultipartData; name, content꞉ string; filename꞉ string = nil;contentType꞉ string = nil)
@example
proc add*(p꞉ var MultipartData; name, content꞉ string; filename꞉ string = nil;contentType꞉ string = nil)
@end example
  Add a value to the multipart data. Raises a @emph{ValueError} exception if @emph{name}, @emph{filename} or @emph{contentType} contain newline characters.

@item add
  @findex proc add*(p꞉ var MultipartData; xs꞉ MultipartEntries)꞉ MultipartData @{.discardable.@}
@example
proc add*(p꞉ var MultipartData; xs꞉ MultipartEntries)꞉ MultipartData @{.discardable.@}
@end example
  Add a list of multipart entries to the multipart data @emph{p}. All values are added without a filename and without a content type.
@example
data.add(@{"action": "login", "format": "json"@})
@end example

@item newMultipartData
  @findex proc newMultipartData*(xs꞉ MultipartEntries)꞉ MultipartData
@example
proc newMultipartData*(xs꞉ MultipartEntries)꞉ MultipartData
@end example
  Create a new multipart data object and fill it with the entries @emph{xs} directly.
@example
var data = newMultipartData(@{"action": "login", "format": "json"@})
@end example

@item addFiles
  @findex proc addFiles*(p꞉ var MultipartData; xs꞉ openarray[tuple[name, file꞉ string]])꞉ MultipartData @{.discardable.@}
@example
proc addFiles*(p꞉ var MultipartData; xs꞉ openarray[tuple[name, file꞉ string]])꞉ MultipartData @{.discardable.@}
@end example
  Add files to a multipart data object. The file will be opened from your disk, read and sent with the automatically determined MIME type. Raises an @emph{IOError} if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use @emph{[]=} instead.
@example
data.addFiles(@{"uploaded_file": "public/test.html"@})
@end example

@item `[]=`
  @findex proc `[]=`*(p꞉ var MultipartData; name, content꞉ string)
@example
proc `[]=`*(p꞉ var MultipartData; name, content꞉ string)
@end example
  Add a multipart entry to the multipart data @emph{p}. The value is added without a filename and without a content type.
@example
data["username"] = "NimUser"
@end example

@item `[]=`
  @findex proc `[]=`*(p꞉ var MultipartData; name꞉ string;file꞉ tuple[name, contentType, content꞉ string])
@example
proc `[]=`*(p꞉ var MultipartData; name꞉ string;file꞉ tuple[name, contentType, content꞉ string])
@end example
  Add a file to the multipart data @emph{p}, specifying filename, contentType and content manually.
@example
data["uploaded_file"] = ("test.html", "text/html",
  "<html><head></head><body><p>test</p></body></html>")
@end example

@item request
  @findex proc request*(url꞉ string; httpMethod꞉ string; extraHeaders = ""; body = "";sslContext = defaultSSLContext; timeout = - 1; userAgent = defUserAgent;proxy꞉ Proxy = nil)꞉ Response
@example
proc request*(url꞉ string; httpMethod꞉ string; extraHeaders = ""; body = "";sslContext = defaultSSLContext; timeout = - 1; userAgent = defUserAgent;proxy꞉ Proxy = nil)꞉ Response
@end example
  Requests @code{url} with the custom method string specified by the\\
@code{httpMethod} parameter.\\
Extra headers can be specified and must be separated by @code{\c\L}\\
An optional timeout can be specified in milliseconds, if reading from the\\


server takes longer than specified an ETimeout exception will be raised.

@item request
  @findex proc request*(url꞉ string; httpMethod = httpGET; extraHeaders = ""; body = "";sslContext = defaultSSLContext; timeout = - 1; userAgent = defUserAgent;proxy꞉ Proxy = nil)꞉ Response
@example
proc request*(url꞉ string; httpMethod = httpGET; extraHeaders = ""; body = "";sslContext = defaultSSLContext; timeout = - 1; userAgent = defUserAgent;proxy꞉ Proxy = nil)꞉ Response
@end example
  Requests @code{url} with the specified @code{httpMethod}.\\
Extra headers can be specified and must be separated by @code{\c\L}\\
An optional timeout can be specified in milliseconds, if reading from the\\


server takes longer than specified an ETimeout exception will be raised.

@item get
  @findex proc get*(url꞉ string; extraHeaders = ""; maxRedirects = 5;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil)꞉ Response
@example
proc get*(url꞉ string; extraHeaders = ""; maxRedirects = 5;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil)꞉ Response
@end example
  GETs the @code{url} and returns a @code{Response} object\\
This proc also handles redirection\\
Extra headers can be specified and must be separated by @code{\c\L}.\\
An optional timeout can be specified in milliseconds, if reading from the\\


server takes longer than specified an ETimeout exception will be raised.

@item getContent
  @findex proc getContent*(url꞉ string; extraHeaders = ""; maxRedirects = 5;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil)꞉ string
@example
proc getContent*(url꞉ string; extraHeaders = ""; maxRedirects = 5;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil)꞉ string
@end example
  GETs the body and returns it as a string.\\
Raises exceptions for the status codes @code{4xx} and @code{5xx}\\
Extra headers can be specified and must be separated by @code{\c\L}.\\
An optional timeout can be specified in milliseconds, if reading from the\\


server takes longer than specified an ETimeout exception will be raised.

@item post
  @findex proc post*(url꞉ string; extraHeaders = ""; body = ""; maxRedirects = 5;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil; multipart꞉ MultipartData = nil)꞉ Response
@example
proc post*(url꞉ string; extraHeaders = ""; body = ""; maxRedirects = 5;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil; multipart꞉ MultipartData = nil)꞉ Response
@end example
  POSTs @code{body} to the @code{url} and returns a @code{Response} object.\\
This proc adds the necessary Content-Length header.\\
This proc also handles redirection.\\
Extra headers can be specified and must be separated by @code{\c\L}.\\
An optional timeout can be specified in milliseconds, if reading from the\\


server takes longer than specified an ETimeout exception will be raised. | The optional @code{multipart} parameter can be used to create @code{multipart/form-data} POSTs comfortably.

@item postContent
  @findex proc postContent*(url: string; extraHeaders = ""; body = ""; maxRedirects = 5;
                 sslContext: SSLContext = defaultSSLContext; timeout = - 1;
                 userAgent = defUserAgent; proxy: Proxy = nil;
                 multipart: MultipartData = nil): string
@example
proc postContent*(url: string; extraHeaders = ""; body = ""; maxRedirects = 5;
                 sslContext: SSLContext = defaultSSLContext; timeout = - 1;
                 userAgent = defUserAgent; proxy: Proxy = nil;
                 multipart: MultipartData = nil): string
@end example
  POSTs @code{body} to @code{url} and returns the response's body as a string\\
Raises exceptions for the status codes @code{4xx} and @code{5xx}\\
Extra headers can be specified and must be separated by @code{\c\L}.\\
An optional timeout can be specified in milliseconds, if reading from the\\


server takes longer than specified an ETimeout exception will be raised. | The optional @code{multipart} parameter can be used to create @code{multipart/form-data} POSTs comfortably.

@item downloadFile
  @findex proc downloadFile*(url꞉ string; outputFilename꞉ string;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil)
@example
proc downloadFile*(url꞉ string; outputFilename꞉ string;sslContext꞉ SSLContext = defaultSSLContext; timeout = - 1;userAgent = defUserAgent; proxy꞉ Proxy = nil)
@end example
  Downloads @code{url} and saves it to @code{outputFilename}\\
An optional timeout can be specified in milliseconds, if reading from the\\


server takes longer than specified an ETimeout exception will be raised.

@item newAsyncHttpClient
  @findex proc newAsyncHttpClient*(userAgent = defUserAgent; maxRedirects = 5;sslContext = defaultSslContext)꞉ AsyncHttpClient
@example
proc newAsyncHttpClient*(userAgent = defUserAgent; maxRedirects = 5;sslContext = defaultSslContext)꞉ AsyncHttpClient
@end example
  Creates a new AsyncHttpClient instance.

@code{userAgent} specifies the user agent that will be used when making requests.

@code{maxRedirects} specifies the maximum amount of redirects to follow, default is 5.

@code{sslContext} specifies the SSL context to use for HTTPS requests.

@item close
  @findex proc close*(client꞉ AsyncHttpClient)
@example
proc close*(client꞉ AsyncHttpClient)
@end example
  Closes any connections held by the HTTP client.

@item request
  @findex proc request*(client꞉ AsyncHttpClient; url꞉ string; httpMethod꞉ string; body = "")꞉ Future[Response] @{.async.@}
@example
proc request*(client꞉ AsyncHttpClient; url꞉ string; httpMethod꞉ string; body = "")꞉ Future[Response] @{.async.@}
@end example
  Connects to the hostname specified by the URL and performs a request using the custom method string specified by @code{httpMethod}.

Connection will kept alive. Further requests on the same @code{client} to the same hostname will not require a new connection to be made. The connection can be closed by using the @code{close} procedure.

The returned future will complete once the request is completed.

@item request
  @findex proc request*(client꞉ AsyncHttpClient; url꞉ string; httpMethod = httpGET; body = "")꞉ Future[Response]
@example
proc request*(client꞉ AsyncHttpClient; url꞉ string; httpMethod = httpGET; body = "")꞉ Future[Response]
@end example
  Connects to the hostname specified by the URL and performs a request using the method specified.

Connection will kept alive. Further requests on the same @code{client} to the same hostname will not require a new connection to be made. The connection can be closed by using the @code{close} procedure.

The returned future will complete once the request is completed.

@item get
  @findex proc get*(client꞉ AsyncHttpClient; url꞉ string)꞉ Future[Response] @{.async.@}
@example
proc get*(client꞉ AsyncHttpClient; url꞉ string)꞉ Future[Response] @{.async.@}
@end example
  Connects to the hostname specified by the URL and performs a GET request.

This procedure will follow redirects up to a maximum number of redirects specified in @code{newAsyncHttpClient}.

@item post
  @findex proc post*(client꞉ AsyncHttpClient; url꞉ string; body = "";multipart꞉ MultipartData = nil)꞉ Future[Response] @{.async.@}
@example
proc post*(client꞉ AsyncHttpClient; url꞉ string; body = "";multipart꞉ MultipartData = nil)꞉ Future[Response] @{.async.@}
@end example
  Connects to the hostname specified by the URL and performs a POST request.

This procedure will follow redirects up to a maximum number of redirects specified in @code{newAsyncHttpClient}.
@end itemize






@node /pure/asyncftpclient, /pure/parsesql , /pure/httpclient, Top



@chapter Types

@itemize


@item ProgressChangedProc
  @tindex ProgressChangedProc* = proc (total, progress꞉ BiggestInt; speed꞉ float)꞉ Future[void] @{.closure, gcsafe.@}
@example
ProgressChangedProc* = proc (total, progress꞉ BiggestInt; speed꞉ float)꞉ Future[void] @{.closure, gcsafe.@}
@end example
  
@end itemize

@chapter Procedures

@itemize


@item send
  @findex proc send*(ftp꞉ AsyncFtpClient; m꞉ string)꞉ Future[TaintedString] @{.async.@}
@example
proc send*(ftp꞉ AsyncFtpClient; m꞉ string)꞉ Future[TaintedString] @{.async.@}
@end example
  Send a message to the server, and wait for a primary reply. @code{\c\L} is added for you.

@strong{Note:} The server may return multiple lines of coded replies.

@item connect
  @findex proc connect*(ftp꞉ AsyncFtpClient) @{.async.@}
@example
proc connect*(ftp꞉ AsyncFtpClient) @{.async.@}
@end example
  Connect to the FTP server specified by @code{ftp}.

@item pwd
  @findex proc pwd*(ftp꞉ AsyncFtpClient)꞉ Future[TaintedString] @{.async.@}
@example
proc pwd*(ftp꞉ AsyncFtpClient)꞉ Future[TaintedString] @{.async.@}
@end example
  Returns the current working directory.

@item cd
  @findex proc cd*(ftp꞉ AsyncFtpClient; dir꞉ string) @{.async.@}
@example
proc cd*(ftp꞉ AsyncFtpClient; dir꞉ string) @{.async.@}
@end example
  Changes the current directory on the remote FTP server to @code{dir}.

@item cdup
  @findex proc cdup*(ftp꞉ AsyncFtpClient) @{.async.@}
@example
proc cdup*(ftp꞉ AsyncFtpClient) @{.async.@}
@end example
  Changes the current directory to the parent of the current directory.

@item listDirs
  @findex proc listDirs*(ftp꞉ AsyncFtpClient; dir = "")꞉ Future[seq[string]] @{.async.@}
@example
proc listDirs*(ftp꞉ AsyncFtpClient; dir = "")꞉ Future[seq[string]] @{.async.@}
@end example
  Returns a list of filenames in the given directory. If @code{dir} is "", the current directory is used. If @code{async} is true, this function will return immediately and it will be your job to use asyncio's @code{poll} to progress this operation.

@item existsFile
  @findex proc existsFile*(ftp꞉ AsyncFtpClient; file꞉ string)꞉ Future[bool] @{.async.@}
@example
proc existsFile*(ftp꞉ AsyncFtpClient; file꞉ string)꞉ Future[bool] @{.async.@}
@end example
  Determines whether @code{file} exists.

@item createDir
  @findex proc createDir*(ftp꞉ AsyncFtpClient; dir꞉ string; recursive = false) @{.async.@}
@example
proc createDir*(ftp꞉ AsyncFtpClient; dir꞉ string; recursive = false) @{.async.@}
@end example
  Creates a directory @code{dir}. If @code{recursive} is true, the topmost subdirectory of @code{dir} will be created first, following the secondmost... etc. this allows you to give a full path as the @code{dir} without worrying about subdirectories not existing.

@item chmod
  @findex proc chmod*(ftp꞉ AsyncFtpClient; path꞉ string; permissions꞉ set[FilePermission]) @{.async.@}
@example
proc chmod*(ftp꞉ AsyncFtpClient; path꞉ string; permissions꞉ set[FilePermission]) @{.async.@}
@end example
  Changes permission of @code{path} to @code{permissions}.

@item list
  @findex proc list*(ftp꞉ AsyncFtpClient; dir = "")꞉ Future[string] @{.async.@}
@example
proc list*(ftp꞉ AsyncFtpClient; dir = "")꞉ Future[string] @{.async.@}
@end example
  Lists all files in @code{dir}. If @code{dir} is @code{""}, uses the current working directory.

@item retrText
  @findex proc retrText*(ftp꞉ AsyncFtpClient; file꞉ string)꞉ Future[string] @{.async.@}
@example
proc retrText*(ftp꞉ AsyncFtpClient; file꞉ string)꞉ Future[string] @{.async.@}
@end example
  Retrieves @code{file}. File must be ASCII text.

@item defaultOnProgressChanged
  @findex proc defaultOnProgressChanged*(total, progress꞉ BiggestInt; speed꞉ float)꞉ Future[void] @{.nimcall, gcsafe.@}
@example
proc defaultOnProgressChanged*(total, progress꞉ BiggestInt; speed꞉ float)꞉ Future[void] @{.nimcall, gcsafe.@}
@end example
  Default FTP @code{onProgressChanged} handler. Does nothing.

@item retrFile
  @findex proc retrFile*(ftp꞉ AsyncFtpClient; file, dest꞉ string;onProgressChanged꞉ ProgressChangedProc = defaultOnProgressChanged) @{.async.@}
@example
proc retrFile*(ftp꞉ AsyncFtpClient; file, dest꞉ string;onProgressChanged꞉ ProgressChangedProc = defaultOnProgressChanged) @{.async.@}
@end example
  Downloads @code{file} and saves it to @code{dest}. The @code{EvRetr} event is passed to the specified @code{handleEvent} function when the download is finished. The event's @code{filename} field will be equal to @code{file}.

@item store
  @findex proc store*(ftp꞉ AsyncFtpClient; file, dest꞉ string;onProgressChanged꞉ ProgressChangedProc = defaultOnProgressChanged) @{.async.@}
@example
proc store*(ftp꞉ AsyncFtpClient; file, dest꞉ string;onProgressChanged꞉ ProgressChangedProc = defaultOnProgressChanged) @{.async.@}
@end example
  Uploads @code{file} to @code{dest} on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The @code{EvStore} event is passed to the specified @code{handleEvent} function when the upload is finished, and the @code{filename} field will be equal to @code{file}.

@item newAsyncFtpClient
  @findex proc newAsyncFtpClient*(address꞉ string; port = Port(21); user, pass = "")꞉ AsyncFtpClient
@example
proc newAsyncFtpClient*(address꞉ string; port = Port(21); user, pass = "")꞉ AsyncFtpClient
@end example
  Creates a new @code{AsyncFtpClient} object.
@end itemize






@node /pure/parsesql, /pure/strutils , /pure/asyncftpclient, Top



@chapter Types

@itemize


@item SqlLexer
  @tindex SqlLexer* = object of BaseLexerfilename꞉ string
@example
SqlLexer* = object of BaseLexerfilename꞉ string
@end example
  the parser object.

@item SqlNodeKind
  @tindex SqlNodeKind* = enum
  nkNone, nkIdent, nkStringLit, nkBitStringLit, nkHexStringLit, nkIntegerLit,
  nkNumericLit, nkPrimaryKey, nkForeignKey, nkNotNull, nkStmtList, nkDot, nkDotDot,
  nkPrefix, nkInfix, nkCall, nkColumnReference, nkReferences, nkDefault, nkCheck,
  nkConstraint, nkUnique, nkIdentity, nkColumnDef, ## name, datatype, constraints
  nkInsert, nkUpdate, nkDelete, nkSelect, nkSelectDistinct, nkSelectColumns, nkAsgn,
  nkFrom, nkGroup, nkHaving, nkOrder, nkDesc, nkUnion, nkIntersect, nkExcept,
  nkColumnList, nkValueList, nkWhere, nkCreateTable, nkCreateTableIfNotExists,
  nkCreateType, nkCreateTypeIfNotExists, nkCreateIndex, nkCreateIndexIfNotExists,
  nkEnumDef
@example
SqlNodeKind* = enum
  nkNone, nkIdent, nkStringLit, nkBitStringLit, nkHexStringLit, nkIntegerLit,
  nkNumericLit, nkPrimaryKey, nkForeignKey, nkNotNull, nkStmtList, nkDot, nkDotDot,
  nkPrefix, nkInfix, nkCall, nkColumnReference, nkReferences, nkDefault, nkCheck,
  nkConstraint, nkUnique, nkIdentity, nkColumnDef, ## name, datatype, constraints
  nkInsert, nkUpdate, nkDelete, nkSelect, nkSelectDistinct, nkSelectColumns, nkAsgn,
  nkFrom, nkGroup, nkHaving, nkOrder, nkDesc, nkUnion, nkIntersect, nkExcept,
  nkColumnList, nkValueList, nkWhere, nkCreateTable, nkCreateTableIfNotExists,
  nkCreateType, nkCreateTypeIfNotExists, nkCreateIndex, nkCreateIndexIfNotExists,
  nkEnumDef
@end example
  kind of SQL abstract syntax tree

@item SqlParser
  @tindex SqlParser* = object of SqlLexertok꞉ Token
@example
SqlParser* = object of SqlLexertok꞉ Token
@end example
  SQL parser object
@end itemize

@chapter Procedures

@itemize


@item len
  @findex proc len*(n꞉ SqlNode)꞉ int
@example
proc len*(n꞉ SqlNode)꞉ int
@end example
  

@item add
  @findex proc add*(father, n꞉ SqlNode)
@example
proc add*(father, n꞉ SqlNode)
@end example
  

@item parseSQL
  @findex proc parseSQL*(input꞉ Stream; filename꞉ string)꞉ SqlNode
@example
proc parseSQL*(input꞉ Stream; filename꞉ string)꞉ SqlNode
@end example
  parses the SQL from @emph{input} into an AST and returns the AST. @emph{filename} is only used for error messages. Syntax errors raise an @emph{EInvalidSql} exception.

@item renderSQL
  @findex proc renderSQL*(n꞉ SqlNode)꞉ string
@example
proc renderSQL*(n꞉ SqlNode)꞉ string
@end example
  Converts an SQL abstract syntax tree to its string representation.
@end itemize






@node /pure/strutils, /pure/marshal , /pure/parsesql, Top
@chapter Constant variables

@itemize


@item AllChars
  @vindex AllChars* = @{'\0' .. '\xFF'@}
@example
AllChars* = @{'\0' .. '\xFF'@}
@end example
  A set with all the possible characters.

Not very useful by its own, you can use it to create @emph{inverted} sets to make the @uref{#find,string,set[char],int, find() proc} find @strong{invalid} characters in strings.  Example:


@example
let invalid = AllChars - Digits
doAssert "01234".find(invalid) == -1
doAssert "01A34".find(invalid) == 2
@end example
@end itemize



@chapter Types

@itemize


@item CharSet
  @tindex CharSet* @{.deprecated.@} = set[char]
@example
CharSet* @{.deprecated.@} = set[char]
@end example
  

@item FloatFormatMode
  @tindex FloatFormatMode* = enum
  ffDefault,                  ## use the shorter floating point notation
  ffDecimal,                  ## use decimal floating point notation
  ffScientific                ## use scientific notation (using ``e`` character)
@example
FloatFormatMode* = enum
  ffDefault,                  ## use the shorter floating point notation
  ffDecimal,                  ## use decimal floating point notation
  ffScientific                ## use scientific notation (using ``e`` character)
@end example
  the different modes of floating point formating
@end itemize

@chapter Procedures

@itemize


@item isAlpha
  @findex proc isAlpha*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsAlphaChar".@}
@example
proc isAlpha*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsAlphaChar".@}
@end example
  Checks whether or not @emph{c} is alphabetical.

This checks a-z, A-Z ASCII characters only.

@item isAlphaNumeric
  @findex proc isAlphaNumeric*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl,extern꞉ "nsuIsAlphaNumericChar".@}
@example
proc isAlphaNumeric*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl,extern꞉ "nsuIsAlphaNumericChar".@}
@end example
  Checks whether or not @emph{c} is alphanumeric.

This checks a-z, A-Z, 0-9 ASCII characters only.

@item isDigit
  @findex proc isDigit*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsDigitChar".@}
@example
proc isDigit*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsDigitChar".@}
@end example
  Checks whether or not @emph{c} is a number.

This checks 0-9 ASCII characters only.

@item isSpace
  @findex proc isSpace*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsSpaceChar".@}
@example
proc isSpace*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsSpaceChar".@}
@end example
  Checks whether or not @emph{c} is a whitespace character.

@item isLower
  @findex proc isLower*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsLowerChar".@}
@example
proc isLower*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsLowerChar".@}
@end example
  Checks whether or not @emph{c} is a lower case character.

This checks ASCII characters only.

@item isUpper
  @findex proc isUpper*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsUpperChar".@}
@example
proc isUpper*(c꞉ char)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsUpperChar".@}
@end example
  Checks whether or not @emph{c} is an upper case character.

This checks ASCII characters only.

@item isAlpha
  @findex proc isAlpha*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsAlphaStr".@}
@example
proc isAlpha*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsAlphaStr".@}
@end example
  Checks whether or not @emph{s} is alphabetical.

This checks a-z, A-Z ASCII characters only. Returns true if all characters in @emph{s} are alphabetic and there is at least one character in @emph{s}.

@item isAlphaNumeric
  @findex proc isAlphaNumeric*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl,extern꞉ "nsuIsAlphaNumericStr".@}
@example
proc isAlphaNumeric*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl,extern꞉ "nsuIsAlphaNumericStr".@}
@end example
  Checks whether or not @emph{s} is alphanumeric.

This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in @emph{s} are alpanumeric and there is at least one character in @emph{s}.

@item isDigit
  @findex proc isDigit*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsDigitStr".@}
@example
proc isDigit*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsDigitStr".@}
@end example
  Checks whether or not @emph{s} is a numeric value.

This checks 0-9 ASCII characters only. Returns true if all characters in @emph{s} are numeric and there is at least one character in @emph{s}.

@item isSpace
  @findex proc isSpace*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsSpaceStr".@}
@example
proc isSpace*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsSpaceStr".@}
@end example
  Checks whether or not @emph{s} is completely whitespace.

Returns true if all characters in @emph{s} are whitespace characters and there is at least one character in @emph{s}.

@item isLower
  @findex proc isLower*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsLowerStr".@}
@example
proc isLower*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsLowerStr".@}
@end example
  Checks whether or not @emph{s} contains all lower case characters.

This checks ASCII characters only. Returns true if all characters in @emph{s} are lower case and there is at least one character  in @emph{s}.

@item isUpper
  @findex proc isUpper*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsUpperStr".@}
@example
proc isUpper*(s꞉ string)꞉ bool @{.noSideEffect, procvar, rtl, extern꞉ "nsuIsUpperStr".@}
@end example
  Checks whether or not @emph{s} contains all upper case characters.

This checks ASCII characters only. Returns true if all characters in @emph{s} are upper case and there is at least one character in @emph{s}.

@item toLower
  @findex proc toLower*(c꞉ char)꞉ char @{.noSideEffect, procvar, rtl, extern꞉ "nsuToLowerChar".@}
@example
proc toLower*(c꞉ char)꞉ char @{.noSideEffect, procvar, rtl, extern꞉ "nsuToLowerChar".@}
@end example
  Converts @emph{c} into lower case.

This works only for the letters @code{A-Z}. See @uref{unicode.html#toLower, unicode.toLower} for a version that works for any Unicode character.

@item toLower
  @findex proc toLower*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl, extern꞉ "nsuToLowerStr".@}
@example
proc toLower*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl, extern꞉ "nsuToLowerStr".@}
@end example
  Converts @emph{s} into lower case.

This works only for the letters @code{A-Z}. See @uref{unicode.html#toLower, unicode.toLower} for a version that works for any Unicode character.

@item toUpper
  @findex proc toUpper*(c꞉ char)꞉ char @{.noSideEffect, procvar, rtl, extern꞉ "nsuToUpperChar".@}
@example
proc toUpper*(c꞉ char)꞉ char @{.noSideEffect, procvar, rtl, extern꞉ "nsuToUpperChar".@}
@end example
  Converts @emph{c} into upper case.

This works only for the letters @code{A-Z}.  See @uref{unicode.html#toUpper, unicode.toUpper} for a version that works for any Unicode character.

@item toUpper
  @findex proc toUpper*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl, extern꞉ "nsuToUpperStr".@}
@example
proc toUpper*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl, extern꞉ "nsuToUpperStr".@}
@end example
  Converts @emph{s} into upper case.

This works only for the letters @code{A-Z}.  See @uref{unicode.html#toUpper, unicode.toUpper} for a version that works for any Unicode character.

@item capitalize
  @findex proc capitalize*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl,extern꞉ "nsuCapitalize".@}
@example
proc capitalize*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl,extern꞉ "nsuCapitalize".@}
@end example
  Converts the first character of @emph{s} into upper case.

This works only for the letters @code{A-Z}.

@item normalize
  @findex proc normalize*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl, extern꞉ "nsuNormalize".@}
@example
proc normalize*(s꞉ string)꞉ string @{.noSideEffect, procvar, rtl, extern꞉ "nsuNormalize".@}
@end example
  Normalizes the string @emph{s}.

That means to convert it to lower case and remove any '_'. This is needed for Nim identifiers for example.

@item cmpIgnoreCase
  @findex proc cmpIgnoreCase*(a, b꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuCmpIgnoreCase",procvar.@}
@example
proc cmpIgnoreCase*(a, b꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuCmpIgnoreCase",procvar.@}
@end example
  Compares two strings in a case insensitive manner. Returns:0 iff a == b\\
< 0 iff a < b\\
> 0 iff a > b\\

@item cmpIgnoreStyle
  @findex proc cmpIgnoreStyle*(a, b꞉ string)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuCmpIgnoreStyle", procvar.@}
@example
proc cmpIgnoreStyle*(a, b꞉ string)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuCmpIgnoreStyle", procvar.@}
@end example
  Compares two strings normalized (i.e. case and underscores do not matter). Returns:0 iff a == b\\
< 0 iff a < b\\
> 0 iff a > b\\

@item strip
  @findex proc strip*(s꞉ string; leading = true; trailing = true; chars꞉ set[char] = Whitespace)꞉ string @{.noSideEffect, rtl, extern꞉ "nsuStrip".@}
@example
proc strip*(s꞉ string; leading = true; trailing = true; chars꞉ set[char] = Whitespace)꞉ string @{.noSideEffect, rtl, extern꞉ "nsuStrip".@}
@end example
  Strips @emph{chars} from @emph{s} and returns the resulting string.

If @emph{leading} is true, leading @emph{chars} are stripped. If @emph{trailing} is true, trailing @emph{chars} are stripped.

@item toOctal
  @findex proc toOctal*(c꞉ char)꞉ string @{.noSideEffect, rtl, extern꞉ "nsuToOctal".@}
@example
proc toOctal*(c꞉ char)꞉ string @{.noSideEffect, rtl, extern꞉ "nsuToOctal".@}
@end example
  Converts a character @emph{c} to its octal representation.

The resulting string may not have a leading zero. Its length is always exactly 3.

@item splitLines
  @findex proc splitLines*(s꞉ string)꞉ seq[string] @{.noSideEffect, rtl, extern꞉ "nsuSplitLines".@}
@example
proc splitLines*(s꞉ string)꞉ seq[string] @{.noSideEffect, rtl, extern꞉ "nsuSplitLines".@}
@end example
  The same as the @uref{#splitLines.i,string, splitLines} iterator, but is a proc that returns a sequence of substrings.

@item countLines
  @findex proc countLines*(s꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuCountLines".@}
@example
proc countLines*(s꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuCountLines".@}
@end example
  Returns the number of new line separators in the string @emph{s}.

This is the same as @code{len(splitLines(s))}, but much more efficient because it doesn't modify the string creating temporal objects. Every @uref{manual.html#character-literals, character literal} newline combination (CR, LF, CR-LF) is supported.

Despite its name this proc might not actually return the @emph{number of lines} in @emph{s} because the concept of what a line is can vary. For example, a string like @code{Hello world} is a line of text, but the proc will return a value of zero because there are no newline separators.  Also, text editors usually don't count trailing newline characters in a text file as a new empty line, but this proc will.

@item split
  @findex proc split*(s꞉ string; seps꞉ set[char] = Whitespace)꞉ seq[string] @{.noSideEffect, rtl,extern꞉ "nsuSplitCharSet".@}
@example
proc split*(s꞉ string; seps꞉ set[char] = Whitespace)꞉ seq[string] @{.noSideEffect, rtl,extern꞉ "nsuSplitCharSet".@}
@end example
  The same as the @uref{#split.i,string,set[char], split iterator}, but is a proc that returns a sequence of substrings.

@item split
  @findex proc split*(s꞉ string; sep꞉ char)꞉ seq[string] @{.noSideEffect, rtl,extern꞉ "nsuSplitChar".@}
@example
proc split*(s꞉ string; sep꞉ char)꞉ seq[string] @{.noSideEffect, rtl,extern꞉ "nsuSplitChar".@}
@end example
  The same as the @uref{#split.i,string,char, split iterator}, but is a proc that returns a sequence of substrings.

@item split
  @findex proc split*(s꞉ string; sep꞉ string)꞉ seq[string] @{.noSideEffect, rtl,extern꞉ "nsuSplitString".@}
@example
proc split*(s꞉ string; sep꞉ string)꞉ seq[string] @{.noSideEffect, rtl,extern꞉ "nsuSplitString".@}
@end example
  Splits the string @emph{s} into substrings using a string separator.

Substrings are separated by the string @emph{sep}. This is a wrapper around the @uref{#split.i,string,string, split iterator}.

@item toHex
  @findex proc toHex*(x꞉ BiggestInt; len꞉ Positive)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuToHex".@}
@example
proc toHex*(x꞉ BiggestInt; len꞉ Positive)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuToHex".@}
@end example
  Converts @emph{x} to its hexadecimal representation.

The resulting string will be exactly @emph{len} characters long. No prefix like @code{0x} is generated. @emph{x} is treated as an unsigned value.

@item intToStr
  @findex proc intToStr*(x꞉ int; minchars꞉ Positive = 1)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuIntToStr".@}
@example
proc intToStr*(x꞉ int; minchars꞉ Positive = 1)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuIntToStr".@}
@end example
  Converts @emph{x} to its decimal representation.

The resulting string will be minimally @emph{minchars} characters long. This is achieved by adding leading zeros.

@item parseInt
  @findex proc parseInt*(s꞉ string)꞉ int @{.noSideEffect, procvar, rtl, extern꞉ "nsuParseInt".@}
@example
proc parseInt*(s꞉ string)꞉ int @{.noSideEffect, procvar, rtl, extern꞉ "nsuParseInt".@}
@end example
  Parses a decimal integer value contained in @emph{s}.

If @emph{s} is not a valid integer, @emph{ValueError} is raised.

@item parseBiggestInt
  @findex proc parseBiggestInt*(s꞉ string)꞉ BiggestInt @{.noSideEffect, procvar, rtl,extern꞉ "nsuParseBiggestInt".@}
@example
proc parseBiggestInt*(s꞉ string)꞉ BiggestInt @{.noSideEffect, procvar, rtl,extern꞉ "nsuParseBiggestInt".@}
@end example
  Parses a decimal integer value contained in @emph{s}.

If @emph{s} is not a valid integer, @emph{ValueError} is raised.

@item parseFloat
  @findex proc parseFloat*(s꞉ string)꞉ float @{.noSideEffect, procvar, rtl,extern꞉ "nsuParseFloat".@}
@example
proc parseFloat*(s꞉ string)꞉ float @{.noSideEffect, procvar, rtl,extern꞉ "nsuParseFloat".@}
@end example
  Parses a decimal floating point value contained in @emph{s}. If @emph{s} is not a valid floating point number, @emph{ValueError} is raised. @code{NAN}, @code{INF}, @code{-INF} are also supported (case insensitive comparison).

@item parseHexInt
  @findex proc parseHexInt*(s꞉ string)꞉ int @{.noSideEffect, procvar, rtl,extern꞉ "nsuParseHexInt".@}
@example
proc parseHexInt*(s꞉ string)꞉ int @{.noSideEffect, procvar, rtl,extern꞉ "nsuParseHexInt".@}
@end example
  Parses a hexadecimal integer value contained in @emph{s}.

If @emph{s} is not a valid integer, @emph{ValueError} is raised. @emph{s} can have one of the following optional prefixes: @code{0x}, @code{0X}, @code{#}.  Underscores within @emph{s} are ignored.

@item parseBool
  @findex proc parseBool*(s꞉ string)꞉ bool
@example
proc parseBool*(s꞉ string)꞉ bool
@end example
  Parses a value into a @emph{bool}.

If @code{s} is one of the following values: @code{y, yes, true, 1, on}, then returns @emph{true}. If @code{s} is one of the following values: @code{n, no, false, 0, off}, then returns @emph{false}.  If @code{s} is something else a @code{ValueError} exception is raised.

@item parseEnum
  @findex proc parseEnum*[T꞉ enum](s꞉ string)꞉ T
@example
proc parseEnum*[T꞉ enum](s꞉ string)꞉ T
@end example
  Parses an enum @code{T}.

Raises @code{ValueError} for an invalid value in @emph{s}. The comparison is done in a style insensitive way.

@item parseEnum
  @findex proc parseEnum*[T꞉ enum](s꞉ string; default꞉ T)꞉ T
@example
proc parseEnum*[T꞉ enum](s꞉ string; default꞉ T)꞉ T
@end example
  Parses an enum @code{T}.

Uses @emph{default} for an invalid value in @emph{s}. The comparison is done in a style insensitive way.

@item repeat
  @findex proc repeat*(c꞉ char; count꞉ Natural)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuRepeatChar".@}
@example
proc repeat*(c꞉ char; count꞉ Natural)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuRepeatChar".@}
@end example
  Returns a string of length @emph{count} consisting only of the character @emph{c}. You can use this proc to left align strings. Example:
@example
proc tabexpand(indent: int, text: string, tabsize: int = 4) =
  echo '\t'.repeat(indent div tabsize), ' '.repeat(indent mod tabsize),
      text

tabexpand(4, "At four")
tabexpand(5, "At five")
tabexpand(6, "At six")
@end example

@item repeat
  @findex proc repeat*(s꞉ string; n꞉ Natural)꞉ string @{.noSideEffect, rtl, extern꞉ "nsuRepeatStr".@}
@example
proc repeat*(s꞉ string; n꞉ Natural)꞉ string @{.noSideEffect, rtl, extern꞉ "nsuRepeatStr".@}
@end example
  Returns String @emph{s} concatenated @emph{n} times.  Example:
@example
echo "+++ STOP ".repeat(4), "+++"
@end example

@item repeatChar
  @findex proc repeatChar*(count꞉ Natural; c꞉ char = ' ')꞉ string @{.deprecated.@}
@example
proc repeatChar*(count꞉ Natural; c꞉ char = ' ')꞉ string @{.deprecated.@}
@end example
  deprecated: use repeat() or spaces()

@item repeatStr
  @findex proc repeatStr*(count꞉ Natural; s꞉ string)꞉ string @{.deprecated.@}
@example
proc repeatStr*(count꞉ Natural; s꞉ string)꞉ string @{.deprecated.@}
@end example
  deprecated: use repeat(string, count) or string.repeat(count)

@item align
  @findex proc align*(s꞉ string; count꞉ Natural; padding = ' ')꞉ string @{.noSideEffect, rtl,extern꞉ "nsuAlignString".@}
@example
proc align*(s꞉ string; count꞉ Natural; padding = ' ')꞉ string @{.noSideEffect, rtl,extern꞉ "nsuAlignString".@}
@end example
  Aligns a string @emph{s} with @emph{padding}, so that it is of length @emph{count}.

@emph{padding} characters (by default spaces) are added before @emph{s} resulting in right alignment. If @code{s.len >= count}, no spaces are added and @emph{s} is returned unchanged. If you need to left align a string use the @uref{#repeatChar, repeatChar proc}. Example:


@example
assert align("abc", 4) == " abc"
assert align("a", 0) == "a"
assert align("1232", 6) == "  1232"
assert align("1232", 6, '#') == "##1232"
@end example

@item wordWrap
  @findex proc wordWrap*(s꞉ string; maxLineWidth = 80; splitLongWords = true;seps꞉ set[char] = Whitespace; newLine = "\x0A")꞉ string @{.noSideEffect,rtl, extern꞉ "nsuWordWrap".@}
@example
proc wordWrap*(s꞉ string; maxLineWidth = 80; splitLongWords = true;seps꞉ set[char] = Whitespace; newLine = "\x0A")꞉ string @{.noSideEffect,rtl, extern꞉ "nsuWordWrap".@}
@end example
  Word wraps @emph{s}.

@item indent
  @findex proc indent*(s꞉ string; count꞉ Natural; padding꞉ string = " ")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuIndent".@}
@example
proc indent*(s꞉ string; count꞉ Natural; padding꞉ string = " ")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuIndent".@}
@end example
  Indents each line in @code{s} by @code{count} amount of @code{padding}.

@strong{Note:} This currently does not preserve the specific new line characters used.

@item unindent
  @findex proc unindent*(s꞉ string; eatAllIndent = false)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuUnindent".@}
@example
proc unindent*(s꞉ string; eatAllIndent = false)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuUnindent".@}
@end example
  Unindents @emph{s}.

@item startsWith
  @findex proc startsWith*(s, prefix꞉ string)꞉ bool @{.noSideEffect, rtl, extern꞉ "nsuStartsWith".@}
@example
proc startsWith*(s, prefix꞉ string)꞉ bool @{.noSideEffect, rtl, extern꞉ "nsuStartsWith".@}
@end example
  Returns true iff @code{s} starts with @code{prefix}.

If @code{prefix == ""} true is returned.

@item endsWith
  @findex proc endsWith*(s, suffix꞉ string)꞉ bool @{.noSideEffect, rtl, extern꞉ "nsuEndsWith".@}
@example
proc endsWith*(s, suffix꞉ string)꞉ bool @{.noSideEffect, rtl, extern꞉ "nsuEndsWith".@}
@end example
  Returns true iff @code{s} ends with @code{suffix}.

If @code{suffix == ""} true is returned.

@item continuesWith
  @findex proc continuesWith*(s, substr꞉ string; start꞉ Natural)꞉ bool @{.noSideEffect, rtl,extern꞉ "nsuContinuesWith".@}
@example
proc continuesWith*(s, substr꞉ string; start꞉ Natural)꞉ bool @{.noSideEffect, rtl,extern꞉ "nsuContinuesWith".@}
@end example
  Returns true iff @code{s} continues with @code{substr} at position @code{start}.

If @code{substr == ""} true is returned.

@item addSep
  @findex proc addSep*(dest꞉ var string; sep = ", "; startLen꞉ Natural = 0) @{.noSideEffect, inline.@}
@example
proc addSep*(dest꞉ var string; sep = ", "; startLen꞉ Natural = 0) @{.noSideEffect, inline.@}
@end example
  Adds a separator to @emph{dest} only if its length is bigger than @emph{startLen}.

A shorthand for:


@example
if dest.len > startLen: add(dest, sep)
@end example
This is often useful for generating some code where the items need to be @emph{separated} by @emph{sep}. @emph{sep} is only added if @emph{dest} is longer than @emph{startLen}. The following example creates a string describing an array of integers:


@example
var arr = "["
for x in items([2, 3, 5, 7, 11]):
  addSep(arr, startLen=len("["))
  add(arr, $x)
add(arr, "]")
@end example

@item allCharsInSet
  @findex proc allCharsInSet*(s꞉ string; theSet꞉ set[char])꞉ bool
@example
proc allCharsInSet*(s꞉ string; theSet꞉ set[char])꞉ bool
@end example
  Returns true iff each character of @emph{s} is in the set @emph{theSet}.

@item abbrev
  @findex proc abbrev*(s꞉ string; possibilities꞉ openArray[string])꞉ int
@example
proc abbrev*(s꞉ string; possibilities꞉ openArray[string])꞉ int
@end example
  Returns the index of the first item in @emph{possibilities} if not ambiguous.

Returns -1 if no item has been found and -2 if multiple items match.

@item join
  @findex proc join*(a꞉ openArray[string]; sep꞉ string)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuJoinSep".@}
@example
proc join*(a꞉ openArray[string]; sep꞉ string)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuJoinSep".@}
@end example
  Concatenates all strings in @emph{a} separating them with @emph{sep}.

@item join
  @findex proc join*(a꞉ openArray[string])꞉ string @{.noSideEffect, rtl, extern꞉ "nsuJoin".@}
@example
proc join*(a꞉ openArray[string])꞉ string @{.noSideEffect, rtl, extern꞉ "nsuJoin".@}
@end example
  Concatenates all strings in @emph{a}.

@item find
  @findex proc find*(s, sub꞉ string; start꞉ Natural = 0)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuFindStr".@}
@example
proc find*(s, sub꞉ string; start꞉ Natural = 0)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuFindStr".@}
@end example
  Searches for @emph{sub} in @emph{s} starting at position @emph{start}.

Searching is case-sensitive. If @emph{sub} is not in @emph{s}, -1 is returned.

@item find
  @findex proc find*(s꞉ string; sub꞉ char; start꞉ Natural = 0)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuFindChar".@}
@example
proc find*(s꞉ string; sub꞉ char; start꞉ Natural = 0)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuFindChar".@}
@end example
  Searches for @emph{sub} in @emph{s} starting at position @emph{start}.

Searching is case-sensitive. If @emph{sub} is not in @emph{s}, -1 is returned.

@item find
  @findex proc find*(s꞉ string; chars꞉ set[char]; start꞉ Natural = 0)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuFindCharSet".@}
@example
proc find*(s꞉ string; chars꞉ set[char]; start꞉ Natural = 0)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuFindCharSet".@}
@end example
  Searches for @emph{chars} in @emph{s} starting at position @emph{start}.

If @emph{s} contains none of the characters in @emph{chars}, -1 is returned.

@item rfind
  @findex proc rfind*(s, sub꞉ string; start꞉ int = - 1)꞉ int @{.noSideEffect.@}
@example
proc rfind*(s, sub꞉ string; start꞉ int = - 1)꞉ int @{.noSideEffect.@}
@end example
  Searches for @emph{sub} in @emph{s} in reverse, starting at @emph{start} and going backwards to 0.

Searching is case-sensitive. If @emph{sub} is not in @emph{s}, -1 is returned.

@item rfind
  @findex proc rfind*(s꞉ string; sub꞉ char; start꞉ int = - 1)꞉ int @{.noSideEffect, rtl.@}
@example
proc rfind*(s꞉ string; sub꞉ char; start꞉ int = - 1)꞉ int @{.noSideEffect, rtl.@}
@end example
  Searches for @emph{sub} in @emph{s} in reverse starting at position @emph{start}.

Searching is case-sensitive. If @emph{sub} is not in @emph{s}, -1 is returned.

@item count
  @findex proc count*(s꞉ string; sub꞉ string; overlapping꞉ bool = false)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuCountString".@}
@example
proc count*(s꞉ string; sub꞉ string; overlapping꞉ bool = false)꞉ int @{.noSideEffect, rtl,extern꞉ "nsuCountString".@}
@end example
  Count the occurrences of a substring @emph{sub} in the string @emph{s}. Overlapping occurrences of @emph{sub} only count when @emph{overlapping} is set to true.

@item count
  @findex proc count*(s꞉ string; sub꞉ char)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuCountChar".@}
@example
proc count*(s꞉ string; sub꞉ char)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuCountChar".@}
@end example
  Count the occurrences of the character @emph{sub} in the string @emph{s}.

@item count
  @findex proc count*(s꞉ string; subs꞉ set[char])꞉ int @{.noSideEffect, rtl,extern꞉ "nsuCountCharSet".@}
@example
proc count*(s꞉ string; subs꞉ set[char])꞉ int @{.noSideEffect, rtl,extern꞉ "nsuCountCharSet".@}
@end example
  Count the occurrences of the group of character @emph{subs} in the string @emph{s}.

@item quoteIfContainsWhite
  @findex proc quoteIfContainsWhite*(s꞉ string)꞉ string @{.deprecated.@}
@example
proc quoteIfContainsWhite*(s꞉ string)꞉ string @{.deprecated.@}
@end example
  Returns @code{'"' & s & '"'} if @emph{s} contains a space and does not start with a quote, else returns @emph{s}.

@strong{DEPRECATED} as it was confused for shell quoting function.  For this application use @uref{osproc.html#quoteShell, osproc.quoteShell}.

@item contains
  @findex proc contains*(s꞉ string; c꞉ char)꞉ bool @{.noSideEffect.@}
@example
proc contains*(s꞉ string; c꞉ char)꞉ bool @{.noSideEffect.@}
@end example
  Same as @code{find(s, c) >= 0}.

@item contains
  @findex proc contains*(s, sub꞉ string)꞉ bool @{.noSideEffect.@}
@example
proc contains*(s, sub꞉ string)꞉ bool @{.noSideEffect.@}
@end example
  Same as @code{find(s, sub) >= 0}.

@item contains
  @findex proc contains*(s꞉ string; chars꞉ set[char])꞉ bool @{.noSideEffect.@}
@example
proc contains*(s꞉ string; chars꞉ set[char])꞉ bool @{.noSideEffect.@}
@end example
  Same as @code{find(s, chars) >= 0}.

@item replace
  @findex proc replace*(s, sub꞉ string; by = "")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuReplaceStr".@}
@example
proc replace*(s, sub꞉ string; by = "")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuReplaceStr".@}
@end example
  Replaces @emph{sub} in @emph{s} by the string @emph{by}.

@item replace
  @findex proc replace*(s꞉ string; sub, by꞉ char)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuReplaceChar".@}
@example
proc replace*(s꞉ string; sub, by꞉ char)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuReplaceChar".@}
@end example
  Replaces @emph{sub} in @emph{s} by the character @emph{by}.

Optimized version of @uref{#replace,string,string, replace} for characters.

@item replaceWord
  @findex proc replaceWord*(s, sub꞉ string; by = "")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuReplaceWord".@}
@example
proc replaceWord*(s, sub꞉ string; by = "")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuReplaceWord".@}
@end example
  Replaces @emph{sub} in @emph{s} by the string @emph{by}.

Each occurrence of @emph{sub} has to be surrounded by word boundaries (comparable to @code{\\w} in regular expressions), otherwise it is not replaced.

@item delete
  @findex proc delete*(s꞉ var string; first, last꞉ int) @{.noSideEffect, rtl, extern꞉ "nsuDelete".@}
@example
proc delete*(s꞉ var string; first, last꞉ int) @{.noSideEffect, rtl, extern꞉ "nsuDelete".@}
@end example
  Deletes in @emph{s} the characters at position @emph{first} .. @emph{last}.

This modifies @emph{s} itself, it does not return a copy.

@item parseOctInt
  @findex proc parseOctInt*(s꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuParseOctInt".@}
@example
proc parseOctInt*(s꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuParseOctInt".@}
@end example
  Parses an octal integer value contained in @emph{s}.

If @emph{s} is not a valid integer, @emph{ValueError} is raised. @emph{s} can have one of the following optional prefixes: @code{0o}, @code{0O}.  Underscores within @emph{s} are ignored.

@item toOct
  @findex proc toOct*(x꞉ BiggestInt; len꞉ Positive)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuToOct".@}
@example
proc toOct*(x꞉ BiggestInt; len꞉ Positive)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuToOct".@}
@end example
  Converts @emph{x} into its octal representation.

The resulting string is always @emph{len} characters long. No leading @code{0o} prefix is generated.

@item toBin
  @findex proc toBin*(x꞉ BiggestInt; len꞉ Positive)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuToBin".@}
@example
proc toBin*(x꞉ BiggestInt; len꞉ Positive)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuToBin".@}
@end example
  Converts @emph{x} into its binary representation.

The resulting string is always @emph{len} characters long. No leading @code{0b} prefix is generated.

@item insertSep
  @findex proc insertSep*(s꞉ string; sep = '_'; digits = 3)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuInsertSep".@}
@example
proc insertSep*(s꞉ string; sep = '_'; digits = 3)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuInsertSep".@}
@end example
  Inserts the separator @emph{sep} after @emph{digits} digits from right to left.

Even though the algorithm works with any string @emph{s}, it is only useful if @emph{s} contains a number. Example: @code{insertSep("1000000") == "1_000_000"}

@item escape
  @findex proc escape*(s꞉ string; prefix = "\""; suffix = "\"")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuEscape".@}
@example
proc escape*(s꞉ string; prefix = "\""; suffix = "\"")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuEscape".@}
@end example
  Escapes a string @emph{s}.

This does these operations (at the same time):


@itemize 
 @item replaces any @code{\} by @code{\\}
@item replaces any @code{'} by @code{\'}
@item replaces any @code{"} by @code{\"}
@item replaces any other character in the set @code{@{'\0'..'\31', '\128'..'\255'@}} by @code{\xHH} where @code{HH} is its hexadecimal value.
 
@end itemize
The procedure has been designed so that its output is usable for many different common syntaxes. The resulting string is prefixed with @emph{prefix} and suffixed with @emph{suffix}. Both may be empty strings.

@item unescape
  @findex proc unescape*(s꞉ string; prefix = "\""; suffix = "\"")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuUnescape".@}
@example
proc unescape*(s꞉ string; prefix = "\""; suffix = "\"")꞉ string @{.noSideEffect, rtl,extern꞉ "nsuUnescape".@}
@end example
  Unescapes a string @emph{s}.

This complements @uref{#escape, escape} as it performs the opposite operations.

If @emph{s} does not begin with @code{prefix} and end with @code{suffix} a ValueError exception will be raised.

@item validIdentifier
  @findex proc validIdentifier*(s꞉ string)꞉ bool @{.noSideEffect, rtl,extern꞉ "nsuValidIdentifier".@}
@example
proc validIdentifier*(s꞉ string)꞉ bool @{.noSideEffect, rtl,extern꞉ "nsuValidIdentifier".@}
@end example
  Returns true if @emph{s} is a valid identifier.

A valid identifier starts with a character of the set @emph{IdentStartChars} and is followed by any number of characters of the set @emph{IdentChars}.

@item editDistance
  @findex proc editDistance*(a, b꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuEditDistance".@}
@example
proc editDistance*(a, b꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nsuEditDistance".@}
@end example
  Returns the edit distance between @emph{a} and @emph{b}.

This uses the  distance algorithm with only a linear memory overhead.  This implementation is highly optimized!

@item formatBiggestFloat
  @findex proc formatBiggestFloat*(f꞉ BiggestFloat; format꞉ FloatFormatMode = ffDefault;precision꞉ range[0 .. 32] = 16; decimalSep = '.')꞉ string @{.noSideEffect, rtl, extern꞉ "nsu$1".@}
@example
proc formatBiggestFloat*(f꞉ BiggestFloat; format꞉ FloatFormatMode = ffDefault;precision꞉ range[0 .. 32] = 16; decimalSep = '.')꞉ string @{.noSideEffect, rtl, extern꞉ "nsu$1".@}
@end example
  Converts a floating point value @emph{f} to a string.

If @code{format == ffDecimal} then precision is the number of digits to be printed after the decimal point. If @code{format == ffScientific} then precision is the maximum number of significant digits to be printed. @emph{precision}'s default value is the maximum number of meaningful digits after the decimal point for Nim's @code{biggestFloat} type.

If @code{precision == 0}, it tries to format it nicely.

@item formatFloat
  @findex proc formatFloat*(f꞉ float; format꞉ FloatFormatMode = ffDefault;precision꞉ range[0 .. 32] = 16; decimalSep = '.')꞉ string @{.noSideEffect,rtl, extern꞉ "nsu$1".@}
@example
proc formatFloat*(f꞉ float; format꞉ FloatFormatMode = ffDefault;precision꞉ range[0 .. 32] = 16; decimalSep = '.')꞉ string @{.noSideEffect,rtl, extern꞉ "nsu$1".@}
@end example
  Converts a floating point value @emph{f} to a string.

If @code{format == ffDecimal} then precision is the number of digits to be printed after the decimal point. If @code{format == ffScientific} then precision is the maximum number of significant digits to be printed. @emph{precision}'s default value is the maximum number of meaningful digits after the decimal point for Nim's @code{float} type.

@item formatSize
  @findex proc formatSize*(bytes꞉ BiggestInt; decimalSep = '.')꞉ string
@example
proc formatSize*(bytes꞉ BiggestInt; decimalSep = '.')꞉ string
@end example
  Rounds and formats @emph{bytes}. Examples:
@example

formatSize(1'i64 shl 31 + 300'i64) == "2.204GB"
formatSize(4096) == "4KB"
@end example

@item addf
  @findex proc addf*(s꞉ var string; formatstr꞉ string; a꞉ varargs[string, `$`]) @{.noSideEffect, rtl,extern꞉ "nsuAddf".@}
@example
proc addf*(s꞉ var string; formatstr꞉ string; a꞉ varargs[string, `$`]) @{.noSideEffect, rtl,extern꞉ "nsuAddf".@}
@end example
  The same as @code{add(s, formatstr % a)}, but more efficient.

@item `%`
  @findex proc `%`*(formatstr꞉ string; a꞉ openArray[string])꞉ string @{.noSideEffect, rtl,extern꞉ "nsuFormatOpenArray".@}
@example
proc `%`*(formatstr꞉ string; a꞉ openArray[string])꞉ string @{.noSideEffect, rtl,extern꞉ "nsuFormatOpenArray".@}
@end example
  Interpolates a format string with the values from @emph{a}.

The  operator performs string substitutions in @emph{formatstr} and returns a modified @emph{formatstr}. This is often called .

This is best explained by an example:


@example
"$1 eats $2." % ["The cat", "fish"]
@end example
Results in:


@example
"The cat eats fish."
@end example
The substitution variables (the thing after the @code{$}) are enumerated from 1 to @code{a.len}. To produce a verbatim @code{$}, use @code{$$}. The notation @code{$#} can be used to refer to the next substitution variable:


@example
"$# eats $#." % ["The cat", "fish"]
@end example
Substitution variables can also be words (that is @code{[A-Za-z_]+[A-Za-z0-9_]*}) in which case the arguments in @emph{a} with even indices are keys and with odd indices are the corresponding values. An example:


@example
"$animal eats $food." % ["animal", "The cat", "food", "fish"]
@end example
Results in:


@example
"The cat eats fish."
@end example
The variables are compared with @emph{cmpIgnoreStyle}. @emph{ValueError} is raised if an ill-formed format string has been passed to the @emph{%} operator.

@item `%`
  @findex proc `%`*(formatstr, a꞉ string)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuFormatSingleElem".@}
@example
proc `%`*(formatstr, a꞉ string)꞉ string @{.noSideEffect, rtl,extern꞉ "nsuFormatSingleElem".@}
@end example
  This is the same as @code{formatstr % [a]}.

@item format
  @findex proc format*(formatstr꞉ string; a꞉ varargs[string, `$`])꞉ string @{.noSideEffect, rtl,extern꞉ "nsuFormatVarargs".@}
@example
proc format*(formatstr꞉ string; a꞉ varargs[string, `$`])꞉ string @{.noSideEffect, rtl,extern꞉ "nsuFormatVarargs".@}
@end example
  This is the same as @code{formatstr % a} except that it supports auto stringification.

@item removeSuffix
  @findex proc removeSuffix*(s꞉ var string; chars꞉ set[char] = Newlines) @{.rtl,extern꞉ "nsuRemoveSuffixCharSet".@}
@example
proc removeSuffix*(s꞉ var string; chars꞉ set[char] = Newlines) @{.rtl,extern꞉ "nsuRemoveSuffixCharSet".@}
@end example
  Removes the first matching character from the string (in-place) given a set of characters. If the set of characters is only equal to @emph{Newlines} then it will remove both the newline and return feed. .. code-block:: nim
@quotation 
@itemize 
 @item var: userInput = "Hello World!rn" otherInput = "Hello!?!"
 
@end itemize
userInput.removeSuffix userInput == "Hello World!" userInput.removeSuffix(@{'!', '?'@}) userInput == "Hello World" otherInput.removeSuffix(@{'!', '?'@}) otherInput == "Hello!?"

 
@end quotation

@item removeSuffix
  @findex proc removeSuffix*(s꞉ var string; c꞉ char) @{.rtl, extern꞉ "nsuRemoveSuffixChar".@}
@example
proc removeSuffix*(s꞉ var string; c꞉ char) @{.rtl, extern꞉ "nsuRemoveSuffixChar".@}
@end example
  Removes a single character (in-place) from a string. .. code-block:: nim
@quotation 
@itemize 
 @item var: table = "users"
 
@end itemize
table.removeSuffix('s') table == "user"

 
@end quotation

@item removeSuffix
  @findex proc removeSuffix*(s꞉ var string; suffix꞉ string) @{.rtl,extern꞉ "nsuRemoveSuffixString".@}
@example
proc removeSuffix*(s꞉ var string; suffix꞉ string) @{.rtl,extern꞉ "nsuRemoveSuffixString".@}
@end example
  Remove the first matching suffix (in-place) from a string. .. code-block:: nim
@quotation 
@itemize 
 @item var: answers = "yeses"
 
@end itemize
answers.removeSuffix("es") answers == "yes"

 
@end quotation
@end itemize

@chapter Templates

@itemize


@item spaces
  @findex template spaces*(n꞉ Natural)꞉ string
@example
template spaces*(n꞉ Natural)꞉ string
@end example
  Returns a String with @emph{n} space characters. You can use this proc to left align strings. Example:
@example
let
  width = 15
  text1 = "Hello user!"
  text2 = "This is a very long string"
echo text1 & spaces(max(0, width - text1.len)) & "|"
echo text2 & spaces(max(0, width - text2.len)) & "|"
@end example
@end itemize




@chapter Iterators

@itemize


@item split
  @itindex iterator split*(s꞉ string; seps꞉ set[char] = Whitespace)꞉ string
@example
iterator split*(s꞉ string; seps꞉ set[char] = Whitespace)꞉ string
@end example
  Splits the string @emph{s} into substrings using a group of separators.

Substrings are separated by a substring containing only @emph{seps}. Note that whole sequences of characters found in @code{seps} will be counted as a single split point and leading/trailing separators will be ignored. The following example:


@example
for word in split("  this is an  example  "):
  writeLine(stdout, word)
@end example
...generates this output:


@example
"this"
"is"
"an"
"example"
@end example
And the following code:


@example
for word in split(";;this;is;an;;example;;;", @{';'@}):
  writeLine(stdout, word)
@end example
...produces the same output as the first example. The code:


@example
let date = "2012-11-20T22:08:08.398990"
let separators = @{' ', '-', ':', 'T'@}
for number in split(date, separators):
  writeLine(stdout, number)
@end example
...results in:


@example
"2012"
"11"
"20"
"22"
"08"
"08.398990"
@end example

@item split
  @itindex iterator split*(s꞉ string; sep꞉ char)꞉ string
@example
iterator split*(s꞉ string; sep꞉ char)꞉ string
@end example
  Splits the string @emph{s} into substrings using a single separator.

Substrings are separated by the character @emph{sep}. Unlike the version of the iterator which accepts a set of separator characters, this proc will not coalesce groups of the separator, returning a string for each found character. The code:


@example
for word in split(";;this;is;an;;example;;;", ';'):
  writeLine(stdout, word)
@end example
Results in:


@example
""
""
"this"
"is"
"an"
""
"example"
""
""
""
@end example

@item split
  @itindex iterator split*(s꞉ string; sep꞉ string)꞉ string
@example
iterator split*(s꞉ string; sep꞉ string)꞉ string
@end example
  Splits the string @emph{s} into substrings using a string separator.

Substrings are separated by the string @emph{sep}.

@item splitLines
  @itindex iterator splitLines*(s꞉ string)꞉ string
@example
iterator splitLines*(s꞉ string)꞉ string
@end example
  Splits the string @emph{s} into its containing lines.

Every @uref{manual.html#character-literals, character literal} newline combination (CR, LF, CR-LF) is supported. The result strings contain no trailing @code{\n}.

Example:


@example
for line in splitLines("\nthis\nis\nan\n\nexample\n"):
  writeLine(stdout, line)
@end example
Results in:


@example
""
"this"
"is"
"an"
""
"example"
""
@end example

@item tokenize
  @itindex iterator tokenize*(s꞉ string; seps꞉ set[char] = Whitespace)꞉ tuple[token꞉ string,isSep꞉ bool]
@example
iterator tokenize*(s꞉ string; seps꞉ set[char] = Whitespace)꞉ tuple[token꞉ string,isSep꞉ bool]
@end example
  Tokenizes the string @emph{s} into substrings.

Substrings are separated by a substring containing only @emph{seps}. Examples:


@example
for word in tokenize("  this is an  example  "):
  writeLine(stdout, word)
@end example
Results in:


@example
("  ", true)
("this", false)
(" ", true)
("is", false)
(" ", true)
("an", false)
("  ", true)
("example", false)
("  ", true)
@end example
@end itemize

@node /pure/marshal, /pure/unittest , /pure/strutils, Top




@chapter Procedures

@itemize


@item load
  @findex proc load*[T](s꞉ Stream; data꞉ var T)
@example
proc load*[T](s꞉ Stream; data꞉ var T)
@end example
  loads @emph{data} from the stream @emph{s}. Raises @emph{EIO} in case of an error.

@item store
  @findex proc store*[T](s꞉ Stream; data꞉ T)
@example
proc store*[T](s꞉ Stream; data꞉ T)
@end example
  stores @emph{data} into the stream @emph{s}. Raises @emph{EIO} in case of an error.

@item `$$`
  @findex proc `$$`*[T](x꞉ T)꞉ string
@example
proc `$$`*[T](x꞉ T)꞉ string
@end example
  returns a string representation of @emph{x}.

@item to
  @findex proc to*[T](data꞉ string)꞉ T
@example
proc to*[T](data꞉ string)꞉ T
@end example
  reads data and transforms it to a @code{T}.
@end itemize






@node /pure/unittest, /pure/uri , /pure/marshal, Top



@chapter Types

@itemize


@item OutputLevel
  @tindex OutputLevel* = enum
  PRINT_ALL,                  ## Print as much as possible.
  PRINT_FAILURES,             ## Print only the failed tests.
  PRINT_NONE                  ## Print nothing.
@example
OutputLevel* = enum
  PRINT_ALL,                  ## Print as much as possible.
  PRINT_FAILURES,             ## Print only the failed tests.
  PRINT_NONE                  ## Print nothing.
@end example
  The output verbosity of the tests.
@end itemize

@chapter Procedures

@itemize


@item checkpoint
  @findex proc checkpoint*(msg꞉ string)
@example
proc checkpoint*(msg꞉ string)
@end example
  Set a checkpoint identified by @emph{msg}. Upon test failure all checkpoints encountered so far are printed out. Example:
@example

checkpoint("Checkpoint A")
check((42, "the Answer to life and everything") == (1, "a"))
checkpoint("Checkpoint B")
@end example
outputs "Checkpoint A" once it fails.
@end itemize

@chapter Templates

@itemize


@item suite
  @findex template suite*(name꞉ expr; body꞉ stmt)꞉ stmt @{.immediate, dirty.@}
@example
template suite*(name꞉ expr; body꞉ stmt)꞉ stmt @{.immediate, dirty.@}
@end example
  Declare a test suite identified by @emph{name} with optional @code{setup} and/or @code{teardown} section.

A test suite is a series of one or more related tests sharing a common fixture (@code{setup}, @code{teardown}). The fixture is executed for EACH test.


@example
suite "test suite for addition":
  setup:
    let result = 4
  
  test "2 + 2 = 4":
    check(2+2 == result)
  
  test "(2 + -2) != 4":
    check(2 + -2 != result)
  
  # No teardown needed
@end example
The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:


@example

[OK] 2 + 2 = 4
[OK] (2 + -2) != 4
@end example

@item test
  @findex template test*(name꞉ expr; body꞉ stmt)꞉ stmt @{.immediate, dirty.@}
@example
template test*(name꞉ expr; body꞉ stmt)꞉ stmt @{.immediate, dirty.@}
@end example
  Define a single test case identified by @emph{name}.
@example

test "roses are red":
  let roses = "red"
  check(roses == "red")
@end example
The above code outputs:


@example

[OK] roses are red
@end example

@item fail
  @findex template fail*()
@example
template fail*()
@end example
  Print out the checkpoints encountered so far and quit if @code{abortOnError} is true. Otherwise, erase the checkpoints and indicate the test has failed (change exit code and test status). This template is useful for debugging, but is otherwise mostly used internally. Example:
@example

checkpoint("Checkpoint A")
complicatedProcInThread()
fail()
@end example
outputs "Checkpoint A" before quitting.

@item require
  @findex template require*(conditions꞉ stmt)꞉ stmt @{.immediate.@}
@example
template require*(conditions꞉ stmt)꞉ stmt @{.immediate.@}
@end example
  Same as @emph{check} except any failed test causes the program to quit immediately. Any teardown statements are not executed and the failed test output is not generated.
@end itemize

@chapter Macros

@itemize


@item check
  @findex macro check*(conditions꞉ stmt)꞉ stmt @{.immediate.@}
@example
macro check*(conditions꞉ stmt)꞉ stmt @{.immediate.@}
@end example
  Verify if a statement or a list of statements is true. A helpful error message and set checkpoints are printed out on failure (if @code{outputLevel} is not @code{PRINT_NONE}). Example:
@example

import strutils

check("AKB48".toLower() == "akb48")

let teams = @{'A', 'K', 'B', '4', '8'@}

check:
  "AKB48".toLower() == "akb48"
  'C' in teams
@end example

@item expect
  @findex macro expect*(exceptions꞉ varargs[expr]; body꞉ stmt)꞉ stmt @{.immediate.@}
@example
macro expect*(exceptions꞉ varargs[expr]; body꞉ stmt)꞉ stmt @{.immediate.@}
@end example
  Test if @emph{body} raises an exception found in the passed @emph{exceptions}. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:
@example

import math
proc defectiveRobot() =
  randomize()
  case random(1..4)
  of 1: raise newException(OSError, "CANNOT COMPUTE!")
  of 2: discard parseInt("Hello World!")
  of 3: raise newException(IOError, "I can't do that Dave.")
  else: assert 2 + 2 == 5

expect IOError, OSError, ValueError, AssertionError:
  defectiveRobot()
@end example
@end itemize




@node /pure/uri, /pure/parseopt2 , /pure/unittest, Top



@chapter Types

@itemize


@item Uri
  @tindex Uri* = object
  scheme*, username*, password*: string
  hostname*, port*, path*, query*, anchor*: string
  opaque*: bool

@example
Uri* = object
  scheme*, username*, password*: string
  hostname*, port*, path*, query*, anchor*: string
  opaque*: bool

@end example
  
@end itemize

@chapter Procedures

@itemize


@item `$`
  @findex proc `$`*(url꞉ Url)꞉ string @{.deprecated.@}
@example
proc `$`*(url꞉ Url)꞉ string @{.deprecated.@}
@end example
  @strong{Deprecated since 0.9.6}: Use @code{Uri} instead.

@item `/`
  @findex proc `/`*(a, b꞉ Url)꞉ Url @{.deprecated.@}
@example
proc `/`*(a, b꞉ Url)꞉ Url @{.deprecated.@}
@end example
  Joins two URLs together, separating them with / if needed.

@strong{Deprecated since 0.9.6}: Use @code{Uri} instead.

@item add
  @findex proc add*(url꞉ var Url; a꞉ Url) @{.deprecated.@}
@example
proc add*(url꞉ var Url; a꞉ Url) @{.deprecated.@}
@end example
  Appends url to url.

@strong{Deprecated since 0.9.6}: Use @code{Uri} instead.

@item initUri
  @findex proc initUri*()꞉ Uri
@example
proc initUri*()꞉ Uri
@end example
  Initializes a URI.

@item parseUri
  @findex proc parseUri*(uri꞉ string; result꞉ var Uri)
@example
proc parseUri*(uri꞉ string; result꞉ var Uri)
@end example
  Parses a URI. The @emph{result} variable will be cleared before.

@item parseUri
  @findex proc parseUri*(uri꞉ string)꞉ Uri
@example
proc parseUri*(uri꞉ string)꞉ Uri
@end example
  Parses a URI and returns it.

@item combine
  @findex proc combine*(base꞉ Uri; reference꞉ Uri)꞉ Uri
@example
proc combine*(base꞉ Uri; reference꞉ Uri)꞉ Uri
@end example
  Combines a base URI with a reference URI.

This uses the algorithm specified in @uref{http://tools.ietf.org/html/rfc3986#section-5.2.2, section 5.2.2 of RFC 3986}.

This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.

For building URIs you may wish to use `/` instead.

Examples:


@example
let foo = combine(parseUri("http://example.com/foo/bar"), parseUri("/baz"))
assert foo.path == "/baz"

let bar = combine(parseUri("http://example.com/foo/bar"), parseUri("baz"))
assert bar.path == "/foo/baz"

let bar = combine(parseUri("http://example.com/foo/bar/"), parseUri("baz"))
assert bar.path == "/foo/bar/baz"
@end example

@item combine
  @findex proc combine*(uris꞉ varargs[Uri])꞉ Uri
@example
proc combine*(uris꞉ varargs[Uri])꞉ Uri
@end example
  Combines multiple URIs together.

@item `/`
  @findex proc `/`*(x꞉ Uri; path꞉ string)꞉ Uri
@example
proc `/`*(x꞉ Uri; path꞉ string)꞉ Uri
@end example
  Concatenates the path specified to the specified URI's path.

Contrary to the @code{combine} procedure you do not have to worry about the slashes at the beginning and end of the path and URI's path respectively.

Examples:


@example
let foo = parseUri("http://example.com/foo/bar") / parseUri("/baz")
assert foo.path == "/foo/bar/baz"

let bar = parseUri("http://example.com/foo/bar") / parseUri("baz")
assert bar.path == "/foo/bar/baz"

let bar = parseUri("http://example.com/foo/bar/") / parseUri("baz")
assert bar.path == "/foo/bar/baz"
@end example

@item `$`
  @findex proc `$`*(u꞉ Uri)꞉ string
@example
proc `$`*(u꞉ Uri)꞉ string
@end example
  Returns the string representation of the specified URI object.
@end itemize






@node /pure/parseopt2, /pure/romans , /pure/uri, Top



@chapter Types

@itemize


@item OptParser
  @tindex OptParser* = object of RootObj
  cmd: seq[string]
  pos: int
  remainingShortOptions: string
  kind*: CmdLineKind           ## the dected command line token
  key*, val*: TaintedString     ## key and value pair; ``key`` is the option
                         ## or the argument, ``value`` is not "" if
                         ## the option was given a value
  
@example
OptParser* = object of RootObj
  cmd: seq[string]
  pos: int
  remainingShortOptions: string
  kind*: CmdLineKind           ## the dected command line token
  key*, val*: TaintedString     ## key and value pair; ``key`` is the option
                         ## or the argument, ``value`` is not "" if
                         ## the option was given a value
  
@end example
  this object implements the command line parser

@item GetoptResult
  @tindex GetoptResult* = tuple[kind꞉ CmdLineKind, key, val꞉ TaintedString]
@example
GetoptResult* = tuple[kind꞉ CmdLineKind, key, val꞉ TaintedString]
@end example
  
@end itemize

@chapter Procedures

@itemize


@item initOptParser
  @findex proc initOptParser*(cmdline꞉ seq[string])꞉ OptParser @{.rtl.@}
@example
proc initOptParser*(cmdline꞉ seq[string])꞉ OptParser @{.rtl.@}
@end example
  Initalizes option parses with cmdline. cmdline should not contain argument 0 - program name. If cmdline == nil default to current command line arguments.

@item initOptParser
  @findex proc initOptParser*(cmdline꞉ string)꞉ OptParser @{.rtl, deprecated.@}
@example
proc initOptParser*(cmdline꞉ string)꞉ OptParser @{.rtl, deprecated.@}
@end example
  Initalizes option parses with cmdline. Splits cmdline in on spaces and calls initOptParser(openarray[string]) Do not use.

@item initOptParser
  @findex proc initOptParser*()꞉ OptParser
@example
proc initOptParser*()꞉ OptParser
@end example
  Initializes option parser from current command line arguments.

@item next
  @findex proc next*(p꞉ var OptParser) @{.rtl, extern꞉ "npo2$1".@}
@example
proc next*(p꞉ var OptParser) @{.rtl, extern꞉ "npo2$1".@}
@end example
  

@item cmdLineRest
  @findex proc cmdLineRest*(p꞉ OptParser)꞉ TaintedString @{.rtl, extern꞉ "npo2$1", deprecated.@}
@example
proc cmdLineRest*(p꞉ OptParser)꞉ TaintedString @{.rtl, extern꞉ "npo2$1", deprecated.@}
@end example
  Returns part of command line string that has not been parsed yet. Do not use - does not correctly handle whitespace.
@end itemize





@chapter Iterators

@itemize


@item getopt
  @itindex iterator getopt*()꞉ GetoptResult
@example
iterator getopt*()꞉ GetoptResult
@end example
  This is an convenience iterator for iterating over the command line. This uses the OptParser object. Example:
@example
var
  filename = ""
for kind, key, val in getopt():
  case kind
  of cmdArgument:
    filename = key
  of cmdLongOption, cmdShortOption:
    case key
    of "help", "h": writeHelp()
    of "version", "v": writeVersion()
  of cmdEnd: assert(false) # cannot happen
if filename == "":
  # no filename has been given, so we show the help:
  writeHelp()
@end example
@end itemize

@node /pure/romans, /pure/streams , /pure/parseopt2, Top
@chapter Constant variables

@itemize


@item RomanNumeralDigits
  @vindex RomanNumeralDigits* = @{'I', 'i', 'V', 'v', 'X', 'x', 'L', 'l', 'C', 'c', 'D', 'd', 'M', 'm'@}
@example
RomanNumeralDigits* = @{'I', 'i', 'V', 'v', 'X', 'x', 'L', 'l', 'C', 'c', 'D', 'd', 'M', 'm'@}
@end example
  set of all characters a Roman numeral may consist of
@end itemize




@chapter Procedures

@itemize


@item romanToDecimal
  @findex proc romanToDecimal*(romanVal꞉ string)꞉ int
@example
proc romanToDecimal*(romanVal꞉ string)꞉ int
@end example
  Converts a Roman numeral to its int representation.

@item decimalToRoman
  @findex proc decimalToRoman*(number꞉ range[1 .. 3999])꞉ string
@example
proc decimalToRoman*(number꞉ range[1 .. 3999])꞉ string
@end example
  Converts a number to a Roman numeral.
@end itemize






@node /pure/streams, /pure/basic2d , /pure/romans, Top



@chapter Types

@itemize


@item StreamObj
  @tindex StreamObj* = object of RootObj
  closeImpl*: proc (s: Stream) @{.nimcall, tags: [], gcsafe.@}
  atEndImpl*: proc (s: Stream): bool @{.nimcall, tags: [], gcsafe.@}
  setPositionImpl*: proc (s: Stream; pos: int) @{.nimcall, tags: [], gcsafe.@}
  getPositionImpl*: proc (s: Stream): int @{.nimcall, tags: [], gcsafe.@}
  readDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int @{.nimcall,
      tags: [ReadIOEffect], gcsafe.@}
  peekDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int @{.nimcall,
      tags: [ReadIOEffect], gcsafe.@}
  writeDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int) @{.nimcall,
      tags: [WriteIOEffect], gcsafe.@}
  flushImpl*: proc (s: Stream) @{.nimcall, tags: [WriteIOEffect], gcsafe.@}

@example
StreamObj* = object of RootObj
  closeImpl*: proc (s: Stream) @{.nimcall, tags: [], gcsafe.@}
  atEndImpl*: proc (s: Stream): bool @{.nimcall, tags: [], gcsafe.@}
  setPositionImpl*: proc (s: Stream; pos: int) @{.nimcall, tags: [], gcsafe.@}
  getPositionImpl*: proc (s: Stream): int @{.nimcall, tags: [], gcsafe.@}
  readDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int @{.nimcall,
      tags: [ReadIOEffect], gcsafe.@}
  peekDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int): int @{.nimcall,
      tags: [ReadIOEffect], gcsafe.@}
  writeDataImpl*: proc (s: Stream; buffer: pointer; bufLen: int) @{.nimcall,
      tags: [WriteIOEffect], gcsafe.@}
  flushImpl*: proc (s: Stream) @{.nimcall, tags: [WriteIOEffect], gcsafe.@}

@end example
  Stream interface that supports writing or reading. Note that these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.

@item StringStreamObj
  @tindex StringStreamObj* = object of StreamObj
  data*: string
  pos: int

@example
StringStreamObj* = object of StreamObj
  data*: string
  pos: int

@end example
  

@item FileStreamObj
  @tindex FileStreamObj* = object of Streamf꞉ File
@example
FileStreamObj* = object of Streamf꞉ File
@end example
  
@end itemize

@chapter Procedures

@itemize


@item flush
  @findex proc flush*(s꞉ Stream)
@example
proc flush*(s꞉ Stream)
@end example
  flushes the buffers that the stream @emph{s} might use.

@item close
  @findex proc close*(s꞉ Stream)
@example
proc close*(s꞉ Stream)
@end example
  closes the stream @emph{s}.

@item close
  @findex proc close*(s, unused꞉ Stream) @{.deprecated.@}
@example
proc close*(s, unused꞉ Stream) @{.deprecated.@}
@end example
  closes the stream @emph{s}.

@item atEnd
  @findex proc atEnd*(s꞉ Stream)꞉ bool
@example
proc atEnd*(s꞉ Stream)꞉ bool
@end example
  checks if more data can be read from @emph{f}. Returns true if all data has been read.

@item atEnd
  @findex proc atEnd*(s, unused꞉ Stream)꞉ bool @{.deprecated.@}
@example
proc atEnd*(s, unused꞉ Stream)꞉ bool @{.deprecated.@}
@end example
  checks if more data can be read from @emph{f}. Returns true if all data has been read.

@item setPosition
  @findex proc setPosition*(s꞉ Stream; pos꞉ int)
@example
proc setPosition*(s꞉ Stream; pos꞉ int)
@end example
  sets the position @emph{pos} of the stream @emph{s}.

@item setPosition
  @findex proc setPosition*(s, unused꞉ Stream; pos꞉ int) @{.deprecated.@}
@example
proc setPosition*(s, unused꞉ Stream; pos꞉ int) @{.deprecated.@}
@end example
  sets the position @emph{pos} of the stream @emph{s}.

@item getPosition
  @findex proc getPosition*(s꞉ Stream)꞉ int
@example
proc getPosition*(s꞉ Stream)꞉ int
@end example
  retrieves the current position in the stream @emph{s}.

@item getPosition
  @findex proc getPosition*(s, unused꞉ Stream)꞉ int @{.deprecated.@}
@example
proc getPosition*(s, unused꞉ Stream)꞉ int @{.deprecated.@}
@end example
  retrieves the current position in the stream @emph{s}.

@item readData
  @findex proc readData*(s꞉ Stream; buffer꞉ pointer; bufLen꞉ int)꞉ int
@example
proc readData*(s꞉ Stream; buffer꞉ pointer; bufLen꞉ int)꞉ int
@end example
  low level proc that reads data into an untyped @emph{buffer} of @emph{bufLen} size.

@item readAll
  @findex proc readAll*(s꞉ Stream)꞉ string
@example
proc readAll*(s꞉ Stream)꞉ string
@end example
  Reads all available data.

@item readData
  @findex proc readData*(s, unused꞉ Stream; buffer꞉ pointer; bufLen꞉ int)꞉ int @{.deprecated.@}
@example
proc readData*(s, unused꞉ Stream; buffer꞉ pointer; bufLen꞉ int)꞉ int @{.deprecated.@}
@end example
  low level proc that reads data into an untyped @emph{buffer} of @emph{bufLen} size.

@item peekData
  @findex proc peekData*(s꞉ Stream; buffer꞉ pointer; bufLen꞉ int)꞉ int
@example
proc peekData*(s꞉ Stream; buffer꞉ pointer; bufLen꞉ int)꞉ int
@end example
  low level proc that reads data into an untyped @emph{buffer} of @emph{bufLen} size without moving stream position

@item writeData
  @findex proc writeData*(s꞉ Stream; buffer꞉ pointer; bufLen꞉ int)
@example
proc writeData*(s꞉ Stream; buffer꞉ pointer; bufLen꞉ int)
@end example
  low level proc that writes an untyped @emph{buffer} of @emph{bufLen} size to the stream @emph{s}.

@item writeData
  @findex proc writeData*(s, unused꞉ Stream; buffer꞉ pointer; bufLen꞉ int) @{.deprecated.@}
@example
proc writeData*(s, unused꞉ Stream; buffer꞉ pointer; bufLen꞉ int) @{.deprecated.@}
@end example
  low level proc that writes an untyped @emph{buffer} of @emph{bufLen} size to the stream @emph{s}.

@item write
  @findex proc write*[T](s꞉ Stream; x꞉ T)
@example
proc write*[T](s꞉ Stream; x꞉ T)
@end example
  generic write procedure. Writes @emph{x} to the stream @emph{s}. Implementation:
@example

s.writeData(s, addr(x), sizeof(x))
@end example

@item write
  @findex proc write*(s꞉ Stream; x꞉ string)
@example
proc write*(s꞉ Stream; x꞉ string)
@end example
  writes the string @emph{x} to the the stream @emph{s}. No length field or terminating zero is written.

@item writeLn
  @findex proc writeLn*(s꞉ Stream; args꞉ varargs[string, `$`]) @{.deprecated.@}
@example
proc writeLn*(s꞉ Stream; args꞉ varargs[string, `$`]) @{.deprecated.@}
@end example
  @strong{Deprecated since version 0.11.4:} Use @strong{writeLine} instead.

@item writeLine
  @findex proc writeLine*(s꞉ Stream; args꞉ varargs[string, `$`])
@example
proc writeLine*(s꞉ Stream; args꞉ varargs[string, `$`])
@end example
  writes one or more strings to the the stream @emph{s} followed by a new line. No length field or terminating zero is written.

@item readChar
  @findex proc readChar*(s꞉ Stream)꞉ char
@example
proc readChar*(s꞉ Stream)꞉ char
@end example
  reads a char from the stream @emph{s}. Raises @emph{EIO} if an error occurred. Returns '0' as an EOF marker.

@item peekChar
  @findex proc peekChar*(s꞉ Stream)꞉ char
@example
proc peekChar*(s꞉ Stream)꞉ char
@end example
  peeks a char from the stream @emph{s}. Raises @emph{EIO} if an error occurred. Returns '0' as an EOF marker.

@item readBool
  @findex proc readBool*(s꞉ Stream)꞉ bool
@example
proc readBool*(s꞉ Stream)꞉ bool
@end example
  reads a bool from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekBool
  @findex proc peekBool*(s꞉ Stream)꞉ bool
@example
proc peekBool*(s꞉ Stream)꞉ bool
@end example
  peeks a bool from the stream @emph{s}. Raises @emph{EIO} if an error occured.

@item readInt8
  @findex proc readInt8*(s꞉ Stream)꞉ int8
@example
proc readInt8*(s꞉ Stream)꞉ int8
@end example
  reads an int8 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekInt8
  @findex proc peekInt8*(s꞉ Stream)꞉ int8
@example
proc peekInt8*(s꞉ Stream)꞉ int8
@end example
  peeks an int8 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item readInt16
  @findex proc readInt16*(s꞉ Stream)꞉ int16
@example
proc readInt16*(s꞉ Stream)꞉ int16
@end example
  reads an int16 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekInt16
  @findex proc peekInt16*(s꞉ Stream)꞉ int16
@example
proc peekInt16*(s꞉ Stream)꞉ int16
@end example
  peeks an int16 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item readInt32
  @findex proc readInt32*(s꞉ Stream)꞉ int32
@example
proc readInt32*(s꞉ Stream)꞉ int32
@end example
  reads an int32 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekInt32
  @findex proc peekInt32*(s꞉ Stream)꞉ int32
@example
proc peekInt32*(s꞉ Stream)꞉ int32
@end example
  peeks an int32 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item readInt64
  @findex proc readInt64*(s꞉ Stream)꞉ int64
@example
proc readInt64*(s꞉ Stream)꞉ int64
@end example
  reads an int64 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekInt64
  @findex proc peekInt64*(s꞉ Stream)꞉ int64
@example
proc peekInt64*(s꞉ Stream)꞉ int64
@end example
  peeks an int64 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item readFloat32
  @findex proc readFloat32*(s꞉ Stream)꞉ float32
@example
proc readFloat32*(s꞉ Stream)꞉ float32
@end example
  reads a float32 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekFloat32
  @findex proc peekFloat32*(s꞉ Stream)꞉ float32
@example
proc peekFloat32*(s꞉ Stream)꞉ float32
@end example
  peeks a float32 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item readFloat64
  @findex proc readFloat64*(s꞉ Stream)꞉ float64
@example
proc readFloat64*(s꞉ Stream)꞉ float64
@end example
  reads a float64 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekFloat64
  @findex proc peekFloat64*(s꞉ Stream)꞉ float64
@example
proc peekFloat64*(s꞉ Stream)꞉ float64
@end example
  peeks a float64 from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item readStr
  @findex proc readStr*(s꞉ Stream; length꞉ int)꞉ TaintedString
@example
proc readStr*(s꞉ Stream; length꞉ int)꞉ TaintedString
@end example
  reads a string of length @emph{length} from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item peekStr
  @findex proc peekStr*(s꞉ Stream; length꞉ int)꞉ TaintedString
@example
proc peekStr*(s꞉ Stream; length꞉ int)꞉ TaintedString
@end example
  peeks a string of length @emph{length} from the stream @emph{s}. Raises @emph{EIO} if an error occurred.

@item readLine
  @findex proc readLine*(s꞉ Stream; line꞉ var TaintedString)꞉ bool
@example
proc readLine*(s꞉ Stream; line꞉ var TaintedString)꞉ bool
@end example
  reads a line of text from the stream @emph{s} into @emph{line}. @emph{line} must not be @code{nil}! May throw an IO exception. A line of text may be delimited by @code{CR}, @code{LF} or @code{CRLF}. The newline character(s) are not part of the returned string. Returns @code{false} if the end of the file has been reached, @code{true} otherwise. If @code{false} is returned @emph{line} contains no new data.

@item peekLine
  @findex proc peekLine*(s꞉ Stream; line꞉ var TaintedString)꞉ bool
@example
proc peekLine*(s꞉ Stream; line꞉ var TaintedString)꞉ bool
@end example
  peeks a line of text from the stream @emph{s} into @emph{line}. @emph{line} must not be @code{nil}! May throw an IO exception. A line of text may be delimited by @code{CR}, @code{LF} or @code{CRLF}. The newline character(s) are not part of the returned string. Returns @code{false} if the end of the file has been reached, @code{true} otherwise. If @code{false} is returned @emph{line} contains no new data.

@item readLine
  @findex proc readLine*(s꞉ Stream)꞉ TaintedString
@example
proc readLine*(s꞉ Stream)꞉ TaintedString
@end example
  Reads a line from a stream @emph{s}. Note: This is not very efficient. Raises @emph{EIO} if an error occurred.

@item peekLine
  @findex proc peekLine*(s꞉ Stream)꞉ TaintedString
@example
proc peekLine*(s꞉ Stream)꞉ TaintedString
@end example
  Peeks a line from a stream @emph{s}. Note: This is not very efficient. Raises @emph{EIO} if an error occurred.

@item newStringStream
  @findex proc newStringStream*(s꞉ string = "")꞉ StringStream
@example
proc newStringStream*(s꞉ string = "")꞉ StringStream
@end example
  creates a new stream from the string @emph{s}.

@item newFileStream
  @findex proc newFileStream*(f꞉ File)꞉ FileStream
@example
proc newFileStream*(f꞉ File)꞉ FileStream
@end example
  creates a new stream from the file @emph{f}.

@item newFileStream
  @findex proc newFileStream*(filename꞉ string; mode꞉ FileMode = fmRead)꞉ FileStream
@example
proc newFileStream*(filename꞉ string; mode꞉ FileMode = fmRead)꞉ FileStream
@end example
  creates a new stream from the file named @emph{filename} with the mode @emph{mode}. If the file cannot be opened, nil is returned. See the @uref{system.html, system} module for a list of available FileMode enums.
@end itemize






@node /pure/basic2d, /pure/unicode , /pure/streams, Top

@chapter Let variable

@itemize


@item YAXIS
  @vindex YAXIS*꞉ Vector2d = vector2d(0.0'f64, 1.0'f64)
@example
YAXIS*꞉ Vector2d = vector2d(0.0'f64, 1.0'f64)
@end example
  Quick access to an 2d y-axis unit vector
@end itemize


@chapter Types

@itemize


@item Vector2d
  @tindex Vector2d* = objectx*, y*꞉ float
@example
Vector2d* = objectx*, y*꞉ float
@end example
  Implements a 2d @strong{direction vector} stored as an @emph{x} coordinate and an @emph{y} coordinate. Direction vector means, that when transforming a vector with a matrix, the translational part of the matrix is ignored.
@end itemize

@chapter Procedures

@itemize


@item matrix2d
  @findex proc matrix2d*(ax, ay, bx, by, tx, ty꞉ float)꞉ Matrix2d @{.noInit.@}
@example
proc matrix2d*(ax, ay, bx, by, tx, ty꞉ float)꞉ Matrix2d @{.noInit.@}
@end example
  Creates a new matrix. @emph{ax},`ay` is the local x axis @emph{bx},`by` is the local y axis @emph{tx},`ty` is the translation

@item vector2d
  @findex proc vector2d*(x, y꞉ float)꞉ Vector2d @{.noInit, inline.@}
@example
proc vector2d*(x, y꞉ float)꞉ Vector2d @{.noInit, inline.@}
@end example
  Returns a new vector (@emph{x},`y`)

@item point2d
  @findex proc point2d*(x, y꞉ float)꞉ Point2d @{.noInit, inline.@}
@example
proc point2d*(x, y꞉ float)꞉ Point2d @{.noInit, inline.@}
@end example
  Returns a new point (@emph{x},`y`)

@item setElements
  @findex proc setElements*(t꞉ var Matrix2d; ax, ay, bx, by, tx, ty꞉ float) @{.inline.@}
@example
proc setElements*(t꞉ var Matrix2d; ax, ay, bx, by, tx, ty꞉ float) @{.inline.@}
@end example
  Sets arbitrary elements in an existing matrix.

@item matrix2d
  @findex proc matrix2d*(ax, ay, bx, by, tx, ty꞉ float)꞉ Matrix2d
@example
proc matrix2d*(ax, ay, bx, by, tx, ty꞉ float)꞉ Matrix2d
@end example
  

@item `&`
  @findex proc `&`*(a, b꞉ Matrix2d)꞉ Matrix2d @{.noInit.@}
@example
proc `&`*(a, b꞉ Matrix2d)꞉ Matrix2d @{.noInit.@}
@end example
  Concatenates matrices returning a new matrix.

@item scale
  @findex proc scale*(s꞉ float)꞉ Matrix2d @{.noInit.@}
@example
proc scale*(s꞉ float)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new scale matrix.

@item scale
  @findex proc scale*(s꞉ float; org꞉ Point2d)꞉ Matrix2d @{.noInit.@}
@example
proc scale*(s꞉ float; org꞉ Point2d)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new scale matrix using, @emph{org} as scale origin.

@item stretch
  @findex proc stretch*(sx, sy꞉ float)꞉ Matrix2d @{.noInit.@}
@example
proc stretch*(sx, sy꞉ float)꞉ Matrix2d @{.noInit.@}
@end example
  Returns new a stretch matrix, which is a scale matrix with non uniform scale in x and y.

@item stretch
  @findex proc stretch*(sx, sy꞉ float; org꞉ Point2d)꞉ Matrix2d @{.noInit.@}
@example
proc stretch*(sx, sy꞉ float; org꞉ Point2d)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new stretch matrix, which is a scale matrix with non uniform scale in x and y. @emph{org} is used as stretch origin.

@item move
  @findex proc move*(dx, dy꞉ float)꞉ Matrix2d @{.noInit.@}
@example
proc move*(dx, dy꞉ float)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new translation matrix.

@item move
  @findex proc move*(v꞉ Vector2d)꞉ Matrix2d @{.noInit.@}
@example
proc move*(v꞉ Vector2d)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new translation matrix from a vector.

@item rotate
  @findex proc rotate*(rad꞉ float)꞉ Matrix2d @{.noInit.@}
@example
proc rotate*(rad꞉ float)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new rotation matrix, which represents a rotation by @emph{rad} radians

@item rotate
  @findex proc rotate*(rad꞉ float; org꞉ Point2d)꞉ Matrix2d @{.noInit.@}
@example
proc rotate*(rad꞉ float; org꞉ Point2d)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new rotation matrix, which represents a rotation by @emph{rad} radians around the origin @emph{org}

@item mirror
  @findex proc mirror*(v꞉ Vector2d)꞉ Matrix2d @{.noInit.@}
@example
proc mirror*(v꞉ Vector2d)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new mirror matrix, mirroring around the line that passes through origo and has the direction of @emph{v}

@item mirror
  @findex proc mirror*(org꞉ Point2d; v꞉ Vector2d)꞉ Matrix2d @{.noInit.@}
@example
proc mirror*(org꞉ Point2d; v꞉ Vector2d)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new mirror matrix, mirroring around the line that passes through @emph{org} and has the direction of @emph{v}

@item skew
  @findex proc skew*(xskew, yskew꞉ float)꞉ Matrix2d @{.noInit.@}
@example
proc skew*(xskew, yskew꞉ float)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new skew matrix, which has its x axis rotated @emph{xskew} radians from the local x axis, and y axis rotated @emph{yskew} radians from the local y axis

@item `$`
  @findex proc `$`*(t꞉ Matrix2d)꞉ string @{.noInit.@}
@example
proc `$`*(t꞉ Matrix2d)꞉ string @{.noInit.@}
@end example
  Returns a string representation of the matrix

@item isUniform
  @findex proc isUniform*(t꞉ Matrix2d; tol = 1e-06'f64)꞉ bool
@example
proc isUniform*(t꞉ Matrix2d; tol = 1e-06'f64)꞉ bool
@end example
  Checks if the transform is uniform, that is perpendicular axes of equal length, which means (for example) it cannot transform a circle into an ellipse. @emph{tol} is used as tolerance for both equal length comparison and perp. comparison.

@item determinant
  @findex proc determinant*(t꞉ Matrix2d)꞉ float
@example
proc determinant*(t꞉ Matrix2d)꞉ float
@end example
  Computes the determinant of the matrix.

@item isMirroring
  @findex proc isMirroring*(m꞉ Matrix2d)꞉ bool
@example
proc isMirroring*(m꞉ Matrix2d)꞉ bool
@end example
  Checks if the @emph{m} is a mirroring matrix, which means it will reverse direction of a curve transformed with it

@item inverse
  @findex proc inverse*(m꞉ Matrix2d)꞉ Matrix2d @{.noInit.@}
@example
proc inverse*(m꞉ Matrix2d)꞉ Matrix2d @{.noInit.@}
@end example
  Returns a new matrix, which is the inverse of the matrix If the matrix is not invertible (determinant=0), an EDivByZero will be raised.

@item equals
  @findex proc equals*(m1꞉ Matrix2d; m2꞉ Matrix2d; tol = 1e-06'f64)꞉ bool
@example
proc equals*(m1꞉ Matrix2d; m2꞉ Matrix2d; tol = 1e-06'f64)꞉ bool
@end example
  Checks if all elements of @emph{m1`and `m2} is equal within a given tolerance @emph{tol}.

@item `=~`
  @findex proc `=~`*(m1, m2꞉ Matrix2d)꞉ bool
@example
proc `=~`*(m1, m2꞉ Matrix2d)꞉ bool
@end example
  Checks if @emph{m1`and `m2} is approximately equal, using a tolerance of 1e-6.

@item isIdentity
  @findex proc isIdentity*(m꞉ Matrix2d; tol = 1e-06'f64)꞉ bool
@example
proc isIdentity*(m꞉ Matrix2d; tol = 1e-06'f64)꞉ bool
@end example
  Checks is a matrix is approximately an identity matrix, using @emph{tol} as tolerance for each element.

@item apply
  @findex proc apply*(m꞉ Matrix2d; x, y꞉ var float; translate = false)
@example
proc apply*(m꞉ Matrix2d; x, y꞉ var float; translate = false)
@end example
  Applies transformation @emph{m} onto @emph{x},`y`, optionally using the translation part of the matrix.

@item vector2d
  @findex proc vector2d*(x, y꞉ float)꞉ Vector2d
@example
proc vector2d*(x, y꞉ float)꞉ Vector2d
@end example
  

@item polarVector2d
  @findex proc polarVector2d*(ang꞉ float; len꞉ float)꞉ Vector2d @{.noInit.@}
@example
proc polarVector2d*(ang꞉ float; len꞉ float)꞉ Vector2d @{.noInit.@}
@end example
  Returns a new vector with angle @emph{ang} and magnitude @emph{len}

@item slopeVector2d
  @findex proc slopeVector2d*(slope꞉ float; len꞉ float)꞉ Vector2d @{.noInit.@}
@example
proc slopeVector2d*(slope꞉ float; len꞉ float)꞉ Vector2d @{.noInit.@}
@end example
  Returns a new vector having slope (dy/dx) given by @emph{slope}, and a magnitude of @emph{len}

@item len
  @findex proc len*(v꞉ Vector2d)꞉ float @{.inline.@}
@example
proc len*(v꞉ Vector2d)꞉ float @{.inline.@}
@end example
  Returns the length of the vector.

@item `len=`
  @findex proc `len =`*(v꞉ var Vector2d; newlen꞉ float) @{.noInit.@}
@example
proc `len =`*(v꞉ var Vector2d; newlen꞉ float) @{.noInit.@}
@end example
  Sets the length of the vector, keeping its angle.

@item sqrLen
  @findex proc sqrLen*(v꞉ Vector2d)꞉ float @{.inline.@}
@example
proc sqrLen*(v꞉ Vector2d)꞉ float @{.inline.@}
@end example
  Computes the squared length of the vector, which is faster than computing the absolute length.

@item angle
  @findex proc angle*(v꞉ Vector2d)꞉ float
@example
proc angle*(v꞉ Vector2d)꞉ float
@end example
  Returns the angle of the vector. (The counter clockwise plane angle between posetive x axis and @emph{v})

@item `$`
  @findex proc `$`*(v꞉ Vector2d)꞉ string
@example
proc `$`*(v꞉ Vector2d)꞉ string
@end example
  String representation of @emph{v}

@item `&`
  @findex proc `&`*(v꞉ Vector2d; m꞉ Matrix2d)꞉ Vector2d @{.noInit.@}
@example
proc `&`*(v꞉ Vector2d; m꞉ Matrix2d)꞉ Vector2d @{.noInit.@}
@end example
  Concatenate vector @emph{v} with a transformation matrix. Transforming a vector ignores the translational part of the matrix.

@item `&=`
  @findex proc `&=`*(v꞉ var Vector2d; m꞉ Matrix2d) @{.inline.@}
@example
proc `&=`*(v꞉ var Vector2d; m꞉ Matrix2d) @{.inline.@}
@end example
  Applies transformation @emph{m} onto @emph{v} in place. Transforming a vector ignores the translational part of the matrix.

@item tryNormalize
  @findex proc tryNormalize*(v꞉ var Vector2d)꞉ bool
@example
proc tryNormalize*(v꞉ var Vector2d)꞉ bool
@end example
  Modifies @emph{v} to have a length of 1.0, keeping its angle. If @emph{v} has zero length (and thus no angle), it is left unmodified and false is returned, otherwise true is returned.

@item normalize
  @findex proc normalize*(v꞉ var Vector2d) @{.inline.@}
@example
proc normalize*(v꞉ var Vector2d) @{.inline.@}
@end example
  Modifies @emph{v} to have a length of 1.0, keeping its angle. If  @emph{v} has zero length, an EDivByZero will be raised.

@item transformNorm
  @findex proc transformNorm*(v꞉ var Vector2d; t꞉ Matrix2d)
@example
proc transformNorm*(v꞉ var Vector2d; t꞉ Matrix2d)
@end example
  Applies a normal direction transformation @emph{t} onto @emph{v} in place. The resulting vector is @emph{not} normalized.  Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.

@item transformInv
  @findex proc transformInv*(v꞉ var Vector2d; t꞉ Matrix2d)
@example
proc transformInv*(v꞉ var Vector2d; t꞉ Matrix2d)
@end example
  Applies inverse of a transformation @emph{t} to @emph{v} in place. This is faster than creating an inverse matrix and apply() it. Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.

@item transformNormInv
  @findex proc transformNormInv*(v꞉ var Vector2d; t꞉ Matrix2d)
@example
proc transformNormInv*(v꞉ var Vector2d; t꞉ Matrix2d)
@end example
  Applies an inverse normal direction transformation @emph{t} onto @emph{v} in place. This is faster than creating an inverse matrix and transformNorm(...) it. Transforming a vector ignores the translational part of the matrix.

@item rotate90
  @findex proc rotate90*(v꞉ var Vector2d) @{.inline.@}
@example
proc rotate90*(v꞉ var Vector2d) @{.inline.@}
@end example
  Quickly rotates vector @emph{v} 90 degrees counter clockwise, without using any trigonometrics.

@item rotate180
  @findex proc rotate180*(v꞉ var Vector2d) @{.inline.@}
@example
proc rotate180*(v꞉ var Vector2d) @{.inline.@}
@end example
  Quickly rotates vector @emph{v} 180 degrees counter clockwise, without using any trigonometrics.

@item rotate270
  @findex proc rotate270*(v꞉ var Vector2d) @{.inline.@}
@example
proc rotate270*(v꞉ var Vector2d) @{.inline.@}
@end example
  Quickly rotates vector @emph{v} 270 degrees counter clockwise, without using any trigonometrics.

@item rotate
  @findex proc rotate*(v꞉ var Vector2d; rad꞉ float)
@example
proc rotate*(v꞉ var Vector2d; rad꞉ float)
@end example
  Rotates vector @emph{v} @emph{rad} radians in place.

@item scale
  @findex proc scale*(v꞉ var Vector2d; fac꞉ float) @{.inline.@}
@example
proc scale*(v꞉ var Vector2d; fac꞉ float) @{.inline.@}
@end example
  Scales vector @emph{v} @emph{rad} radians in place.

@item stretch
  @findex proc stretch*(v꞉ var Vector2d; facx, facy꞉ float) @{.inline.@}
@example
proc stretch*(v꞉ var Vector2d; facx, facy꞉ float) @{.inline.@}
@end example
  Stretches vector @emph{v} @emph{facx} times horizontally, and @emph{facy} times vertically.

@item mirror
  @findex proc mirror*(v꞉ var Vector2d; mirrvec꞉ Vector2d)
@example
proc mirror*(v꞉ var Vector2d; mirrvec꞉ Vector2d)
@end example
  Mirrors vector @emph{v} using @emph{mirrvec} as mirror direction.

@item `-`
  @findex proc `-`*(v꞉ Vector2d)꞉ Vector2d
@example
proc `-`*(v꞉ Vector2d)꞉ Vector2d
@end example
  Negates a vector

@item dot
  @findex proc dot*(v1, v2꞉ Vector2d)꞉ float
@example
proc dot*(v1, v2꞉ Vector2d)꞉ float
@end example
  Computes the dot product of two vectors. Returns 0.0 if the vectors are perpendicular.

@item cross
  @findex proc cross*(v1, v2꞉ Vector2d)꞉ float
@example
proc cross*(v1, v2꞉ Vector2d)꞉ float
@end example
  Computes the cross product of two vectors, also called the 'perpendicular dot product' in 2d. Returns 0.0 if the vectors are parallel.

@item equals
  @findex proc equals*(v1, v2꞉ Vector2d; tol = 1e-06'f64)꞉ bool
@example
proc equals*(v1, v2꞉ Vector2d; tol = 1e-06'f64)꞉ bool
@end example
  Checks if two vectors approximately equals with a tolerance.

@item `=~`
  @findex proc `=~`*(v1, v2꞉ Vector2d)꞉ bool
@example
proc `=~`*(v1, v2꞉ Vector2d)꞉ bool
@end example
  Checks if two vectors approximately equals with a hardcoded tolerance 1e-6

@item angleTo
  @findex proc angleTo*(v1, v2꞉ Vector2d)꞉ float
@example
proc angleTo*(v1, v2꞉ Vector2d)꞉ float
@end example
  Returns the smallest of the two possible angles between @emph{v1} and @emph{v2} in radians.

@item angleCCW
  @findex proc angleCCW*(v1, v2꞉ Vector2d)꞉ float
@example
proc angleCCW*(v1, v2꞉ Vector2d)꞉ float
@end example
  Returns the counter clockwise plane angle from @emph{v1} to @emph{v2}, in range 0 - 2*PI

@item angleCW
  @findex proc angleCW*(v1, v2꞉ Vector2d)꞉ float
@example
proc angleCW*(v1, v2꞉ Vector2d)꞉ float
@end example
  Returns the clockwise plane angle from @emph{v1} to @emph{v2}, in range 0 - 2*PI

@item turnAngle
  @findex proc turnAngle*(v1, v2꞉ Vector2d)꞉ float
@example
proc turnAngle*(v1, v2꞉ Vector2d)꞉ float
@end example
  Returns the amount v1 should be rotated (in radians) to equal v2, in range -PI to PI

@item bisect
  @findex proc bisect*(v1, v2꞉ Vector2d)꞉ Vector2d @{.noInit.@}
@example
proc bisect*(v1, v2꞉ Vector2d)꞉ Vector2d @{.noInit.@}
@end example
  Computes the bisector between v1 and v2 as a normalized vector. If one of the input vectors has zero length, a normalized version of the other is returned. If both input vectors has zero length, an arbitrary normalized vector is returned.

@item point2d
  @findex proc point2d*(x, y꞉ float)꞉ Point2d
@example
proc point2d*(x, y꞉ float)꞉ Point2d
@end example
  

@item sqrDist
  @findex proc sqrDist*(a, b꞉ Point2d)꞉ float
@example
proc sqrDist*(a, b꞉ Point2d)꞉ float
@end example
  Computes the squared distance between @emph{a} and @emph{b}

@item dist
  @findex proc dist*(a, b꞉ Point2d)꞉ float @{.inline.@}
@example
proc dist*(a, b꞉ Point2d)꞉ float @{.inline.@}
@end example
  Computes the absolute distance between @emph{a} and @emph{b}

@item angle
  @findex proc angle*(a, b꞉ Point2d)꞉ float
@example
proc angle*(a, b꞉ Point2d)꞉ float
@end example
  Computes the angle of the vector @emph{b}-@emph{a}

@item `$`
  @findex proc `$`*(p꞉ Point2d)꞉ string
@example
proc `$`*(p꞉ Point2d)꞉ string
@end example
  String representation of @emph{p}

@item `&`
  @findex proc `&`*(p꞉ Point2d; t꞉ Matrix2d)꞉ Point2d @{.noInit, inline.@}
@example
proc `&`*(p꞉ Point2d; t꞉ Matrix2d)꞉ Point2d @{.noInit, inline.@}
@end example
  Concatenates a point @emph{p} with a transform @emph{t}, resulting in a new, transformed point.

@item `&=`
  @findex proc `&=`*(p꞉ var Point2d; t꞉ Matrix2d) @{.inline.@}
@example
proc `&=`*(p꞉ var Point2d; t꞉ Matrix2d) @{.inline.@}
@end example
  Applies transformation @emph{t} onto @emph{p} in place.

@item transformInv
  @findex proc transformInv*(p꞉ var Point2d; t꞉ Matrix2d) @{.inline.@}
@example
proc transformInv*(p꞉ var Point2d; t꞉ Matrix2d) @{.inline.@}
@end example
  Applies the inverse of transformation @emph{t} onto @emph{p} in place. If the matrix is not invertable (determinant=0) , EDivByZero will be raised.

@item `+`
  @findex proc `+`*(p꞉ Point2d; v꞉ Vector2d)꞉ Point2d @{.noInit, inline.@}
@example
proc `+`*(p꞉ Point2d; v꞉ Vector2d)꞉ Point2d @{.noInit, inline.@}
@end example
  Adds a vector @emph{v} to a point @emph{p}, resulting in a new point.

@item `+=`
  @findex proc `+=`*(p꞉ var Point2d; v꞉ Vector2d) @{.noInit, inline.@}
@example
proc `+=`*(p꞉ var Point2d; v꞉ Vector2d) @{.noInit, inline.@}
@end example
  Adds a vector @emph{v} to a point @emph{p} in place.

@item `-`
  @findex proc `-`*(p꞉ Point2d; v꞉ Vector2d)꞉ Point2d @{.noInit, inline.@}
@example
proc `-`*(p꞉ Point2d; v꞉ Vector2d)꞉ Point2d @{.noInit, inline.@}
@end example
  Subtracts a vector @emph{v} from a point @emph{p}, resulting in a new point.

@item `-`
  @findex proc `-`*(p1, p2꞉ Point2d)꞉ Vector2d @{.noInit, inline.@}
@example
proc `-`*(p1, p2꞉ Point2d)꞉ Vector2d @{.noInit, inline.@}
@end example
  Subtracts @emph{p2`from `p1} resulting in a difference vector.

@item `-=`
  @findex proc `-=`*(p꞉ var Point2d; v꞉ Vector2d) @{.noInit, inline.@}
@example
proc `-=`*(p꞉ var Point2d; v꞉ Vector2d) @{.noInit, inline.@}
@end example
  Subtracts a vector @emph{v} from a point @emph{p} in place.

@item `=~`
  @findex proc `=~`*(p1, p2꞉ Point2d)꞉ bool @{.inline.@}
@example
proc `=~`*(p1, p2꞉ Point2d)꞉ bool @{.inline.@}
@end example
  Checks if two vectors approximately equals with a hardcoded tolerance 1e-6

@item polar
  @findex proc polar*(p꞉ Point2d; ang, dist꞉ float)꞉ Point2d @{.noInit.@}
@example
proc polar*(p꞉ Point2d; ang, dist꞉ float)꞉ Point2d @{.noInit.@}
@end example
  Returns a point with a given angle and distance away from @emph{p}

@item rotate
  @findex proc rotate*(p꞉ var Point2d; rad꞉ float)
@example
proc rotate*(p꞉ var Point2d; rad꞉ float)
@end example
  Rotates a point in place @emph{rad} radians around origo.

@item rotate
  @findex proc rotate*(p꞉ var Point2d; rad꞉ float; org꞉ Point2d)
@example
proc rotate*(p꞉ var Point2d; rad꞉ float; org꞉ Point2d)
@end example
  Rotates a point in place @emph{rad} radians using @emph{org} as center of rotation.

@item scale
  @findex proc scale*(p꞉ var Point2d; fac꞉ float) @{.inline.@}
@example
proc scale*(p꞉ var Point2d; fac꞉ float) @{.inline.@}
@end example
  Scales a point in place @emph{fac} times with world origo as origin.

@item scale
  @findex proc scale*(p꞉ var Point2d; fac꞉ float; org꞉ Point2d) @{.inline.@}
@example
proc scale*(p꞉ var Point2d; fac꞉ float; org꞉ Point2d) @{.inline.@}
@end example
  Scales the point in place @emph{fac} times with @emph{org} as origin.

@item stretch
  @findex proc stretch*(p꞉ var Point2d; facx, facy꞉ float) @{.inline.@}
@example
proc stretch*(p꞉ var Point2d; facx, facy꞉ float) @{.inline.@}
@end example
  Scales a point in place non uniformly @emph{facx} and @emph{facy} times with world origo as origin.

@item stretch
  @findex proc stretch*(p꞉ var Point2d; facx, facy꞉ float; org꞉ Point2d) @{.inline.@}
@example
proc stretch*(p꞉ var Point2d; facx, facy꞉ float; org꞉ Point2d) @{.inline.@}
@end example
  Scales the point in place non uniformly @emph{facx} and @emph{facy} times with @emph{org} as origin.

@item move
  @findex proc move*(p꞉ var Point2d; dx, dy꞉ float) @{.inline.@}
@example
proc move*(p꞉ var Point2d; dx, dy꞉ float) @{.inline.@}
@end example
  Translates a point @emph{dx}, @emph{dy} in place.

@item move
  @findex proc move*(p꞉ var Point2d; v꞉ Vector2d) @{.inline.@}
@example
proc move*(p꞉ var Point2d; v꞉ Vector2d) @{.inline.@}
@end example
  Translates a point with vector @emph{v} in place.

@item sgnArea
  @findex proc sgnArea*(a, b, c꞉ Point2d)꞉ float
@example
proc sgnArea*(a, b, c꞉ Point2d)꞉ float
@end example
  Computes the signed area of the triangle thru points @emph{a},`b` and @emph{c} result>0.0 for counter clockwise triangle result<0.0 for clockwise triangle This is commonly used to determinate side of a point with respect to a line.

@item area
  @findex proc area*(a, b, c꞉ Point2d)꞉ float
@example
proc area*(a, b, c꞉ Point2d)꞉ float
@end example
  Computes the area of the triangle thru points @emph{a},`b` and @emph{c}

@item closestPoint
  @findex proc closestPoint*(p꞉ Point2d; pts꞉ varargs[Point2d])꞉ Point2d
@example
proc closestPoint*(p꞉ Point2d; pts꞉ varargs[Point2d])꞉ Point2d
@end example
  Returns a point selected from @emph{pts}, that has the closest euclidean distance to @emph{p}

@item normAngle
  @findex proc normAngle*(ang꞉ float)꞉ float
@example
proc normAngle*(ang꞉ float)꞉ float
@end example
  Returns an angle in radians, that is equal to @emph{ang}, but in the range 0 to <2*PI

@item degToRad
  @findex proc degToRad*(deg꞉ float)꞉ float @{.inline.@}
@example
proc degToRad*(deg꞉ float)꞉ float @{.inline.@}
@end example
  converts @emph{deg} degrees to radians

@item radToDeg
  @findex proc radToDeg*(rad꞉ float)꞉ float @{.inline.@}
@example
proc radToDeg*(rad꞉ float)꞉ float @{.inline.@}
@end example
  converts @emph{rad} radians to degrees
@end itemize






@node /pure/unicode, /pure/net , /pure/basic2d, Top



@chapter Types

@itemize


@item Rune16
  @tindex Rune16* = distinct int16
@example
Rune16* = distinct int16
@end example
  16 bit Unicode character
@end itemize

@chapter Procedures

@itemize


@item `<=%`
  @findex proc `<=%`*(a, b꞉ Rune)꞉ bool
@example
proc `<=%`*(a, b꞉ Rune)꞉ bool
@end example
  

@item `<%`
  @findex proc `<%`*(a, b꞉ Rune)꞉ bool
@example
proc `<%`*(a, b꞉ Rune)꞉ bool
@end example
  

@item `==`
  @findex proc `==`*(a, b꞉ Rune)꞉ bool
@example
proc `==`*(a, b꞉ Rune)꞉ bool
@end example
  

@item runeLen
  @findex proc runeLen*(s꞉ string)꞉ int @{.rtl, extern꞉ "nuc$1".@}
@example
proc runeLen*(s꞉ string)꞉ int @{.rtl, extern꞉ "nuc$1".@}
@end example
  Returns the number of Unicode characters of the string @code{s}

@item runeLenAt
  @findex proc runeLenAt*(s꞉ string; i꞉ Natural)꞉ int
@example
proc runeLenAt*(s꞉ string; i꞉ Natural)꞉ int
@end example
  Returns the number of bytes the rune starting at @code{s[i]} takes

@item validateUtf8
  @findex proc validateUtf8*(s꞉ string)꞉ int
@example
proc validateUtf8*(s꞉ string)꞉ int
@end example
  Returns the position of the invalid byte in @code{s} if the string @code{s} does not hold valid UTF-8 data. Otherwise @code{-1} is returned.

@item runeAt
  @findex proc runeAt*(s꞉ string; i꞉ Natural)꞉ Rune
@example
proc runeAt*(s꞉ string; i꞉ Natural)꞉ Rune
@end example
  Returns the unicode character in @code{s} at byte index @code{i}

@item toUTF8
  @findex proc toUTF8*(c꞉ Rune)꞉ string @{.rtl, extern꞉ "nuc$1".@}
@example
proc toUTF8*(c꞉ Rune)꞉ string @{.rtl, extern꞉ "nuc$1".@}
@end example
  Converts a rune into its UTF-8 representation

@item `$`
  @findex proc `$`*(rune꞉ Rune)꞉ string
@example
proc `$`*(rune꞉ Rune)꞉ string
@end example
  Converts a Rune to a string

@item `$`
  @findex proc `$`*(runes꞉ seq[Rune])꞉ string
@example
proc `$`*(runes꞉ seq[Rune])꞉ string
@end example
  Converts a sequence of Runes to a string

@item toLower
  @findex proc toLower*(c꞉ Rune)꞉ Rune @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc toLower*(c꞉ Rune)꞉ Rune @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Converts @code{c} into lower case. This works for any Unicode character. If possible, prefer @code{toLower} over @code{toUpper}.

@item toUpper
  @findex proc toUpper*(c꞉ Rune)꞉ Rune @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc toUpper*(c꞉ Rune)꞉ Rune @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Converts @code{c} into upper case. This works for any Unicode character. If possible, prefer @code{toLower} over @code{toUpper}.

@item toTitle
  @findex proc toTitle*(c꞉ Rune)꞉ Rune @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc toTitle*(c꞉ Rune)꞉ Rune @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Converts @code{c} to title case

@item isLower
  @findex proc isLower*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc isLower*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Returns true iff @code{c} is a lower case Unicode character. If possible, prefer @code{isLower} over @code{isUpper}.

@item isUpper
  @findex proc isUpper*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc isUpper*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Returns true iff @code{c} is a upper case Unicode character. If possible, prefer @code{isLower} over @code{isUpper}.

@item isAlpha
  @findex proc isAlpha*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc isAlpha*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Returns true iff @code{c} is an @emph{alpha} Unicode character (i.e., a letter)

@item isTitle
  @findex proc isTitle*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc isTitle*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Returns true iff @code{c} is a Unicode titlecase character

@item isWhiteSpace
  @findex proc isWhiteSpace*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc isWhiteSpace*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Returns true iff @code{c} is a Unicode whitespace character

@item isCombining
  @findex proc isCombining*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc isCombining*(c꞉ Rune)꞉ bool @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Returns true iff @code{c} is a Unicode combining character

@item toRunes
  @findex proc toRunes*(s꞉ string)꞉ seq[Rune]
@example
proc toRunes*(s꞉ string)꞉ seq[Rune]
@end example
  Obtains a sequence containing the Runes in @code{s}

@item cmpRunesIgnoreCase
  @findex proc cmpRunesIgnoreCase*(a, b꞉ string)꞉ int @{.rtl, extern꞉ "nuc$1", procvar.@}
@example
proc cmpRunesIgnoreCase*(a, b꞉ string)꞉ int @{.rtl, extern꞉ "nuc$1", procvar.@}
@end example
  Compares two UTF-8 strings and ignores the case. Returns:0 iff a == b\\
< 0 iff a < b\\
> 0 iff a > b\\

@item reversed
  @findex proc reversed*(s꞉ string)꞉ string
@example
proc reversed*(s꞉ string)꞉ string
@end example
  Returns the reverse of @code{s}, interpreting it as Unicode characters. Unicode combining characters are correctly interpreted as well:
@example

assert reversed("Reverse this!") == "!siht esreveR"
assert reversed("先秦兩漢") == "漢兩秦先"
assert reversed("as⃝df̅") == "f̅ds⃝a"
assert reversed("a⃞b⃞c⃞") == "c⃞b⃞a⃞"
@end example

@item graphemeLen
  @findex proc graphemeLen*(s꞉ string; i꞉ Natural)꞉ Natural
@example
proc graphemeLen*(s꞉ string; i꞉ Natural)꞉ Natural
@end example
  The number of bytes belonging to 's[i]' including following combining characters.

@item lastRune
  @findex proc lastRune*(s꞉ string; last꞉ int)꞉ (Rune, int)
@example
proc lastRune*(s꞉ string; last꞉ int)꞉ (Rune, int)
@end example
  length of the last rune in 's[0..last]'. Returns the rune and its length in bytes.
@end itemize

@chapter Templates

@itemize


@item fastRuneAt
  @findex template fastRuneAt*(s꞉ string; i꞉ int; result꞉ expr; doInc = true)
@example
template fastRuneAt*(s꞉ string; i꞉ int; result꞉ expr; doInc = true)
@end example
  Returns the Unicode character @code{s[i]} in @code{result}. If @code{doInc == true} @code{i} is incremented by the number of bytes that have been processed.
@end itemize




@chapter Iterators

@itemize


@item runes
  @itindex iterator runes*(s꞉ string)꞉ Rune
@example
iterator runes*(s꞉ string)꞉ Rune
@end example
  Iterates over any unicode character of the string @code{s}
@end itemize

@node /pure/net, /pure/xmldomparser , /pure/unicode, Top
@chapter Constant variables

@itemize


@item BufferSize
  @vindex BufferSize*꞉ int = 4000
@example
BufferSize*꞉ int = 4000
@end example
  size of a buffered socket's buffer
@end itemize



@chapter Types

@itemize


@item SslHandshakeType
  @tindex SslHandshakeType* = enumhandshakeAsClient, handshakeAsServer
@example
SslHandshakeType* = enumhandshakeAsClient, handshakeAsServer
@end example
  

@item SocketFlag
  @tindex SocketFlag* @{.pure.@} = enumPeek, SafeDisconn            ## Ensures disconnection exceptions (ECONNRESET, EPIPE etc) are not thrown.
@example
SocketFlag* @{.pure.@} = enumPeek, SafeDisconn            ## Ensures disconnection exceptions (ECONNRESET, EPIPE etc) are not thrown.
@end example
  

@item IpAddress
  @tindex IpAddress* = object
  case family*: IpAddressFamily ## the type of the IP address (IPv4 or IPv6)
  of IpAddressFamily.IPv6:
      address_v6*: array[0 .. 15, uint8] ## Contains the IP address in bytes in
                                    ## case of IPv6
    
  of IpAddressFamily.IPv4:
      address_v4*: array[0 .. 3, uint8] ## Contains the IP address in bytes in
                                   ## case of IPv4
    
  
@example
IpAddress* = object
  case family*: IpAddressFamily ## the type of the IP address (IPv4 or IPv6)
  of IpAddressFamily.IPv6:
      address_v6*: array[0 .. 15, uint8] ## Contains the IP address in bytes in
                                    ## case of IPv6
    
  of IpAddressFamily.IPv4:
      address_v4*: array[0 .. 3, uint8] ## Contains the IP address in bytes in
                                   ## case of IPv4
    
  
@end example
  stores an arbitrary IP address
@end itemize

@chapter Procedures

@itemize


@item isIpAddress
  @findex proc isIpAddress*(address_str꞉ string)꞉ bool @{.tags꞉ [].@}
@example
proc isIpAddress*(address_str꞉ string)꞉ bool @{.tags꞉ [].@}
@end example
  

@item parseIpAddress
  @findex proc parseIpAddress*(address_str꞉ string)꞉ IpAddress
@example
proc parseIpAddress*(address_str꞉ string)꞉ IpAddress
@end example
  

@item socketError
  @findex proc socketError*(socket꞉ Socket; err꞉ int = - 1; async = false;lastError = (- 1).OSErrorCode)꞉ void
@example
proc socketError*(socket꞉ Socket; err꞉ int = - 1; async = false;lastError = (- 1).OSErrorCode)꞉ void
@end example
  

@item isDisconnectionError
  @findex proc isDisconnectionError*(flags꞉ set[SocketFlag]; lastError꞉ OSErrorCode)꞉ bool
@example
proc isDisconnectionError*(flags꞉ set[SocketFlag]; lastError꞉ OSErrorCode)꞉ bool
@end example
  Determines whether @code{lastError} is a disconnection error. Only does this if flags contains @code{SafeDisconn}.

@item toOSFlags
  @findex proc toOSFlags*(socketFlags꞉ set[SocketFlag])꞉ cint
@example
proc toOSFlags*(socketFlags꞉ set[SocketFlag])꞉ cint
@end example
  Converts the flags into the underlying OS representation.

@item newSocket
  @findex proc newSocket*(fd꞉ SocketHandle; domain꞉ Domain = AF_INET;sockType꞉ SockType = SOCK_STREAM; protocol꞉ Protocol = IPPROTO_TCP;buffered = true)꞉ Socket
@example
proc newSocket*(fd꞉ SocketHandle; domain꞉ Domain = AF_INET;sockType꞉ SockType = SOCK_STREAM; protocol꞉ Protocol = IPPROTO_TCP;buffered = true)꞉ Socket
@end example
  Creates a new socket as specified by the params.

@item newSocket
  @findex proc newSocket*(domain, sockType, protocol꞉ cint; buffered = true)꞉ Socket
@example
proc newSocket*(domain, sockType, protocol꞉ cint; buffered = true)꞉ Socket
@end example
  Creates a new socket.

If an error occurs EOS will be raised.

@item newSocket
  @findex proc newSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ Socket
@example
proc newSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP; buffered = true)꞉ Socket
@end example
  Creates a new socket.

If an error occurs EOS will be raised.

@item raiseSSLError
  @findex proc raiseSSLError*(s = "")
@example
proc raiseSSLError*(s = "")
@end example
  Raises a new SSL error.

@item newContext
  @findex proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";keyFile = "")꞉ SSLContext
@example
proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";keyFile = "")꞉ SSLContext
@end example
  Creates an SSL context.

Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are available with the addition of @code{protSSLv23} which allows for compatibility with all of them.

There are currently only two options for verify mode; one is @code{CVerifyNone} and with it certificates will not be verified the other is @code{CVerifyPeer} and certificates will be verified for it, @code{CVerifyPeer} is the safest choice.

The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: @code{openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem}.

@item wrapSocket
  @findex proc wrapSocket*(ctx꞉ SSLContext; socket꞉ Socket)
@example
proc wrapSocket*(ctx꞉ SSLContext; socket꞉ Socket)
@end example
  Wraps a socket in an SSL context. This function effectively turns @code{socket} into an SSL socket.

This must be called on an unconnected socket; an SSL session will be started when the socket is connected.

@strong{Disclaimer}: This code is not well tested, may be very unsafe and prone to security vulnerabilities.

@item wrapConnectedSocket
  @findex proc wrapConnectedSocket*(ctx꞉ SSLContext; socket꞉ Socket;handshake꞉ SslHandshakeType)
@example
proc wrapConnectedSocket*(ctx꞉ SSLContext; socket꞉ Socket;handshake꞉ SslHandshakeType)
@end example
  Wraps a connected socket in an SSL context. This function effectively turns @code{socket} into an SSL socket.

This should be called on a connected socket, and will perform an SSL handshake immediately.

@strong{Disclaimer}: This code is not well tested, may be very unsafe and prone to security vulnerabilities.

@item getSocketError
  @findex proc getSocketError*(socket꞉ Socket)꞉ OSErrorCode
@example
proc getSocketError*(socket꞉ Socket)꞉ OSErrorCode
@end example
  Checks @code{osLastError} for a valid error. If it has been reset it uses the last error stored in the socket object.

@item socketError
  @findex proc socketError*(socket꞉ Socket; err꞉ int = - 1; async = false;lastError = (- 1).OSErrorCode)
@example
proc socketError*(socket꞉ Socket; err꞉ int = - 1; async = false;lastError = (- 1).OSErrorCode)
@end example
  Raises an OSError based on the error code returned by @code{SSLGetError} (for SSL sockets) and @code{osLastError} otherwise.

If @code{async} is @code{true} no error will be thrown in the case when the error was caused by no data being available to be read.

If @code{err} is not lower than 0 no exception will be raised.

@item listen
  @findex proc listen*(socket꞉ Socket; backlog = SOMAXCONN) @{.tags꞉ [ReadIOEffect].@}
@example
proc listen*(socket꞉ Socket; backlog = SOMAXCONN) @{.tags꞉ [ReadIOEffect].@}
@end example
  Marks @code{socket} as accepting connections. @code{Backlog} specifies the maximum length of the queue of pending connections.

Raises an EOS error upon failure.

@item bindAddr
  @findex proc bindAddr*(socket꞉ Socket; port = Port(0); address = "") @{.tags꞉ [ReadIOEffect].@}
@example
proc bindAddr*(socket꞉ Socket; port = Port(0); address = "") @{.tags꞉ [ReadIOEffect].@}
@end example
  Binds @code{address}:@code{port} to the socket.

If @code{address} is "" then ADDR_ANY will be bound.

@item acceptAddr
  @findex proc acceptAddr*(server꞉ Socket; client꞉ var Socket; address꞉ var string;flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [ReadIOEffect], gcsafe,locks꞉ 0.@}
@example
proc acceptAddr*(server꞉ Socket; client꞉ var Socket; address꞉ var string;flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [ReadIOEffect], gcsafe,locks꞉ 0.@}
@end example
  Blocks until a connection is being made from a client. When a connection is made sets @code{client} to the client socket and @code{address} to the address of the connecting client. This function will raise EOS if an error occurs.

The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.

@strong{Note}: @code{client} must be initialised (with @code{new}), this function makes no effort to initialise the @code{client} variable.

The @code{accept} call may result in an error if the connecting socket disconnects during the duration of the @code{accept}. If the @code{SafeDisconn} flag is specified then this error will not be raised and instead accept will be called again.

@item accept
  @findex proc accept*(server꞉ Socket; client꞉ var Socket; flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [ReadIOEffect].@}
@example
proc accept*(server꞉ Socket; client꞉ var Socket; flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [ReadIOEffect].@}
@end example
  Equivalent to @code{acceptAddr} but doesn't return the address, only the socket.

@strong{Note}: @code{client} must be initialised (with @code{new}), this function makes no effort to initialise the @code{client} variable.

The @code{accept} call may result in an error if the connecting socket disconnects during the duration of the @code{accept}. If the @code{SafeDisconn} flag is specified then this error will not be raised and instead accept will be called again.

@item close
  @findex proc close*(socket꞉ Socket)
@example
proc close*(socket꞉ Socket)
@end example
  Closes a socket.

@item toCInt
  @findex proc toCInt*(opt꞉ SOBool)꞉ cint
@example
proc toCInt*(opt꞉ SOBool)꞉ cint
@end example
  Converts a @code{SOBool} into its Socket Option cint representation.

@item getSockOpt
  @findex proc getSockOpt*(socket꞉ Socket; opt꞉ SOBool; level = SOL_SOCKET)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@example
proc getSockOpt*(socket꞉ Socket; opt꞉ SOBool; level = SOL_SOCKET)꞉ bool @{.tags꞉ [ReadIOEffect].@}
@end example
  Retrieves option @code{opt} as a boolean value.

@item getLocalAddr
  @findex proc getLocalAddr*(socket꞉ Socket)꞉ (string, Port)
@example
proc getLocalAddr*(socket꞉ Socket)꞉ (string, Port)
@end example
  Get the socket's local address and port number.

This is high-level interface for .

@item getPeerAddr
  @findex proc getPeerAddr*(socket꞉ Socket)꞉ (string, Port)
@example
proc getPeerAddr*(socket꞉ Socket)꞉ (string, Port)
@end example
  Get the socket's peer address and port number.

This is high-level interface for .

@item setSockOpt
  @findex proc setSockOpt*(socket꞉ Socket; opt꞉ SOBool; value꞉ bool; level = SOL_SOCKET) @{.tags꞉ [WriteIOEffect].@}
@example
proc setSockOpt*(socket꞉ Socket; opt꞉ SOBool; value꞉ bool; level = SOL_SOCKET) @{.tags꞉ [WriteIOEffect].@}
@end example
  Sets option @code{opt} to a boolean value specified by @code{value}.

@item connect
  @findex proc connect*(socket꞉ Socket; address꞉ string; port = Port(0)) @{.tags꞉ [ReadIOEffect].@}
@example
proc connect*(socket꞉ Socket; address꞉ string; port = Port(0)) @{.tags꞉ [ReadIOEffect].@}
@end example
  Connects socket to @code{address}:@code{port}. @code{Address} can be an IP address or a host name. If @code{address} is a host name, this function will try each IP of that host name. @code{htons} is already performed on @code{port} so you must not do it.

If @code{socket} is an SSL socket a handshake will be automatically performed.

@item handshake
  @findex proc handshake*(socket꞉ Socket)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc handshake*(socket꞉ Socket)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  This proc needs to be called on a socket after it connects. This is only applicable when using @code{connectAsync}. This proc performs the SSL handshake.

Returns @code{False} whenever the socket is not yet ready for a handshake, @code{True} whenever handshake completed successfully.

A ESSL error is raised on any other errors.

@item gotHandshake
  @findex proc gotHandshake*(socket꞉ Socket)꞉ bool
@example
proc gotHandshake*(socket꞉ Socket)꞉ bool
@end example
  Determines whether a handshake has occurred between a client (@code{socket}) and the server that @code{socket} is connected to.

Throws ESSL if @code{socket} is not an SSL socket.

@item hasDataBuffered
  @findex proc hasDataBuffered*(s꞉ Socket)꞉ bool
@example
proc hasDataBuffered*(s꞉ Socket)꞉ bool
@end example
  Determines whether a socket has data buffered.

@item recv
  @findex proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  Receives data from a socket.

@strong{Note}: This is a low-level function, you may be interested in the higher level versions of this function which are also named @code{recv}.

@item recv
  @findex proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int; timeout꞉ int)꞉ int @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@example
proc recv*(socket꞉ Socket; data꞉ pointer; size꞉ int; timeout꞉ int)꞉ int @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@end example
  overload with a @code{timeout} parameter in milliseconds.

@item recv
  @findex proc recv*(socket꞉ Socket; data꞉ var string; size꞉ int; timeout = - 1;flags = @{SocketFlag.SafeDisconn@})꞉ int
@example
proc recv*(socket꞉ Socket; data꞉ var string; size꞉ int; timeout = - 1;flags = @{SocketFlag.SafeDisconn@})꞉ int
@end example
  Higher-level version of @code{recv}.

When 0 is returned the socket's connection has been closed.

This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.

A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.

@strong{Note}: @code{data} must be initialised.

@strong{Warning}: Only the @code{SafeDisconn} flag is currently supported.

@item readLine
  @findex proc readLine*(socket꞉ Socket; line꞉ var TaintedString; timeout = - 1;flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@example
proc readLine*(socket꞉ Socket; line꞉ var TaintedString; timeout = - 1;flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [ReadIOEffect, TimeEffect].@}
@end example
  Reads a line of data from @code{socket}.

If a full line is read @code{\r\L} is not added to @code{line}, however if solely @code{\r\L} is read then @code{line} will be set to it.

If the socket is disconnected, @code{line} will be set to @code{""}.

An EOS exception will be raised in the case of a socket error.

A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.

@strong{Warning}: Only the @code{SafeDisconn} flag is currently supported.

@item recvFrom
  @findex proc recvFrom*(socket꞉ Socket; data꞉ var string; length꞉ int; address꞉ var string;port꞉ var Port; flags = 0'i32)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc recvFrom*(socket꞉ Socket; data꞉ var string; length꞉ int; address꞉ var string;port꞉ var Port; flags = 0'i32)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  Receives data from @code{socket}. This function should normally be used with connection-less sockets (UDP sockets).

If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.

@strong{Warning:} This function does not yet have a buffered implementation, so when @code{socket} is buffered the non-buffered implementation will be used. Therefore if @code{socket} contains something in its buffer this function will make no effort to return it.

@item skip
  @findex proc skip*(socket꞉ Socket; size꞉ int; timeout = - 1)
@example
proc skip*(socket꞉ Socket; size꞉ int; timeout = - 1)
@end example
  Skips @code{size} amount of bytes.

An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.

Returns the number of skipped bytes.

@item send
  @findex proc send*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [WriteIOEffect].@}
@example
proc send*(socket꞉ Socket; data꞉ pointer; size꞉ int)꞉ int @{.tags꞉ [WriteIOEffect].@}
@end example
  Sends data to a socket.

@strong{Note}: This is a low-level version of @code{send}. You likely should use the version below.

@item send
  @findex proc send*(socket꞉ Socket; data꞉ string; flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [WriteIOEffect].@}
@example
proc send*(socket꞉ Socket; data꞉ string; flags = @{SocketFlag.SafeDisconn@}) @{.tags꞉ [WriteIOEffect].@}
@end example
  sends data to a socket.

@item trySend
  @findex proc trySend*(socket꞉ Socket; data꞉ string)꞉ bool @{.tags꞉ [WriteIOEffect].@}
@example
proc trySend*(socket꞉ Socket; data꞉ string)꞉ bool @{.tags꞉ [WriteIOEffect].@}
@end example
  Safe alternative to @code{send}. Does not raise an EOS when an error occurs, and instead returns @code{false} on failure.

@item sendTo
  @findex proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ pointer; size꞉ int;af꞉ Domain = AF_INET; flags = 0'i32)꞉ int @{.tags꞉ [WriteIOEffect].@}
@example
proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ pointer; size꞉ int;af꞉ Domain = AF_INET; flags = 0'i32)꞉ int @{.tags꞉ [WriteIOEffect].@}
@end example
  This proc sends @code{data} to the specified @code{address}, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.

@strong{Note:} You may wish to use the high-level version of this function which is defined below.

@strong{Note:} This proc is not available for SSL sockets.

@item sendTo
  @findex proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ string)꞉ int @{.tags꞉ [WriteIOEffect].@}
@example
proc sendTo*(socket꞉ Socket; address꞉ string; port꞉ Port; data꞉ string)꞉ int @{.tags꞉ [WriteIOEffect].@}
@end example
  This proc sends @code{data} to the specified @code{address}, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.

This is the high-level version of the above @code{sendTo} function.

@item connect
  @findex proc connect*(socket꞉ Socket; address꞉ string; port = Port(0); timeout꞉ int) @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc connect*(socket꞉ Socket; address꞉ string; port = Port(0); timeout꞉ int) @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  Connects to server as specified by @code{address} on port specified by @code{port}.

The @code{timeout} paremeter specifies the time in milliseconds to allow for the connection to the server to be made.

@item isSsl
  @findex proc isSsl*(socket꞉ Socket)꞉ bool
@example
proc isSsl*(socket꞉ Socket)꞉ bool
@end example
  Determines whether @code{socket} is a SSL socket.

@item getFd
  @findex proc getFd*(socket꞉ Socket)꞉ SocketHandle
@example
proc getFd*(socket꞉ Socket)꞉ SocketHandle
@end example
  Returns the socket's file descriptor

@item IPv4_any
  @findex proc IPv4_any*()꞉ IpAddress
@example
proc IPv4_any*()꞉ IpAddress
@end example
  Returns the IPv4 any address, which can be used to listen on all available network adapters

@item IPv4_loopback
  @findex proc IPv4_loopback*()꞉ IpAddress
@example
proc IPv4_loopback*()꞉ IpAddress
@end example
  Returns the IPv4 loopback address (127.0.0.1)

@item IPv4_broadcast
  @findex proc IPv4_broadcast*()꞉ IpAddress
@example
proc IPv4_broadcast*()꞉ IpAddress
@end example
  Returns the IPv4 broadcast address (255.255.255.255)

@item IPv6_any
  @findex proc IPv6_any*()꞉ IpAddress
@example
proc IPv6_any*()꞉ IpAddress
@end example
  Returns the IPv6 any address (::0), which can be used to listen on all available network adapters

@item IPv6_loopback
  @findex proc IPv6_loopback*()꞉ IpAddress
@example
proc IPv6_loopback*()꞉ IpAddress
@end example
  Returns the IPv6 loopback address (::1)

@item `==`
  @findex proc `==`*(lhs, rhs꞉ IpAddress)꞉ bool
@example
proc `==`*(lhs, rhs꞉ IpAddress)꞉ bool
@end example
  Compares two IpAddresses for Equality. Returns two if the addresses are equal

@item `$`
  @findex proc `$`*(address꞉ IpAddress)꞉ string
@example
proc `$`*(address꞉ IpAddress)꞉ string
@end example
  Converts an IpAddress into the textual representation
@end itemize






@node /pure/xmldomparser, /pure/securehash , /pure/net, Top




@chapter Procedures

@itemize


@item loadXMLStream
  @findex proc loadXMLStream*(stream꞉ Stream)꞉ PDocument
@example
proc loadXMLStream*(stream꞉ Stream)꞉ PDocument
@end example
  Loads and parses XML from a stream specified by @code{stream}, and returns a @code{PDocument}

@item loadXML
  @findex proc loadXML*(xml꞉ string)꞉ PDocument
@example
proc loadXML*(xml꞉ string)꞉ PDocument
@end example
  Loads and parses XML from a string specified by @code{xml}, and returns a @code{PDocument}

@item loadXMLFile
  @findex proc loadXMLFile*(path꞉ string)꞉ PDocument
@example
proc loadXMLFile*(path꞉ string)꞉ PDocument
@end example
  Loads and parses XML from a file specified by @code{path}, and returns a @code{PDocument}
@end itemize






@node /pure/securehash, /pure/md5 , /pure/xmldomparser, Top



@chapter Types

@itemize


@item SecureHash
  @tindex SecureHash* = distinct Sha1Digest
@example
SecureHash* = distinct Sha1Digest
@end example
  
@end itemize

@chapter Procedures

@itemize


@item secureHash
  @findex proc secureHash*(str꞉ string)꞉ SecureHash
@example
proc secureHash*(str꞉ string)꞉ SecureHash
@end example
  

@item secureHashFile
  @findex proc secureHashFile*(filename꞉ string)꞉ SecureHash
@example
proc secureHashFile*(filename꞉ string)꞉ SecureHash
@end example
  

@item `$`
  @findex proc `$`*(self꞉ SecureHash)꞉ string
@example
proc `$`*(self꞉ SecureHash)꞉ string
@end example
  

@item parseSecureHash
  @findex proc parseSecureHash*(hash꞉ string)꞉ SecureHash
@example
proc parseSecureHash*(hash꞉ string)꞉ SecureHash
@end example
  

@item `==`
  @findex proc `==`*(a, b꞉ SecureHash)꞉ bool
@example
proc `==`*(a, b꞉ SecureHash)꞉ bool
@end example
  
@end itemize






@node /pure/md5, /pure/stats , /pure/securehash, Top



@chapter Types

@itemize


@item MD5Context
  @tindex MD5Context* @{.final.@} = object
  state: MD5State
  count: array[0 .. 1, uint32]
  buffer: MD5Buffer

@example
MD5Context* @{.final.@} = object
  state: MD5State
  count: array[0 .. 1, uint32]
  buffer: MD5Buffer

@end example
  
@end itemize

@chapter Procedures

@itemize


@item md5Init
  @findex proc md5Init*(c꞉ var MD5Context)
@example
proc md5Init*(c꞉ var MD5Context)
@end example
  initializes a MD5Context

@item md5Update
  @findex proc md5Update*(c꞉ var MD5Context; input꞉ cstring; len꞉ int)
@example
proc md5Update*(c꞉ var MD5Context; input꞉ cstring; len꞉ int)
@end example
  updates the MD5Context with the @emph{input} data of length @emph{len}

@item md5Final
  @findex proc md5Final*(c꞉ var MD5Context; digest꞉ var MD5Digest)
@example
proc md5Final*(c꞉ var MD5Context; digest꞉ var MD5Digest)
@end example
  finishes the MD5Context and stores the result in @emph{digest}

@item toMD5
  @findex proc toMD5*(s꞉ string)꞉ MD5Digest
@example
proc toMD5*(s꞉ string)꞉ MD5Digest
@end example
  computes the MD5Digest value for a string @emph{s}

@item `$`
  @findex proc `$`*(d꞉ MD5Digest)꞉ string
@example
proc `$`*(d꞉ MD5Digest)꞉ string
@end example
  converts a MD5Digest value into its string representation

@item getMD5
  @findex proc getMD5*(s꞉ string)꞉ string
@example
proc getMD5*(s꞉ string)꞉ string
@end example
  computes an MD5 value of @emph{s} and returns its string representation

@item `==`
  @findex proc `==`*(D1, D2꞉ MD5Digest)꞉ bool
@example
proc `==`*(D1, D2꞉ MD5Digest)꞉ bool
@end example
  checks if two MD5Digest values are identical
@end itemize






@node /pure/stats, /pure/times , /pure/md5, Top



@chapter Types

@itemize


@item RunningRegress
  @tindex RunningRegress* = object
  n*: int                      ## number of pushed data
  x_stats*: RunningStat        ## stats for first set of data
  y_stats*: RunningStat        ## stats for second set of data
  s_xy: float                  ## accumulated data for combined xy
  
@example
RunningRegress* = object
  n*: int                      ## number of pushed data
  x_stats*: RunningStat        ## stats for first set of data
  y_stats*: RunningStat        ## stats for second set of data
  s_xy: float                  ## accumulated data for combined xy
  
@end example
  an accumulator for regression calculations
@end itemize

@chapter Procedures

@itemize


@item clear
  @findex proc clear*(s꞉ var RunningStat)
@example
proc clear*(s꞉ var RunningStat)
@end example
  reset @emph{s}

@item push
  @findex proc push*(s꞉ var RunningStat; x꞉ float)
@example
proc push*(s꞉ var RunningStat; x꞉ float)
@end example
  pushes a value @emph{x} for processing

@item push
  @findex proc push*(s꞉ var RunningStat; x꞉ int)
@example
proc push*(s꞉ var RunningStat; x꞉ int)
@end example
  pushes a value @emph{x} for processing.

@emph{x} is simply converted to @code{float} and the other push operation is called.

@item push
  @findex proc push*(s꞉ var RunningStat; x꞉ openarray[float | int])
@example
proc push*(s꞉ var RunningStat; x꞉ openarray[float | int])
@end example
  pushes all values of @emph{x} for processing.

Int values of @emph{x} are simply converted to @code{float} and the other push operation is called.

@item mean
  @findex proc mean*(s꞉ RunningStat)꞉ float
@example
proc mean*(s꞉ RunningStat)꞉ float
@end example
  computes the current mean of @emph{s}

@item variance
  @findex proc variance*(s꞉ RunningStat)꞉ float
@example
proc variance*(s꞉ RunningStat)꞉ float
@end example
  computes the current population variance of @emph{s}

@item varianceS
  @findex proc varianceS*(s꞉ RunningStat)꞉ float
@example
proc varianceS*(s꞉ RunningStat)꞉ float
@end example
  computes the current sample variance of @emph{s}

@item standardDeviation
  @findex proc standardDeviation*(s꞉ RunningStat)꞉ float
@example
proc standardDeviation*(s꞉ RunningStat)꞉ float
@end example
  computes the current population standard deviation of @emph{s}

@item standardDeviationS
  @findex proc standardDeviationS*(s꞉ RunningStat)꞉ float
@example
proc standardDeviationS*(s꞉ RunningStat)꞉ float
@end example
  computes the current sample standard deviation of @emph{s}

@item skewness
  @findex proc skewness*(s꞉ RunningStat)꞉ float
@example
proc skewness*(s꞉ RunningStat)꞉ float
@end example
  computes the current population skewness of @emph{s}

@item skewnessS
  @findex proc skewnessS*(s꞉ RunningStat)꞉ float
@example
proc skewnessS*(s꞉ RunningStat)꞉ float
@end example
  computes the current sample skewness of @emph{s}

@item kurtosis
  @findex proc kurtosis*(s꞉ RunningStat)꞉ float
@example
proc kurtosis*(s꞉ RunningStat)꞉ float
@end example
  computes the current population kurtosis of @emph{s}

@item kurtosisS
  @findex proc kurtosisS*(s꞉ RunningStat)꞉ float
@example
proc kurtosisS*(s꞉ RunningStat)꞉ float
@end example
  computes the current sample kurtosis of @emph{s}

@item `+`
  @findex proc `+`*(a, b꞉ RunningStat)꞉ RunningStat
@example
proc `+`*(a, b꞉ RunningStat)꞉ RunningStat
@end example
  combine two RunningStats.

Useful if performing parallel analysis of data series and need to re-combine parallel result sets

@item `+=`
  @findex proc `+=`*(a꞉ var RunningStat; b꞉ RunningStat) @{.inline.@}
@example
proc `+=`*(a꞉ var RunningStat; b꞉ RunningStat) @{.inline.@}
@end example
  add a second RunningStats @emph{b} to @emph{a}

@item mean
  @findex proc mean*[T](x꞉ openArray[T])꞉ float
@example
proc mean*[T](x꞉ openArray[T])꞉ float
@end example
  computes the mean of @emph{x}

@item variance
  @findex proc variance*[T](x꞉ openArray[T])꞉ float
@example
proc variance*[T](x꞉ openArray[T])꞉ float
@end example
  computes the population variance of @emph{x}

@item varianceS
  @findex proc varianceS*[T](x꞉ openArray[T])꞉ float
@example
proc varianceS*[T](x꞉ openArray[T])꞉ float
@end example
  computes the sample variance of @emph{x}

@item standardDeviation
  @findex proc standardDeviation*[T](x꞉ openArray[T])꞉ float
@example
proc standardDeviation*[T](x꞉ openArray[T])꞉ float
@end example
  computes the population standardDeviation of @emph{x}

@item standardDeviationS
  @findex proc standardDeviationS*[T](x꞉ openArray[T])꞉ float
@example
proc standardDeviationS*[T](x꞉ openArray[T])꞉ float
@end example
  computes the sanple standardDeviation of @emph{x}

@item skewness
  @findex proc skewness*[T](x꞉ openArray[T])꞉ float
@example
proc skewness*[T](x꞉ openArray[T])꞉ float
@end example
  computes the population skewness of @emph{x}

@item skewnessS
  @findex proc skewnessS*[T](x꞉ openArray[T])꞉ float
@example
proc skewnessS*[T](x꞉ openArray[T])꞉ float
@end example
  computes the sample skewness of @emph{x}

@item kurtosis
  @findex proc kurtosis*[T](x꞉ openArray[T])꞉ float
@example
proc kurtosis*[T](x꞉ openArray[T])꞉ float
@end example
  computes the population kurtosis of @emph{x}

@item kurtosisS
  @findex proc kurtosisS*[T](x꞉ openArray[T])꞉ float
@example
proc kurtosisS*[T](x꞉ openArray[T])꞉ float
@end example
  computes the sample kurtosis of @emph{x}

@item clear
  @findex proc clear*(r꞉ var RunningRegress)
@example
proc clear*(r꞉ var RunningRegress)
@end example
  reset @emph{r}

@item push
  @findex proc push*(r꞉ var RunningRegress; x, y꞉ float)
@example
proc push*(r꞉ var RunningRegress; x, y꞉ float)
@end example
  pushes two values @emph{x} and @emph{y} for processing

@item push
  @findex proc push*(r꞉ var RunningRegress; x, y꞉ int) @{.inline.@}
@example
proc push*(r꞉ var RunningRegress; x, y꞉ int) @{.inline.@}
@end example
  pushes two values @emph{x} and @emph{y} for processing.

@emph{x} and @emph{y} are converted to @code{float} and the other push operation is called.

@item push
  @findex proc push*(r꞉ var RunningRegress; x, y꞉ openarray[float | int])
@example
proc push*(r꞉ var RunningRegress; x, y꞉ openarray[float | int])
@end example
  pushes two sets of values @emph{x} and @emph{y} for processing.

@item slope
  @findex proc slope*(r꞉ RunningRegress)꞉ float
@example
proc slope*(r꞉ RunningRegress)꞉ float
@end example
  computes the current slope of @emph{r}

@item intercept
  @findex proc intercept*(r꞉ RunningRegress)꞉ float
@example
proc intercept*(r꞉ RunningRegress)꞉ float
@end example
  computes the current intercept of @emph{r}

@item correlation
  @findex proc correlation*(r꞉ RunningRegress)꞉ float
@example
proc correlation*(r꞉ RunningRegress)꞉ float
@end example
  computes the current correlation of the two data sets pushed into @emph{r}

@item `+`
  @findex proc `+`*(a, b꞉ RunningRegress)꞉ RunningRegress
@example
proc `+`*(a, b꞉ RunningRegress)꞉ RunningRegress
@end example
  combine two @emph{RunningRegress} objects.

Useful if performing parallel analysis of data series and need to re-combine parallel result sets

@item `+=`
  @findex proc `+=`*(a꞉ var RunningRegress; b꞉ RunningRegress)
@example
proc `+=`*(a꞉ var RunningRegress; b꞉ RunningRegress)
@end example
  add RunningRegress @emph{b} to @emph{a}
@end itemize






@node /pure/times, /pure/typetraits , /pure/stats, Top



@chapter Types

@itemize


@item WeekDay
  @tindex WeekDay* = enumdMon, dTue, dWed, dThu, dFri, dSat, dSun
@example
WeekDay* = enumdMon, dTue, dWed, dThu, dFri, dSat, dSun
@end example
  represents a weekday

@item TimeInterval
  @tindex TimeInterval* = object
  milliseconds*: int           ## The number of milliseconds
  seconds*: int                ## The number of seconds
  minutes*: int                ## The number of minutes
  hours*: int                  ## The number of hours
  days*: int                   ## The number of days
  months*: int                 ## The number of months
  years*: int                  ## The number of years
  
@example
TimeInterval* = object
  milliseconds*: int           ## The number of milliseconds
  seconds*: int                ## The number of seconds
  minutes*: int                ## The number of minutes
  hours*: int                  ## The number of hours
  days*: int                   ## The number of days
  months*: int                 ## The number of months
  years*: int                  ## The number of years
  
@end example
  a time interval
@end itemize

@chapter Procedures

@itemize


@item getTime
  @findex proc getTime*()꞉ Time @{.tags꞉ [TimeEffect], benign.@}
@example
proc getTime*()꞉ Time @{.tags꞉ [TimeEffect], benign.@}
@end example
  gets the current calendar time as a UNIX epoch value (number of seconds elapsed since 1970) with integer precission. Use epochTime for higher resolution.

@item getLocalTime
  @findex proc getLocalTime*(t꞉ Time)꞉ TimeInfo @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@example
proc getLocalTime*(t꞉ Time)꞉ TimeInfo @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@end example
  converts the calendar time @emph{t} to broken-time representation, expressed relative to the user's specified time zone.

@item getGMTime
  @findex proc getGMTime*(t꞉ Time)꞉ TimeInfo @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@example
proc getGMTime*(t꞉ Time)꞉ TimeInfo @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@end example
  converts the calendar time @emph{t} to broken-down time representation, expressed in Coordinated Universal Time (UTC).

@item timeInfoToTime
  @findex proc timeInfoToTime*(timeInfo꞉ TimeInfo)꞉ Time @{.tags꞉ [], benign.@}
@example
proc timeInfoToTime*(timeInfo꞉ TimeInfo)꞉ Time @{.tags꞉ [], benign.@}
@end example
  converts a broken-down time structure to calendar time representation. The function ignores the specified contents of the structure members @emph{weekday} and @emph{yearday} and recomputes them from the other information in the broken-down time structure.

@item fromSeconds
  @findex proc fromSeconds*(since1970꞉ float)꞉ Time @{.tags꞉ [], raises꞉ [], benign.@}
@example
proc fromSeconds*(since1970꞉ float)꞉ Time @{.tags꞉ [], raises꞉ [], benign.@}
@end example
  Takes a float which contains the number of seconds since the unix epoch and returns a time object.

@item fromSeconds
  @findex proc fromSeconds*(since1970꞉ int64)꞉ Time @{.tags꞉ [], raises꞉ [], benign.@}
@example
proc fromSeconds*(since1970꞉ int64)꞉ Time @{.tags꞉ [], raises꞉ [], benign.@}
@end example
  Takes an int which contains the number of seconds since the unix epoch and returns a time object.

@item toSeconds
  @findex proc toSeconds*(time꞉ Time)꞉ float @{.tags꞉ [], raises꞉ [], benign.@}
@example
proc toSeconds*(time꞉ Time)꞉ float @{.tags꞉ [], raises꞉ [], benign.@}
@end example
  Returns the time in seconds since the unix epoch.

@item `$`
  @findex proc `$`*(timeInfo꞉ TimeInfo)꞉ string @{.tags꞉ [], raises꞉ [], benign.@}
@example
proc `$`*(timeInfo꞉ TimeInfo)꞉ string @{.tags꞉ [], raises꞉ [], benign.@}
@end example
  converts a @emph{TimeInfo} object to a string representation.

@item `$`
  @findex proc `$`*(time꞉ Time)꞉ string @{.tags꞉ [], raises꞉ [], benign.@}
@example
proc `$`*(time꞉ Time)꞉ string @{.tags꞉ [], raises꞉ [], benign.@}
@end example
  converts a calendar time to a string representation.

@item `-`
  @findex proc `-`*(a, b꞉ Time)꞉ int64 @{.rtl, extern꞉ "ntDiffTime", tags꞉ [], raises꞉ [], benign.@}
@example
proc `-`*(a, b꞉ Time)꞉ int64 @{.rtl, extern꞉ "ntDiffTime", tags꞉ [], raises꞉ [], benign.@}
@end example
  computes the difference of two calendar times. Result is in seconds.

@item `<`
  @findex proc `<`*(a, b꞉ Time)꞉ bool @{.rtl, extern꞉ "ntLtTime", tags꞉ [], raises꞉ [].@}
@example
proc `<`*(a, b꞉ Time)꞉ bool @{.rtl, extern꞉ "ntLtTime", tags꞉ [], raises꞉ [].@}
@end example
  returns true iff @code{a < b}, that is iff a happened before b.

@item `<=`
  @findex proc `<=`*(a, b꞉ Time)꞉ bool @{.rtl, extern꞉ "ntLeTime", tags꞉ [], raises꞉ [].@}
@example
proc `<=`*(a, b꞉ Time)꞉ bool @{.rtl, extern꞉ "ntLeTime", tags꞉ [], raises꞉ [].@}
@end example
  returns true iff @code{a <= b}.

@item `==`
  @findex proc `==`*(a, b꞉ Time)꞉ bool @{.rtl, extern꞉ "ntEqTime", tags꞉ [], raises꞉ [].@}
@example
proc `==`*(a, b꞉ Time)꞉ bool @{.rtl, extern꞉ "ntEqTime", tags꞉ [], raises꞉ [].@}
@end example
  returns true if @code{a == b}, that is if both times represent the same value

@item getTzname
  @findex proc getTzname*()꞉ tuple[nonDST, DST꞉ string] @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@example
proc getTzname*()꞉ tuple[nonDST, DST꞉ string] @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@end example
  returns the local timezone; @code{nonDST} is the name of the local non-DST timezone, @code{DST} is the name of the local DST timezone.

@item getTimezone
  @findex proc getTimezone*()꞉ int @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@example
proc getTimezone*()꞉ int @{.tags꞉ [TimeEffect], raises꞉ [], benign.@}
@end example
  returns the offset of the local (non-DST) timezone in seconds west of UTC.

@item getStartMilsecs
  @findex proc getStartMilsecs*()꞉ int @{.deprecated, tags꞉ [TimeEffect], benign.@}
@example
proc getStartMilsecs*()꞉ int @{.deprecated, tags꞉ [TimeEffect], benign.@}
@end example
  get the milliseconds from the start of the program. @strong{Deprecated since version 0.8.10.} Use @code{epochTime} or @code{cpuTime} instead.

@item initInterval
  @findex proc initInterval*(milliseconds, seconds, minutes, hours, days, months, years꞉ int = 0)꞉ TimeInterval
@example
proc initInterval*(milliseconds, seconds, minutes, hours, days, months, years꞉ int = 0)꞉ TimeInterval
@end example
  creates a new @code{TimeInterval}.

You can also use the convenience procedures called @code{milliseconds}, @code{seconds}, @code{minutes}, @code{hours}, @code{days}, @code{months}, and @code{years}.

Example:


@example

let day = initInterval(hours=24)
let tomorrow = getTime() + day
echo(tomorrow)
@end example

@item `+`
  @findex proc `+`*(ti1, ti2꞉ TimeInterval)꞉ TimeInterval
@example
proc `+`*(ti1, ti2꞉ TimeInterval)꞉ TimeInterval
@end example
  Adds two @code{TimeInterval} objects together.

@item `-`
  @findex proc `-`*(ti1, ti2꞉ TimeInterval)꞉ TimeInterval
@example
proc `-`*(ti1, ti2꞉ TimeInterval)꞉ TimeInterval
@end example
  Subtracts TimeInterval @code{ti1} from @code{ti2}.

@item isLeapYear
  @findex proc isLeapYear*(year꞉ int)꞉ bool
@example
proc isLeapYear*(year꞉ int)꞉ bool
@end example
  returns true if @code{year} is a leap year

@item getDaysInMonth
  @findex proc getDaysInMonth*(month꞉ Month; year꞉ int)꞉ int
@example
proc getDaysInMonth*(month꞉ Month; year꞉ int)꞉ int
@end example
  Get the number of days in a @code{month} of a @code{year}

@item getDaysInYear
  @findex proc getDaysInYear*(year꞉ int)꞉ int
@example
proc getDaysInYear*(year꞉ int)꞉ int
@end example
  Get the number of days in a @code{year}

@item `+`
  @findex proc `+`*(a꞉ TimeInfo; interval꞉ TimeInterval)꞉ TimeInfo
@example
proc `+`*(a꞉ TimeInfo; interval꞉ TimeInterval)꞉ TimeInfo
@end example
  adds @code{interval} time from TimeInfo @code{a}.

@strong{Note:} This has been only briefly tested and it may not be very accurate.

@item `-`
  @findex proc `-`*(a꞉ TimeInfo; interval꞉ TimeInterval)꞉ TimeInfo
@example
proc `-`*(a꞉ TimeInfo; interval꞉ TimeInterval)꞉ TimeInfo
@end example
  subtracts @code{interval} time from TimeInfo @code{a}.

@strong{Note:} This has been only briefly tested, it is inaccurate especially when you subtract so much that you reach the Julian calendar.

@item miliseconds
  @findex proc miliseconds*(t꞉ TimeInterval)꞉ int @{.deprecated.@}
@example
proc miliseconds*(t꞉ TimeInterval)꞉ int @{.deprecated.@}
@end example
  

@item `miliseconds=`
  @findex proc `miliseconds =`*(t꞉ var TimeInterval; milliseconds꞉ int) @{.deprecated.@}
@example
proc `miliseconds =`*(t꞉ var TimeInterval; milliseconds꞉ int) @{.deprecated.@}
@end example
  An alias for a misspelled field in @code{TimeInterval}.

@strong{Warning:} This should not be used! It will be removed in the next version.

@item epochTime
  @findex proc epochTime*()꞉ float @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@example
proc epochTime*()꞉ float @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@end example
  gets time after the UNIX epoch (1970) in seconds. It is a float because sub-second resolution is likely to be supported (depending on the hardware/OS).

@item cpuTime
  @findex proc cpuTime*()꞉ float @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@example
proc cpuTime*()꞉ float @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@end example
  gets time spent that the CPU spent to run the current process in seconds. This may be more useful for benchmarking than @code{epochTime}. However, it may measure the real time instead (depending on the OS). The value of the result has no meaning. To generate useful timing values, take the difference between the results of two @code{cpuTime} calls:
@example
var t0 = cpuTime()
doWork()
echo "CPU time [s] ", cpuTime() - t0
@end example

@item unixTimeToWinTime
  @findex proc unixTimeToWinTime*(t꞉ Time)꞉ int64
@example
proc unixTimeToWinTime*(t꞉ Time)꞉ int64
@end example
  converts a UNIX @emph{Time} (@code{time_t}) to a Windows file time

@item winTimeToUnixTime
  @findex proc winTimeToUnixTime*(t꞉ int64)꞉ Time
@example
proc winTimeToUnixTime*(t꞉ int64)꞉ Time
@end example
  converts a Windows time to a UNIX @emph{Time} (@code{time_t})

@item getDateStr
  @findex proc getDateStr*()꞉ string @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@example
proc getDateStr*()꞉ string @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@end example
  gets the current date as a string of the format @code{YYYY-MM-DD}.

@item getClockStr
  @findex proc getClockStr*()꞉ string @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@example
proc getClockStr*()꞉ string @{.rtl, extern꞉ "nt$1", tags꞉ [TimeEffect].@}
@end example
  gets the current clock time as a string of the format @code{HH:MM:SS}.

@item `$`
  @findex proc `$`*(day꞉ WeekDay)꞉ string
@example
proc `$`*(day꞉ WeekDay)꞉ string
@end example
  stingify operator for @code{WeekDay}.

@item `$`
  @findex proc `$`*(m꞉ Month)꞉ string
@example
proc `$`*(m꞉ Month)꞉ string
@end example
  stingify operator for @code{Month}.

@item milliseconds
  @findex proc milliseconds*(ms꞉ int)꞉ TimeInterval @{.inline.@}
@example
proc milliseconds*(ms꞉ int)꞉ TimeInterval @{.inline.@}
@end example
  TimeInterval of @emph{ms} milliseconds

Note: not all time functions have millisecond resolution

@item seconds
  @findex proc seconds*(s꞉ int)꞉ TimeInterval @{.inline.@}
@example
proc seconds*(s꞉ int)꞉ TimeInterval @{.inline.@}
@end example
  TimeInterval of @emph{s} seconds

@code{echo getTime() + 5.second}

@item minutes
  @findex proc minutes*(m꞉ int)꞉ TimeInterval @{.inline.@}
@example
proc minutes*(m꞉ int)꞉ TimeInterval @{.inline.@}
@end example
  TimeInterval of @emph{m} minutes

@code{echo getTime() + 5.minutes}

@item hours
  @findex proc hours*(h꞉ int)꞉ TimeInterval @{.inline.@}
@example
proc hours*(h꞉ int)꞉ TimeInterval @{.inline.@}
@end example
  TimeInterval of @emph{h} hours

@code{echo getTime() + 2.hours}

@item days
  @findex proc days*(d꞉ int)꞉ TimeInterval @{.inline.@}
@example
proc days*(d꞉ int)꞉ TimeInterval @{.inline.@}
@end example
  TimeInterval of @emph{d} days

@code{echo getTime() + 2.days}

@item months
  @findex proc months*(m꞉ int)꞉ TimeInterval @{.inline.@}
@example
proc months*(m꞉ int)꞉ TimeInterval @{.inline.@}
@end example
  TimeInterval of @emph{m} months

@code{echo getTime() + 2.months}

@item years
  @findex proc years*(y꞉ int)꞉ TimeInterval @{.inline.@}
@example
proc years*(y꞉ int)꞉ TimeInterval @{.inline.@}
@end example
  TimeInterval of @emph{y} years

@code{echo getTime() + 2.years}

@item `+=`
  @findex proc `+=`*(t꞉ var Time; ti꞉ TimeInterval)
@example
proc `+=`*(t꞉ var Time; ti꞉ TimeInterval)
@end example
  modifies @emph{t} by adding the interval @emph{ti}

@item `+`
  @findex proc `+`*(t꞉ Time; ti꞉ TimeInterval)꞉ Time
@example
proc `+`*(t꞉ Time; ti꞉ TimeInterval)꞉ Time
@end example
  adds the interval @emph{ti} to Time @emph{t} by converting to localTime, adding the interval, and converting back

@code{echo getTime() + 1.day}

@item `-=`
  @findex proc `-=`*(t꞉ var Time; ti꞉ TimeInterval)
@example
proc `-=`*(t꞉ var Time; ti꞉ TimeInterval)
@end example
  modifies @emph{t} by subtracting the interval @emph{ti}

@item `-`
  @findex proc `-`*(t꞉ Time; ti꞉ TimeInterval)꞉ Time
@example
proc `-`*(t꞉ Time; ti꞉ TimeInterval)꞉ Time
@end example
  adds the interval @emph{ti} to Time @emph{t}

@code{echo getTime() - 1.day}

@item format
  @findex proc format*(info꞉ TimeInfo; f꞉ string)꞉ string
@example
proc format*(info꞉ TimeInfo; f꞉ string)꞉ string
@end example
  This function formats @emph{info} as specified by @emph{f}. The following format specifiers are available:
@multitable @columnfractions  0.3333333333333333 0.3333333333333333 0.3333333333333333
@item @b{Specifier}
@tab @b{Description}

@tab @b{Example}
@item d
@tab Numeric value of the day of the month, it will be one or two digits long.

@tab @code{1/04/2012 -> 1}, @code{21/04/2012 -> 21}
@item dd
@tab Same as above, but always two digits.

@tab @code{1/04/2012 -> 01}, @code{21/04/2012 -> 21}
@item ddd
@tab Three letter string which indicates the day of the week.

@tab @code{Saturday -> Sat}, @code{Monday -> Mon}
@item dddd
@tab Full string for the day of the week.

@tab @code{Saturday -> Saturday}, @code{Monday -> Monday}
@item h
@tab The hours in one digit if possible. Ranging from 0-12.

@tab @code{5pm -> 5}, @code{2am -> 2}
@item hh
@tab The hours in two digits always. If the hour is one digit 0 is prepended.

@tab @code{5pm -> 05}, @code{11am -> 11}
@item H
@tab The hours in one digit if possible, randing from 0-24.

@tab @code{5pm -> 17}, @code{2am -> 2}
@item HH
@tab The hours in two digits always. 0 is prepended if the hour is one digit.

@tab @code{5pm -> 17}, @code{2am -> 02}
@item m
@tab The minutes in 1 digit if possible.

@tab @code{5:30 -> 30}, @code{2:01 -> 1}
@item mm
@tab Same as above but always 2 digits, 0 is prepended if the minute is one digit.

@tab @code{5:30 -> 30}, @code{2:01 -> 01}
@item M
@tab The month in one digit if possible.

@tab @code{September -> 9}, @code{December -> 12}
@item MM
@tab The month in two digits always. 0 is prepended.

@tab @code{September -> 09}, @code{December -> 12}
@item MMM
@tab Abbreviated three-letter form of the month.

@tab @code{September -> Sep}, @code{December -> Dec}
@item MMMM
@tab Full month string, properly capitalized.

@tab @code{September -> September}
@item s
@tab Seconds as one digit if possible.

@tab @code{00:00:06 -> 6}
@item ss
@tab Same as above but always two digits. 0 is prepended.

@tab @code{00:00:06 -> 06}
@item t
@tab @code{A} when time is in the AM. @code{P} when time is in the PM.

@tab 
@item tt
@tab Same as above, but @code{AM} and @code{PM} instead of @code{A} and @code{P} respectively.

@tab 
@item y(yyyy)
@tab This displays the year to different digits. You most likely only want 2 or 4 'y's

@tab 
@item yy
@tab Displays the year to two digits.

@tab @code{2012 -> 12}
@item yyyy
@tab Displays the year to four digits.

@tab @code{2012 -> 2012}
@item z
@tab Displays the timezone offset from UTC.

@tab @code{GMT+7 -> +7}, @code{GMT-5 -> -5}
@item zz
@tab Same as above but with leading 0.

@tab @code{GMT+7 -> +07}, @code{GMT-5 -> -05}
@item zzz
@tab Same as above but with @code{:00}.

@tab @code{GMT+7 -> +07:00}, @code{GMT-5 -> -05:00}
@item ZZZ
@tab Displays the name of the timezone.

@tab @code{GMT -> GMT}, @code{EST -> EST}


@end multitable
Other strings can be inserted by putting them in @code{''}. For example @code{hh'->'mm} will give @code{01->56}.  The following characters can be inserted without quoting them: @code{:} @code{-} @code{(} @code{)} @code{/} @code{[} @code{]} @code{,}. However you don't need to necessarily separate format specifiers, a unambiguous format string like @code{yyyyMMddhhmmss} is valid too.

@item parse
  @findex proc parse*(value, layout꞉ string)꞉ TimeInfo
@example
proc parse*(value, layout꞉ string)꞉ TimeInfo
@end example
  This function parses a date/time string using the standard format identifiers (below) The function defaults information not provided in the format string from the running program (timezone, month, year, etc)
@multitable @columnfractions  0.3333333333333333 0.3333333333333333 0.3333333333333333
@item @b{Specifier}
@tab @b{Description}

@tab @b{Example}
@item d
@tab Numeric value of the day of the month, it will be one or two digits long.

@tab @code{1/04/2012 -> 1}, @code{21/04/2012 -> 21}
@item dd
@tab Same as above, but always two digits.

@tab @code{1/04/2012 -> 01}, @code{21/04/2012 -> 21}
@item ddd
@tab Three letter string which indicates the day of the week.

@tab @code{Saturday -> Sat}, @code{Monday -> Mon}
@item dddd
@tab Full string for the day of the week.

@tab @code{Saturday -> Saturday}, @code{Monday -> Monday}
@item h
@tab The hours in one digit if possible. Ranging from 0-12.

@tab @code{5pm -> 5}, @code{2am -> 2}
@item hh
@tab The hours in two digits always. If the hour is one digit 0 is prepended.

@tab @code{5pm -> 05}, @code{11am -> 11}
@item H
@tab The hours in one digit if possible, randing from 0-24.

@tab @code{5pm -> 17}, @code{2am -> 2}
@item HH
@tab The hours in two digits always. 0 is prepended if the hour is one digit.

@tab @code{5pm -> 17}, @code{2am -> 02}
@item m
@tab The minutes in 1 digit if possible.

@tab @code{5:30 -> 30}, @code{2:01 -> 1}
@item mm
@tab Same as above but always 2 digits, 0 is prepended if the minute is one digit.

@tab @code{5:30 -> 30}, @code{2:01 -> 01}
@item M
@tab The month in one digit if possible.

@tab @code{September -> 9}, @code{December -> 12}
@item MM
@tab The month in two digits always. 0 is prepended.

@tab @code{September -> 09}, @code{December -> 12}
@item MMM
@tab Abbreviated three-letter form of the month.

@tab @code{September -> Sep}, @code{December -> Dec}
@item MMMM
@tab Full month string, properly capitalized.

@tab @code{September -> September}
@item s
@tab Seconds as one digit if possible.

@tab @code{00:00:06 -> 6}
@item ss
@tab Same as above but always two digits. 0 is prepended.

@tab @code{00:00:06 -> 06}
@item t
@tab @code{A} when time is in the AM. @code{P} when time is in the PM.

@tab 
@item tt
@tab Same as above, but @code{AM} and @code{PM} instead of @code{A} and @code{P} respectively.

@tab 
@item yy
@tab Displays the year to two digits.

@tab @code{2012 -> 12}
@item yyyy
@tab Displays the year to four digits.

@tab @code{2012 -> 2012}
@item z
@tab Displays the timezone offset from UTC.

@tab @code{GMT+7 -> +7}, @code{GMT-5 -> -5}
@item zz
@tab Same as above but with leading 0.

@tab @code{GMT+7 -> +07}, @code{GMT-5 -> -05}
@item zzz
@tab Same as above but with @code{:00}.

@tab @code{GMT+7 -> +07:00}, @code{GMT-5 -> -05:00}
@item ZZZ
@tab Displays the name of the timezone.

@tab @code{GMT -> GMT}, @code{EST -> EST}


@end multitable
Other strings can be inserted by putting them in @code{''}. For example @code{hh'->'mm} will give @code{01->56}.  The following characters can be inserted without quoting them: @code{:} @code{-} @code{(} @code{)} @code{/} @code{[} @code{]} @code{,}. However you don't need to necessarily separate format specifiers, a unambiguous format string like @code{yyyyMMddhhmmss} is valid too.

@item countLeapYears
  @findex proc countLeapYears*(yearSpan꞉ int)꞉ int
@example
proc countLeapYears*(yearSpan꞉ int)꞉ int
@end example
  Returns the number of leap years spanned by a given number of years.

Note: for leap years, start date is assumed to be 1 AD. counts the number of leap years up to January 1st of a given year. Keep in mind that if specified year is a leap year, the leap day has not happened before January 1st of that year.

@item countDays
  @findex proc countDays*(yearSpan꞉ int)꞉ int
@example
proc countDays*(yearSpan꞉ int)꞉ int
@end example
  Returns the number of days spanned by a given number of years.

@item countYears
  @findex proc countYears*(daySpan꞉ int)꞉ int
@example
proc countYears*(daySpan꞉ int)꞉ int
@end example
  Returns the number of years spanned by a given number of days.

@item countYearsAndDays
  @findex proc countYearsAndDays*(daySpan꞉ int)꞉ tuple[years꞉ int, days꞉ int]
@example
proc countYearsAndDays*(daySpan꞉ int)꞉ tuple[years꞉ int, days꞉ int]
@end example
  Returns the number of years spanned by a given number of days and the remainder as days.

@item getDayOfWeek
  @findex proc getDayOfWeek*(day, month, year꞉ int)꞉ WeekDay
@example
proc getDayOfWeek*(day, month, year꞉ int)꞉ WeekDay
@end example
  Returns the day of the week enum from day, month and year.

@item getDayOfWeekJulian
  @findex proc getDayOfWeekJulian*(day, month, year꞉ int)꞉ WeekDay
@example
proc getDayOfWeekJulian*(day, month, year꞉ int)꞉ WeekDay
@end example
  Returns the day of the week enum from day, month and year, according to the Julian calender.

@item timeToTimeInfo
  @findex proc timeToTimeInfo*(t꞉ Time)꞉ TimeInfo
@example
proc timeToTimeInfo*(t꞉ Time)꞉ TimeInfo
@end example
  Converts a Time to TimeInfo.

@item timeToTimeInterval
  @findex proc timeToTimeInterval*(t꞉ Time)꞉ TimeInterval
@example
proc timeToTimeInterval*(t꞉ Time)꞉ TimeInterval
@end example
  Converts a Time to a TimeInterval.
@end itemize






@node /pure/typetraits, /pure/oswalkdir , /pure/times, Top




@chapter Procedures

@itemize


@item name
  @findex proc name*(t꞉ typedesc)꞉ string @{.magic꞉ "TypeTrait".@}
@example
proc name*(t꞉ typedesc)꞉ string @{.magic꞉ "TypeTrait".@}
@end example
  Returns the name of the given type.

Example:


@example

import typetraits

proc `$`*[T](some:typedesc[T]): string = name(T)

template test(x): stmt =
  echo "type: ", type(x), ", value: ", x

test 42
# --> type: int, value: 42
test "Foo"
# --> type: string, value: Foo
test(@@['A','B'])
# --> type: seq[char], value: @@[A, B]
@end example

@item arity
  @findex proc arity*(t꞉ typedesc)꞉ int @{.magic꞉ "TypeTrait".@}
@example
proc arity*(t꞉ typedesc)꞉ int @{.magic꞉ "TypeTrait".@}
@end example
  Returns the arity of the given type
@end itemize






@node /pure/oswalkdir, /pure/osproc , /pure/typetraits, Top



@chapter Types

@itemize


@item PathComponent
  @tindex PathComponent* = enum
  pcFile,                     ## path refers to a file
  pcLinkToFile,               ## path refers to a symbolic link to a file
  pcDir,                      ## path refers to a directory
  pcLinkToDir                 ## path refers to a symbolic link to a directory
@example
PathComponent* = enum
  pcFile,                     ## path refers to a file
  pcLinkToFile,               ## path refers to a symbolic link to a file
  pcDir,                      ## path refers to a directory
  pcLinkToDir                 ## path refers to a symbolic link to a directory
@end example
  Enumeration specifying a path component.
@end itemize






@chapter Iterators

@itemize


@item walkDir
  @itindex iterator walkDir*(dir꞉ string; relative = false)꞉ tuple[kind꞉ PathComponent,path꞉ string]
@example
iterator walkDir*(dir꞉ string; relative = false)꞉ tuple[kind꞉ PathComponent,path꞉ string]
@end example
  

@item walkDirRec
  @itindex iterator walkDirRec*(dir꞉ string; filter = @{pcFile, pcDir@})꞉ string
@example
iterator walkDirRec*(dir꞉ string; filter = @{pcFile, pcDir@})꞉ string
@end example
  
@end itemize

@node /pure/osproc, /pure/dynlib , /pure/oswalkdir, Top
@chapter Constant variables

@itemize


@item poUseShell
  @vindex poUseShell* @{.deprecated.@} = poUsePath
@example
poUseShell* @{.deprecated.@} = poUsePath
@end example
  Deprecated alias for poUsePath.
@end itemize



@chapter Types

@itemize


@item Process
  @tindex Process* = ref ProcessObj
@example
Process* = ref ProcessObj
@end example
  represents an operating system process
@end itemize

@chapter Procedures

@itemize


@item quoteShellWindows
  @findex proc quoteShellWindows*(s꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nosp$1".@}
@example
proc quoteShellWindows*(s꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nosp$1".@}
@end example
  Quote s, so it can be safely passed to Windows API. Based on Python's subprocess.list2cmdline See @uref{http://msdn.microsoft.com/en-us/library/17w5ykft.aspx, http://msdn.microsoft.com/en-us/library/17w5ykft.aspx}

@item quoteShellPosix
  @findex proc quoteShellPosix*(s꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nosp$1".@}
@example
proc quoteShellPosix*(s꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nosp$1".@}
@end example
  Quote s, so it can be safely passed to POSIX shell. Based on Python's pipes.quote

@item quoteShell
  @findex proc quoteShell*(s꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nosp$1".@}
@example
proc quoteShell*(s꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nosp$1".@}
@end example
  Quote s, so it can be safely passed to shell.

@item execProcess
  @findex proc execProcess*(command: string; args: openArray[string] = [];
                 env: StringTableRef = nil; options: set[ProcessOption] = @{
    poStdErrToStdOut, poUsePath, poEvalCommand@}): TaintedString @{.rtl,
    extern: "nosp$1", tags: [ExecIOEffect, ReadIOEffect].@}
@example
proc execProcess*(command: string; args: openArray[string] = [];
                 env: StringTableRef = nil; options: set[ProcessOption] = @{
    poStdErrToStdOut, poUsePath, poEvalCommand@}): TaintedString @{.rtl,
    extern: "nosp$1", tags: [ExecIOEffect, ReadIOEffect].@}
@end example
  A convenience procedure that executes @code{command} with @code{startProcess} and returns its output as a string. WARNING: this function uses poEvalCommand by default for backward compatibility. Make sure to pass options explicitly.
@example

let outp = execProcess("nim c -r mytestfile.nim")
# Note: outp may have an interleave of text from the nim compile
# and any output from mytestfile when it runs
@end example

@item execCmd
  @findex proc execCmd*(command꞉ string)꞉ int @{.rtl, extern꞉ "nosp$1", tags꞉ [ExecIOEffect].@}
@example
proc execCmd*(command꞉ string)꞉ int @{.rtl, extern꞉ "nosp$1", tags꞉ [ExecIOEffect].@}
@end example
  Executes @code{command} and returns its error code. Standard input, output, error streams are inherited from the calling process. This operation is also often called .
@example

let errC = execCmd("nim c -r mytestfile.nim")
@end example

@item startProcess
  @findex proc startProcess*(command: string; workingDir: string = "";
                  args: openArray[string] = []; env: StringTableRef = nil;
                  options: set[ProcessOption] = @{poStdErrToStdOut@}): Process @{.rtl,
    extern: "nosp$1", tags: [ExecIOEffect, ReadEnvEffect].@}
@example
proc startProcess*(command: string; workingDir: string = "";
                  args: openArray[string] = []; env: StringTableRef = nil;
                  options: set[ProcessOption] = @{poStdErrToStdOut@}): Process @{.rtl,
    extern: "nosp$1", tags: [ExecIOEffect, ReadEnvEffect].@}
@end example
  Starts a process. @emph{Command} is the executable file, @emph{workingDir} is the process's working directory. If @code{workingDir == ""} the current directory is used. @emph{args} are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. @emph{args} should not contain this argument! @emph{env} is the environment that will be passed to the process. If @code{env == nil} the environment is inherited of the parent process. @emph{options} are additional flags that may be passed to @emph{startProcess}. See the documentation of @code{ProcessOption} for the meaning of these flags. You need to @emph{close} the process when done.

Note that you can't pass any @emph{args} if you use the option @code{poEvalCommand}, which invokes the system shell to run the specified @emph{command}. In this situation you have to concatenate manually the contents of @emph{args} to @emph{command} carefully escaping/quoting any special characters, since it will be passed @emph{as is} to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.

Return value: The newly created process object. Nil is never returned, but @code{EOS} is raised in case of an error.

@item startCmd
  @findex proc startCmd*(command꞉ string;options꞉ set[ProcessOption] = @{poStdErrToStdOut, poUsePath@})꞉ Process @{.tags꞉ [ExecIOEffect, ReadEnvEffect], deprecated.@}
@example
proc startCmd*(command꞉ string;options꞉ set[ProcessOption] = @{poStdErrToStdOut, poUsePath@})꞉ Process @{.tags꞉ [ExecIOEffect, ReadEnvEffect], deprecated.@}
@end example
  Deprecated - use @emph{startProcess} directly.

@item close
  @findex proc close*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc close*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  When the process has finished executing, cleanup related handles

@item suspend
  @findex proc suspend*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc suspend*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  Suspends the process @emph{p}.

@item resume
  @findex proc resume*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc resume*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  Resumes the process @emph{p}.

@item terminate
  @findex proc terminate*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc terminate*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  Stop the process @emph{p}. On Posix OSes the procedure sends @code{SIGTERM} to the process. On Windows the Win32 API function @code{TerminateProcess()} is called to stop the process.

@item kill
  @findex proc kill*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc kill*(p꞉ Process) @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  Kill the process @emph{p}. On Posix OSes the procedure sends @code{SIGKILL} to the process. On Windows @code{kill()} is simply an alias for @code{terminate()}.

@item running
  @findex proc running*(p꞉ Process)꞉ bool @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc running*(p꞉ Process)꞉ bool @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  Returns true iff the process @emph{p} is still running. Returns immediately.

@item processID
  @findex proc processID*(p꞉ Process)꞉ int @{.rtl, extern꞉ "nosp$1".@}
@example
proc processID*(p꞉ Process)꞉ int @{.rtl, extern꞉ "nosp$1".@}
@end example
  returns @emph{p}'s process ID.

@item waitForExit
  @findex proc waitForExit*(p꞉ Process; timeout꞉ int = - 1)꞉ int @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc waitForExit*(p꞉ Process; timeout꞉ int = - 1)꞉ int @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  waits for the process to finish and returns @emph{p}'s error code.

@strong{Warning}: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.

@item peekExitCode
  @findex proc peekExitCode*(p꞉ Process)꞉ int @{.tags꞉ [].@}
@example
proc peekExitCode*(p꞉ Process)꞉ int @{.tags꞉ [].@}
@end example
  return -1 if the process is still running. Otherwise the process' exit code

@item inputStream
  @findex proc inputStream*(p꞉ Process)꞉ Stream @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc inputStream*(p꞉ Process)꞉ Stream @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  returns @code{p}'s input stream for writing to.

@strong{Warning}: The returned @emph{Stream} should not be closed manually as it is closed when closing the Process @code{p}.

@item outputStream
  @findex proc outputStream*(p꞉ Process)꞉ Stream @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc outputStream*(p꞉ Process)꞉ Stream @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  returns @code{p}'s output stream for reading from.

@strong{Warning}: The returned @emph{Stream} should not be closed manually as it is closed when closing the Process @code{p}.

@item errorStream
  @findex proc errorStream*(p꞉ Process)꞉ Stream @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc errorStream*(p꞉ Process)꞉ Stream @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  returns @code{p}'s error stream for reading from.

@strong{Warning}: The returned @emph{Stream} should not be closed manually as it is closed when closing the Process @code{p}.

@item inputHandle
  @findex proc inputHandle*(p꞉ Process)꞉ FileHandle @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc inputHandle*(p꞉ Process)꞉ FileHandle @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  returns @code{p}'s input file handle for writing to.

@strong{Warning}: The returned @emph{FileHandle} should not be closed manually as it is closed when closing the Process @code{p}.

@item outputHandle
  @findex proc outputHandle*(p꞉ Process)꞉ FileHandle @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc outputHandle*(p꞉ Process)꞉ FileHandle @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  returns @code{p}'s output file handle for reading from.

@strong{Warning}: The returned @emph{FileHandle} should not be closed manually as it is closed when closing the Process @code{p}.

@item errorHandle
  @findex proc errorHandle*(p꞉ Process)꞉ FileHandle @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@example
proc errorHandle*(p꞉ Process)꞉ FileHandle @{.rtl, extern꞉ "nosp$1", tags꞉ [].@}
@end example
  returns @code{p}'s error file handle for reading from.

@strong{Warning}: The returned @emph{FileHandle} should not be closed manually as it is closed when closing the Process @code{p}.

@item countProcessors
  @findex proc countProcessors*()꞉ int @{.rtl, extern꞉ "nosp$1".@}
@example
proc countProcessors*()꞉ int @{.rtl, extern꞉ "nosp$1".@}
@end example
  returns the numer of the processors/cores the machine has. Returns 0 if it cannot be detected.

@item execProcesses
  @findex proc execProcesses*(cmds: openArray[string];
                   options = @{poStdErrToStdOut, poParentStreams@};
                   n = countProcessors(); beforeRunEvent: proc (idx: int) = nil;
                   afterRunEvent: proc (idx: int; p: Process) = nil): int @{.rtl,
    extern: "nosp$1", tags: [ExecIOEffect, TimeEffect, ReadEnvEffect, RootEffect].@}
@example
proc execProcesses*(cmds: openArray[string];
                   options = @{poStdErrToStdOut, poParentStreams@};
                   n = countProcessors(); beforeRunEvent: proc (idx: int) = nil;
                   afterRunEvent: proc (idx: int; p: Process) = nil): int @{.rtl,
    extern: "nosp$1", tags: [ExecIOEffect, TimeEffect, ReadEnvEffect, RootEffect].@}
@end example
  executes the commands @emph{cmds} in parallel. Creates @emph{n} processes that execute in parallel. The highest return value of all processes is returned. Runs @emph{beforeRunEvent} before running each command.

@item select
  @findex proc select*(readfds꞉ var seq[Process]; timeout = 500)꞉ int @{.benign.@}
@example
proc select*(readfds꞉ var seq[Process]; timeout = 500)꞉ int @{.benign.@}
@end example
  @emph{select} with a sensible Nim interface. @emph{timeout} is in milliseconds. Specify -1 for no timeout. Returns the number of processes that are ready to read from. The processes that are ready to be read from are removed from @emph{readfds}.

@strong{Warning}: This function may give unexpected or completely wrong results on Windows.

@item hasData
  @findex proc hasData*(p꞉ Process)꞉ bool
@example
proc hasData*(p꞉ Process)꞉ bool
@end example
  

@item execCmdEx
  @findex proc execCmdEx*(command꞉ string;options꞉ set[ProcessOption] = @{poStdErrToStdOut, poUsePath@})꞉ tuple[output꞉ TaintedString, exitCode꞉ int] @{.tags꞉ [ExecIOEffect, ReadIOEffect], gcsafe.@}
@example
proc execCmdEx*(command꞉ string;options꞉ set[ProcessOption] = @{poStdErrToStdOut, poUsePath@})꞉ tuple[output꞉ TaintedString, exitCode꞉ int] @{.tags꞉ [ExecIOEffect, ReadIOEffect], gcsafe.@}
@end example
  a convenience proc that runs the @emph{command}, grabs all its output and exit code and returns both.
@example

let (outp, errC) = execCmdEx("nim c -r mytestfile.nim")
@end example
@end itemize






@node /pure/dynlib, /pure/gentabs , /pure/osproc, Top



@chapter Types

@itemize


@item LibHandle
  @tindex LibHandle* = pointer
@example
LibHandle* = pointer
@end example
  a handle to a dynamically loaded library
@end itemize

@chapter Procedures

@itemize


@item loadLib
  @findex proc loadLib*(path꞉ string; global_symbols = false)꞉ LibHandle
@example
proc loadLib*(path꞉ string; global_symbols = false)꞉ LibHandle
@end example
  loads a library from @emph{path}. Returns nil if the library could not be loaded.

@item loadLib
  @findex proc loadLib*()꞉ LibHandle
@example
proc loadLib*()꞉ LibHandle
@end example
  gets the handle from the current executable. Returns nil if the library could not be loaded.

@item unloadLib
  @findex proc unloadLib*(lib꞉ LibHandle)
@example
proc unloadLib*(lib꞉ LibHandle)
@end example
  unloads the library @emph{lib}

@item raiseInvalidLibrary
  @findex proc raiseInvalidLibrary*(name꞉ cstring) @{.noinline, noreturn.@}
@example
proc raiseInvalidLibrary*(name꞉ cstring) @{.noinline, noreturn.@}
@end example
  raises an @emph{EInvalidLibrary} exception.

@item symAddr
  @findex proc symAddr*(lib꞉ LibHandle; name꞉ cstring)꞉ pointer
@example
proc symAddr*(lib꞉ LibHandle; name꞉ cstring)꞉ pointer
@end example
  retrieves the address of a procedure/variable from @emph{lib}. Returns nil if the symbol could not be found.

@item checkedSymAddr
  @findex proc checkedSymAddr*(lib꞉ LibHandle; name꞉ cstring)꞉ pointer
@example
proc checkedSymAddr*(lib꞉ LibHandle; name꞉ cstring)꞉ pointer
@end example
  retrieves the address of a procedure/variable from @emph{lib}. Raises @emph{EInvalidLibrary} if the symbol could not be found.
@end itemize






@node /pure/gentabs, /pure/numeric , /pure/dynlib, Top



@chapter Types

@itemize


@item PGenTable
  @tindex PGenTable*[T] = ref GenTable[T]
@example
PGenTable*[T] = ref GenTable[T]
@end example
  use this type to declare hash tables
@end itemize

@chapter Procedures

@itemize


@item len
  @findex proc len*[T](tbl꞉ PGenTable[T])꞉ int @{.inline.@}
@example
proc len*[T](tbl꞉ PGenTable[T])꞉ int @{.inline.@}
@end example
  returns the number of keys in @emph{tbl}.

@item newGenTable
  @findex proc newGenTable*[T](mode꞉ GenTableMode)꞉ PGenTable[T]
@example
proc newGenTable*[T](mode꞉ GenTableMode)꞉ PGenTable[T]
@end example
  creates a new generic hash table that is empty.

@item hasKey
  @findex proc hasKey*[T](tbl꞉ PGenTable[T]; key꞉ string)꞉ bool
@example
proc hasKey*[T](tbl꞉ PGenTable[T]; key꞉ string)꞉ bool
@end example
  returns true iff @emph{key} is in the table @emph{tbl}.

@item `[]`
  @findex proc `[]`*[T](tbl꞉ PGenTable[T]; key꞉ string)꞉ T
@example
proc `[]`*[T](tbl꞉ PGenTable[T]; key꞉ string)꞉ T
@end example
  retrieves the value at @code{tbl[key]}. If @emph{key} is not in @emph{tbl}, default(T) is returned and no exception is raised. One can check with @code{hasKey} whether the key exists.

@item `[]=`
  @findex proc `[]=`*[T](tbl꞉ PGenTable[T]; key꞉ string; val꞉ T)
@example
proc `[]=`*[T](tbl꞉ PGenTable[T]; key꞉ string; val꞉ T)
@end example
  puts a (key, value)-pair into @emph{tbl}.
@end itemize





@chapter Iterators

@itemize


@item pairs
  @itindex iterator pairs*[T](tbl꞉ PGenTable[T])꞉ tuple[key꞉ string, value꞉ T]
@example
iterator pairs*[T](tbl꞉ PGenTable[T])꞉ tuple[key꞉ string, value꞉ T]
@end example
  iterates over any (key, value) pair in the table @emph{tbl}.
@end itemize

@node /pure/numeric, /pure/hashes , /pure/gentabs, Top



@chapter Types

@itemize


@item OneVarFunction
  @tindex OneVarFunction* = proc (x꞉ float)꞉ float
@example
OneVarFunction* = proc (x꞉ float)꞉ float
@end example
  
@end itemize

@chapter Procedures

@itemize


@item brent
  @findex proc brent*(xmin, xmax꞉ float; function꞉ OneVarFunction; tol꞉ float; maxiter = 1000)꞉ tuple[rootx, rooty꞉ float, success꞉ bool]
@example
proc brent*(xmin, xmax꞉ float; function꞉ OneVarFunction; tol꞉ float; maxiter = 1000)꞉ tuple[rootx, rooty꞉ float, success꞉ bool]
@end example
  Searches @emph{function} for a root between @emph{xmin} and @emph{xmax} using brents method. If the function value at @emph{xmin`and `xmax} has the same sign, @emph{rootx}/@emph{rooty} is set too the extrema value closest to x-axis and succes is set to false. Otherwise there exists at least one root and success is set to true. This root is searched for at most @emph{maxiter} iterations. If @emph{tol} tolerance is reached within @emph{maxiter} iterations the root refinement stops and success=true.
@end itemize






@node /pure/hashes, /pure/nativesockets , /pure/numeric, Top



@chapter Types

@itemize


@item Hash
  @tindex Hash* = int
@example
Hash* = int
@end example
  a hash value; hash tables using these values should always have a size of a power of two and can use the @code{and} operator instead of @code{mod} for truncation of the hash value.
@end itemize

@chapter Procedures

@itemize


@item `!&`
  @findex proc `!&`*(h꞉ Hash; val꞉ int)꞉ Hash @{.inline.@}
@example
proc `!&`*(h꞉ Hash; val꞉ int)꞉ Hash @{.inline.@}
@end example
  mixes a hash value @emph{h} with @emph{val} to produce a new hash value. This is only needed if you need to implement a hash proc for a new datatype.

@item `!$`
  @findex proc `!$`*(h꞉ Hash)꞉ Hash @{.inline.@}
@example
proc `!$`*(h꞉ Hash)꞉ Hash @{.inline.@}
@end example
  finishes the computation of the hash value. This is only needed if you need to implement a hash proc for a new datatype.

@item hashData
  @findex proc hashData*(data꞉ pointer; size꞉ int)꞉ Hash
@example
proc hashData*(data꞉ pointer; size꞉ int)꞉ Hash
@end example
  hashes an array of bytes of size @emph{size}

@item hash
  @findex proc hash*(x꞉ pointer)꞉ Hash @{.inline.@}
@example
proc hash*(x꞉ pointer)꞉ Hash @{.inline.@}
@end example
  efficient hashing of pointers

@item hash
  @findex proc hash*[T꞉ proc](x꞉ T)꞉ Hash @{.inline.@}
@example
proc hash*[T꞉ proc](x꞉ T)꞉ Hash @{.inline.@}
@end example
  efficient hashing of proc vars; closures are supported too.

@item hash
  @findex proc hash*(x꞉ int)꞉ Hash @{.inline.@}
@example
proc hash*(x꞉ int)꞉ Hash @{.inline.@}
@end example
  efficient hashing of integers

@item hash
  @findex proc hash*(x꞉ int64)꞉ Hash @{.inline.@}
@example
proc hash*(x꞉ int64)꞉ Hash @{.inline.@}
@end example
  efficient hashing of int64 integers

@item hash
  @findex proc hash*(x꞉ char)꞉ Hash @{.inline.@}
@example
proc hash*(x꞉ char)꞉ Hash @{.inline.@}
@end example
  efficient hashing of characters

@item hash
  @findex proc hash*[T꞉ Ordinal](x꞉ T)꞉ Hash @{.inline.@}
@example
proc hash*[T꞉ Ordinal](x꞉ T)꞉ Hash @{.inline.@}
@end example
  efficient hashing of other ordinal types (e.g., enums)

@item hash
  @findex proc hash*(x꞉ string)꞉ Hash
@example
proc hash*(x꞉ string)꞉ Hash
@end example
  efficient hashing of strings

@item hash
  @findex proc hash*(sBuf꞉ string; sPos, ePos꞉ int)꞉ Hash
@example
proc hash*(sBuf꞉ string; sPos, ePos꞉ int)꞉ Hash
@end example
  efficient hashing of a string buffer, from starting position @emph{sPos} to ending position @emph{ePos}

@code{hash(myStr, 0, myStr.high)} is equivalent to @code{hash(myStr)}

@item hashIgnoreStyle
  @findex proc hashIgnoreStyle*(x꞉ string)꞉ Hash
@example
proc hashIgnoreStyle*(x꞉ string)꞉ Hash
@end example
  efficient hashing of strings; style is ignored

@item hashIgnoreStyle
  @findex proc hashIgnoreStyle*(sBuf꞉ string; sPos, ePos꞉ int)꞉ Hash
@example
proc hashIgnoreStyle*(sBuf꞉ string; sPos, ePos꞉ int)꞉ Hash
@end example
  efficient hashing of a string buffer, from starting position @emph{sPos} to ending position @emph{ePos}; style is ignored

@code{hashIgnoreStyle(myBuf, 0, myBuf.high)} is equivalent to @code{hashIgnoreStyle(myBuf)}

@item hashIgnoreCase
  @findex proc hashIgnoreCase*(x꞉ string)꞉ Hash
@example
proc hashIgnoreCase*(x꞉ string)꞉ Hash
@end example
  efficient hashing of strings; case is ignored

@item hashIgnoreCase
  @findex proc hashIgnoreCase*(sBuf꞉ string; sPos, ePos꞉ int)꞉ Hash
@example
proc hashIgnoreCase*(sBuf꞉ string; sPos, ePos꞉ int)꞉ Hash
@end example
  efficient hashing of a string buffer, from starting position @emph{sPos} to ending position @emph{ePos}; case is ignored

@code{hashIgnoreCase(myBuf, 0, myBuf.high)} is equivalent to @code{hashIgnoreCase(myBuf)}

@item hash
  @findex proc hash*(x꞉ float)꞉ Hash @{.inline.@}
@example
proc hash*(x꞉ float)꞉ Hash @{.inline.@}
@end example
  efficient hashing of floats.

@item hash
  @findex proc hash*[A](x꞉ openArray[A])꞉ Hash
@example
proc hash*[A](x꞉ openArray[A])꞉ Hash
@end example
  

@item hash
  @findex proc hash*[A](x꞉ set[A])꞉ Hash
@example
proc hash*[A](x꞉ set[A])꞉ Hash
@end example
  

@item hash
  @findex proc hash*[T꞉ tuple](x꞉ T)꞉ Hash
@example
proc hash*[T꞉ tuple](x꞉ T)꞉ Hash
@end example
  efficient hashing of tuples.

@item hash
  @findex proc hash*[A](x꞉ openArray[A])꞉ Hash
@example
proc hash*[A](x꞉ openArray[A])꞉ Hash
@end example
  efficient hashing of arrays and sequences.

@item hash
  @findex proc hash*[A](aBuf꞉ openArray[A]; sPos, ePos꞉ int)꞉ Hash
@example
proc hash*[A](aBuf꞉ openArray[A]; sPos, ePos꞉ int)꞉ Hash
@end example
  efficient hashing of portions of arrays and sequences.

@code{hash(myBuf, 0, myBuf.high)} is equivalent to @code{hash(myBuf)}

@item hash
  @findex proc hash*[A](x꞉ set[A])꞉ Hash
@example
proc hash*[A](x꞉ set[A])꞉ Hash
@end example
  efficient hashing of sets.
@end itemize






@node /pure/nativesockets, /pure/xmldom , /pure/hashes, Top

@chapter Let variable

@itemize


@item osInvalidSocket
  @vindex osInvalidSocket* = winlean.INVALID_SOCKET
@example
osInvalidSocket* = winlean.INVALID_SOCKET
@end example
  
@end itemize


@chapter Types

@itemize


@item Hostent
  @tindex Hostent* = object
  name*: string
  aliases*: seq[string]
  addrtype*: Domain
  length*: int
  addrList*: seq[string]

@example
Hostent* = object
  name*: string
  aliases*: seq[string]
  addrtype*: Domain
  length*: int
  addrList*: seq[string]

@end example
  information about a given host
@end itemize

@chapter Procedures

@itemize


@item ioctlsocket
  @findex proc ioctlsocket*(s꞉ SocketHandle; cmd꞉ clong; argptr꞉ ptr clong)꞉ cint @{.stdcall,importc꞉ "ioctlsocket", dynlib꞉ "ws2_32.dll".@}
@example
proc ioctlsocket*(s꞉ SocketHandle; cmd꞉ clong; argptr꞉ ptr clong)꞉ cint @{.stdcall,importc꞉ "ioctlsocket", dynlib꞉ "ws2_32.dll".@}
@end example
  

@item `==`
  @findex proc `==`*(a, b꞉ Port)꞉ bool @{.borrow.@}
@example
proc `==`*(a, b꞉ Port)꞉ bool @{.borrow.@}
@end example
  @code{==} for ports.

@item `$`
  @findex proc `$`*(p꞉ Port)꞉ string @{.borrow.@}
@example
proc `$`*(p꞉ Port)꞉ string @{.borrow.@}
@end example
  returns the port number as a string

@item toInt
  @findex proc toInt*(domain꞉ Domain)꞉ cint
@example
proc toInt*(domain꞉ Domain)꞉ cint
@end example
  Converts the Domain enum to a platform-dependent @code{cint}.

@item toInt
  @findex proc toInt*(typ꞉ SockType)꞉ cint
@example
proc toInt*(typ꞉ SockType)꞉ cint
@end example
  Converts the SockType enum to a platform-dependent @code{cint}.

@item toInt
  @findex proc toInt*(p꞉ Protocol)꞉ cint
@example
proc toInt*(p꞉ Protocol)꞉ cint
@end example
  Converts the Protocol enum to a platform-dependent @code{cint}.

@item newNativeSocket
  @findex proc newNativeSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP)꞉ SocketHandle
@example
proc newNativeSocket*(domain꞉ Domain = AF_INET; sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP)꞉ SocketHandle
@end example
  Creates a new socket; returns @emph{InvalidSocket} if an error occurs.

@item newNativeSocket
  @findex proc newNativeSocket*(domain꞉ cint; sockType꞉ cint; protocol꞉ cint)꞉ SocketHandle
@example
proc newNativeSocket*(domain꞉ cint; sockType꞉ cint; protocol꞉ cint)꞉ SocketHandle
@end example
  Creates a new socket; returns @emph{InvalidSocket} if an error occurs.

Use this overload if one of the enums specified above does not contain what you need.

@item close
  @findex proc close*(socket꞉ SocketHandle)
@example
proc close*(socket꞉ SocketHandle)
@end example
  closes a socket.

@item bindAddr
  @findex proc bindAddr*(socket꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ SockLen)꞉ cint
@example
proc bindAddr*(socket꞉ SocketHandle; name꞉ ptr SockAddr; namelen꞉ SockLen)꞉ cint
@end example
  

@item listen
  @findex proc listen*(socket꞉ SocketHandle; backlog = SOMAXCONN)꞉ cint @{.tags꞉ [ReadIOEffect].@}
@example
proc listen*(socket꞉ SocketHandle; backlog = SOMAXCONN)꞉ cint @{.tags꞉ [ReadIOEffect].@}
@end example
  Marks @code{socket} as accepting connections. @code{Backlog} specifies the maximum length of the queue of pending connections.

@item getAddrInfo
  @findex proc getAddrInfo*(address꞉ string; port꞉ Port; domain꞉ Domain = AF_INET;sockType꞉ SockType = SOCK_STREAM; protocol꞉ Protocol = IPPROTO_TCP)꞉ ptr AddrInfo
@example
proc getAddrInfo*(address꞉ string; port꞉ Port; domain꞉ Domain = AF_INET;sockType꞉ SockType = SOCK_STREAM; protocol꞉ Protocol = IPPROTO_TCP)꞉ ptr AddrInfo
@end example
  @quotation @strong{Warning}: The resulting @code{ptr TAddrInfo} must be freed using @code{dealloc}! 
@end quotation

@item dealloc
  @findex proc dealloc*(ai꞉ ptr AddrInfo)
@example
proc dealloc*(ai꞉ ptr AddrInfo)
@end example
  

@item ntohl
  @findex proc ntohl*(x꞉ int32)꞉ int32
@example
proc ntohl*(x꞉ int32)꞉ int32
@end example
  Converts 32-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.

@item ntohs
  @findex proc ntohs*(x꞉ int16)꞉ int16
@example
proc ntohs*(x꞉ int16)꞉ int16
@end example
  Converts 16-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.

@item getServByName
  @findex proc getServByName*(name, proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@example
proc getServByName*(name, proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@end example
  Searches the database from the beginning and finds the first entry for which the service name specified by @code{name} matches the s_name member and the protocol name specified by @code{proto} matches the s_proto member.

On posix this will search through the @code{/etc/services} file.

@item getServByPort
  @findex proc getServByPort*(port꞉ Port; proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@example
proc getServByPort*(port꞉ Port; proto꞉ string)꞉ Servent @{.tags꞉ [ReadIOEffect].@}
@end example
  Searches the database from the beginning and finds the first entry for which the port specified by @code{port} matches the s_port member and the protocol name specified by @code{proto} matches the s_proto member.

On posix this will search through the @code{/etc/services} file.

@item getHostByAddr
  @findex proc getHostByAddr*(ip꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@example
proc getHostByAddr*(ip꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@end example
  This function will lookup the hostname of an IP Address.

@item getHostByName
  @findex proc getHostByName*(name꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@example
proc getHostByName*(name꞉ string)꞉ Hostent @{.tags꞉ [ReadIOEffect].@}
@end example
  This function will lookup the IP address of a hostname.

@item getSockDomain
  @findex proc getSockDomain*(socket꞉ SocketHandle)꞉ Domain
@example
proc getSockDomain*(socket꞉ SocketHandle)꞉ Domain
@end example
  returns the socket's domain (AF_INET or AF_INET6).

@item getAddrString
  @findex proc getAddrString*(sockAddr꞉ ptr SockAddr)꞉ string
@example
proc getAddrString*(sockAddr꞉ ptr SockAddr)꞉ string
@end example
  return the string representation of address within sockAddr

@item getSockName
  @findex proc getSockName*(socket꞉ SocketHandle)꞉ Port
@example
proc getSockName*(socket꞉ SocketHandle)꞉ Port
@end example
  returns the socket's associated port number.

@item getLocalAddr
  @findex proc getLocalAddr*(socket꞉ SocketHandle; domain꞉ Domain)꞉ (string, Port)
@example
proc getLocalAddr*(socket꞉ SocketHandle; domain꞉ Domain)꞉ (string, Port)
@end example
  returns the socket's local address and port number.

Similar to POSIX's .

@item getPeerAddr
  @findex proc getPeerAddr*(socket꞉ SocketHandle; domain꞉ Domain)꞉ (string, Port)
@example
proc getPeerAddr*(socket꞉ SocketHandle; domain꞉ Domain)꞉ (string, Port)
@end example
  returns the socket's peer address and port number.

Similar to POSIX's

@item getSockOptInt
  @findex proc getSockOptInt*(socket꞉ SocketHandle; level, optname꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc getSockOptInt*(socket꞉ SocketHandle; level, optname꞉ int)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  getsockopt for integer options.

@item setSockOptInt
  @findex proc setSockOptInt*(socket꞉ SocketHandle; level, optname, optval꞉ int) @{.tags꞉ [WriteIOEffect].@}
@example
proc setSockOptInt*(socket꞉ SocketHandle; level, optname, optval꞉ int) @{.tags꞉ [WriteIOEffect].@}
@end example
  setsockopt for integer options.

@item setBlocking
  @findex proc setBlocking*(s꞉ SocketHandle; blocking꞉ bool)
@example
proc setBlocking*(s꞉ SocketHandle; blocking꞉ bool)
@end example
  Sets blocking mode on socket.

Raises EOS on error.

@item select
  @findex proc select*(readfds꞉ var seq[SocketHandle]; timeout = 500)꞉ int
@example
proc select*(readfds꞉ var seq[SocketHandle]; timeout = 500)꞉ int
@end example
  Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. @code{Timeout} is in milliseconds and -1 can be specified for no timeout.

A socket is removed from the specific @code{seq} when it has data waiting to be read/written to or has errors (@code{exceptfds}).

@item selectWrite
  @findex proc selectWrite*(writefds꞉ var seq[SocketHandle]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc selectWrite*(writefds꞉ var seq[SocketHandle]; timeout = 500)꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  When a socket in @code{writefds} is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which can be written to will also be removed from @code{writefds}.

@code{timeout} is specified in milliseconds and @code{-1} can be specified for an unlimited time.
@end itemize

@chapter Templates

@itemize


@item htonl
  @findex template htonl*(x꞉ int32)꞉ expr
@example
template htonl*(x꞉ int32)꞉ expr
@end example
  Converts 32-bit integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.

@item htons
  @findex template htons*(x꞉ int16)꞉ expr
@example
template htons*(x꞉ int16)꞉ expr
@end example
  Converts 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.
@end itemize





@node /pure/xmldom, /pure/coro , /pure/nativesockets, Top



@chapter Types

@itemize


@item EWrongDocumentErr
  @tindex EWrongDocumentErr* = object of EDOMException
@example
EWrongDocumentErr* = object of EDOMException
@end example
  If a node is used in a different document than the one that created it (that doesn't support it)
@end itemize

@chapter Procedures

@itemize


@item getDOM
  @findex proc getDOM*()꞉ PDOMImplementation
@example
proc getDOM*()꞉ PDOMImplementation
@end example
  Returns a DOMImplementation

@item createDocument
  @findex proc createDocument*(dom꞉ PDOMImplementation; namespaceURI꞉ string;qualifiedName꞉ string)꞉ PDocument
@example
proc createDocument*(dom꞉ PDOMImplementation; namespaceURI꞉ string;qualifiedName꞉ string)꞉ PDocument
@end example
  Creates an XML Document object of the specified type with its document element.

@item createDocument
  @findex proc createDocument*(dom꞉ PDOMImplementation; n꞉ PElement)꞉ PDocument
@example
proc createDocument*(dom꞉ PDOMImplementation; n꞉ PElement)꞉ PDocument
@end example
  Creates an XML Document object of the specified type with its document element.

@item hasFeature
  @findex proc hasFeature*(dom꞉ PDOMImplementation; feature꞉ string; version꞉ string = "")꞉ bool
@example
proc hasFeature*(dom꞉ PDOMImplementation; feature꞉ string; version꞉ string = "")꞉ bool
@end example
  Returns @code{true} if this @code{version} of the DomImplementation implements @code{feature}, otherwise @code{false}

@item implementation
  @findex proc implementation*(doc꞉ PDocument)꞉ PDOMImplementation
@example
proc implementation*(doc꞉ PDocument)꞉ PDOMImplementation
@end example
  

@item documentElement
  @findex proc documentElement*(doc꞉ PDocument)꞉ PElement
@example
proc documentElement*(doc꞉ PDocument)꞉ PElement
@end example
  

@item createAttribute
  @findex proc createAttribute*(doc꞉ PDocument; name꞉ string)꞉ PAttr
@example
proc createAttribute*(doc꞉ PDocument; name꞉ string)꞉ PAttr
@end example
  Creates an Attr of the given name. Note that the Attr instance can then be set on an Element using the setAttributeNode method. To create an attribute with a qualified name and namespace URI, use the createAttributeNS method.

@item createAttributeNS
  @findex proc createAttributeNS*(doc꞉ PDocument; namespaceURI꞉ string; qualifiedName꞉ string)꞉ PAttr
@example
proc createAttributeNS*(doc꞉ PDocument; namespaceURI꞉ string; qualifiedName꞉ string)꞉ PAttr
@end example
  Creates an attribute of the given qualified name and namespace URI

@item createCDATASection
  @findex proc createCDATASection*(doc꞉ PDocument; data꞉ string)꞉ PCDataSection
@example
proc createCDATASection*(doc꞉ PDocument; data꞉ string)꞉ PCDataSection
@end example
  Creates a CDATASection node whose value is the specified string.

@item createComment
  @findex proc createComment*(doc꞉ PDocument; data꞉ string)꞉ PComment
@example
proc createComment*(doc꞉ PDocument; data꞉ string)꞉ PComment
@end example
  Creates a Comment node given the specified string.

@item createDocumentFragment
  @findex proc createDocumentFragment*(doc꞉ PDocument)꞉ PDocumentFragment
@example
proc createDocumentFragment*(doc꞉ PDocument)꞉ PDocumentFragment
@end example
  Creates an empty DocumentFragment object.

@item createElement
  @findex proc createElement*(doc꞉ PDocument; tagName꞉ string)꞉ PElement
@example
proc createElement*(doc꞉ PDocument; tagName꞉ string)꞉ PElement
@end example
  Creates an element of the type specified.

@item createElementNS
  @findex proc createElementNS*(doc꞉ PDocument; namespaceURI꞉ string; qualifiedName꞉ string)꞉ PElement
@example
proc createElementNS*(doc꞉ PDocument; namespaceURI꞉ string; qualifiedName꞉ string)꞉ PElement
@end example
  Creates an element of the given qualified name and namespace URI.

@item createProcessingInstruction
  @findex proc createProcessingInstruction*(doc꞉ PDocument; target꞉ string; data꞉ string)꞉ PProcessingInstruction
@example
proc createProcessingInstruction*(doc꞉ PDocument; target꞉ string; data꞉ string)꞉ PProcessingInstruction
@end example
  Creates a ProcessingInstruction node given the specified name and data strings.

@item createTextNode
  @findex proc createTextNode*(doc꞉ PDocument; data꞉ string)꞉ PText
@example
proc createTextNode*(doc꞉ PDocument; data꞉ string)꞉ PText
@end example
  Creates a Text node given the specified string.

@item getElementsByTagName
  @findex proc getElementsByTagName*(doc꞉ PDocument; tagName꞉ string)꞉ seq[PNode]
@example
proc getElementsByTagName*(doc꞉ PDocument; tagName꞉ string)꞉ seq[PNode]
@end example
  Returns a NodeList of all the Elements with a given tag name in the order in which they are encountered in a preorder traversal of the Document tree.

@item getElementsByTagNameNS
  @findex proc getElementsByTagNameNS*(doc꞉ PDocument; namespaceURI꞉ string; localName꞉ string)꞉ seq[PNode]
@example
proc getElementsByTagNameNS*(doc꞉ PDocument; namespaceURI꞉ string; localName꞉ string)꞉ seq[PNode]
@end example
  Returns a NodeList of all the Elements with a given localName and namespaceURI in the order in which they are encountered in a preorder traversal of the Document tree.

@item importNode
  @findex proc importNode*(doc꞉ PDocument; importedNode꞉ PNode; deep꞉ bool)꞉ PNode
@example
proc importNode*(doc꞉ PDocument; importedNode꞉ PNode; deep꞉ bool)꞉ PNode
@end example
  Imports a node from another document to this document

@item firstChild
  @findex proc firstChild*(n꞉ PNode)꞉ PNode
@example
proc firstChild*(n꞉ PNode)꞉ PNode
@end example
  Returns this node's first child

@item lastChild
  @findex proc lastChild*(n꞉ PNode)꞉ PNode
@example
proc lastChild*(n꞉ PNode)꞉ PNode
@end example
  Returns this node's last child

@item localName
  @findex proc localName*(n꞉ PNode)꞉ string
@example
proc localName*(n꞉ PNode)꞉ string
@end example
  Returns this nodes local name

@item namespaceURI
  @findex proc namespaceURI*(n꞉ PNode)꞉ string
@example
proc namespaceURI*(n꞉ PNode)꞉ string
@end example
  Returns this nodes namespace URI

@item `namespaceURI=`
  @findex proc `namespaceURI =`*(n꞉ PNode; value꞉ string)
@example
proc `namespaceURI =`*(n꞉ PNode; value꞉ string)
@end example
  

@item nextSibling
  @findex proc nextSibling*(n꞉ PNode)꞉ PNode
@example
proc nextSibling*(n꞉ PNode)꞉ PNode
@end example
  Returns the next sibling of this node

@item nodeName
  @findex proc nodeName*(n꞉ PNode)꞉ string
@example
proc nodeName*(n꞉ PNode)꞉ string
@end example
  Returns the name of this node

@item nodeType
  @findex proc nodeType*(n꞉ PNode)꞉ int
@example
proc nodeType*(n꞉ PNode)꞉ int
@end example
  Returns the type of this node

@item ownerDocument
  @findex proc ownerDocument*(n꞉ PNode)꞉ PDocument
@example
proc ownerDocument*(n꞉ PNode)꞉ PDocument
@end example
  Returns the owner document of this node

@item parentNode
  @findex proc parentNode*(n꞉ PNode)꞉ PNode
@example
proc parentNode*(n꞉ PNode)꞉ PNode
@end example
  Returns the parent node of this node

@item previousSibling
  @findex proc previousSibling*(n꞉ PNode)꞉ PNode
@example
proc previousSibling*(n꞉ PNode)꞉ PNode
@end example
  Returns the previous sibling of this node

@item `prefix=`
  @findex proc `prefix =`*(n꞉ PNode; value꞉ string)
@example
proc `prefix =`*(n꞉ PNode; value꞉ string)
@end example
  Modifies the prefix of this node

@item appendChild
  @findex proc appendChild*(n꞉ PNode; newChild꞉ PNode)
@example
proc appendChild*(n꞉ PNode; newChild꞉ PNode)
@end example
  Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.

@item cloneNode
  @findex proc cloneNode*(n꞉ PNode; deep꞉ bool)꞉ PNode
@example
proc cloneNode*(n꞉ PNode; deep꞉ bool)꞉ PNode
@end example
  Returns a duplicate of this node, if @code{deep} is @emph{true}, Element node's children are copied

@item hasAttributes
  @findex proc hasAttributes*(n꞉ PNode)꞉ bool
@example
proc hasAttributes*(n꞉ PNode)꞉ bool
@end example
  Returns whether this node (if it is an element) has any attributes.

@item hasChildNodes
  @findex proc hasChildNodes*(n꞉ PNode)꞉ bool
@example
proc hasChildNodes*(n꞉ PNode)꞉ bool
@end example
  Returns whether this node has any children.

@item insertBefore
  @findex proc insertBefore*(n꞉ PNode; newChild꞉ PNode; refChild꞉ PNode)꞉ PNode
@example
proc insertBefore*(n꞉ PNode; newChild꞉ PNode; refChild꞉ PNode)꞉ PNode
@end example
  Inserts the node @code{newChild} before the existing child node @code{refChild}. If @code{refChild} is nil, insert @code{newChild} at the end of the list of children.

@item isSupported
  @findex proc isSupported*(n꞉ PNode; feature꞉ string; version꞉ string)꞉ bool
@example
proc isSupported*(n꞉ PNode; feature꞉ string; version꞉ string)꞉ bool
@end example
  Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.

@item normalize
  @findex proc normalize*(n꞉ PNode)
@example
proc normalize*(n꞉ PNode)
@end example
  Merges all separated TextNodes together, and removes any empty TextNodes

@item removeChild
  @findex proc removeChild*(n꞉ PNode; oldChild꞉ PNode)꞉ PNode
@example
proc removeChild*(n꞉ PNode; oldChild꞉ PNode)꞉ PNode
@end example
  Removes the child node indicated by @code{oldChild} from the list of children, and returns it.

@item replaceChild
  @findex proc replaceChild*(n꞉ PNode; newChild꞉ PNode; oldChild꞉ PNode)꞉ PNode
@example
proc replaceChild*(n꞉ PNode; newChild꞉ PNode; oldChild꞉ PNode)꞉ PNode
@end example
  Replaces the child node @code{oldChild} with @code{newChild} in the list of children, and returns the @code{oldChild} node.

@item getNamedItem
  @findex proc getNamedItem*(nList꞉ seq[PNode]; name꞉ string)꞉ PNode
@example
proc getNamedItem*(nList꞉ seq[PNode]; name꞉ string)꞉ PNode
@end example
  Retrieves a node specified by @code{name}. If this node cannot be found returns @code{nil}

@item getNamedItem
  @findex proc getNamedItem*(nList꞉ seq[PAttr]; name꞉ string)꞉ PAttr
@example
proc getNamedItem*(nList꞉ seq[PAttr]; name꞉ string)꞉ PAttr
@end example
  Retrieves a node specified by @code{name}. If this node cannot be found returns @code{nil}

@item getNamedItemNS
  @findex proc getNamedItemNS*(nList꞉ seq[PNode]; namespaceURI꞉ string; localName꞉ string)꞉ PNode
@example
proc getNamedItemNS*(nList꞉ seq[PNode]; namespaceURI꞉ string; localName꞉ string)꞉ PNode
@end example
  Retrieves a node specified by @code{localName} and @code{namespaceURI}. If this node cannot be found returns @code{nil}

@item getNamedItemNS
  @findex proc getNamedItemNS*(nList꞉ seq[PAttr]; namespaceURI꞉ string; localName꞉ string)꞉ PAttr
@example
proc getNamedItemNS*(nList꞉ seq[PAttr]; namespaceURI꞉ string; localName꞉ string)꞉ PAttr
@end example
  Retrieves a node specified by @code{localName} and @code{namespaceURI}. If this node cannot be found returns @code{nil}

@item item
  @findex proc item*(nList꞉ seq[PNode]; index꞉ int)꞉ PNode
@example
proc item*(nList꞉ seq[PNode]; index꞉ int)꞉ PNode
@end example
  Returns the @code{index} th item in the map. If @code{index} is greater than or equal to the number of nodes in this map, this returns @code{nil}.

@item removeNamedItem
  @findex proc removeNamedItem*(nList꞉ var seq[PNode]; name꞉ string)꞉ PNode
@example
proc removeNamedItem*(nList꞉ var seq[PNode]; name꞉ string)꞉ PNode
@end example
  Removes a node specified by @code{name} Raises the @code{ENotFoundErr} exception, if the node was not found

@item removeNamedItemNS
  @findex proc removeNamedItemNS*(nList꞉ var seq[PNode]; namespaceURI꞉ string; localName꞉ string)꞉ PNode
@example
proc removeNamedItemNS*(nList꞉ var seq[PNode]; namespaceURI꞉ string; localName꞉ string)꞉ PNode
@end example
  Removes a node specified by local name and namespace URI

@item setNamedItem
  @findex proc setNamedItem*(nList꞉ var seq[PNode]; arg꞉ PNode)꞉ PNode
@example
proc setNamedItem*(nList꞉ var seq[PNode]; arg꞉ PNode)꞉ PNode
@end example
  Adds @code{arg} as a @code{Node} to the @code{NList} If a node with the same name is already present in this map, it is replaced by the new one.

@item setNamedItem
  @findex proc setNamedItem*(nList꞉ var seq[PAttr]; arg꞉ PAttr)꞉ PAttr
@example
proc setNamedItem*(nList꞉ var seq[PAttr]; arg꞉ PAttr)꞉ PAttr
@end example
  Adds @code{arg} as a @code{Node} to the @code{NList} If a node with the same name is already present in this map, it is replaced by the new one.

@item setNamedItemNS
  @findex proc setNamedItemNS*(nList꞉ var seq[PNode]; arg꞉ PNode)꞉ PNode
@example
proc setNamedItemNS*(nList꞉ var seq[PNode]; arg꞉ PNode)꞉ PNode
@end example
  Adds a node using its @code{namespaceURI} and @code{localName}

@item setNamedItemNS
  @findex proc setNamedItemNS*(nList꞉ var seq[PAttr]; arg꞉ PAttr)꞉ PAttr
@example
proc setNamedItemNS*(nList꞉ var seq[PAttr]; arg꞉ PAttr)꞉ PAttr
@end example
  Adds a node using its @code{namespaceURI} and @code{localName}

@item name
  @findex proc name*(a꞉ PAttr)꞉ string
@example
proc name*(a꞉ PAttr)꞉ string
@end example
  Returns the name of the Attribute

@item specified
  @findex proc specified*(a꞉ PAttr)꞉ bool
@example
proc specified*(a꞉ PAttr)꞉ bool
@end example
  Specifies whether this attribute was specified in the original document

@item ownerElement
  @findex proc ownerElement*(a꞉ PAttr)꞉ PElement
@example
proc ownerElement*(a꞉ PAttr)꞉ PElement
@end example
  Returns this Attributes owner element

@item tagName
  @findex proc tagName*(el꞉ PElement)꞉ string
@example
proc tagName*(el꞉ PElement)꞉ string
@end example
  Returns the Element Tag Name

@item getAttribute
  @findex proc getAttribute*(el꞉ PElement; name꞉ string)꞉ string
@example
proc getAttribute*(el꞉ PElement; name꞉ string)꞉ string
@end example
  Retrieves an attribute value by @code{name}

@item getAttributeNS
  @findex proc getAttributeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ string
@example
proc getAttributeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ string
@end example
  Retrieves an attribute value by @code{localName} and @code{namespaceURI}

@item getAttributeNode
  @findex proc getAttributeNode*(el꞉ PElement; name꞉ string)꞉ PAttr
@example
proc getAttributeNode*(el꞉ PElement; name꞉ string)꞉ PAttr
@end example
  Retrieves an attribute node by @code{name} To retrieve an attribute node by qualified name and namespace URI, use the @emph{getAttributeNodeNS} method

@item getAttributeNodeNS
  @findex proc getAttributeNodeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ PAttr
@example
proc getAttributeNodeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ PAttr
@end example
  Retrieves an @emph{Attr} node by @code{localName} and @code{namespaceURI}

@item getElementsByTagName
  @findex proc getElementsByTagName*(el꞉ PElement; name꞉ string)꞉ seq[PNode]
@example
proc getElementsByTagName*(el꞉ PElement; name꞉ string)꞉ seq[PNode]
@end example
  Returns a @emph{NodeList} of all descendant @emph{Elements} of @code{el} with a given tag @code{name}, in the order in which they are encountered in a preorder traversal of this @emph{Element} tree If @code{name} is @emph{*}, returns all descendant of @code{el}

@item getElementsByTagNameNS
  @findex proc getElementsByTagNameNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ seq[PNode]
@example
proc getElementsByTagNameNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ seq[PNode]
@end example
  Returns a @emph{NodeList} of all the descendant Elements with a given @code{localName} and @code{namespaceURI} in the order in which they are encountered in a preorder traversal of this Element tree

@item hasAttribute
  @findex proc hasAttribute*(el꞉ PElement; name꞉ string)꞉ bool
@example
proc hasAttribute*(el꞉ PElement; name꞉ string)꞉ bool
@end example
  Returns @code{true} when an attribute with a given @code{name} is specified on this element , @code{false} otherwise.

@item hasAttributeNS
  @findex proc hasAttributeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ bool
@example
proc hasAttributeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)꞉ bool
@end example
  Returns @code{true} when an attribute with a given @code{localName} and @code{namespaceURI} is specified on this element , @code{false} otherwise

@item removeAttribute
  @findex proc removeAttribute*(el꞉ PElement; name꞉ string)
@example
proc removeAttribute*(el꞉ PElement; name꞉ string)
@end example
  Removes an attribute by @code{name}

@item removeAttributeNS
  @findex proc removeAttributeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)
@example
proc removeAttributeNS*(el꞉ PElement; namespaceURI꞉ string; localName꞉ string)
@end example
  Removes an attribute by @code{localName} and @code{namespaceURI}

@item removeAttributeNode
  @findex proc removeAttributeNode*(el꞉ PElement; oldAttr꞉ PAttr)꞉ PAttr
@example
proc removeAttributeNode*(el꞉ PElement; oldAttr꞉ PAttr)꞉ PAttr
@end example
  Removes the specified attribute node If the attribute node cannot be found raises @code{ENotFoundErr}

@item setAttributeNode
  @findex proc setAttributeNode*(el꞉ PElement; newAttr꞉ PAttr)꞉ PAttr
@example
proc setAttributeNode*(el꞉ PElement; newAttr꞉ PAttr)꞉ PAttr
@end example
  Adds a new attribute node, if an attribute with the same @emph{nodeName} is present, it is replaced by the new one and the replaced attribute is returned, otherwise @code{nil} is returned.

@item setAttributeNodeNS
  @findex proc setAttributeNodeNS*(el꞉ PElement; newAttr꞉ PAttr)꞉ PAttr
@example
proc setAttributeNodeNS*(el꞉ PElement; newAttr꞉ PAttr)꞉ PAttr
@end example
  Adds a new attribute node, if an attribute with the localName and namespaceURI of @code{newAttr} is present, it is replaced by the new one and the replaced attribute is returned, otherwise @code{nil} is returned.

@item setAttribute
  @findex proc setAttribute*(el꞉ PElement; name꞉ string; value꞉ string)
@example
proc setAttribute*(el꞉ PElement; name꞉ string; value꞉ string)
@end example
  Adds a new attribute, as specified by @code{name} and @code{value} If an attribute with that name is already present in the element, its value is changed to be that of the value parameter Raises the EInvalidCharacterErr if the specified @code{name} contains illegal characters

@item setAttributeNS
  @findex proc setAttributeNS*(el꞉ PElement; namespaceURI, localName, value꞉ string)
@example
proc setAttributeNS*(el꞉ PElement; namespaceURI, localName, value꞉ string)
@end example
  Adds a new attribute, as specified by @code{namespaceURI}, @code{localName} and @code{value}.

@item splitData
  @findex proc splitData*(textNode꞉ PText; offset꞉ int)꞉ PText
@example
proc splitData*(textNode꞉ PText; offset꞉ int)꞉ PText
@end example
  Breaks this node into two nodes at the specified offset, keeping both in the tree as siblings.

@item target
  @findex proc target*(pi꞉ PProcessingInstruction)꞉ string
@example
proc target*(pi꞉ PProcessingInstruction)꞉ string
@end example
  Returns the Processing Instructions target

@item `$`
  @findex proc `$`*(doc꞉ PDocument)꞉ string
@example
proc `$`*(doc꞉ PDocument)꞉ string
@end example
  Converts a PDocument object into a string representation of it's XML
@end itemize






@node /pure/coro, /pure/db_common , /pure/xmldom, Top




@chapter Procedures

@itemize


@item start
  @findex proc start*(c꞉ proc (); stacksize꞉ int = defaultStackSize)
@example
proc start*(c꞉ proc (); stacksize꞉ int = defaultStackSize)
@end example
  Adds coroutine to event loop. It does not run immediately.

@item suspend
  @findex proc suspend*(sleepTime꞉ float = 0)
@example
proc suspend*(sleepTime꞉ float = 0)
@end example
  Stops coroutine execution and resumes no sooner than after @code{sleeptime} seconds. Until then other coroutines are executed.

This is similar to a , or a @emph{yieldFrom}:idx in Python.

@item run
  @findex proc run*()
@example
proc run*()
@end example
  Starts main event loop which exits when all coroutines exit. Calling this proc starts execution of first coroutine.

@item alive
  @findex proc alive*(c꞉ proc ())꞉ bool
@example
proc alive*(c꞉ proc ())꞉ bool
@end example
  Returns @code{true} if coroutine has not returned, @code{false} otherwise.

@item wait
  @findex proc wait*(c꞉ proc (); interval = 0.01'f64)
@example
proc wait*(c꞉ proc (); interval = 0.01'f64)
@end example
  Returns only after coroutine @code{c} has returned. @code{interval} is time in seconds how often.
@end itemize






@node /pure/db_common, /pure/xmltree , /pure/coro, Top



@chapter Types

@itemize


@item DbColumns
  @tindex DbColumns* = seq[DbColumn]
@example
DbColumns* = seq[DbColumn]
@end example
  
@end itemize

@chapter Procedures

@itemize


@item dbError
  @findex proc dbError*(msg꞉ string) @{.noreturn, noinline.@}
@example
proc dbError*(msg꞉ string) @{.noreturn, noinline.@}
@end example
  raises an DbError exception with message @emph{msg}.
@end itemize

@chapter Templates

@itemize


@item sql
  @findex template sql*(query꞉ string)꞉ SqlQuery
@example
template sql*(query꞉ string)꞉ SqlQuery
@end example
  constructs a SqlQuery from the string @emph{query}. This is supposed to be used as a raw-string-literal modifier: @code{sql"update user set counter = counter + 1"}

If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.
@end itemize





@node /pure/xmltree, /pure/strtabs , /pure/db_common, Top
@chapter Constant variables

@itemize


@item xmlHeader
  @vindex xmlHeader* = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\x0A"
@example
xmlHeader* = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\x0A"
@end example
  header to use for complete XML output
@end itemize




@chapter Procedures

@itemize


@item newElement
  @findex proc newElement*(tag꞉ string)꞉ XmlNode
@example
proc newElement*(tag꞉ string)꞉ XmlNode
@end example
  creates a new @code{PXmlNode} of kind @code{xnText} with the given @emph{tag}.

@item newText
  @findex proc newText*(text꞉ string)꞉ XmlNode
@example
proc newText*(text꞉ string)꞉ XmlNode
@end example
  creates a new @code{PXmlNode} of kind @code{xnText} with the text @emph{text}.

@item newComment
  @findex proc newComment*(comment꞉ string)꞉ XmlNode
@example
proc newComment*(comment꞉ string)꞉ XmlNode
@end example
  creates a new @code{PXmlNode} of kind @code{xnComment} with the text @emph{comment}.

@item newCData
  @findex proc newCData*(cdata꞉ string)꞉ XmlNode
@example
proc newCData*(cdata꞉ string)꞉ XmlNode
@end example
  creates a new @code{PXmlNode} of kind @code{xnComment} with the text @emph{cdata}.

@item newEntity
  @findex proc newEntity*(entity꞉ string)꞉ XmlNode
@example
proc newEntity*(entity꞉ string)꞉ XmlNode
@end example
  creates a new @code{PXmlNode} of kind @code{xnEntity} with the text @emph{entity}.

@item text
  @findex proc text*(n꞉ XmlNode)꞉ string @{.inline.@}
@example
proc text*(n꞉ XmlNode)꞉ string @{.inline.@}
@end example
  gets the associated text with the node @emph{n}. @emph{n} can be a CDATA, Text, comment, or entity node.

@item `text=`
  @findex proc `text =`*(n꞉ XmlNode; text꞉ string) @{.inline.@}
@example
proc `text =`*(n꞉ XmlNode; text꞉ string) @{.inline.@}
@end example
  sets the associated text with the node @emph{n}. @emph{n} can be a CDATA, Text, comment, or entity node.

@item rawText
  @findex proc rawText*(n꞉ XmlNode)꞉ string @{.inline.@}
@example
proc rawText*(n꞉ XmlNode)꞉ string @{.inline.@}
@end example
  returns the underlying 'text' string by reference. This is only used for speed hacks.

@item rawTag
  @findex proc rawTag*(n꞉ XmlNode)꞉ string @{.inline.@}
@example
proc rawTag*(n꞉ XmlNode)꞉ string @{.inline.@}
@end example
  returns the underlying 'tag' string by reference. This is only used for speed hacks.

@item innerText
  @findex proc innerText*(n꞉ XmlNode)꞉ string
@example
proc innerText*(n꞉ XmlNode)꞉ string
@end example
  gets the inner text of @emph{n}. @emph{n} has to be an @code{xnElement} node. Only @code{xnText} and @code{xnEntity} nodes are considered part of @emph{n}'s inner text, other child nodes are silently ignored.

@item tag
  @findex proc tag*(n꞉ XmlNode)꞉ string @{.inline.@}
@example
proc tag*(n꞉ XmlNode)꞉ string @{.inline.@}
@end example
  gets the tag name of @emph{n}. @emph{n} has to be an @code{xnElement} node.

@item `tag=`
  @findex proc `tag =`*(n꞉ XmlNode; tag꞉ string) @{.inline.@}
@example
proc `tag =`*(n꞉ XmlNode; tag꞉ string) @{.inline.@}
@end example
  sets the tag name of @emph{n}. @emph{n} has to be an @code{xnElement} node.

@item add
  @findex proc add*(father, son꞉ XmlNode) @{.inline.@}
@example
proc add*(father, son꞉ XmlNode) @{.inline.@}
@end example
  adds the child @emph{son} to @emph{father}.

@item insert
  @findex proc insert*(father, son꞉ XmlNode; index꞉ int) @{.inline.@}
@example
proc insert*(father, son꞉ XmlNode; index꞉ int) @{.inline.@}
@end example
  insert the child @emph{son} to a given position in @emph{father}.

@item len
  @findex proc len*(n꞉ XmlNode)꞉ int @{.inline.@}
@example
proc len*(n꞉ XmlNode)꞉ int @{.inline.@}
@end example
  returns the number @emph{n}'s children.

@item kind
  @findex proc kind*(n꞉ XmlNode)꞉ XmlNodeKind @{.inline.@}
@example
proc kind*(n꞉ XmlNode)꞉ XmlNodeKind @{.inline.@}
@end example
  returns @emph{n}'s kind.

@item `[]`
  @findex proc `[]`*(n꞉ XmlNode; i꞉ int)꞉ XmlNode @{.inline.@}
@example
proc `[]`*(n꞉ XmlNode; i꞉ int)꞉ XmlNode @{.inline.@}
@end example
  returns the @emph{i}'th child of @emph{n}.

@item delete
  @findex proc delete*(n꞉ XmlNode; i꞉ Natural) @{.noSideEffect.@}
@example
proc delete*(n꞉ XmlNode; i꞉ Natural) @{.noSideEffect.@}
@end example
  delete the @emph{i}'th child of @emph{n}.

@item `[]`
  @findex proc `[]`*(n꞉ var XmlNode; i꞉ int)꞉ var XmlNode @{.inline.@}
@example
proc `[]`*(n꞉ var XmlNode; i꞉ int)꞉ var XmlNode @{.inline.@}
@end example
  returns the @emph{i}'th child of @emph{n} so that it can be modified

@item mget
  @findex proc mget*(n꞉ var XmlNode; i꞉ int)꞉ var XmlNode @{.inline, deprecated.@}
@example
proc mget*(n꞉ var XmlNode; i꞉ int)꞉ var XmlNode @{.inline, deprecated.@}
@end example
  returns the @emph{i}'th child of @emph{n} so that it can be modified. Use ```[]``` instead.

@item attrs
  @findex proc attrs*(n꞉ XmlNode)꞉ XmlAttributes @{.inline.@}
@example
proc attrs*(n꞉ XmlNode)꞉ XmlAttributes @{.inline.@}
@end example
  gets the attributes belonging to @emph{n}. Returns @emph{nil} if attributes have not been initialised for this node.

@item `attrs=`
  @findex proc `attrs =`*(n꞉ XmlNode; attr꞉ XmlAttributes) @{.inline.@}
@example
proc `attrs =`*(n꞉ XmlNode; attr꞉ XmlAttributes) @{.inline.@}
@end example
  sets the attributes belonging to @emph{n}.

@item attrsLen
  @findex proc attrsLen*(n꞉ XmlNode)꞉ int @{.inline.@}
@example
proc attrsLen*(n꞉ XmlNode)꞉ int @{.inline.@}
@end example
  returns the number of @emph{n}'s attributes.

@item clientData
  @findex proc clientData*(n꞉ XmlNode)꞉ int @{.inline.@}
@example
proc clientData*(n꞉ XmlNode)꞉ int @{.inline.@}
@end example
  gets the client data of @emph{n}. The client data field is used by the HTML parser and generator.

@item `clientData=`
  @findex proc `clientData =`*(n꞉ XmlNode; data꞉ int) @{.inline.@}
@example
proc `clientData =`*(n꞉ XmlNode; data꞉ int) @{.inline.@}
@end example
  sets the client data of @emph{n}. The client data field is used by the HTML parser and generator.

@item addEscaped
  @findex proc addEscaped*(result꞉ var string; s꞉ string)
@example
proc addEscaped*(result꞉ var string; s꞉ string)
@end example
  same as @code{result.add(escape(s))}, but more efficient.

@item escape
  @findex proc escape*(s꞉ string)꞉ string
@example
proc escape*(s꞉ string)꞉ string
@end example
  escapes @emph{s} for inclusion into an XML document. Escapes these characters:
@multitable @columnfractions  0.5 0.5
@item @b{char}
@tab @b{is converted to}
@item @code{<}
@tab @code{&lt;}
@item @code{>}
@tab @code{&gt;}
@item @code{&}
@tab @code{&amp;}
@item @code{"}
@tab @code{&quot;}
@item @code{'}
@tab @code{&#x27;}
@item @code{/}
@tab @code{&#x2F;}


@end multitable

@item add
  @findex proc add*(result꞉ var string; n꞉ XmlNode; indent = 0; indWidth = 2)
@example
proc add*(result꞉ var string; n꞉ XmlNode; indent = 0; indWidth = 2)
@end example
  adds the textual representation of @emph{n} to @emph{result}.

@item `$`
  @findex proc `$`*(n꞉ XmlNode)꞉ string
@example
proc `$`*(n꞉ XmlNode)꞉ string
@end example
  converts @emph{n} into its string representation. No @code{<$xml ...$>} declaration is produced, so that the produced XML fragments are composable.

@item newXmlTree
  @findex proc newXmlTree*(tag꞉ string; children꞉ openArray[XmlNode];attributes꞉ XmlAttributes = nil)꞉ XmlNode
@example
proc newXmlTree*(tag꞉ string; children꞉ openArray[XmlNode];attributes꞉ XmlAttributes = nil)꞉ XmlNode
@end example
  creates a new XML tree with @emph{tag}, @emph{children} and @emph{attributes}

@item child
  @findex proc child*(n꞉ XmlNode; name꞉ string)꞉ XmlNode
@example
proc child*(n꞉ XmlNode; name꞉ string)꞉ XmlNode
@end example
  Finds the first child element of @emph{n} with a name of @emph{name}. Returns @emph{nil} on failure.

@item attr
  @findex proc attr*(n꞉ XmlNode; name꞉ string)꞉ string
@example
proc attr*(n꞉ XmlNode; name꞉ string)꞉ string
@end example
  Finds the first attribute of @emph{n} with a name of @emph{name}. Returns "" on failure.

@item findAll
  @findex proc findAll*(n꞉ XmlNode; tag꞉ string; result꞉ var seq[XmlNode])
@example
proc findAll*(n꞉ XmlNode; tag꞉ string; result꞉ var seq[XmlNode])
@end example
  Iterates over all the children of @emph{n} returning those matching @emph{tag}.

Found nodes satisfying the condition will be appended to the @emph{result} sequence, which can't be nil or the proc will crash. Usage example:


@example
var
  html: XmlNode
  tags: seq[XmlNode] = @@[]

html = buildHtml()
findAll(html, "img", tags)
for imgTag in tags:
  process(imgTag)
@end example

@item findAll
  @findex proc findAll*(n꞉ XmlNode; tag꞉ string)꞉ seq[XmlNode]
@example
proc findAll*(n꞉ XmlNode; tag꞉ string)꞉ seq[XmlNode]
@end example
  Shortcut version to assign in let blocks. Example:
@example
var html: XmlNode

html = buildHtml(html)
for imgTag in html.findAll("img"):
  process(imgTag)
@end example
@end itemize


@chapter Macros

@itemize


@item `<>`
  @findex macro `<>`*(x꞉ expr)꞉ expr @{.immediate.@}
@example
macro `<>`*(x꞉ expr)꞉ expr @{.immediate.@}
@end example
  Constructor macro for XML. Example usage:
@example
<>a(href="http://nim-lang.org", newText("Nim rules."))
@end example
Produces an XML tree for:
@verbatim

<a href="http://nim-lang.org">Nim rules.</a>
@end verbatim
@end itemize



@chapter Iterators

@itemize


@item items
  @itindex iterator items*(n꞉ XmlNode)꞉ XmlNode @{.inline.@}
@example
iterator items*(n꞉ XmlNode)꞉ XmlNode @{.inline.@}
@end example
  iterates over any child of @emph{n}.

@item mitems
  @itindex iterator mitems*(n꞉ var XmlNode)꞉ var XmlNode @{.inline.@}
@example
iterator mitems*(n꞉ var XmlNode)꞉ var XmlNode @{.inline.@}
@end example
  iterates over any child of @emph{n}.
@end itemize

@node /pure/strtabs, /pure/algorithm , /pure/xmltree, Top



@chapter Types

@itemize


@item StringTableRef
  @tindex StringTableRef* = ref StringTableObj
@example
StringTableRef* = ref StringTableObj
@end example
  use this type to declare string tables

@item FormatFlag
  @tindex FormatFlag* = enum
  useEnvironment,             ## use environment variable if the ``$key``
                 ## is not found in the table
  useEmpty,                   ## use the empty string as a default, thus it
           ## won't throw an exception if ``$key`` is not
           ## in the table
  useKey                      ## do not replace ``$key`` if it is not found
        ## in the table (or in the environment)
@example
FormatFlag* = enum
  useEnvironment,             ## use environment variable if the ``$key``
                 ## is not found in the table
  useEmpty,                   ## use the empty string as a default, thus it
           ## won't throw an exception if ``$key`` is not
           ## in the table
  useKey                      ## do not replace ``$key`` if it is not found
        ## in the table (or in the environment)
@end example
  flags for the @emph{%} operator
@end itemize

@chapter Procedures

@itemize


@item len
  @findex proc len*(t꞉ StringTableRef)꞉ int @{.rtl, extern꞉ "nst$1".@}
@example
proc len*(t꞉ StringTableRef)꞉ int @{.rtl, extern꞉ "nst$1".@}
@end example
  returns the number of keys in @emph{t}.

@item `[]`
  @findex proc `[]`*(t꞉ StringTableRef; key꞉ string)꞉ var string @{.rtl, extern꞉ "nstTake",deprecatedGet.@}
@example
proc `[]`*(t꞉ StringTableRef; key꞉ string)꞉ var string @{.rtl, extern꞉ "nstTake",deprecatedGet.@}
@end example
  retrieves the location at @code{t[key]}. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. One can check with @code{hasKey} whether the key exists.

@item mget
  @findex proc mget*(t꞉ StringTableRef; key꞉ string)꞉ var string @{.deprecated.@}
@example
proc mget*(t꞉ StringTableRef; key꞉ string)꞉ var string @{.deprecated.@}
@end example
  retrieves the location at @code{t[key]}. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item getOrDefault
  @findex proc getOrDefault*(t꞉ StringTableRef; key꞉ string)꞉ string
@example
proc getOrDefault*(t꞉ StringTableRef; key꞉ string)꞉ string
@end example
  

@item hasKey
  @findex proc hasKey*(t꞉ StringTableRef; key꞉ string)꞉ bool @{.rtl, extern꞉ "nst$1".@}
@example
proc hasKey*(t꞉ StringTableRef; key꞉ string)꞉ bool @{.rtl, extern꞉ "nst$1".@}
@end example
  returns true iff @emph{key} is in the table @emph{t}.

@item `[]=`
  @findex proc `[]=`*(t꞉ StringTableRef; key, val꞉ string) @{.rtl, extern꞉ "nstPut".@}
@example
proc `[]=`*(t꞉ StringTableRef; key, val꞉ string) @{.rtl, extern꞉ "nstPut".@}
@end example
  puts a (key, value)-pair into @emph{t}.

@item newStringTable
  @findex proc newStringTable*(mode꞉ StringTableMode)꞉ StringTableRef @{.rtl, extern꞉ "nst$1".@}
@example
proc newStringTable*(mode꞉ StringTableMode)꞉ StringTableRef @{.rtl, extern꞉ "nst$1".@}
@end example
  creates a new string table that is empty.

@item clear
  @findex proc clear*(s꞉ StringTableRef; mode꞉ StringTableMode)
@example
proc clear*(s꞉ StringTableRef; mode꞉ StringTableMode)
@end example
  resets a string table to be empty again.

@item newStringTable
  @findex proc newStringTable*(keyValuePairs꞉ varargs[string]; mode꞉ StringTableMode)꞉ StringTableRef @{.rtl, extern꞉ "nst$1WithPairs".@}
@example
proc newStringTable*(keyValuePairs꞉ varargs[string]; mode꞉ StringTableMode)꞉ StringTableRef @{.rtl, extern꞉ "nst$1WithPairs".@}
@end example
  creates a new string table with given key value pairs. Example:
@verbatim
var mytab = newStringTable("key1", "val1", "key2", "val2",
                           modeCaseInsensitive)
@end verbatim

@item newStringTable
  @findex proc newStringTable*(keyValuePairs꞉ varargs[tuple[key, val꞉ string]];mode꞉ StringTableMode = modeCaseSensitive)꞉ StringTableRef @{.rtl,extern꞉ "nst$1WithTableConstr".@}
@example
proc newStringTable*(keyValuePairs꞉ varargs[tuple[key, val꞉ string]];mode꞉ StringTableMode = modeCaseSensitive)꞉ StringTableRef @{.rtl,extern꞉ "nst$1WithTableConstr".@}
@end example
  creates a new string table with given key value pairs. Example:
@verbatim
var mytab = newStringTable(@{"key1": "val1", "key2": "val2"@},
                           modeCaseInsensitive)
@end verbatim

@item `%`
  @findex proc `%`*(f꞉ string; t꞉ StringTableRef; flags꞉ set[FormatFlag] = @{@})꞉ string @{.rtl,extern꞉ "nstFormat".@}
@example
proc `%`*(f꞉ string; t꞉ StringTableRef; flags꞉ set[FormatFlag] = @{@})꞉ string @{.rtl,extern꞉ "nstFormat".@}
@end example
  The @emph{%} operator for string tables.

@item `$`
  @findex proc `$`*(t꞉ StringTableRef)꞉ string @{.rtl, extern꞉ "nstDollar".@}
@example
proc `$`*(t꞉ StringTableRef)꞉ string @{.rtl, extern꞉ "nstDollar".@}
@end example
  The @emph{$} operator for string tables.
@end itemize





@chapter Iterators

@itemize


@item pairs
  @itindex iterator pairs*(t꞉ StringTableRef)꞉ tuple[key, value꞉ string]
@example
iterator pairs*(t꞉ StringTableRef)꞉ tuple[key, value꞉ string]
@end example
  iterates over every (key, value) pair in the table @emph{t}.

@item keys
  @itindex iterator keys*(t꞉ StringTableRef)꞉ string
@example
iterator keys*(t꞉ StringTableRef)꞉ string
@end example
  iterates over every key in the table @emph{t}.

@item values
  @itindex iterator values*(t꞉ StringTableRef)꞉ string
@example
iterator values*(t꞉ StringTableRef)꞉ string
@end example
  iterates over every value in the table @emph{t}.
@end itemize

@node /pure/algorithm, /pure/httpserver , /pure/strtabs, Top



@chapter Types

@itemize


@item SortOrder
  @tindex SortOrder* = enumDescending, Ascending
@example
SortOrder* = enumDescending, Ascending
@end example
  sort order
@end itemize

@chapter Procedures

@itemize


@item `*`
  @findex proc `*`*(x꞉ int; order꞉ SortOrder)꞉ int @{.inline.@}
@example
proc `*`*(x꞉ int; order꞉ SortOrder)꞉ int @{.inline.@}
@end example
  flips @emph{x} if @code{order == Descending}; if @code{order == Ascending} then @emph{x} is returned. @emph{x} is supposed to be the result of a comparator, ie @code{< 0} for @emph{less than}, @code{== 0} for @emph{equal}, @code{> 0} for @emph{greater than}.

@item fill
  @findex proc fill*[T](a꞉ var openArray[T]; first, last꞉ Natural; value꞉ T)
@example
proc fill*[T](a꞉ var openArray[T]; first, last꞉ Natural; value꞉ T)
@end example
  fills the array @code{a[first..last]} with @emph{value}.

@item fill
  @findex proc fill*[T](a꞉ var openArray[T]; value꞉ T)
@example
proc fill*[T](a꞉ var openArray[T]; value꞉ T)
@end example
  fills the array @emph{a} with @emph{value}.

@item reverse
  @findex proc reverse*[T](a꞉ var openArray[T]; first, last꞉ Natural)
@example
proc reverse*[T](a꞉ var openArray[T]; first, last꞉ Natural)
@end example
  reverses the array @code{a[first..last]}.

@item reverse
  @findex proc reverse*[T](a꞉ var openArray[T])
@example
proc reverse*[T](a꞉ var openArray[T])
@end example
  reverses the array @emph{a}.

@item reversed
  @findex proc reversed*[T](a꞉ openArray[T]; first꞉ Natural; last꞉ int)꞉ seq[T]
@example
proc reversed*[T](a꞉ openArray[T]; first꞉ Natural; last꞉ int)꞉ seq[T]
@end example
  returns the reverse of the array @emph{a[first..last]}.

@item reversed
  @findex proc reversed*[T](a꞉ openArray[T])꞉ seq[T]
@example
proc reversed*[T](a꞉ openArray[T])꞉ seq[T]
@end example
  returns the reverse of the array @emph{a}.

@item binarySearch
  @findex proc binarySearch*[T](a꞉ openArray[T]; key꞉ T)꞉ int
@example
proc binarySearch*[T](a꞉ openArray[T]; key꞉ T)꞉ int
@end example
  binary search for @emph{key} in @emph{a}. Returns -1 if not found.

@item smartBinarySearch
  @findex proc smartBinarySearch*[T](a꞉ openArray[T]; key꞉ T)꞉ int
@example
proc smartBinarySearch*[T](a꞉ openArray[T]; key꞉ T)꞉ int
@end example
  @code{a.len} must be a power of 2 for this to work.

@item lowerBound
  @findex proc lowerBound*[T](a꞉ openArray[T]; key꞉ T; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@})꞉ int
@example
proc lowerBound*[T](a꞉ openArray[T]; key꞉ T; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@})꞉ int
@end example
  same as binarySearch except that if key is not in @emph{a} then this returns the location where @emph{key} would be if it were. In other words if you have a sorted sequence and you call insert(thing, elm, lowerBound(thing, elm)) the sequence will still be sorted.

@emph{cmp} is the comparator function to use, the expected return values are the same as that of system.cmp.

example:
@verbatim

var arr = @@[1,2,3,5,6,7,8,9]
arr.insert(4, arr.lowerBound(4))
# after running the above arr is `[1,2,3,4,5,6,7,8,9]`
@end verbatim

@item lowerBound
  @findex proc lowerBound*[T](a꞉ openArray[T]; key꞉ T)꞉ int
@example
proc lowerBound*[T](a꞉ openArray[T]; key꞉ T)꞉ int
@end example
  

@item sort
  @findex proc sort*[T](a꞉ var openArray[T]; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@};order = SortOrder.Ascending)
@example
proc sort*[T](a꞉ var openArray[T]; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@};order = SortOrder.Ascending)
@end example
  Default Nim sort (an implementation of merge sort). The sorting is guaranteed to be stable and the worst case is guaranteed to be O(n log n). The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length @code{a.len div 2}. Currently Nim does not support a sensible default argument for @code{cmp}, so you have to provide one of your own. However, the @code{system.cmp} procs can be used:
@example

sort(myIntArray, system.cmp[int])

# do not use cmp[string] here as we want to use the specialized
# overload:
sort(myStrArray, system.cmp)
@end example
You can inline adhoc comparison procs with the @uref{manual.html#do-notation, do notation}. Example:


@example

people.sort do (x, y: Person) -> int:
  result = cmp(x.surname, y.surname)
  if result == 0:
    result = cmp(x.name, y.name)
@end example

@item sorted
  @findex proc sorted*[T](a꞉ openArray[T]; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@};order = SortOrder.Ascending)꞉ seq[T]
@example
proc sorted*[T](a꞉ openArray[T]; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@};order = SortOrder.Ascending)꞉ seq[T]
@end example
  returns @emph{a} sorted by @emph{cmp} in the specified @emph{order}.

@item isSorted
  @findex proc isSorted*[T](a꞉ openarray[T]; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@};order = SortOrder.Ascending)꞉ bool
@example
proc isSorted*[T](a꞉ openarray[T]; cmp꞉ proc (x, y꞉ T)꞉ int @{.closure.@};order = SortOrder.Ascending)꞉ bool
@end example
  Checks to see whether @emph{a} is already sorted in @emph{order} using @emph{cmp} for the comparison. Parameters identical to @emph{sort}

@item product
  @findex proc product*[T](x꞉ openArray[seq[T]])꞉ seq[seq[T]]
@example
proc product*[T](x꞉ openArray[seq[T]])꞉ seq[seq[T]]
@end example
  produces the Cartesian product of the array. Warning: complexity may explode.

@item nextPermutation
  @findex proc nextPermutation*[T](x꞉ var openarray[T])꞉ bool @{.discardable.@}
@example
proc nextPermutation*[T](x꞉ var openarray[T])꞉ bool @{.discardable.@}
@end example
  Calculates the next lexicographic permutation, directly modifying @code{x}. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.
@example

var v = @@[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
v.nextPermutation()
echo v # @@[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
@end example

@item prevPermutation
  @findex proc prevPermutation*[T](x꞉ var openarray[T])꞉ bool @{.discardable.@}
@example
proc prevPermutation*[T](x꞉ var openarray[T])꞉ bool @{.discardable.@}
@end example
  Calculates the previous lexicographic permutation, directly modifying @code{x}.  The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.
@example

var v = @@[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
v.prevPermutation()
echo v # @@[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
@end example
@end itemize

@chapter Templates

@itemize


@item sortedByIt
  @findex template sortedByIt*(seq1, op꞉ expr)꞉ expr
@example
template sortedByIt*(seq1, op꞉ expr)꞉ expr
@end example
  Convenience template around the @code{sorted} proc to reduce typing.

The template injects the @code{it} variable which you can use directly in an expression. Example:


@example

type Person = tuple[name: string, age: int]
var
  p1: Person = (name: "p1", age: 60)
  p2: Person = (name: "p2", age: 20)
  p3: Person = (name: "p3", age: 30)
  p4: Person = (name: "p4", age: 30)
  people = @@[p1,p2,p4,p3]

echo people.sortedByIt(it.name)
@end example
Because the underlying @code{cmp()} is defined for tuples you can do a nested sort like in the following example:


@example

echo people.sortedByIt((it.age, it.name))
@end example
@end itemize





@node /pure/httpserver, /pure/etcpriv , /pure/algorithm, Top




@chapter Procedures

@itemize


@item serveFile
  @findex proc serveFile*(client꞉ Socket; filename꞉ string)
@example
proc serveFile*(client꞉ Socket; filename꞉ string)
@end example
  serves a file to the client.

@item open
  @findex proc open*(s꞉ var Server; port = Port(80); reuseAddr = false)
@example
proc open*(s꞉ var Server; port = Port(80); reuseAddr = false)
@end example
  creates a new server at port @emph{port}. If @code{port == 0} a free port is acquired that can be accessed later by the @code{port} proc.

@item port
  @findex proc port*(s꞉ var Server)꞉ Port
@example
proc port*(s꞉ var Server)꞉ Port
@end example
  get the port number the server has acquired.

@item next
  @findex proc next*(s꞉ var Server)
@example
proc next*(s꞉ var Server)
@end example
  proceed to the first/next request.

@item close
  @findex proc close*(s꞉ Server)
@example
proc close*(s꞉ Server)
@end example
  closes the server (and the socket the server uses).

@item run
  @findex proc run*(handleRequest꞉ proc (client꞉ Socket; path, query꞉ string)꞉ bool @{.closure.@};port = Port(80))
@example
proc run*(handleRequest꞉ proc (client꞉ Socket; path, query꞉ string)꞉ bool @{.closure.@};port = Port(80))
@end example
  encapsulates the server object and main loop

@item asyncHTTPServer
  @findex proc asyncHTTPServer*(handleRequest꞉ proc (server꞉ PAsyncHTTPServer; client꞉ Socket;path, query꞉ string)꞉ bool @{.closure, gcsafe.@};port = Port(80); address = ""; reuseAddr = false)꞉ PAsyncHTTPServer
@example
proc asyncHTTPServer*(handleRequest꞉ proc (server꞉ PAsyncHTTPServer; client꞉ Socket;path, query꞉ string)꞉ bool @{.closure, gcsafe.@};port = Port(80); address = ""; reuseAddr = false)꞉ PAsyncHTTPServer
@end example
  Creates an Asynchronous HTTP server at @code{port}.

@item register
  @findex proc register*(d꞉ Dispatcher; s꞉ PAsyncHTTPServer)
@example
proc register*(d꞉ Dispatcher; s꞉ PAsyncHTTPServer)
@end example
  Registers a @code{PAsyncHTTPServer} with a @code{Dispatcher}.

@item close
  @findex proc close*(h꞉ PAsyncHTTPServer)
@example
proc close*(h꞉ PAsyncHTTPServer)
@end example
  Closes the @code{PAsyncHTTPServer}.
@end itemize






@node /pure/etcpriv, /pure/math , /pure/httpserver, Top
@chapter Constant variables

@itemize


@item magicIdentSeparatorRuneByteWidth
  @vindex magicIdentSeparatorRuneByteWidth* = 3
@example
magicIdentSeparatorRuneByteWidth* = 3
@end example
  
@end itemize




@chapter Procedures

@itemize


@item isMagicIdentSeparatorRune
  @findex proc isMagicIdentSeparatorRune*(cs꞉ cstring; i꞉ int)꞉ bool @{.inline.@}
@example
proc isMagicIdentSeparatorRune*(cs꞉ cstring; i꞉ int)꞉ bool @{.inline.@}
@end example
  
@end itemize






@node /pure/math, /pure/complex , /pure/etcpriv, Top



@chapter Types

@itemize


@item FloatClass
  @tindex FloatClass* = enum
  fcNormal,                   ## value is an ordinary nonzero floating point value
  fcSubnormal,                ## value is a subnormal (a very small) floating point value
  fcZero,                     ## value is zero
  fcNegZero,                  ## value is the negative zero
  fcNan,                      ## value is Not-A-Number (NAN)
  fcInf,                      ## value is positive infinity
  fcNegInf                    ## value is negative infinity
@example
FloatClass* = enum
  fcNormal,                   ## value is an ordinary nonzero floating point value
  fcSubnormal,                ## value is a subnormal (a very small) floating point value
  fcZero,                     ## value is zero
  fcNegZero,                  ## value is the negative zero
  fcNan,                      ## value is Not-A-Number (NAN)
  fcInf,                      ## value is positive infinity
  fcNegInf                    ## value is negative infinity
@end example
  describes the class a floating point value belongs to. This is the type that is returned by @emph{classify}.
@end itemize

@chapter Procedures

@itemize


@item binom
  @findex proc binom*(n, k꞉ int)꞉ int @{.noSideEffect.@}
@example
proc binom*(n, k꞉ int)꞉ int @{.noSideEffect.@}
@end example
  Computes the binomial coefficient

@item fac
  @findex proc fac*(n꞉ int)꞉ int @{.noSideEffect.@}
@example
proc fac*(n꞉ int)꞉ int @{.noSideEffect.@}
@end example
  Computes the faculty/factorial function.

@item classify
  @findex proc classify*(x꞉ float)꞉ FloatClass
@example
proc classify*(x꞉ float)꞉ FloatClass
@end example
  Classifies a floating point value. Returns @emph{x}'s class as specified by @emph{FloatClass}.

@item isPowerOfTwo
  @findex proc isPowerOfTwo*(x꞉ int)꞉ bool @{.noSideEffect.@}
@example
proc isPowerOfTwo*(x꞉ int)꞉ bool @{.noSideEffect.@}
@end example
  Returns true, if @emph{x} is a power of two, false otherwise. Zero and negative numbers are not a power of two.

@item nextPowerOfTwo
  @findex proc nextPowerOfTwo*(x꞉ int)꞉ int @{.noSideEffect.@}
@example
proc nextPowerOfTwo*(x꞉ int)꞉ int @{.noSideEffect.@}
@end example
  Returns @emph{x} rounded up to the nearest power of two. Zero and negative numbers get rounded up to 1.

@item countBits32
  @findex proc countBits32*(n꞉ int32)꞉ int @{.noSideEffect.@}
@example
proc countBits32*(n꞉ int32)꞉ int @{.noSideEffect.@}
@end example
  Counts the set bits in @emph{n}.

@item sum
  @findex proc sum*[T](x꞉ openArray[T])꞉ T @{.noSideEffect.@}
@example
proc sum*[T](x꞉ openArray[T])꞉ T @{.noSideEffect.@}
@end example
  Computes the sum of the elements in @emph{x}. If @emph{x} is empty, 0 is returned.

@item random
  @findex proc random*(max꞉ int)꞉ int @{.benign.@}
@example
proc random*(max꞉ int)꞉ int @{.benign.@}
@end example
  Returns a random number in the range 0..max-1. The sequence of random number is always the same, unless @emph{randomize} is called which initializes the random number generator with a "random" number, i.e. a tickcount.

@item random
  @findex proc random*(max꞉ float)꞉ float @{.benign.@}
@example
proc random*(max꞉ float)꞉ float @{.benign.@}
@end example
  Returns a random number in the range 0..<max. The sequence of random number is always the same, unless @emph{randomize} is called which initializes the random number generator with a "random" number, i.e. a tickcount. This has a 16-bit resolution on windows and a 48-bit resolution on other platforms.

@item randomize
  @findex proc randomize*() @{.benign.@}
@example
proc randomize*() @{.benign.@}
@end example
  Initializes the random number generator with a "random" number, i.e. a tickcount. Note: Does nothing for the JavaScript target, as JavaScript does not support this. Nor does it work for NimScript.

@item randomize
  @findex proc randomize*(seed꞉ int) @{.benign.@}
@example
proc randomize*(seed꞉ int) @{.benign.@}
@end example
  Initializes the random number generator with a specific seed. Note: Does nothing for the JavaScript target, as JavaScript does not support this.

@item sqrt
  @findex proc sqrt*(x꞉ float)꞉ float @{.importc꞉ "sqrt", header꞉ "<math.h>".@}
@example
proc sqrt*(x꞉ float)꞉ float @{.importc꞉ "sqrt", header꞉ "<math.h>".@}
@end example
  Computes the square root of @emph{x}.

@item cbrt
  @findex proc cbrt*(x꞉ float)꞉ float @{.importc꞉ "cbrt", header꞉ "<math.h>".@}
@example
proc cbrt*(x꞉ float)꞉ float @{.importc꞉ "cbrt", header꞉ "<math.h>".@}
@end example
  Computes the cubic root of @emph{x}

@item ln
  @findex proc ln*(x꞉ float)꞉ float @{.importc꞉ "log", header꞉ "<math.h>".@}
@example
proc ln*(x꞉ float)꞉ float @{.importc꞉ "log", header꞉ "<math.h>".@}
@end example
  Computes the natural log of @emph{x}

@item log10
  @findex proc log10*(x꞉ float)꞉ float @{.importc꞉ "log10", header꞉ "<math.h>".@}
@example
proc log10*(x꞉ float)꞉ float @{.importc꞉ "log10", header꞉ "<math.h>".@}
@end example
  Computes the common logarithm (base 10) of @emph{x}

@item log2
  @findex proc log2*(x꞉ float)꞉ float
@example
proc log2*(x꞉ float)꞉ float
@end example
  Computes the binary logarithm (base 2) of @emph{x}

@item exp
  @findex proc exp*(x꞉ float)꞉ float @{.importc꞉ "exp", header꞉ "<math.h>".@}
@example
proc exp*(x꞉ float)꞉ float @{.importc꞉ "exp", header꞉ "<math.h>".@}
@end example
  Computes the exponential function of @emph{x} (pow(E, x))

@item frexp
  @findex proc frexp*(x꞉ float; exponent꞉ var int)꞉ float @{.importc꞉ "frexp", header꞉ "<math.h>".@}
@example
proc frexp*(x꞉ float; exponent꞉ var int)꞉ float @{.importc꞉ "frexp", header꞉ "<math.h>".@}
@end example
  Split a number into mantissa and exponent. @emph{frexp} calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that @emph{x} (the original float value) equals m * 2**n. frexp stores n in @emph{exponent} and returns m.

@item round
  @findex proc round*(x꞉ float)꞉ int @{.importc꞉ "lrint", header꞉ "<math.h>".@}
@example
proc round*(x꞉ float)꞉ int @{.importc꞉ "lrint", header꞉ "<math.h>".@}
@end example
  Converts a float to an int by rounding.

@item arccos
  @findex proc arccos*(x꞉ float)꞉ float @{.importc꞉ "acos", header꞉ "<math.h>".@}
@example
proc arccos*(x꞉ float)꞉ float @{.importc꞉ "acos", header꞉ "<math.h>".@}
@end example
  Computes the arc cosine of @emph{x}

@item arcsin
  @findex proc arcsin*(x꞉ float)꞉ float @{.importc꞉ "asin", header꞉ "<math.h>".@}
@example
proc arcsin*(x꞉ float)꞉ float @{.importc꞉ "asin", header꞉ "<math.h>".@}
@end example
  Computes the arc sine of @emph{x}

@item arctan
  @findex proc arctan*(x꞉ float)꞉ float @{.importc꞉ "atan", header꞉ "<math.h>".@}
@example
proc arctan*(x꞉ float)꞉ float @{.importc꞉ "atan", header꞉ "<math.h>".@}
@end example
  Calculate the arc tangent of @emph{y} / @emph{x}

@item arctan2
  @findex proc arctan2*(y, x꞉ float)꞉ float @{.importc꞉ "atan2", header꞉ "<math.h>".@}
@example
proc arctan2*(y, x꞉ float)꞉ float @{.importc꞉ "atan2", header꞉ "<math.h>".@}
@end example
  Calculate the arc tangent of @emph{y} / @emph{x}. @emph{atan2} returns the arc tangent of @emph{y} / @emph{x}; it produces correct results even when the resulting angle is near pi/2 or -pi/2 (@emph{x} near 0).

@item cos
  @findex proc cos*(x꞉ float)꞉ float @{.importc꞉ "cos", header꞉ "<math.h>".@}
@example
proc cos*(x꞉ float)꞉ float @{.importc꞉ "cos", header꞉ "<math.h>".@}
@end example
  Computes the cosine of @emph{x}

@item cosh
  @findex proc cosh*(x꞉ float)꞉ float @{.importc꞉ "cosh", header꞉ "<math.h>".@}
@example
proc cosh*(x꞉ float)꞉ float @{.importc꞉ "cosh", header꞉ "<math.h>".@}
@end example
  Computes the hyperbolic cosine of @emph{x}

@item hypot
  @findex proc hypot*(x, y꞉ float)꞉ float @{.importc꞉ "hypot", header꞉ "<math.h>".@}
@example
proc hypot*(x, y꞉ float)꞉ float @{.importc꞉ "hypot", header꞉ "<math.h>".@}
@end example
  Computes the hypotenuse of a right-angle triangle with @emph{x} and @emph{y} as its base and height. Equivalent to @code{sqrt(x*x + y*y)}.

@item sinh
  @findex proc sinh*(x꞉ float)꞉ float @{.importc꞉ "sinh", header꞉ "<math.h>".@}
@example
proc sinh*(x꞉ float)꞉ float @{.importc꞉ "sinh", header꞉ "<math.h>".@}
@end example
  Computes the hyperbolic sine of @emph{x}

@item sin
  @findex proc sin*(x꞉ float)꞉ float @{.importc꞉ "sin", header꞉ "<math.h>".@}
@example
proc sin*(x꞉ float)꞉ float @{.importc꞉ "sin", header꞉ "<math.h>".@}
@end example
  Computes the sine of @emph{x}

@item tan
  @findex proc tan*(x꞉ float)꞉ float @{.importc꞉ "tan", header꞉ "<math.h>".@}
@example
proc tan*(x꞉ float)꞉ float @{.importc꞉ "tan", header꞉ "<math.h>".@}
@end example
  Computes the tangent of @emph{x}

@item tanh
  @findex proc tanh*(x꞉ float)꞉ float @{.importc꞉ "tanh", header꞉ "<math.h>".@}
@example
proc tanh*(x꞉ float)꞉ float @{.importc꞉ "tanh", header꞉ "<math.h>".@}
@end example
  Computes the hyperbolic tangent of @emph{x}

@item pow
  @findex proc pow*(x, y꞉ float)꞉ float @{.importc꞉ "pow", header꞉ "<math.h>".@}
@example
proc pow*(x, y꞉ float)꞉ float @{.importc꞉ "pow", header꞉ "<math.h>".@}
@end example
  Computes @emph{x} to power of @emph{y}.

@item erf
  @findex proc erf*(x꞉ float)꞉ float @{.importc꞉ "erf", header꞉ "<math.h>".@}
@example
proc erf*(x꞉ float)꞉ float @{.importc꞉ "erf", header꞉ "<math.h>".@}
@end example
  The error function

@item erfc
  @findex proc erfc*(x꞉ float)꞉ float @{.importc꞉ "erfc", header꞉ "<math.h>".@}
@example
proc erfc*(x꞉ float)꞉ float @{.importc꞉ "erfc", header꞉ "<math.h>".@}
@end example
  The complementary error function

@item lgamma
  @findex proc lgamma*(x꞉ float)꞉ float @{.importc꞉ "lgamma", header꞉ "<math.h>".@}
@example
proc lgamma*(x꞉ float)꞉ float @{.importc꞉ "lgamma", header꞉ "<math.h>".@}
@end example
  Natural log of the gamma function

@item tgamma
  @findex proc tgamma*(x꞉ float)꞉ float @{.importc꞉ "tgamma", header꞉ "<math.h>".@}
@example
proc tgamma*(x꞉ float)꞉ float @{.importc꞉ "tgamma", header꞉ "<math.h>".@}
@end example
  The gamma function

@item trunc
  @findex proc trunc*(x꞉ float)꞉ float @{.importc꞉ "trunc", header꞉ "<math.h>".@}
@example
proc trunc*(x꞉ float)꞉ float @{.importc꞉ "trunc", header꞉ "<math.h>".@}
@end example
  Truncates @emph{x} to the decimal point
@example
echo trunc(PI) # 3.0
@end example

@item floor
  @findex proc floor*(x꞉ float)꞉ float @{.importc꞉ "floor", header꞉ "<math.h>".@}
@example
proc floor*(x꞉ float)꞉ float @{.importc꞉ "floor", header꞉ "<math.h>".@}
@end example
  Computes the floor function (i.e., the largest integer not greater than @emph{x})
@example
echo floor(-3.5) ## -4.0
@end example

@item ceil
  @findex proc ceil*(x꞉ float)꞉ float @{.importc꞉ "ceil", header꞉ "<math.h>".@}
@example
proc ceil*(x꞉ float)꞉ float @{.importc꞉ "ceil", header꞉ "<math.h>".@}
@end example
  Computes the ceiling function (i.e., the smallest integer not less than @emph{x})
@example
echo ceil(-2.1) ## -2.0
@end example

@item fmod
  @findex proc fmod*(x, y꞉ float)꞉ float @{.importc꞉ "fmod", header꞉ "<math.h>".@}
@example
proc fmod*(x, y꞉ float)꞉ float @{.importc꞉ "fmod", header꞉ "<math.h>".@}
@end example
  Computes the remainder of @emph{x} divided by @emph{y}
@example
echo fmod(-2.5, 0.3) ## -0.1
@end example

@item degToRad
  @findex proc degToRad*[T꞉ float32 | float64](d꞉ T)꞉ T @{.inline.@}
@example
proc degToRad*[T꞉ float32 | float64](d꞉ T)꞉ T @{.inline.@}
@end example
  Convert from degrees to radians

@item radToDeg
  @findex proc radToDeg*[T꞉ float32 | float64](d꞉ T)꞉ T @{.inline.@}
@example
proc radToDeg*[T꞉ float32 | float64](d꞉ T)꞉ T @{.inline.@}
@end example
  Convert from radians to degrees

@item `mod`
  @findex proc `mod`*(x, y꞉ float)꞉ float
@example
proc `mod`*(x, y꞉ float)꞉ float
@end example
  Computes the modulo operation for float operators. Equivalent to @code{x - y * floor(x/y)}. Note that the remainder will always have the same sign as the divisor.
@example
echo (4.0 mod -3.1) # -2.2
@end example

@item random
  @findex proc random*[T](x꞉ Slice[T])꞉ T
@example
proc random*[T](x꞉ Slice[T])꞉ T
@end example
  For a slice @emph{a .. b} returns a value in the range @emph{a .. b-1}.

@item random
  @findex proc random*[T](a꞉ openArray[T])꞉ T
@example
proc random*[T](a꞉ openArray[T])꞉ T
@end example
  returns a random element from the openarray @emph{a}.

@item `^`
  @findex proc `^`*[T](x, y꞉ T)꞉ T
@example
proc `^`*[T](x, y꞉ T)꞉ T
@end example
  Computes @code{x} to the power @code{y`. ``x} must be non-negative, use @emph{pow <#pow,float,float>} for negative exponents.

@item gcd
  @findex proc gcd*[T](x, y꞉ T)꞉ T
@example
proc gcd*[T](x, y꞉ T)꞉ T
@end example
  Computes the greatest common divisor of @code{x} and @code{y}. Note that for floats, the result cannot always be interpreted as "greatest decimal @emph{z} such that @code{z*N == x and z*M == y} where N and M are positive integers."

@item lcm
  @findex proc lcm*[T](x, y꞉ T)꞉ T
@example
proc lcm*[T](x, y꞉ T)꞉ T
@end example
  Computes the least common multiple of @code{x} and @code{y}.
@end itemize






@node /pure/complex, /pure/json , /pure/math, Top



@chapter Types

@itemize


@item Complex
  @tindex Complex* = tuple[re, im꞉ float]
@example
Complex* = tuple[re, im꞉ float]
@end example
  a complex number, consisting of a real and an imaginary part
@end itemize

@chapter Procedures

@itemize


@item toComplex
  @findex proc toComplex*(x꞉ SomeInteger)꞉ Complex
@example
proc toComplex*(x꞉ SomeInteger)꞉ Complex
@end example
  Convert some integer @code{x} to a complex number.

@item `==`
  @findex proc `==`*(x, y꞉ Complex)꞉ bool
@example
proc `==`*(x, y꞉ Complex)꞉ bool
@end example
  Compare two complex numbers @emph{x} and @emph{y} for equality.

@item `=~`
  @findex proc `=~`*(x, y꞉ Complex)꞉ bool
@example
proc `=~`*(x, y꞉ Complex)꞉ bool
@end example
  Compare two complex numbers @emph{x} and @emph{y} approximately.

@item `+`
  @findex proc `+`*(x, y꞉ Complex)꞉ Complex
@example
proc `+`*(x, y꞉ Complex)꞉ Complex
@end example
  Add two complex numbers.

@item `+`
  @findex proc `+`*(x꞉ Complex; y꞉ float)꞉ Complex
@example
proc `+`*(x꞉ Complex; y꞉ float)꞉ Complex
@end example
  Add complex @emph{x} to float @emph{y}.

@item `+`
  @findex proc `+`*(x꞉ float; y꞉ Complex)꞉ Complex
@example
proc `+`*(x꞉ float; y꞉ Complex)꞉ Complex
@end example
  Add float @emph{x} to complex @emph{y}.

@item `-`
  @findex proc `-`*(z꞉ Complex)꞉ Complex
@example
proc `-`*(z꞉ Complex)꞉ Complex
@end example
  Unary minus for complex numbers.

@item `-`
  @findex proc `-`*(x, y꞉ Complex)꞉ Complex
@example
proc `-`*(x, y꞉ Complex)꞉ Complex
@end example
  Subtract two complex numbers.

@item `-`
  @findex proc `-`*(x꞉ Complex; y꞉ float)꞉ Complex
@example
proc `-`*(x꞉ Complex; y꞉ float)꞉ Complex
@end example
  Subtracts float @emph{y} from complex @emph{x}.

@item `-`
  @findex proc `-`*(x꞉ float; y꞉ Complex)꞉ Complex
@example
proc `-`*(x꞉ float; y꞉ Complex)꞉ Complex
@end example
  Subtracts complex @emph{y} from float @emph{x}.

@item `/`
  @findex proc `/`*(x, y꞉ Complex)꞉ Complex
@example
proc `/`*(x, y꞉ Complex)꞉ Complex
@end example
  Divide @emph{x} by @emph{y}.

@item `/`
  @findex proc `/`*(x꞉ Complex; y꞉ float)꞉ Complex
@example
proc `/`*(x꞉ Complex; y꞉ float)꞉ Complex
@end example
  Divide complex @emph{x} by float @emph{y}.

@item `/`
  @findex proc `/`*(x꞉ float; y꞉ Complex)꞉ Complex
@example
proc `/`*(x꞉ float; y꞉ Complex)꞉ Complex
@end example
  Divide float @emph{x} by complex @emph{y}.

@item `*`
  @findex proc `*`*(x, y꞉ Complex)꞉ Complex
@example
proc `*`*(x, y꞉ Complex)꞉ Complex
@end example
  Multiply @emph{x} with @emph{y}.

@item `*`
  @findex proc `*`*(x꞉ float; y꞉ Complex)꞉ Complex
@example
proc `*`*(x꞉ float; y꞉ Complex)꞉ Complex
@end example
  Multiply float @emph{x} with complex @emph{y}.

@item `*`
  @findex proc `*`*(x꞉ Complex; y꞉ float)꞉ Complex
@example
proc `*`*(x꞉ Complex; y꞉ float)꞉ Complex
@end example
  Multiply complex @emph{x} with float @emph{y}.

@item `+=`
  @findex proc `+=`*(x꞉ var Complex; y꞉ Complex)
@example
proc `+=`*(x꞉ var Complex; y꞉ Complex)
@end example
  Add @emph{y} to @emph{x}.

@item `+=`
  @findex proc `+=`*(x꞉ var Complex; y꞉ float)
@example
proc `+=`*(x꞉ var Complex; y꞉ float)
@end example
  Add @emph{y} to the complex number @emph{x}.

@item `-=`
  @findex proc `-=`*(x꞉ var Complex; y꞉ Complex)
@example
proc `-=`*(x꞉ var Complex; y꞉ Complex)
@end example
  Subtract @emph{y} from @emph{x}.

@item `-=`
  @findex proc `-=`*(x꞉ var Complex; y꞉ float)
@example
proc `-=`*(x꞉ var Complex; y꞉ float)
@end example
  Subtract @emph{y} from the complex number @emph{x}.

@item `*=`
  @findex proc `*=`*(x꞉ var Complex; y꞉ Complex)
@example
proc `*=`*(x꞉ var Complex; y꞉ Complex)
@end example
  Multiply @emph{y} to @emph{x}.

@item `*=`
  @findex proc `*=`*(x꞉ var Complex; y꞉ float)
@example
proc `*=`*(x꞉ var Complex; y꞉ float)
@end example
  Multiply @emph{y} to the complex number @emph{x}.

@item `/=`
  @findex proc `/=`*(x꞉ var Complex; y꞉ Complex)
@example
proc `/=`*(x꞉ var Complex; y꞉ Complex)
@end example
  Divide @emph{x} by @emph{y} in place.

@item `/=`
  @findex proc `/=`*(x꞉ var Complex; y꞉ float)
@example
proc `/=`*(x꞉ var Complex; y꞉ float)
@end example
  Divide complex @emph{x} by float @emph{y} in place.

@item abs
  @findex proc abs*(z꞉ Complex)꞉ float
@example
proc abs*(z꞉ Complex)꞉ float
@end example
  Return the distance from (0,0) to @emph{z}.

@item conjugate
  @findex proc conjugate*(z꞉ Complex)꞉ Complex
@example
proc conjugate*(z꞉ Complex)꞉ Complex
@end example
  Conjugate of complex number @emph{z}.

@item sqrt
  @findex proc sqrt*(z꞉ Complex)꞉ Complex
@example
proc sqrt*(z꞉ Complex)꞉ Complex
@end example
  Square root for a complex number @emph{z}.

@item exp
  @findex proc exp*(z꞉ Complex)꞉ Complex
@example
proc exp*(z꞉ Complex)꞉ Complex
@end example
  e raised to the power @emph{z}.

@item ln
  @findex proc ln*(z꞉ Complex)꞉ Complex
@example
proc ln*(z꞉ Complex)꞉ Complex
@end example
  Returns the natural log of @emph{z}.

@item log10
  @findex proc log10*(z꞉ Complex)꞉ Complex
@example
proc log10*(z꞉ Complex)꞉ Complex
@end example
  Returns the log base 10 of @emph{z}.

@item log2
  @findex proc log2*(z꞉ Complex)꞉ Complex
@example
proc log2*(z꞉ Complex)꞉ Complex
@end example
  Returns the log base 2 of @emph{z}.

@item pow
  @findex proc pow*(x, y꞉ Complex)꞉ Complex
@example
proc pow*(x, y꞉ Complex)꞉ Complex
@end example
  @emph{x} raised to the power @emph{y}.

@item sin
  @findex proc sin*(z꞉ Complex)꞉ Complex
@example
proc sin*(z꞉ Complex)꞉ Complex
@end example
  Returns the sine of @emph{z}.

@item arcsin
  @findex proc arcsin*(z꞉ Complex)꞉ Complex
@example
proc arcsin*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse sine of @emph{z}.

@item cos
  @findex proc cos*(z꞉ Complex)꞉ Complex
@example
proc cos*(z꞉ Complex)꞉ Complex
@end example
  Returns the cosine of @emph{z}.

@item arccos
  @findex proc arccos*(z꞉ Complex)꞉ Complex
@example
proc arccos*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse cosine of @emph{z}.

@item tan
  @findex proc tan*(z꞉ Complex)꞉ Complex
@example
proc tan*(z꞉ Complex)꞉ Complex
@end example
  Returns the tangent of @emph{z}.

@item arctan
  @findex proc arctan*(z꞉ Complex)꞉ Complex
@example
proc arctan*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse tangent of @emph{z}.

@item cot
  @findex proc cot*(z꞉ Complex)꞉ Complex
@example
proc cot*(z꞉ Complex)꞉ Complex
@end example
  Returns the cotangent of @emph{z}.

@item arccot
  @findex proc arccot*(z꞉ Complex)꞉ Complex
@example
proc arccot*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse cotangent of @emph{z}.

@item sec
  @findex proc sec*(z꞉ Complex)꞉ Complex
@example
proc sec*(z꞉ Complex)꞉ Complex
@end example
  Returns the secant of @emph{z}.

@item arcsec
  @findex proc arcsec*(z꞉ Complex)꞉ Complex
@example
proc arcsec*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse secant of @emph{z}.

@item csc
  @findex proc csc*(z꞉ Complex)꞉ Complex
@example
proc csc*(z꞉ Complex)꞉ Complex
@end example
  Returns the cosecant of @emph{z}.

@item arccsc
  @findex proc arccsc*(z꞉ Complex)꞉ Complex
@example
proc arccsc*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse cosecant of @emph{z}.

@item sinh
  @findex proc sinh*(z꞉ Complex)꞉ Complex
@example
proc sinh*(z꞉ Complex)꞉ Complex
@end example
  Returns the hyperbolic sine of @emph{z}.

@item arcsinh
  @findex proc arcsinh*(z꞉ Complex)꞉ Complex
@example
proc arcsinh*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse hyperbolic sine of @emph{z}.

@item cosh
  @findex proc cosh*(z꞉ Complex)꞉ Complex
@example
proc cosh*(z꞉ Complex)꞉ Complex
@end example
  Returns the hyperbolic cosine of @emph{z}.

@item arccosh
  @findex proc arccosh*(z꞉ Complex)꞉ Complex
@example
proc arccosh*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse hyperbolic cosine of @emph{z}.

@item tanh
  @findex proc tanh*(z꞉ Complex)꞉ Complex
@example
proc tanh*(z꞉ Complex)꞉ Complex
@end example
  Returns the hyperbolic tangent of @emph{z}.

@item arctanh
  @findex proc arctanh*(z꞉ Complex)꞉ Complex
@example
proc arctanh*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse hyperbolic tangent of @emph{z}.

@item sech
  @findex proc sech*(z꞉ Complex)꞉ Complex
@example
proc sech*(z꞉ Complex)꞉ Complex
@end example
  Returns the hyperbolic secant of @emph{z}.

@item arcsech
  @findex proc arcsech*(z꞉ Complex)꞉ Complex
@example
proc arcsech*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse hyperbolic secant of @emph{z}.

@item csch
  @findex proc csch*(z꞉ Complex)꞉ Complex
@example
proc csch*(z꞉ Complex)꞉ Complex
@end example
  Returns the hyperbolic cosecant of @emph{z}.

@item arccsch
  @findex proc arccsch*(z꞉ Complex)꞉ Complex
@example
proc arccsch*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse hyperbolic cosecant of @emph{z}.

@item coth
  @findex proc coth*(z꞉ Complex)꞉ Complex
@example
proc coth*(z꞉ Complex)꞉ Complex
@end example
  Returns the hyperbolic cotangent of @emph{z}.

@item arccoth
  @findex proc arccoth*(z꞉ Complex)꞉ Complex
@example
proc arccoth*(z꞉ Complex)꞉ Complex
@end example
  Returns the inverse hyperbolic cotangent of @emph{z}.

@item phase
  @findex proc phase*(z꞉ Complex)꞉ float
@example
proc phase*(z꞉ Complex)꞉ float
@end example
  Returns the phase of @emph{z}.

@item polar
  @findex proc polar*(z꞉ Complex)꞉ tuple[r, phi꞉ float]
@example
proc polar*(z꞉ Complex)꞉ tuple[r, phi꞉ float]
@end example
  Returns @emph{z} in polar coordinates.

@item rect
  @findex proc rect*(r꞉ float; phi꞉ float)꞉ Complex
@example
proc rect*(r꞉ float; phi꞉ float)꞉ Complex
@end example
  Returns the complex number with polar coordinates @emph{r} and @emph{phi}.

@item `$`
  @findex proc `$`*(z꞉ Complex)꞉ string
@example
proc `$`*(z꞉ Complex)꞉ string
@end example
  Returns @emph{z}'s string representation as @code{"(re, im)"}.
@end itemize






@node /pure/json, /pure/parseutils , /pure/complex, Top



@chapter Types

@itemize


@item JsonParser
  @tindex JsonParser* = object of BaseLexer
  a: string
  tok: TokKind
  kind: JsonEventKind
  err: JsonError
  state: seq[ParserState]
  filename: string

@example
JsonParser* = object of BaseLexer
  a: string
  tok: TokKind
  kind: JsonEventKind
  err: JsonError
  state: seq[ParserState]
  filename: string

@end example
  the parser object.

@item JsonParsingError
  @tindex JsonParsingError* = object of ValueError
@example
JsonParsingError* = object of ValueError
@end example
  is raised for a JSON error
@end itemize

@chapter Procedures

@itemize


@item open
  @findex proc open*(my꞉ var JsonParser; input꞉ Stream; filename꞉ string)
@example
proc open*(my꞉ var JsonParser; input꞉ Stream; filename꞉ string)
@end example
  initializes the parser with an input stream. @emph{Filename} is only used for nice error messages.

@item close
  @findex proc close*(my꞉ var JsonParser) @{.inline.@}
@example
proc close*(my꞉ var JsonParser) @{.inline.@}
@end example
  closes the parser @emph{my} and its associated input stream.

@item str
  @findex proc str*(my꞉ JsonParser)꞉ string @{.inline.@}
@example
proc str*(my꞉ JsonParser)꞉ string @{.inline.@}
@end example
  returns the character data for the events: @code{jsonInt}, @code{jsonFloat}, @code{jsonString}

@item getInt
  @findex proc getInt*(my꞉ JsonParser)꞉ BiggestInt @{.inline.@}
@example
proc getInt*(my꞉ JsonParser)꞉ BiggestInt @{.inline.@}
@end example
  returns the number for the event: @code{jsonInt}

@item getFloat
  @findex proc getFloat*(my꞉ JsonParser)꞉ float @{.inline.@}
@example
proc getFloat*(my꞉ JsonParser)꞉ float @{.inline.@}
@end example
  returns the number for the event: @code{jsonFloat}

@item kind
  @findex proc kind*(my꞉ JsonParser)꞉ JsonEventKind @{.inline.@}
@example
proc kind*(my꞉ JsonParser)꞉ JsonEventKind @{.inline.@}
@end example
  returns the current event type for the JSON parser

@item getColumn
  @findex proc getColumn*(my꞉ JsonParser)꞉ int @{.inline.@}
@example
proc getColumn*(my꞉ JsonParser)꞉ int @{.inline.@}
@end example
  get the current column the parser has arrived at.

@item getLine
  @findex proc getLine*(my꞉ JsonParser)꞉ int @{.inline.@}
@example
proc getLine*(my꞉ JsonParser)꞉ int @{.inline.@}
@end example
  get the current line the parser has arrived at.

@item getFilename
  @findex proc getFilename*(my꞉ JsonParser)꞉ string @{.inline.@}
@example
proc getFilename*(my꞉ JsonParser)꞉ string @{.inline.@}
@end example
  get the filename of the file that the parser processes.

@item errorMsg
  @findex proc errorMsg*(my꞉ JsonParser)꞉ string
@example
proc errorMsg*(my꞉ JsonParser)꞉ string
@end example
  returns a helpful error message for the event @code{jsonError}

@item errorMsgExpected
  @findex proc errorMsgExpected*(my꞉ JsonParser; e꞉ string)꞉ string
@example
proc errorMsgExpected*(my꞉ JsonParser; e꞉ string)꞉ string
@end example
  returns an error message "@emph{e} expected" in the same format as the other error messages

@item next
  @findex proc next*(my꞉ var JsonParser)
@example
proc next*(my꞉ var JsonParser)
@end example
  retrieves the first/next event. This controls the parser.

@item raiseParseErr
  @findex proc raiseParseErr*(p꞉ JsonParser; msg꞉ string) @{.noinline, noreturn.@}
@example
proc raiseParseErr*(p꞉ JsonParser; msg꞉ string) @{.noinline, noreturn.@}
@end example
  raises an @emph{EJsonParsingError} exception.

@item newJString
  @findex proc newJString*(s꞉ string)꞉ JsonNode
@example
proc newJString*(s꞉ string)꞉ JsonNode
@end example
  Creates a new @emph{JString JsonNode}.

@item newJInt
  @findex proc newJInt*(n꞉ BiggestInt)꞉ JsonNode
@example
proc newJInt*(n꞉ BiggestInt)꞉ JsonNode
@end example
  Creates a new @emph{JInt JsonNode}.

@item newJFloat
  @findex proc newJFloat*(n꞉ float)꞉ JsonNode
@example
proc newJFloat*(n꞉ float)꞉ JsonNode
@end example
  Creates a new @emph{JFloat JsonNode}.

@item newJBool
  @findex proc newJBool*(b꞉ bool)꞉ JsonNode
@example
proc newJBool*(b꞉ bool)꞉ JsonNode
@end example
  Creates a new @emph{JBool JsonNode}.

@item newJNull
  @findex proc newJNull*()꞉ JsonNode
@example
proc newJNull*()꞉ JsonNode
@end example
  Creates a new @emph{JNull JsonNode}.

@item newJObject
  @findex proc newJObject*()꞉ JsonNode
@example
proc newJObject*()꞉ JsonNode
@end example
  Creates a new @emph{JObject JsonNode}

@item newJArray
  @findex proc newJArray*()꞉ JsonNode
@example
proc newJArray*()꞉ JsonNode
@end example
  Creates a new @emph{JArray JsonNode}

@item getStr
  @findex proc getStr*(n꞉ JsonNode; default꞉ string = "")꞉ string
@example
proc getStr*(n꞉ JsonNode; default꞉ string = "")꞉ string
@end example
  Retrieves the string value of a @emph{JString JsonNode}.

Returns @code{default} if @code{n} is not a @code{JString}, or if @code{n} is nil.

@item getNum
  @findex proc getNum*(n꞉ JsonNode; default꞉ BiggestInt = 0)꞉ BiggestInt
@example
proc getNum*(n꞉ JsonNode; default꞉ BiggestInt = 0)꞉ BiggestInt
@end example
  Retrieves the int value of a @emph{JInt JsonNode}.

Returns @code{default} if @code{n} is not a @code{JInt}, or if @code{n} is nil.

@item getFNum
  @findex proc getFNum*(n꞉ JsonNode; default꞉ float = 0.0'f64)꞉ float
@example
proc getFNum*(n꞉ JsonNode; default꞉ float = 0.0'f64)꞉ float
@end example
  Retrieves the float value of a @emph{JFloat JsonNode}.

Returns @code{default} if @code{n} is not a @code{JFloat} or @code{JInt}, or if @code{n} is nil.

@item getBVal
  @findex proc getBVal*(n꞉ JsonNode; default꞉ bool = false)꞉ bool
@example
proc getBVal*(n꞉ JsonNode; default꞉ bool = false)꞉ bool
@end example
  Retrieves the bool value of a @emph{JBool JsonNode}.

Returns @code{default} if @code{n} is not a @code{JBool}, or if @code{n} is nil.

@item getFields
  @findex proc getFields*(n꞉ JsonNode; default꞉ seq[tuple[key꞉ string, val꞉ JsonNode]] = @@ [])꞉ seq[tuple[key꞉ string, val꞉ JsonNode]]
@example
proc getFields*(n꞉ JsonNode; default꞉ seq[tuple[key꞉ string, val꞉ JsonNode]] = @@ [])꞉ seq[tuple[key꞉ string, val꞉ JsonNode]]
@end example
  Retrieves the key, value pairs of a @emph{JObject JsonNode}.

Returns @code{default} if @code{n} is not a @code{JObject}, or if @code{n} is nil.

@item getElems
  @findex proc getElems*(n꞉ JsonNode; default꞉ seq[JsonNode] = @@ [])꞉ seq[JsonNode]
@example
proc getElems*(n꞉ JsonNode; default꞉ seq[JsonNode] = @@ [])꞉ seq[JsonNode]
@end example
  Retrieves the int value of a @emph{JArray JsonNode}.

Returns @code{default} if @code{n} is not a @code{JArray}, or if @code{n} is nil.

@item `%`
  @findex proc `%`*(s꞉ string)꞉ JsonNode
@example
proc `%`*(s꞉ string)꞉ JsonNode
@end example
  Generic constructor for JSON data. Creates a new @emph{JString JsonNode}.

@item `%`
  @findex proc `%`*(n꞉ BiggestInt)꞉ JsonNode
@example
proc `%`*(n꞉ BiggestInt)꞉ JsonNode
@end example
  Generic constructor for JSON data. Creates a new @emph{JInt JsonNode}.

@item `%`
  @findex proc `%`*(n꞉ float)꞉ JsonNode
@example
proc `%`*(n꞉ float)꞉ JsonNode
@end example
  Generic constructor for JSON data. Creates a new @emph{JFloat JsonNode}.

@item `%`
  @findex proc `%`*(b꞉ bool)꞉ JsonNode
@example
proc `%`*(b꞉ bool)꞉ JsonNode
@end example
  Generic constructor for JSON data. Creates a new @emph{JBool JsonNode}.

@item `%`
  @findex proc `%`*(keyVals꞉ openArray[tuple[key꞉ string, val꞉ JsonNode]])꞉ JsonNode
@example
proc `%`*(keyVals꞉ openArray[tuple[key꞉ string, val꞉ JsonNode]])꞉ JsonNode
@end example
  Generic constructor for JSON data. Creates a new @emph{JObject JsonNode}

@item `%`
  @findex proc `%`*(elements꞉ openArray[JsonNode])꞉ JsonNode
@example
proc `%`*(elements꞉ openArray[JsonNode])꞉ JsonNode
@end example
  Generic constructor for JSON data. Creates a new @emph{JArray JsonNode}

@item `==`
  @findex proc `==`*(a, b꞉ JsonNode)꞉ bool
@example
proc `==`*(a, b꞉ JsonNode)꞉ bool
@end example
  Check two nodes for equality

@item hash
  @findex proc hash*(n꞉ JsonNode)꞉ Hash
@example
proc hash*(n꞉ JsonNode)꞉ Hash
@end example
  Compute the hash for a JSON node

@item len
  @findex proc len*(n꞉ JsonNode)꞉ int
@example
proc len*(n꞉ JsonNode)꞉ int
@end example
  If @emph{n} is a @emph{JArray}, it returns the number of elements. If @emph{n} is a @emph{JObject}, it returns the number of pairs. Else it returns 0.

@item `[]`
  @findex proc `[]`*(node꞉ JsonNode; name꞉ string)꞉ JsonNode @{.inline.@}
@example
proc `[]`*(node꞉ JsonNode; name꞉ string)꞉ JsonNode @{.inline.@}
@end example
  Gets a field from a @emph{JObject}, which must not be nil. If the value at @emph{name} does not exist, returns nil

@item `[]`
  @findex proc `[]`*(node꞉ JsonNode; index꞉ int)꞉ JsonNode @{.inline.@}
@example
proc `[]`*(node꞉ JsonNode; index꞉ int)꞉ JsonNode @{.inline.@}
@end example
  Gets the node at @emph{index} in an Array. Result is undefined if @emph{index} is out of bounds

@item hasKey
  @findex proc hasKey*(node꞉ JsonNode; key꞉ string)꞉ bool
@example
proc hasKey*(node꞉ JsonNode; key꞉ string)꞉ bool
@end example
  Checks if @emph{key} exists in @emph{node}.

@item existsKey
  @findex proc existsKey*(node꞉ JsonNode; key꞉ string)꞉ bool @{.deprecated.@}
@example
proc existsKey*(node꞉ JsonNode; key꞉ string)꞉ bool @{.deprecated.@}
@end example
  Deprecated for @emph{hasKey}

@item add
  @findex proc add*(father, child꞉ JsonNode)
@example
proc add*(father, child꞉ JsonNode)
@end example
  Adds @emph{child} to a JArray node @emph{father}.

@item add
  @findex proc add*(obj꞉ JsonNode; key꞉ string; val꞉ JsonNode)
@example
proc add*(obj꞉ JsonNode; key꞉ string; val꞉ JsonNode)
@end example
  Adds @code{(key, val)} pair to the JObject node @emph{obj}. For speed reasons no check for duplicate keys is performed! But @code{[]=} performs the check.

@item `[]=`
  @findex proc `[]=`*(obj꞉ JsonNode; key꞉ string; val꞉ JsonNode) @{.inline.@}
@example
proc `[]=`*(obj꞉ JsonNode; key꞉ string; val꞉ JsonNode) @{.inline.@}
@end example
  Sets a field from a @emph{JObject}. Performs a check for duplicate keys.

@item `@@@{@@@}`
  @findex proc `@{@}`*(node꞉ JsonNode; keys꞉ varargs[string])꞉ JsonNode
@example
proc `@{@}`*(node꞉ JsonNode; keys꞉ varargs[string])꞉ JsonNode
@end example
  Traverses the node and gets the given value. If any of the keys do not exist, returns nil. Also returns nil if one of the intermediate data structures is not an object

@item `@@@{@@@}=`
  @findex proc `@{@}=`*(node꞉ JsonNode; keys꞉ varargs[string]; value꞉ JsonNode)
@example
proc `@{@}=`*(node꞉ JsonNode; keys꞉ varargs[string]; value꞉ JsonNode)
@end example
  Traverses the node and tries to set the value at the given location to @emph{value} If any of the keys are missing, they are added

@item delete
  @findex proc delete*(obj꞉ JsonNode; key꞉ string)
@example
proc delete*(obj꞉ JsonNode; key꞉ string)
@end example
  Deletes @code{obj[key]} preserving the order of the other (key, value)-pairs.

@item copy
  @findex proc copy*(p꞉ JsonNode)꞉ JsonNode
@example
proc copy*(p꞉ JsonNode)꞉ JsonNode
@end example
  Performs a deep copy of @emph{a}.

@item escapeJson
  @findex proc escapeJson*(s꞉ string)꞉ string
@example
proc escapeJson*(s꞉ string)꞉ string
@end example
  Converts a string @emph{s} to its JSON representation.

@item pretty
  @findex proc pretty*(node꞉ JsonNode; indent = 2)꞉ string
@example
proc pretty*(node꞉ JsonNode; indent = 2)꞉ string
@end example
  Converts @emph{node} to its JSON Representation, with indentation and on multiple lines.

@item toUgly
  @findex proc toUgly*(result꞉ var string; node꞉ JsonNode)
@example
proc toUgly*(result꞉ var string; node꞉ JsonNode)
@end example
  Converts @emph{node} to its JSON Representation, without regard for human readability. Meant to improve @code{$} string conversion performance.

This provides higher efficiency than the @code{toPretty} procedure as it does @strong{not} attempt to format the resulting JSON to make it human readable.

@item `$`
  @findex proc `$`*(node꞉ JsonNode)꞉ string
@example
proc `$`*(node꞉ JsonNode)꞉ string
@end example
  Converts @emph{node} to its JSON Representation on one line.

@item parseJson
  @findex proc parseJson*(s꞉ Stream; filename꞉ string)꞉ JsonNode
@example
proc parseJson*(s꞉ Stream; filename꞉ string)꞉ JsonNode
@end example
  Parses from a stream @emph{s} into a @emph{JsonNode}. @emph{filename} is only needed for nice error messages.

@item parseJson
  @findex proc parseJson*(buffer꞉ string)꞉ JsonNode
@example
proc parseJson*(buffer꞉ string)꞉ JsonNode
@end example
  Parses JSON from @emph{buffer}.

@item parseFile
  @findex proc parseFile*(filename꞉ string)꞉ JsonNode
@example
proc parseFile*(filename꞉ string)꞉ JsonNode
@end example
  Parses @emph{file} into a @emph{JsonNode}.
@end itemize


@chapter Macros

@itemize


@item `%*`
  @findex macro `%*`*(x꞉ expr)꞉ expr
@example
macro `%*`*(x꞉ expr)꞉ expr
@end example
  Convert an expression to a JsonNode directly, without having to specify @emph{%} for every element.
@end itemize



@chapter Iterators

@itemize


@item items
  @itindex iterator items*(node꞉ JsonNode)꞉ JsonNode
@example
iterator items*(node꞉ JsonNode)꞉ JsonNode
@end example
  Iterator for the items of @emph{node}. @emph{node} has to be a JArray.

@item mitems
  @itindex iterator mitems*(node꞉ var JsonNode)꞉ var JsonNode
@example
iterator mitems*(node꞉ var JsonNode)꞉ var JsonNode
@end example
  Iterator for the items of @emph{node}. @emph{node} has to be a JArray. Items can be modified.

@item pairs
  @itindex iterator pairs*(node꞉ JsonNode)꞉ tuple[key꞉ string, val꞉ JsonNode]
@example
iterator pairs*(node꞉ JsonNode)꞉ tuple[key꞉ string, val꞉ JsonNode]
@end example
  Iterator for the child elements of @emph{node}. @emph{node} has to be a JObject.

@item mpairs
  @itindex iterator mpairs*(node꞉ var JsonNode)꞉ var tuple[key꞉ string, val꞉ JsonNode]
@example
iterator mpairs*(node꞉ var JsonNode)꞉ var tuple[key꞉ string, val꞉ JsonNode]
@end example
  Iterator for the child elements of @emph{node}. @emph{node} has to be a JObject. Items can be modified
@end itemize

@node /pure/parseutils, /pure/terminal , /pure/json, Top



@chapter Types

@itemize


@item InterpolatedKind
  @tindex InterpolatedKind* = enum
  ikStr,                      ## ``str`` part of the interpolated string
  ikDollar,                   ## escaped ``$`` part of the interpolated string
  ikVar,                      ## ``var`` part of the interpolated string
  ikExpr                      ## ``expr`` part of the interpolated string
@example
InterpolatedKind* = enum
  ikStr,                      ## ``str`` part of the interpolated string
  ikDollar,                   ## escaped ``$`` part of the interpolated string
  ikVar,                      ## ``var`` part of the interpolated string
  ikExpr                      ## ``expr`` part of the interpolated string
@end example
  describes for @emph{interpolatedFragments} which part of the interpolated string is yielded; for example in "str$$$var$@{expr@}"
@end itemize

@chapter Procedures

@itemize


@item parseHex
  @findex proc parseHex*(s꞉ string; number꞉ var int; start = 0; maxLen = 0)꞉ int @{.rtl,extern꞉ "npuParseHex", noSideEffect.@}
@example
proc parseHex*(s꞉ string; number꞉ var int; start = 0; maxLen = 0)꞉ int @{.rtl,extern꞉ "npuParseHex", noSideEffect.@}
@end example
  Parses a hexadecimal number and stores its value in @code{number}.

Returns the number of the parsed characters or 0 in case of an error. This proc is sensitive to the already existing value of @code{number} and will likely not do what you want unless you make sure @code{number} is zero. You can use this feature to @emph{chain} calls, though the result int will quickly overflow. Example:


@example
var value = 0
discard parseHex("0x38", value)
assert value == 56
discard parseHex("0x34", value)
assert value == 56 * 256 + 52
value = -1
discard parseHex("0x38", value)
assert value == -200
@end example
If 'maxLen==0' the length of the hexadecimal number has no upper bound. Not more than ```maxLen`` characters are parsed.

@item parseOct
  @findex proc parseOct*(s꞉ string; number꞉ var int; start = 0)꞉ int @{.rtl, extern꞉ "npuParseOct",noSideEffect.@}
@example
proc parseOct*(s꞉ string; number꞉ var int; start = 0)꞉ int @{.rtl, extern꞉ "npuParseOct",noSideEffect.@}
@end example
  parses an octal number and stores its value in @code{number}. Returns the number of the parsed characters or 0 in case of an error.

@item parseIdent
  @findex proc parseIdent*(s꞉ string; ident꞉ var string; start = 0)꞉ int
@example
proc parseIdent*(s꞉ string; ident꞉ var string; start = 0)꞉ int
@end example
  parses an identifier and stores it in @code{ident}. Returns the number of the parsed characters or 0 in case of an error.

@item parseIdent
  @findex proc parseIdent*(s꞉ string; start = 0)꞉ string
@example
proc parseIdent*(s꞉ string; start = 0)꞉ string
@end example
  parses an identifier and stores it in @code{ident}. Returns the parsed identifier or an empty string in case of an error.

@item parseToken
  @findex proc parseToken*(s꞉ string; token꞉ var string; validChars꞉ set[char]; start = 0)꞉ int @{.inline, deprecated.@}
@example
proc parseToken*(s꞉ string; token꞉ var string; validChars꞉ set[char]; start = 0)꞉ int @{.inline, deprecated.@}
@end example
  parses a token and stores it in @code{token}. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in @emph{validChars}.

@strong{Deprecated since version 0.8.12}: Use @code{parseWhile} instead.

@item skipWhitespace
  @findex proc skipWhitespace*(s꞉ string; start = 0)꞉ int @{.inline.@}
@example
proc skipWhitespace*(s꞉ string; start = 0)꞉ int @{.inline.@}
@end example
  skips the whitespace starting at @code{s[start]}. Returns the number of skipped characters.

@item skip
  @findex proc skip*(s, token꞉ string; start = 0)꞉ int @{.inline.@}
@example
proc skip*(s, token꞉ string; start = 0)꞉ int @{.inline.@}
@end example
  skips the @emph{token} starting at @code{s[start]}. Returns the length of @emph{token} or 0 if there was no @emph{token} at @code{s[start]}.

@item skipIgnoreCase
  @findex proc skipIgnoreCase*(s, token꞉ string; start = 0)꞉ int
@example
proc skipIgnoreCase*(s, token꞉ string; start = 0)꞉ int
@end example
  same as @emph{skip} but case is ignored for token matching.

@item skipUntil
  @findex proc skipUntil*(s꞉ string; until꞉ set[char]; start = 0)꞉ int @{.inline.@}
@example
proc skipUntil*(s꞉ string; until꞉ set[char]; start = 0)꞉ int @{.inline.@}
@end example
  Skips all characters until one char from the set @emph{until} is found or the end is reached. Returns number of characters skipped.

@item skipUntil
  @findex proc skipUntil*(s꞉ string; until꞉ char; start = 0)꞉ int @{.inline.@}
@example
proc skipUntil*(s꞉ string; until꞉ char; start = 0)꞉ int @{.inline.@}
@end example
  Skips all characters until the char @emph{until} is found or the end is reached. Returns number of characters skipped.

@item skipWhile
  @findex proc skipWhile*(s꞉ string; toSkip꞉ set[char]; start = 0)꞉ int @{.inline.@}
@example
proc skipWhile*(s꞉ string; toSkip꞉ set[char]; start = 0)꞉ int @{.inline.@}
@end example
  Skips all characters while one char from the set @emph{token} is found. Returns number of characters skipped.

@item parseUntil
  @findex proc parseUntil*(s꞉ string; token꞉ var string; until꞉ set[char]; start = 0)꞉ int @{.inline.@}
@example
proc parseUntil*(s꞉ string; token꞉ var string; until꞉ set[char]; start = 0)꞉ int @{.inline.@}
@end example
  parses a token and stores it in @code{token}. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin @emph{until}.

@item parseUntil
  @findex proc parseUntil*(s꞉ string; token꞉ var string; until꞉ char; start = 0)꞉ int @{.inline.@}
@example
proc parseUntil*(s꞉ string; token꞉ var string; until꞉ char; start = 0)꞉ int @{.inline.@}
@end example
  parses a token and stores it in @code{token}. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the @emph{until} character.

@item parseWhile
  @findex proc parseWhile*(s꞉ string; token꞉ var string; validChars꞉ set[char]; start = 0)꞉ int @{.inline.@}
@example
proc parseWhile*(s꞉ string; token꞉ var string; validChars꞉ set[char]; start = 0)꞉ int @{.inline.@}
@end example
  parses a token and stores it in @code{token}. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in @emph{validChars}.

@item captureBetween
  @findex proc captureBetween*(s꞉ string; first꞉ char; second = '\0'; start = 0)꞉ string
@example
proc captureBetween*(s꞉ string; first꞉ char; second = '\0'; start = 0)꞉ string
@end example
  Finds the first occurrence of @code{first}, then returns everything from there up to @code{second``(if ``second} is '0', then @code{first} is used).

@item parseBiggestInt
  @findex proc parseBiggestInt*(s꞉ string; number꞉ var BiggestInt; start = 0)꞉ int @{.rtl,extern꞉ "npuParseBiggestInt", noSideEffect.@}
@example
proc parseBiggestInt*(s꞉ string; number꞉ var BiggestInt; start = 0)꞉ int @{.rtl,extern꞉ "npuParseBiggestInt", noSideEffect.@}
@end example
  parses an integer starting at @emph{start} and stores the value into @emph{number}. Result is the number of processed chars or 0 if there is no integer. @emph{EOverflow} is raised if an overflow occurs.

@item parseInt
  @findex proc parseInt*(s꞉ string; number꞉ var int; start = 0)꞉ int @{.rtl, extern꞉ "npuParseInt",noSideEffect.@}
@example
proc parseInt*(s꞉ string; number꞉ var int; start = 0)꞉ int @{.rtl, extern꞉ "npuParseInt",noSideEffect.@}
@end example
  parses an integer starting at @emph{start} and stores the value into @emph{number}. Result is the number of processed chars or 0 if there is no integer. @emph{EOverflow} is raised if an overflow occurs.

@item parseBiggestFloat
  @findex proc parseBiggestFloat*(s꞉ string; number꞉ var BiggestFloat; start = 0)꞉ int @{.magic꞉ "ParseBiggestFloat", importc꞉ "nimParseBiggestFloat", noSideEffect.@}
@example
proc parseBiggestFloat*(s꞉ string; number꞉ var BiggestFloat; start = 0)꞉ int @{.magic꞉ "ParseBiggestFloat", importc꞉ "nimParseBiggestFloat", noSideEffect.@}
@end example
  parses a float starting at @emph{start} and stores the value into @emph{number}. Result is the number of processed chars or 0 if a parsing error occurred.

@item parseFloat
  @findex proc parseFloat*(s꞉ string; number꞉ var float; start = 0)꞉ int @{.rtl,extern꞉ "npuParseFloat", noSideEffect.@}
@example
proc parseFloat*(s꞉ string; number꞉ var float; start = 0)꞉ int @{.rtl,extern꞉ "npuParseFloat", noSideEffect.@}
@end example
  parses a float starting at @emph{start} and stores the value into @emph{number}. Result is the number of processed chars or 0 if there occurred a parsing error.
@end itemize





@chapter Iterators

@itemize


@item interpolatedFragments
  @itindex iterator interpolatedFragments*(s꞉ string)꞉ tuple[kind꞉ InterpolatedKind,value꞉ string]
@example
iterator interpolatedFragments*(s꞉ string)꞉ tuple[kind꞉ InterpolatedKind,value꞉ string]
@end example
  Tokenizes the string @emph{s} into substrings for interpolation purposes.

Example:


@example
for k, v in interpolatedFragments("  $this is $@{an  example@}  $$"):
  echo "(", k, ", \"", v, "\")"
@end example
Results in:


@example
(ikString, "  ")
(ikExpr, "this")
(ikString, " is ")
(ikExpr, "an  example")
(ikString, "  ")
(ikDollar, "$")
@end example
@end itemize

@node /pure/terminal, /pure/oids , /pure/parseutils, Top



@chapter Types

@itemize


@item Style
  @tindex Style* = enum
  styleBright = 1,              ## bright text
  styleDim,                   ## dim text
  styleUnknown,               ## unknown
  styleUnderscore = 4,          ## underscored text
  styleBlink,                 ## blinking/bold text
  styleReverse = 7,             ## unknown
  styleHidden                 ## hidden text
@example
Style* = enum
  styleBright = 1,              ## bright text
  styleDim,                   ## dim text
  styleUnknown,               ## unknown
  styleUnderscore = 4,          ## underscored text
  styleBlink,                 ## blinking/bold text
  styleReverse = 7,             ## unknown
  styleHidden                 ## hidden text
@end example
  different styles for text output

@item BackgroundColor
  @tindex BackgroundColor* = enum
  bgBlack = 40,                 ## black
  bgRed,                      ## red
  bgGreen,                    ## green
  bgYellow,                   ## yellow
  bgBlue,                     ## blue
  bgMagenta,                  ## magenta
  bgCyan,                     ## cyan
  bgWhite                     ## white
@example
BackgroundColor* = enum
  bgBlack = 40,                 ## black
  bgRed,                      ## red
  bgGreen,                    ## green
  bgYellow,                   ## yellow
  bgBlue,                     ## blue
  bgMagenta,                  ## magenta
  bgCyan,                     ## cyan
  bgWhite                     ## white
@end example
  terminal's background colors

@item TerminalCmd
  @tindex TerminalCmd* = enumresetStyle                  ## reset attributes
@example
TerminalCmd* = enumresetStyle                  ## reset attributes
@end example
  commands that can be expressed as arguments
@end itemize

@chapter Procedures

@itemize


@item setCursorPos
  @findex proc setCursorPos*(f꞉ File; x, y꞉ int)
@example
proc setCursorPos*(f꞉ File; x, y꞉ int)
@end example
  Sets the terminal's cursor to the (x,y) position. (0,0) is the upper left of the screen.

@item setCursorXPos
  @findex proc setCursorXPos*(f꞉ File; x꞉ int)
@example
proc setCursorXPos*(f꞉ File; x꞉ int)
@end example
  Sets the terminal's cursor to the x position. The y position is not changed.

@item setCursorYPos
  @findex proc setCursorYPos*(f꞉ File; y꞉ int)
@example
proc setCursorYPos*(f꞉ File; y꞉ int)
@end example
  Sets the terminal's cursor to the y position. The x position is not changed. @strong{Warning}: This is not supported on UNIX!

@item cursorUp
  @findex proc cursorUp*(f꞉ File; count = 1)
@example
proc cursorUp*(f꞉ File; count = 1)
@end example
  Moves the cursor up by @emph{count} rows.

@item cursorDown
  @findex proc cursorDown*(f꞉ File; count = 1)
@example
proc cursorDown*(f꞉ File; count = 1)
@end example
  Moves the cursor down by @emph{count} rows.

@item cursorForward
  @findex proc cursorForward*(f꞉ File; count = 1)
@example
proc cursorForward*(f꞉ File; count = 1)
@end example
  Moves the cursor forward by @emph{count} columns.

@item cursorBackward
  @findex proc cursorBackward*(f꞉ File; count = 1)
@example
proc cursorBackward*(f꞉ File; count = 1)
@end example
  Moves the cursor backward by @emph{count} columns.

@item eraseLine
  @findex proc eraseLine*(f꞉ File)
@example
proc eraseLine*(f꞉ File)
@end example
  Erases the entire current line.

@item eraseScreen
  @findex proc eraseScreen*(f꞉ File)
@example
proc eraseScreen*(f꞉ File)
@end example
  Erases the screen with the background colour and moves the cursor to home.

@item resetAttributes
  @findex proc resetAttributes*(f꞉ File)
@example
proc resetAttributes*(f꞉ File)
@end example
  Resets all attributes.

@item setStyle
  @findex proc setStyle*(f꞉ File; style꞉ set[Style])
@example
proc setStyle*(f꞉ File; style꞉ set[Style])
@end example
  Sets the terminal style.

@item writeStyled
  @findex proc writeStyled*(txt꞉ string; style꞉ set[Style] = @{styleBright@})
@example
proc writeStyled*(txt꞉ string; style꞉ set[Style] = @{styleBright@})
@end example
  Writes the text @emph{txt} in a given @emph{style} to stdout.

@item setForegroundColor
  @findex proc setForegroundColor*(f꞉ File; fg꞉ ForegroundColor; bright = false)
@example
proc setForegroundColor*(f꞉ File; fg꞉ ForegroundColor; bright = false)
@end example
  Sets the terminal's foreground color.

@item setBackgroundColor
  @findex proc setBackgroundColor*(f꞉ File; bg꞉ BackgroundColor; bright = false)
@example
proc setBackgroundColor*(f꞉ File; bg꞉ BackgroundColor; bright = false)
@end example
  Sets the terminal's background color.

@item isatty
  @findex proc isatty*(f꞉ File)꞉ bool
@example
proc isatty*(f꞉ File)꞉ bool
@end example
  Returns true if @emph{f} is associated with a terminal device.

@item getch
  @findex proc getch*()꞉ char
@example
proc getch*()꞉ char
@end example
  Read a single character from the terminal, blocking until it is entered. The character is not printed to the terminal. This is not available for Windows.

@item resetAttributes
  @findex proc resetAttributes*() @{.noconv.@}
@example
proc resetAttributes*() @{.noconv.@}
@end example
  Resets all attributes on stdout. It is advisable to register this as a quit proc with @code{system.addQuitProc(resetAttributes)}.
@end itemize

@chapter Templates

@itemize


@item styledEcho
  @findex template styledEcho*(args꞉ varargs[expr])꞉ expr
@example
template styledEcho*(args꞉ varargs[expr])꞉ expr
@end example
  Echoes styles arguments to stdout using @code{styledWriteLine}.

@item setCursorPos
  @findex template setCursorPos*(x, y꞉ int)
@example
template setCursorPos*(x, y꞉ int)
@end example
  

@item setCursorXPos
  @findex template setCursorXPos*(x꞉ int)
@example
template setCursorXPos*(x꞉ int)
@end example
  

@item cursorUp
  @findex template cursorUp*(count = 1)
@example
template cursorUp*(count = 1)
@end example
  

@item cursorDown
  @findex template cursorDown*(count = 1)
@example
template cursorDown*(count = 1)
@end example
  

@item cursorForward
  @findex template cursorForward*(count = 1)
@example
template cursorForward*(count = 1)
@end example
  

@item cursorBackward
  @findex template cursorBackward*(count = 1)
@example
template cursorBackward*(count = 1)
@end example
  

@item eraseLine
  @findex template eraseLine*()
@example
template eraseLine*()
@end example
  

@item eraseScreen
  @findex template eraseScreen*()
@example
template eraseScreen*()
@end example
  

@item setStyle
  @findex template setStyle*(style꞉ set[Style])
@example
template setStyle*(style꞉ set[Style])
@end example
  

@item setForegroundColor
  @findex template setForegroundColor*(fg꞉ ForegroundColor; bright = false)
@example
template setForegroundColor*(fg꞉ ForegroundColor; bright = false)
@end example
  

@item setBackgroundColor
  @findex template setBackgroundColor*(bg꞉ BackgroundColor; bright = false)
@example
template setBackgroundColor*(bg꞉ BackgroundColor; bright = false)
@end example
  
@end itemize

@chapter Macros

@itemize


@item styledWriteLine
  @findex macro styledWriteLine*(f꞉ File; m꞉ varargs[expr])꞉ stmt
@example
macro styledWriteLine*(f꞉ File; m꞉ varargs[expr])꞉ stmt
@end example
  Similar to @code{writeLine}, but treating terminal style arguments specially. When some argument is @code{Style}, @code{set[Style]}, @code{ForegroundColor}, @code{BackgroundColor} or @code{TerminalCmd} then it is not sent directly to @code{f}, but instead corresponding terminal style proc is called.

Example:


@example

proc error(msg: string) =
  styleWriteLine(stderr, fgRed, "Error: ", resetStyle, msg)
@end example
@end itemize




@node /pure/oids, /pure/colors , /pure/terminal, Top



@chapter Types

@itemize


@item Oid
  @tindex Oid* = object
  time: int32                  ## 
  fuzz: int32                  ## 
  count: int32                 ## 
  
@example
Oid* = object
  time: int32                  ## 
  fuzz: int32                  ## 
  count: int32                 ## 
  
@end example
  an OID
@end itemize

@chapter Procedures

@itemize


@item `==`
  @findex proc `==`*(oid1꞉ Oid; oid2꞉ Oid)꞉ bool
@example
proc `==`*(oid1꞉ Oid; oid2꞉ Oid)꞉ bool
@end example
  Compare two Mongo Object IDs for equality

@item hexbyte
  @findex proc hexbyte*(hex꞉ char)꞉ int
@example
proc hexbyte*(hex꞉ char)꞉ int
@end example
  

@item parseOid
  @findex proc parseOid*(str꞉ cstring)꞉ Oid
@example
proc parseOid*(str꞉ cstring)꞉ Oid
@end example
  parses an OID.

@item oidToString
  @findex proc oidToString*(oid꞉ Oid; str꞉ cstring)
@example
proc oidToString*(oid꞉ Oid; str꞉ cstring)
@end example
  

@item `$`
  @findex proc `$`*(oid꞉ Oid)꞉ string
@example
proc `$`*(oid꞉ Oid)꞉ string
@end example
  

@item genOid
  @findex proc genOid*()꞉ Oid
@example
proc genOid*()꞉ Oid
@end example
  generates a new OID.

@item generatedTime
  @findex proc generatedTime*(oid꞉ Oid)꞉ Time
@example
proc generatedTime*(oid꞉ Oid)꞉ Time
@end example
  returns the generated timestamp of the OID.
@end itemize






@node /pure/colors, /pure/ospaths , /pure/oids, Top



@chapter Types

@itemize


@item Color
  @tindex Color* = distinct int
@example
Color* = distinct int
@end example
  a color stored as RGB
@end itemize

@chapter Procedures

@itemize


@item `==`
  @findex proc `==`*(a, b꞉ Color)꞉ bool @{.borrow.@}
@example
proc `==`*(a, b꞉ Color)꞉ bool @{.borrow.@}
@end example
  compares two colors.

@item `+`
  @findex proc `+`*(a, b꞉ Color)꞉ Color
@example
proc `+`*(a, b꞉ Color)꞉ Color
@end example
  adds two colors: This uses saturated artithmetic, so that each color component cannot overflow (255 is used as a maximum).

@item `-`
  @findex proc `-`*(a, b꞉ Color)꞉ Color
@example
proc `-`*(a, b꞉ Color)꞉ Color
@end example
  subtracts two colors: This uses saturated artithmetic, so that each color component cannot overflow (255 is used as a maximum).

@item extractRGB
  @findex proc extractRGB*(a꞉ Color)꞉ tuple[r, g, b꞉ range[0 .. 255]]
@example
proc extractRGB*(a꞉ Color)꞉ tuple[r, g, b꞉ range[0 .. 255]]
@end example
  extracts the red/green/blue components of the color @emph{a}.

@item intensity
  @findex proc intensity*(a꞉ Color; f꞉ float)꞉ Color
@example
proc intensity*(a꞉ Color; f꞉ float)꞉ Color
@end example
  returns @emph{a} with intensity @emph{f}. @emph{f} should be a float from 0.0 (completely dark) to 1.0 (full color intensity).

@item `$`
  @findex proc `$`*(c꞉ Color)꞉ string
@example
proc `$`*(c꞉ Color)꞉ string
@end example
  converts a color into its textual representation. Example: @code{#00FF00}.

@item parseColor
  @findex proc parseColor*(name꞉ string)꞉ Color
@example
proc parseColor*(name꞉ string)꞉ Color
@end example
  parses @emph{name} to a color value. If no valid color could be parsed @code{EInvalidValue} is raised.

@item isColor
  @findex proc isColor*(name꞉ string)꞉ bool
@example
proc isColor*(name꞉ string)꞉ bool
@end example
  returns true if @emph{name} is a known color name or a hexadecimal color prefixed with @code{#}.

@item rgb
  @findex proc rgb*(r, g, b꞉ range[0 .. 255])꞉ Color
@example
proc rgb*(r, g, b꞉ range[0 .. 255])꞉ Color
@end example
  constructs a color from RGB values.
@end itemize

@chapter Templates

@itemize


@item mix
  @findex template mix*(a, b꞉ Color; fn꞉ expr)꞉ expr
@example
template mix*(a, b꞉ Color; fn꞉ expr)꞉ expr
@end example
  uses @emph{fn} to mix the colors @emph{a} and @emph{b}. @emph{fn} is invoked for each component R, G, and B. This is a template because @emph{fn} should be inlined and the compiler cannot inline proc pointers yet. If @emph{fn}'s result is not in the range[0..255], it will be saturated to be so.
@end itemize





@node /pure/ospaths, /pure/asynchttpserver , /pure/colors, Top
@chapter Constant variables

@itemize


@item DynlibFormat
  @vindex DynlibFormat* = "lib$1.so"
@example
DynlibFormat* = "lib$1.so"
@end example
  The format string to turn a filename into a  file (also called  on some operating systems).

@item ExtSep
  @vindex ExtSep* = '.'
@example
ExtSep* = '.'
@end example
  The character which separates the base filename from the extension; for example, the '.' in @code{os.nim}.
@end itemize



@chapter Types

@itemize


@item OSErrorCode
  @tindex OSErrorCode* = distinct int32
@example
OSErrorCode* = distinct int32
@end example
  Specifies an OS Error Code.
@end itemize

@chapter Procedures

@itemize


@item joinPath
  @findex proc joinPath*(head, tail꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc joinPath*(head, tail꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Joins two directory names to one.

For example on Unix:


@example
joinPath("usr", "lib")
@end example
results in:


@example
"usr/lib"
@end example
If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:


@example
assert joinPath("usr", "") == "usr/"
assert joinPath("", "lib") == "lib"
assert joinPath("", "/lib") == "/lib"
assert joinPath("usr/", "/lib") == "usr/lib"
@end example

@item joinPath
  @findex proc joinPath*(parts꞉ varargs[string])꞉ string @{.noSideEffect, rtl,extern꞉ "nos$1OpenArray".@}
@example
proc joinPath*(parts꞉ varargs[string])꞉ string @{.noSideEffect, rtl,extern꞉ "nos$1OpenArray".@}
@end example
  The same as @emph{joinPath(head, tail)}, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.

@item `/`
  @findex proc `/`*(head, tail꞉ string)꞉ string @{.noSideEffect.@}
@example
proc `/`*(head, tail꞉ string)꞉ string @{.noSideEffect.@}
@end example
  The same as @code{joinPath(head, tail)}

Here are some examples for Unix:


@example
assert "usr" / "" == "usr/"
assert "" / "lib" == "lib"
assert "" / "/lib" == "/lib"
assert "usr/" / "/lib" == "usr/lib"
@end example

@item splitPath
  @findex proc splitPath*(path꞉ string)꞉ tuple[head, tail꞉ string] @{.noSideEffect, rtl,extern꞉ "nos$1".@}
@example
proc splitPath*(path꞉ string)꞉ tuple[head, tail꞉ string] @{.noSideEffect, rtl,extern꞉ "nos$1".@}
@end example
  Splits a directory into (head, tail), so that @code{head / tail == path} (except for edge cases like "/usr").

Examples:


@example
splitPath("usr/local/bin") -> ("usr/local", "bin")
splitPath("usr/local/bin/") -> ("usr/local/bin", "")
splitPath("bin") -> ("", "bin")
splitPath("/bin") -> ("", "bin")
splitPath("") -> ("", "")
@end example

@item parentDir
  @findex proc parentDir*(path꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc parentDir*(path꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Returns the parent directory of @emph{path}.

This is often the same as the @code{head} result of @code{splitPath}. If there is no parent, "" is returned.Example: @code{parentDir("/usr/local/bin") == "/usr/local"}.\\
Example: @code{parentDir("/usr/local/bin/") == "/usr/local"}.\\

@item tailDir
  @findex proc tailDir*(path꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc tailDir*(path꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Returns the tail part of @emph{path}..Example: @code{tailDir("/usr/local/bin") == "local/bin"}.\\
Example: @code{tailDir("usr/local/bin/") == "local/bin"}.\\
Example: @code{tailDir("bin") == ""}.\\

@item isRootDir
  @findex proc isRootDir*(path꞉ string)꞉ bool @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc isRootDir*(path꞉ string)꞉ bool @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Checks whether a given @emph{path} is a root directory

@item `/../`
  @findex proc `/../`*(head, tail꞉ string)꞉ string @{.noSideEffect.@}
@example
proc `/../`*(head, tail꞉ string)꞉ string @{.noSideEffect.@}
@end example
  The same as @code{parentDir(head) / tail} unless there is no parent directory. Then @code{head / tail} is performed instead.

@item splitFile
  @findex proc splitFile*(path꞉ string)꞉ tuple[dir, name, ext꞉ string] @{.noSideEffect, rtl,extern꞉ "nos$1".@}
@example
proc splitFile*(path꞉ string)꞉ tuple[dir, name, ext꞉ string] @{.noSideEffect, rtl,extern꞉ "nos$1".@}
@end example
  Splits a filename into (dir, filename, extension). @emph{dir} does not end in @emph{DirSep}. @emph{extension} includes the leading dot.

Example:


@example
var (dir, name, ext) = splitFile("usr/local/nimc.html")
assert dir == "usr/local"
assert name == "nimc"
assert ext == ".html"
@end example
If @emph{path} has no extension, @emph{ext} is the empty string. If @emph{path} has no directory component, @emph{dir} is the empty string. If @emph{path} has no filename component, @emph{name} and @emph{ext} are empty strings.

@item extractFilename
  @findex proc extractFilename*(path꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc extractFilename*(path꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Extracts the filename of a given @emph{path}. This is the same as @code{name & ext} from @code{splitFile(path)}.

@item changeFileExt
  @findex proc changeFileExt*(filename, ext꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc changeFileExt*(filename, ext꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Changes the file extension to @emph{ext}.

If the @emph{filename} has no extension, @emph{ext} will be added. If @emph{ext} == "" then any extension is removed. @emph{Ext} should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)

@item addFileExt
  @findex proc addFileExt*(filename, ext꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc addFileExt*(filename, ext꞉ string)꞉ string @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Adds the file extension @emph{ext} to @emph{filename}, unless @emph{filename} already has an extension.

@emph{Ext} should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)

@item cmpPaths
  @findex proc cmpPaths*(pathA, pathB꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc cmpPaths*(pathA, pathB꞉ string)꞉ int @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Compares two paths.

On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively. Returns:

0 iff pathA == pathB\\
< 0 iff pathA < pathB\\
> 0 iff pathA > pathB\\

@item isAbsolute
  @findex proc isAbsolute*(path꞉ string)꞉ bool @{.rtl, noSideEffect, extern꞉ "nos$1".@}
@example
proc isAbsolute*(path꞉ string)꞉ bool @{.rtl, noSideEffect, extern꞉ "nos$1".@}
@end example
  Checks whether a given @emph{path} is absolute.

On Windows, network paths are considered absolute too.

@item unixToNativePath
  @findex proc unixToNativePath*(path꞉ string; drive = "")꞉ string @{.noSideEffect, rtl,extern꞉ "nos$1".@}
@example
proc unixToNativePath*(path꞉ string; drive = "")꞉ string @{.noSideEffect, rtl,extern꞉ "nos$1".@}
@end example
  Converts an UNIX-like path to a native one.

On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.

On systems with a concept of "drives", @emph{drive} is used to determine which drive label to use during absolute path conversion. @emph{drive} defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of "drives".

@item getHomeDir
  @findex proc getHomeDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@example
proc getHomeDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@end example
  Returns the home directory of the current user.

This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.

@item getConfigDir
  @findex proc getConfigDir*()꞉ string @{.rtl, extern꞉ "nos$1",tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@example
proc getConfigDir*()꞉ string @{.rtl, extern꞉ "nos$1",tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@end example
  Returns the config directory of the current user for applications.

@item getTempDir
  @findex proc getTempDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@example
proc getTempDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@end example
  Returns the temporary directory of the current user for applications to save temporary files in.

@item expandTilde
  @findex proc expandTilde*(path꞉ string)꞉ string @{.tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@example
proc expandTilde*(path꞉ string)꞉ string @{.tags꞉ [ReadEnvEffect, ReadIOEffect].@}
@end example
  Expands a path starting with @code{~/} to a full path.

If @emph{path} starts with the tilde character and is followed by @emph{/} or @emph{\} this proc will return the reminder of the path appended to the result of the getHomeDir() proc, otherwise the input path will be returned without modification.

The behaviour of this proc is the same on the Windows platform despite not having this convention. Example:


@example
let configFile = expandTilde("~" / "appname.cfg")
echo configFile
# --> C:\Users\amber\appname.cfg
@end example

@item findExe
  @findex proc findExe*(exe꞉ string)꞉ string @{.tags꞉ [ReadDirEffect, ReadEnvEffect, ReadIOEffect].@}
@example
proc findExe*(exe꞉ string)꞉ string @{.tags꞉ [ReadDirEffect, ReadEnvEffect, ReadIOEffect].@}
@end example
  Searches for @emph{exe} in the current working directory and then in directories listed in the @code{PATH} environment variable. Returns "" if the @emph{exe} cannot be found. On DOS-like platforms, @emph{exe} is added the @uref{#ExeExt, ExeExt} file extension if it has none.
@end itemize





@chapter Iterators

@itemize


@item parentDirs
  @itindex iterator parentDirs*(path꞉ string; fromRoot = false; inclusive = true)꞉ string
@example
iterator parentDirs*(path꞉ string; fromRoot = false; inclusive = true)꞉ string
@end example
  Walks over all parent directories of a given @emph{path}

If @emph{fromRoot} is set, the traversal will start from the file system root diretory. If @emph{inclusive} is set, the original argument will be included in the traversal.

Relative paths won't be expanded by this proc. Instead, it will traverse only the directories appearing in the relative path.
@end itemize

@node /pure/asynchttpserver, /pure/asyncdispatch , /pure/ospaths, Top



@chapter Types

@itemize


@item HttpVersion
  @tindex HttpVersion* = enumHttpVer11, HttpVer10
@example
HttpVersion* = enumHttpVer11, HttpVer10
@end example
  
@end itemize

@chapter Procedures

@itemize


@item `==`
  @findex proc `==`*(protocol꞉ tuple[orig꞉ string, major, minor꞉ int]; ver꞉ HttpVersion)꞉ bool
@example
proc `==`*(protocol꞉ tuple[orig꞉ string, major, minor꞉ int]; ver꞉ HttpVersion)꞉ bool
@end example
  

@item newAsyncHttpServer
  @findex proc newAsyncHttpServer*(reuseAddr = true)꞉ AsyncHttpServer
@example
proc newAsyncHttpServer*(reuseAddr = true)꞉ AsyncHttpServer
@end example
  Creates a new @code{AsyncHttpServer} instance.

@item sendHeaders
  @findex proc sendHeaders*(req꞉ Request; headers꞉ StringTableRef)꞉ Future[void]
@example
proc sendHeaders*(req꞉ Request; headers꞉ StringTableRef)꞉ Future[void]
@end example
  Sends the specified headers to the requesting client.

@item respond
  @findex proc respond*(req꞉ Request; code꞉ HttpCode; content꞉ string;headers꞉ StringTableRef = nil)꞉ Future[void]
@example
proc respond*(req꞉ Request; code꞉ HttpCode; content꞉ string;headers꞉ StringTableRef = nil)꞉ Future[void]
@end example
  Responds to the request with the specified @code{HttpCode}, headers and content.

This procedure will @strong{not} close the client socket.

@item serve
  @findex proc serve*(server꞉ AsyncHttpServer; port꞉ Port;callback꞉ proc (request꞉ Request)꞉ Future[void] @{.closure, gcsafe.@};address = "") @{.async.@}
@example
proc serve*(server꞉ AsyncHttpServer; port꞉ Port;callback꞉ proc (request꞉ Request)꞉ Future[void] @{.closure, gcsafe.@};address = "") @{.async.@}
@end example
  Starts the process of listening for incoming HTTP connections on the specified address and port.

When a request is made by a client the specified callback will be called.

@item close
  @findex proc close*(server꞉ AsyncHttpServer)
@example
proc close*(server꞉ AsyncHttpServer)
@end example
  Terminates the async http server instance.
@end itemize






@node /pure/asyncdispatch, /pure/xmlparser , /pure/asynchttpserver, Top



@chapter Types

@itemize


@item FutureError
  @tindex FutureError* = object of Exceptioncause*꞉ FutureBase
@example
FutureError* = object of Exceptioncause*꞉ FutureBase
@end example
  

@item AsyncFD
  @tindex AsyncFD* = distinct int
@example
AsyncFD* = distinct int
@end example
  
@end itemize

@chapter Procedures

@itemize


@item newFuture
  @findex proc newFuture*[T](fromProc꞉ string = "unspecified")꞉ Future[T]
@example
proc newFuture*[T](fromProc꞉ string = "unspecified")꞉ Future[T]
@end example
  Creates a new future.

Specifying @code{fromProc}, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.

@item newFutureVar
  @findex proc newFutureVar*[T](fromProc = "unspecified")꞉ FutureVar[T]
@example
proc newFutureVar*[T](fromProc = "unspecified")꞉ FutureVar[T]
@end example
  Create a new @code{FutureVar}. This Future type is ideally suited for situations where you want to avoid unnecessary allocations of Futures.

Specifying @code{fromProc}, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.

@item clean
  @findex proc clean*[T](future꞉ FutureVar[T])
@example
proc clean*[T](future꞉ FutureVar[T])
@end example
  Resets the @code{finished} status of @code{future}.

@item complete
  @findex proc complete*[T](future꞉ Future[T]; val꞉ T)
@example
proc complete*[T](future꞉ Future[T]; val꞉ T)
@end example
  Completes @code{future} with value @code{val}.

@item complete
  @findex proc complete*(future꞉ Future[void])
@example
proc complete*(future꞉ Future[void])
@end example
  Completes a void @code{future}.

@item complete
  @findex proc complete*[T](future꞉ FutureVar[T])
@example
proc complete*[T](future꞉ FutureVar[T])
@end example
  Completes a @code{FutureVar}.

@item fail
  @findex proc fail*[T](future꞉ Future[T]; error꞉ ref Exception)
@example
proc fail*[T](future꞉ Future[T]; error꞉ ref Exception)
@end example
  Completes @code{future} with @code{error}.

@item `callback=`
  @findex proc `callback =`*(future꞉ FutureBase; cb꞉ proc () @{.closure, gcsafe.@})
@example
proc `callback =`*(future꞉ FutureBase; cb꞉ proc () @{.closure, gcsafe.@})
@end example
  Sets the callback proc to be called when the future completes.

If future has already completed then @code{cb} will be called immediately.

@strong{Note}: You most likely want the other @code{callback} setter which passes @code{future} as a param to the callback.

@item `callback=`
  @findex proc `callback =`*[T](future꞉ Future[T];cb꞉ proc (future꞉ Future[T]) @{.closure, gcsafe.@})
@example
proc `callback =`*[T](future꞉ Future[T];cb꞉ proc (future꞉ Future[T]) @{.closure, gcsafe.@})
@end example
  Sets the callback proc to be called when the future completes.

If future has already completed then @code{cb} will be called immediately.

@item read
  @findex proc read*[T](future꞉ Future[T])꞉ T
@example
proc read*[T](future꞉ Future[T])꞉ T
@end example
  Retrieves the value of @code{future}. Future must be finished otherwise this function will fail with a @code{ValueError} exception.

If the result of the future is an error then that error will be raised.

@item readError
  @findex proc readError*[T](future꞉ Future[T])꞉ ref Exception
@example
proc readError*[T](future꞉ Future[T])꞉ ref Exception
@end example
  Retrieves the exception stored in @code{future}.

An @code{ValueError} exception will be thrown if no exception exists in the specified Future.

@item mget
  @findex proc mget*[T](future꞉ FutureVar[T])꞉ var T
@example
proc mget*[T](future꞉ FutureVar[T])꞉ var T
@end example
  Returns a mutable value stored in @code{future}.

Unlike @code{read}, this function will not raise an exception if the Future has not been finished.

@item finished
  @findex proc finished*[T](future꞉ Future[T])꞉ bool
@example
proc finished*[T](future꞉ Future[T])꞉ bool
@end example
  Determines whether @code{future} has completed.

@code{True} may indicate an error or a value. Use @code{failed} to distinguish.

@item failed
  @findex proc failed*(future꞉ FutureBase)꞉ bool
@example
proc failed*(future꞉ FutureBase)꞉ bool
@end example
  Determines whether @code{future} completed with an error.

@item asyncCheck
  @findex proc asyncCheck*[T](future꞉ Future[T])
@example
proc asyncCheck*[T](future꞉ Future[T])
@end example
  Sets a callback on @code{future} which raises an exception if the future finished with an error.

This should be used instead of @code{discard} to discard void futures.

@item `and`
  @findex proc `and`*[T, Y](fut1꞉ Future[T]; fut2꞉ Future[Y])꞉ Future[void]
@example
proc `and`*[T, Y](fut1꞉ Future[T]; fut2꞉ Future[Y])꞉ Future[void]
@end example
  Returns a future which will complete once both @code{fut1} and @code{fut2} complete.

@item `or`
  @findex proc `or`*[T, Y](fut1꞉ Future[T]; fut2꞉ Future[Y])꞉ Future[void]
@example
proc `or`*[T, Y](fut1꞉ Future[T]; fut2꞉ Future[Y])꞉ Future[void]
@end example
  Returns a future which will complete once either @code{fut1} or @code{fut2} complete.

@item `==`
  @findex proc `==`*(x꞉ AsyncFD; y꞉ AsyncFD)꞉ bool @{.borrow.@}
@example
proc `==`*(x꞉ AsyncFD; y꞉ AsyncFD)꞉ bool @{.borrow.@}
@end example
  

@item newDispatcher
  @findex proc newDispatcher*()꞉ PDispatcher
@example
proc newDispatcher*()꞉ PDispatcher
@end example
  Creates a new Dispatcher instance.

@item getGlobalDispatcher
  @findex proc getGlobalDispatcher*()꞉ PDispatcher
@example
proc getGlobalDispatcher*()꞉ PDispatcher
@end example
  Retrieves the global thread-local dispatcher.

@item register
  @findex proc register*(fd꞉ AsyncFD)
@example
proc register*(fd꞉ AsyncFD)
@end example
  Registers @code{fd} with the dispatcher.

@item poll
  @findex proc poll*(timeout = 500)
@example
proc poll*(timeout = 500)
@end example
  Waits for completion events and processes them.

@item connect
  @findex proc connect*(socket꞉ AsyncFD; address꞉ string; port꞉ Port;domain = nativesockets.AF_INET)꞉ Future[void]
@example
proc connect*(socket꞉ AsyncFD; address꞉ string; port꞉ Port;domain = nativesockets.AF_INET)꞉ Future[void]
@end example
  Connects @code{socket} to server at @code{address:port}.

Returns a @code{Future} which will complete when the connection succeeds or an error occurs.

@item recv
  @findex proc recv*(socket꞉ AsyncFD; size꞉ int; flags = @{SocketFlag.SafeDisconn@})꞉ Future[string]
@example
proc recv*(socket꞉ AsyncFD; size꞉ int; flags = @{SocketFlag.SafeDisconn@})꞉ Future[string]
@end example
  Reads @strong{up to} @code{size} bytes from @code{socket}. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of @code{""}.

@strong{Warning}: The @code{Peek} socket flag is not supported on Windows.

@item recvInto
  @findex proc recvInto*(socket꞉ AsyncFD; buf꞉ cstring; size꞉ int;flags = @{SocketFlag.SafeDisconn@})꞉ Future[int]
@example
proc recvInto*(socket꞉ AsyncFD; buf꞉ cstring; size꞉ int;flags = @{SocketFlag.SafeDisconn@})꞉ Future[int]
@end example
  Reads @strong{up to} @code{size} bytes from @code{socket} into @code{buf}, which must at least be of that size. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of @code{0}.

@strong{Warning}: The @code{Peek} socket flag is not supported on Windows.

@item send
  @findex proc send*(socket꞉ AsyncFD; data꞉ string; flags = @{SocketFlag.SafeDisconn@})꞉ Future[void]
@example
proc send*(socket꞉ AsyncFD; data꞉ string; flags = @{SocketFlag.SafeDisconn@})꞉ Future[void]
@end example
  Sends @code{data} to @code{socket}. The returned future will complete once all data has been sent.

@item acceptAddr
  @findex proc acceptAddr*(socket꞉ AsyncFD; flags = @{SocketFlag.SafeDisconn@})꞉ Future[tuple[address꞉ string, client꞉ AsyncFD]]
@example
proc acceptAddr*(socket꞉ AsyncFD; flags = @{SocketFlag.SafeDisconn@})꞉ Future[tuple[address꞉ string, client꞉ AsyncFD]]
@end example
  Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.

The resulting client socket is automatically registered to the dispatcher.

The @code{accept} call may result in an error if the connecting socket disconnects during the duration of the @code{accept}. If the @code{SafeDisconn} flag is specified then this error will not be raised and instead accept will be called again.

@item newAsyncNativeSocket
  @findex proc newAsyncNativeSocket*(domain, sockType, protocol꞉ cint)꞉ AsyncFD
@example
proc newAsyncNativeSocket*(domain, sockType, protocol꞉ cint)꞉ AsyncFD
@end example
  Creates a new socket and registers it with the dispatcher implicitly.

@item newAsyncNativeSocket
  @findex proc newAsyncNativeSocket*(domain꞉ Domain = nativesockets.AF_INET;sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP)꞉ AsyncFD
@example
proc newAsyncNativeSocket*(domain꞉ Domain = nativesockets.AF_INET;sockType꞉ SockType = SOCK_STREAM;protocol꞉ Protocol = IPPROTO_TCP)꞉ AsyncFD
@end example
  Creates a new socket and registers it with the dispatcher implicitly.

@item closeSocket
  @findex proc closeSocket*(socket꞉ AsyncFD)
@example
proc closeSocket*(socket꞉ AsyncFD)
@end example
  Closes a socket and ensures that it is unregistered.

@item unregister
  @findex proc unregister*(fd꞉ AsyncFD)
@example
proc unregister*(fd꞉ AsyncFD)
@end example
  Unregisters @code{fd}.

@item sleepAsync
  @findex proc sleepAsync*(ms꞉ int)꞉ Future[void]
@example
proc sleepAsync*(ms꞉ int)꞉ Future[void]
@end example
  Suspends the execution of the current async procedure for the next @code{ms} milliseconds.

@item accept
  @findex proc accept*(socket꞉ AsyncFD; flags = @{SocketFlag.SafeDisconn@})꞉ Future[AsyncFD]
@example
proc accept*(socket꞉ AsyncFD; flags = @{SocketFlag.SafeDisconn@})꞉ Future[AsyncFD]
@end example
  Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted.

@item recvLine
  @findex proc recvLine*(socket꞉ AsyncFD)꞉ Future[string] @{.async.@}
@example
proc recvLine*(socket꞉ AsyncFD)꞉ Future[string] @{.async.@}
@end example
  Reads a line of data from @code{socket}. Returned future will complete once a full line is read or an error occurs.

If a full line is read @code{\r\L} is not added to @code{line}, however if solely @code{\r\L} is read then @code{line} will be set to it.

If the socket is disconnected, @code{line} will be set to @code{""}.

If the socket is disconnected in the middle of a line (before @code{\r\L} is read) then line will be set to @code{""}. The partial line @strong{will be lost}.

@strong{Warning}: This assumes that lines are delimited by @code{\r\L}.

@strong{Note}: This procedure is mostly used for testing. You likely want to use @code{asyncnet.recvLine} instead.

@item runForever
  @findex proc runForever*()
@example
proc runForever*()
@end example
  Begins a never ending global dispatcher poll loop.

@item waitFor
  @findex proc waitFor*[T](fut꞉ Future[T])꞉ T
@example
proc waitFor*[T](fut꞉ Future[T])꞉ T
@end example
  @strong{Blocks} the current thread until the specified future completes.
@end itemize


@chapter Macros

@itemize


@item async
  @findex macro async*(prc꞉ stmt)꞉ stmt @{.immediate.@}
@example
macro async*(prc꞉ stmt)꞉ stmt @{.immediate.@}
@end example
  Macro which processes async procedures into the appropriate iterators and yield statements.
@end itemize




@node /pure/xmlparser, /pure/cookies , /pure/asyncdispatch, Top



@chapter Types

@itemize


@item XmlError
  @tindex XmlError* = object of ValueErrorerrors*꞉ seq[string]         ## all detected parsing errors
@example
XmlError* = object of ValueErrorerrors*꞉ seq[string]         ## all detected parsing errors
@end example
  exception that is raised for invalid XML
@end itemize

@chapter Procedures

@itemize


@item parseXml
  @findex proc parseXml*(s꞉ Stream; filename꞉ string; errors꞉ var seq[string])꞉ XmlNode
@example
proc parseXml*(s꞉ Stream; filename꞉ string; errors꞉ var seq[string])꞉ XmlNode
@end example
  parses the XML from stream @emph{s} and returns a @code{PXmlNode}. Every occurred parsing error is added to the @emph{errors} sequence.

@item parseXml
  @findex proc parseXml*(s꞉ Stream)꞉ XmlNode
@example
proc parseXml*(s꞉ Stream)꞉ XmlNode
@end example
  parses the XTML from stream @emph{s} and returns a @code{PXmlNode}. All parsing errors are turned into an @code{EInvalidXML} exception.

@item loadXml
  @findex proc loadXml*(path꞉ string; errors꞉ var seq[string])꞉ XmlNode
@example
proc loadXml*(path꞉ string; errors꞉ var seq[string])꞉ XmlNode
@end example
  Loads and parses XML from file specified by @code{path}, and returns a @code{PXmlNode}. Every occurred parsing error is added to the @emph{errors} sequence.

@item loadXml
  @findex proc loadXml*(path꞉ string)꞉ XmlNode
@example
proc loadXml*(path꞉ string)꞉ XmlNode
@end example
  Loads and parses XML from file specified by @code{path}, and returns a @code{PXmlNode}.  All parsing errors are turned into an @code{EInvalidXML} exception.
@end itemize






@node /pure/cookies, /pure/matchers , /pure/xmlparser, Top




@chapter Procedures

@itemize


@item parseCookies
  @findex proc parseCookies*(s꞉ string)꞉ StringTableRef
@example
proc parseCookies*(s꞉ string)꞉ StringTableRef
@end example
  parses cookies into a string table.

@item setCookie
  @findex proc setCookie*(key, value꞉ string; domain = ""; path = ""; expires = ""; noName = false;secure = false; httpOnly = false)꞉ string
@example
proc setCookie*(key, value꞉ string; domain = ""; path = ""; expires = ""; noName = false;secure = false; httpOnly = false)꞉ string
@end example
  Creates a command in the format of @code{Set-Cookie: key=value; Domain=...; ...}

@item setCookie
  @findex proc setCookie*(key, value꞉ string; expires꞉ TimeInfo; domain = ""; path = "";noName = false; secure = false; httpOnly = false)꞉ string
@example
proc setCookie*(key, value꞉ string; expires꞉ TimeInfo; domain = ""; path = "";noName = false; secure = false; httpOnly = false)꞉ string
@end example
  Creates a command in the format of @code{Set-Cookie: key=value; Domain=...; ...}

@strong{Note:} UTC is assumed as the timezone for @code{expires}.
@end itemize






@node /pure/matchers, /pure/os , /pure/cookies, Top




@chapter Procedures

@itemize


@item validEmailAddress
  @findex proc validEmailAddress*(s꞉ string)꞉ bool @{.noSideEffect, rtl,extern꞉ "nsuValidEmailAddress".@}
@example
proc validEmailAddress*(s꞉ string)꞉ bool @{.noSideEffect, rtl,extern꞉ "nsuValidEmailAddress".@}
@end example
  returns true if @emph{s} seems to be a valid e-mail address. The checking also uses a domain list.

@item parseInt
  @findex proc parseInt*(s꞉ string; value꞉ var int; validRange꞉ Slice[int]) @{.noSideEffect, rtl,extern꞉ "nmatchParseInt".@}
@example
proc parseInt*(s꞉ string; value꞉ var int; validRange꞉ Slice[int]) @{.noSideEffect, rtl,extern꞉ "nmatchParseInt".@}
@end example
  parses @emph{s} into an integer in the range @emph{validRange}. If successful, @emph{value} is modified to contain the result. Otherwise no exception is raised and @emph{value} is not touched; this way a reasonable default value won't be overwritten.
@end itemize






@node /pure/os, /pure/rationals , /pure/matchers, Top



@chapter Types

@itemize


@item FilePermission
  @tindex FilePermission* = enum
  fpUserExec,                 ## execute access for the file owner
  fpUserWrite,                ## write access for the file owner
  fpUserRead,                 ## read access for the file owner
  fpGroupExec,                ## execute access for the group
  fpGroupWrite,               ## write access for the group
  fpGroupRead,                ## read access for the group
  fpOthersExec,               ## execute access for others
  fpOthersWrite,              ## write access for others
  fpOthersRead                ## read access for others
@example
FilePermission* = enum
  fpUserExec,                 ## execute access for the file owner
  fpUserWrite,                ## write access for the file owner
  fpUserRead,                 ## read access for the file owner
  fpGroupExec,                ## execute access for the group
  fpGroupWrite,               ## write access for the group
  fpGroupRead,                ## read access for the group
  fpOthersExec,               ## execute access for others
  fpOthersWrite,              ## write access for others
  fpOthersRead                ## read access for others
@end example
  file access permission; modelled after UNIX

@item PathComponent
  @tindex PathComponent* = enum
  pcFile,                     ## path refers to a file
  pcLinkToFile,               ## path refers to a symbolic link to a file
  pcDir,                      ## path refers to a directory
  pcLinkToDir                 ## path refers to a symbolic link to a directory
@example
PathComponent* = enum
  pcFile,                     ## path refers to a file
  pcLinkToFile,               ## path refers to a symbolic link to a file
  pcDir,                      ## path refers to a directory
  pcLinkToDir                 ## path refers to a symbolic link to a directory
@end example
  Enumeration specifying a path component.

@item cuint32
  @tindex cuint32* @{.importc꞉ "unsigned int", nodecl.@} = int
@example
cuint32* @{.importc꞉ "unsigned int", nodecl.@} = int
@end example
  

@item FileId
  @tindex FileId* = int64
@example
FileId* = int64
@end example
  

@item FileInfo
  @tindex FileInfo* = object
  id*: tuple[device: DeviceId, file: FileId]
  kind*: PathComponent
  size*: BiggestInt
  permissions*: set[FilePermission]
  linkCount*: BiggestInt
  lastAccessTime*: Time
  lastWriteTime*: Time
  creationTime*: Time

@example
FileInfo* = object
  id*: tuple[device: DeviceId, file: FileId]
  kind*: PathComponent
  size*: BiggestInt
  permissions*: set[FilePermission]
  linkCount*: BiggestInt
  lastAccessTime*: Time
  lastWriteTime*: Time
  creationTime*: Time

@end example
  Contains information associated with a file object.
@end itemize

@chapter Procedures

@itemize


@item osErrorMsg
  @findex proc osErrorMsg*()꞉ string @{.rtl, extern꞉ "nos$1", deprecated.@}
@example
proc osErrorMsg*()꞉ string @{.rtl, extern꞉ "nos$1", deprecated.@}
@end example
  Retrieves the operating system's error flag, @code{errno}. On Windows @code{GetLastError} is checked before @code{errno}. Returns "" if no error occurred.

@strong{Deprecated since version 0.9.4}: use the other @code{osErrorMsg} proc.

@item raiseOSError
  @findex proc raiseOSError*(msg꞉ string = "") @{.noinline, rtl, extern꞉ "nos$1", deprecated.@}
@example
proc raiseOSError*(msg꞉ string = "") @{.noinline, rtl, extern꞉ "nos$1", deprecated.@}
@end example
  raises an OSError exception with the given message @code{msg}. If @code{msg == ""}, the operating system's error flag (@code{errno}) is converted to a readable error message. On Windows @code{GetLastError} is checked before @code{errno}. If no error flag is set, the message @code{unknown OS error} is used.

@strong{Deprecated since version 0.9.4}: use the other @code{raiseOSError} proc.

@item `==`
  @findex proc `==`*(err1, err2꞉ OSErrorCode)꞉ bool @{.borrow.@}
@example
proc `==`*(err1, err2꞉ OSErrorCode)꞉ bool @{.borrow.@}
@end example
  

@item `$`
  @findex proc `$`*(err꞉ OSErrorCode)꞉ string @{.borrow.@}
@example
proc `$`*(err꞉ OSErrorCode)꞉ string @{.borrow.@}
@end example
  

@item osErrorMsg
  @findex proc osErrorMsg*(errorCode꞉ OSErrorCode)꞉ string
@example
proc osErrorMsg*(errorCode꞉ OSErrorCode)꞉ string
@end example
  Converts an OS error code into a human readable string.

The error code can be retrieved using the @code{osLastError} proc.

If conversion fails, or @code{errorCode} is @code{0} then @code{""} will be returned.

On Windows, the @code{-d:useWinAnsi} compilation flag can be used to make this procedure use the non-unicode Win API calls to retrieve the message.

@item raiseOSError
  @findex proc raiseOSError*(errorCode꞉ OSErrorCode; additionalInfo = "") @{.noinline.@}
@example
proc raiseOSError*(errorCode꞉ OSErrorCode; additionalInfo = "") @{.noinline.@}
@end example
  Raises an @code{OSError} exception. The @code{errorCode} will determine the message, @code{osErrorMsg} will be used to get this message.

The error code can be retrieved using the @code{osLastError} proc.

If the error code is @code{0} or an error message could not be retrieved, the message @code{unknown OS error} will be used.

@item osLastError
  @findex proc osLastError*()꞉ OSErrorCode
@example
proc osLastError*()꞉ OSErrorCode
@end example
  Retrieves the last operating system error code.

This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The @code{OSErrorMsg} procedure can then be used to convert this code into a string.

@strong{Warning}: The behaviour of this procedure varies between Windows and POSIX systems. On Windows some OS calls can reset the error code to @code{0} causing this procedure to return @code{0}. It is therefore advised to call this procedure immediately after an OS call fails. On POSIX systems this is not a problem.

@item existsFile
  @findex proc existsFile*(filename꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@example
proc existsFile*(filename꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@end example
  Returns true if the file exists, false otherwise.

@item existsDir
  @findex proc existsDir*(dir꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@example
proc existsDir*(dir꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@end example
  Returns true iff the directory @emph{dir} exists. If @emph{dir} is a file, false is returned.

@item symlinkExists
  @findex proc symlinkExists*(link꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@example
proc symlinkExists*(link꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@end example
  Returns true iff the symlink @emph{link} exists. Will return true regardless of whether the link points to a directory or file.

@item fileExists
  @findex proc fileExists*(filename꞉ string)꞉ bool @{.inline.@}
@example
proc fileExists*(filename꞉ string)꞉ bool @{.inline.@}
@end example
  Synonym for existsFile

@item dirExists
  @findex proc dirExists*(dir꞉ string)꞉ bool @{.inline.@}
@example
proc dirExists*(dir꞉ string)꞉ bool @{.inline.@}
@end example
  Synonym for existsDir

@item getLastModificationTime
  @findex proc getLastModificationTime*(file꞉ string)꞉ Time @{.rtl, extern꞉ "nos$1".@}
@example
proc getLastModificationTime*(file꞉ string)꞉ Time @{.rtl, extern꞉ "nos$1".@}
@end example
  Returns the @emph{file}'s last modification time.

@item getLastAccessTime
  @findex proc getLastAccessTime*(file꞉ string)꞉ Time @{.rtl, extern꞉ "nos$1".@}
@example
proc getLastAccessTime*(file꞉ string)꞉ Time @{.rtl, extern꞉ "nos$1".@}
@end example
  Returns the @emph{file}'s last read or write access time.

@item getCreationTime
  @findex proc getCreationTime*(file꞉ string)꞉ Time @{.rtl, extern꞉ "nos$1".@}
@example
proc getCreationTime*(file꞉ string)꞉ Time @{.rtl, extern꞉ "nos$1".@}
@end example
  Returns the @emph{file}'s creation time.

@strong{Note:} Under POSIX OS's, the returned time may actually be the time at which the file's attribute's were last modified. See @uref{https://github.com/nim-lang/Nim/issues/1058, here} for details.

@item fileNewer
  @findex proc fileNewer*(a, b꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1".@}
@example
proc fileNewer*(a, b꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1".@}
@end example
  Returns true if the file @emph{a} is newer than file @emph{b}, i.e. if @emph{a}'s modification time is later than @emph{b}'s.

@item getCurrentDir
  @findex proc getCurrentDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [].@}
@example
proc getCurrentDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [].@}
@end example
  Returns the .

@item setCurrentDir
  @findex proc setCurrentDir*(newDir꞉ string) @{.inline, tags꞉ [].@}
@example
proc setCurrentDir*(newDir꞉ string) @{.inline, tags꞉ [].@}
@end example
  Sets the ; @emph{OSError} is raised if @emph{newDir} cannot been set.

@item expandFilename
  @findex proc expandFilename*(filename꞉ string)꞉ string @{.rtl, extern꞉ "nos$1",tags꞉ [ReadDirEffect].@}
@example
proc expandFilename*(filename꞉ string)꞉ string @{.rtl, extern꞉ "nos$1",tags꞉ [ReadDirEffect].@}
@end example
  Returns the full path of @emph{filename}, raises OSError in case of an error.

@item sameFile
  @findex proc sameFile*(path1, path2꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@example
proc sameFile*(path1, path2꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@end example
  Returns true if both pathname arguments refer to the same physical file or directory. Raises an exception if any of the files does not exist or information about it can not be obtained.

This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.

@item sameFileContent
  @findex proc sameFileContent*(path1, path2꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect].@}
@example
proc sameFileContent*(path1, path2꞉ string)꞉ bool @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect].@}
@end example
  Returns true if both pathname arguments refer to files with identical binary content.

@item getFilePermissions
  @findex proc getFilePermissions*(filename꞉ string)꞉ set[FilePermission] @{.rtl,extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@example
proc getFilePermissions*(filename꞉ string)꞉ set[FilePermission] @{.rtl,extern꞉ "nos$1", tags꞉ [ReadDirEffect].@}
@end example
  retrieves file permissions for @emph{filename}. @emph{OSError} is raised in case of an error. On Windows, only the @code{readonly} flag is checked, every other permission is available in any case.

@item setFilePermissions
  @findex proc setFilePermissions*(filename꞉ string; permissions꞉ set[FilePermission]) @{.rtl,extern꞉ "nos$1", tags꞉ [WriteDirEffect].@}
@example
proc setFilePermissions*(filename꞉ string; permissions꞉ set[FilePermission]) @{.rtl,extern꞉ "nos$1", tags꞉ [WriteDirEffect].@}
@end example
  sets the file permissions for @emph{filename}. @emph{OSError} is raised in case of an error. On Windows, only the @code{readonly} flag is changed, depending on @code{fpUserWrite}.

@item copyFile
  @findex proc copyFile*(source, dest꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc copyFile*(source, dest꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  Copies a file from @emph{source} to @emph{dest}.

If this fails, @emph{OSError} is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use @uref{#getFilePermissions, getFilePermissions()} and @uref{#setFilePermissions, setFilePermissions()} to copy them by hand (or use the convenience @uref{#copyFileWithPermissions, copyFileWithPermissions()} proc), otherwise @emph{dest} will inherit the default permissions of a newly created file for the user. If @emph{dest} already exists, the file attributes will be preserved and the content overwritten.

@item moveFile
  @findex proc moveFile*(source, dest꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc moveFile*(source, dest꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  Moves a file from @emph{source} to @emph{dest}. If this fails, @emph{OSError} is raised.

@item removeFile
  @findex proc removeFile*(file꞉ string) @{.rtl, extern꞉ "nos$1", tags꞉ [WriteDirEffect].@}
@example
proc removeFile*(file꞉ string) @{.rtl, extern꞉ "nos$1", tags꞉ [WriteDirEffect].@}
@end example
  Removes the @emph{file}. If this fails, @emph{OSError} is raised. This does not fail if the file never existed in the first place. On Windows, ignores the read-only attribute.

@item execShellCmd
  @findex proc execShellCmd*(command꞉ string)꞉ int @{.rtl, extern꞉ "nos$1", tags꞉ [ExecIOEffect].@}
@example
proc execShellCmd*(command꞉ string)꞉ int @{.rtl, extern꞉ "nos$1", tags꞉ [ExecIOEffect].@}
@end example
  Executes a .

Command has the form 'program args' where args are the command line arguments given to program. The proc returns the error code of the shell when it has finished. The proc does not return until the process has finished. To execute a program without having a shell involved, use the @emph{execProcess} proc of the @emph{osproc} module.

@item getEnv
  @findex proc getEnv*(key꞉ string)꞉ TaintedString @{.tags꞉ [ReadEnvEffect].@}
@example
proc getEnv*(key꞉ string)꞉ TaintedString @{.tags꞉ [ReadEnvEffect].@}
@end example
  Returns the value of the  named @emph{key}.

If the variable does not exist, "" is returned. To distinguish whether a variable exists or it's value is just "", call @emph{existsEnv(key)}.

@item existsEnv
  @findex proc existsEnv*(key꞉ string)꞉ bool @{.tags꞉ [ReadEnvEffect].@}
@example
proc existsEnv*(key꞉ string)꞉ bool @{.tags꞉ [ReadEnvEffect].@}
@end example
  Checks whether the environment variable named @emph{key} exists. Returns true if it exists, false otherwise.

@item putEnv
  @findex proc putEnv*(key, val꞉ string) @{.tags꞉ [WriteEnvEffect].@}
@example
proc putEnv*(key, val꞉ string) @{.tags꞉ [WriteEnvEffect].@}
@end example
  Sets the value of the  named @emph{key} to @emph{val}. If an error occurs, @emph{EInvalidEnvVar} is raised.

@item removeDir
  @findex proc removeDir*(dir꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [WriteDirEffect, ReadDirEffect], benign.@}
@example
proc removeDir*(dir꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [WriteDirEffect, ReadDirEffect], benign.@}
@end example
  Removes the directory @emph{dir} including all subdirectories and files in @emph{dir} (recursively).

If this fails, @emph{OSError} is raised. This does not fail if the directory never existed in the first place.

@item createDir
  @findex proc createDir*(dir꞉ string) @{.rtl, extern꞉ "nos$1", tags꞉ [WriteDirEffect].@}
@example
proc createDir*(dir꞉ string) @{.rtl, extern꞉ "nos$1", tags꞉ [WriteDirEffect].@}
@end example
  Creates the  @emph{dir}.

The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, @emph{OSError} is raised. It does @strong{not} fail if the path already exists because for most usages this does not indicate an error.

@item copyDir
  @findex proc copyDir*(source, dest꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [WriteIOEffect, ReadIOEffect], benign.@}
@example
proc copyDir*(source, dest꞉ string) @{.rtl, extern꞉ "nos$1",tags꞉ [WriteIOEffect, ReadIOEffect], benign.@}
@end example
  Copies a directory from @emph{source} to @emph{dest}.

If this fails, @emph{OSError} is raised. On the Windows platform this proc will copy the attributes from @emph{source} into @emph{dest}. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use @uref{#copyDirWithPermissions, copyDirWithPermissions()}.

@item createSymlink
  @findex proc createSymlink*(src, dest꞉ string)
@example
proc createSymlink*(src, dest꞉ string)
@end example
  Create a symbolic link at @emph{dest} which points to the item specified by @emph{src}. On most operating systems, will fail if a lonk

@strong{Warning}: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).

@item createHardlink
  @findex proc createHardlink*(src, dest꞉ string)
@example
proc createHardlink*(src, dest꞉ string)
@end example
  Create a hard link at @emph{dest} which points to the item specified by @emph{src}.

@strong{Warning}: Most OS's restrict the creation of hard links to root users (administrators) .

@item parseCmdLine
  @findex proc parseCmdLine*(c꞉ string)꞉ seq[string] @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@example
proc parseCmdLine*(c꞉ string)꞉ seq[string] @{.noSideEffect, rtl, extern꞉ "nos$1".@}
@end example
  Splits a command line into several components; This proc is only occasionally useful, better use the @emph{parseopt} module.

On Windows, it uses the following parsing rules (see @uref{http://msdn.microsoft.com/en-us/library/17w5ykft.aspx, http://msdn.microsoft.com/en-us/library/17w5ykft.aspx} ):


@itemize 
 @item Arguments are delimited by white space, which is either a space or a tab.
@item The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.
@item A string surrounded by double quotation marks ("string") is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.
@item A double quotation mark preceded by a backslash (") is interpreted as a literal double quotation mark character (").
@item Backslashes are interpreted literally, unless they immediately precede a double quotation mark.
@item If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.
@item If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is "escaped" by the remaining backslash, causing a literal double quotation mark (") to be placed in argv.
 
@end itemize
On Posix systems, it uses the following parsing rules: Components are separated by whitespace unless the whitespace occurs within @code{"} or @code{'} quotes.

@item copyFileWithPermissions
  @findex proc copyFileWithPermissions*(source, dest꞉ string; ignorePermissionErrors = true)
@example
proc copyFileWithPermissions*(source, dest꞉ string; ignorePermissionErrors = true)
@end example
  Copies a file from @emph{source} to @emph{dest} preserving file permissions.

This is a wrapper proc around @uref{#copyFile, copyFile()}, @uref{#getFilePermissions, getFilePermissions()} and @uref{#setFilePermissions, setFilePermissions()} on non Windows platform. On Windows this proc is just a wrapper for @uref{#copyFile, copyFile()} since that proc already copies attributes.

On non Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If @emph{ignorePermissionErrors} is true, errors while reading/setting file attributes will be ignored, otherwise will raise @emph{OSError}.

@item copyDirWithPermissions
  @findex proc copyDirWithPermissions*(source, dest꞉ string; ignorePermissionErrors = true) @{.rtl, extern꞉ "nos$1", tags꞉ [WriteIOEffect, ReadIOEffect], benign.@}
@example
proc copyDirWithPermissions*(source, dest꞉ string; ignorePermissionErrors = true) @{.rtl, extern꞉ "nos$1", tags꞉ [WriteIOEffect, ReadIOEffect], benign.@}
@end example
  Copies a directory from @emph{source} to @emph{dest} preserving file permissions.

If this fails, @emph{OSError} is raised. This is a wrapper proc around @uref{#copyDir, copyDir()} and @uref{#copyFileWithPermissions, copyFileWithPermissions()} on non Windows platforms. On Windows this proc is just a wrapper for @uref{#copyDir, copyDir()} since that proc already copies attributes.

On non Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If @emph{ignorePermissionErrors} is true, errors while reading/setting file attributes will be ignored, otherwise will raise @emph{OSError}.

@item inclFilePermissions
  @findex proc inclFilePermissions*(filename꞉ string; permissions꞉ set[FilePermission]) @{.rtl,extern꞉ "nos$1", tags꞉ [ReadDirEffect, WriteDirEffect].@}
@example
proc inclFilePermissions*(filename꞉ string; permissions꞉ set[FilePermission]) @{.rtl,extern꞉ "nos$1", tags꞉ [ReadDirEffect, WriteDirEffect].@}
@end example
  a convenience procedure for:
@example
setFilePermissions(filename, getFilePermissions(filename)+permissions)
@end example

@item exclFilePermissions
  @findex proc exclFilePermissions*(filename꞉ string; permissions꞉ set[FilePermission]) @{.rtl,extern꞉ "nos$1", tags꞉ [ReadDirEffect, WriteDirEffect].@}
@example
proc exclFilePermissions*(filename꞉ string; permissions꞉ set[FilePermission]) @{.rtl,extern꞉ "nos$1", tags꞉ [ReadDirEffect, WriteDirEffect].@}
@end example
  a convenience procedure for:
@example
setFilePermissions(filename, getFilePermissions(filename)-permissions)
@end example

@item expandSymlink
  @findex proc expandSymlink*(symlinkPath꞉ string)꞉ string
@example
proc expandSymlink*(symlinkPath꞉ string)꞉ string
@end example
  Returns a string representing the path to which the symbolic link points.

On Windows this is a noop, @code{symlinkPath} is simply returned.

@item paramCount
  @findex proc paramCount*()꞉ int @{.tags꞉ [ReadIOEffect].@}
@example
proc paramCount*()꞉ int @{.tags꞉ [ReadIOEffect].@}
@end example
  Returns the number of  given to the application.

If your binary was called without parameters this will return zero.  You can later query each individual paramater with @uref{#paramStr, paramStr()} or retrieve all of them in one go with @uref{#commandLineParams, commandLineParams()}.

@strong{Availability}: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with @uref{system.html#declared, declared()}. Example:


@example
when declared(paramCount):
  # Use paramCount() here
else:
  # Do something else!
@end example

@item paramStr
  @findex proc paramStr*(i꞉ int)꞉ TaintedString @{.tags꞉ [ReadIOEffect].@}
@example
proc paramStr*(i꞉ int)꞉ TaintedString @{.tags꞉ [ReadIOEffect].@}
@end example
  Returns the @emph{i}-th  given to the application.

@emph{i} should be in the range @emph{1..paramCount()}, the @emph{EInvalidIndex} exception will be raised for invalid values.  Instead of iterating over @uref{#paramCount, paramCount()} with this proc you can call the convenience @uref{#commandLineParams, commandLineParams()}.

It is possible to call @code{paramStr(0)} but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call @uref{#getAppFilename, getAppFilename()} instead.

@strong{Availability}: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with @uref{system.html#declared, declared()}. Example:


@example
when declared(paramStr):
  # Use paramStr() here
else:
  # Do something else!
@end example

@item commandLineParams
  @findex proc commandLineParams*()꞉ seq[TaintedString]
@example
proc commandLineParams*()꞉ seq[TaintedString]
@end example
  Convenience proc which returns the command line parameters.

This returns @strong{only} the parameters. If you want to get the application executable filename, call @uref{#getAppFilename, getAppFilename()}.

@strong{Availability}: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with @uref{system.html#declared, declared()}. Example:


@example
when declared(commandLineParams):
  # Use commandLineParams() here
else:
  # Do something else!
@end example

@item getAppFilename
  @findex proc getAppFilename*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadIOEffect].@}
@example
proc getAppFilename*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadIOEffect].@}
@end example
  Returns the filename of the application's executable.

This procedure will resolve symlinks.

@strong{Note}: This does not work reliably on BSD.

@item getApplicationFilename
  @findex proc getApplicationFilename*()꞉ string @{.rtl, extern꞉ "nos$1", deprecated.@}
@example
proc getApplicationFilename*()꞉ string @{.rtl, extern꞉ "nos$1", deprecated.@}
@end example
  Returns the filename of the application's executable. @strong{Deprecated since version 0.8.12}: use @code{getAppFilename} instead.

@item getApplicationDir
  @findex proc getApplicationDir*()꞉ string @{.rtl, extern꞉ "nos$1", deprecated.@}
@example
proc getApplicationDir*()꞉ string @{.rtl, extern꞉ "nos$1", deprecated.@}
@end example
  Returns the directory of the application's executable. @strong{Deprecated since version 0.8.12}: use @code{getAppDir} instead.

@item getAppDir
  @findex proc getAppDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadIOEffect].@}
@example
proc getAppDir*()꞉ string @{.rtl, extern꞉ "nos$1", tags꞉ [ReadIOEffect].@}
@end example
  Returns the directory of the application's executable. @strong{Note}: This does not work reliably on BSD.

@item sleep
  @findex proc sleep*(milsecs꞉ int) @{.rtl, extern꞉ "nos$1", tags꞉ [TimeEffect].@}
@example
proc sleep*(milsecs꞉ int) @{.rtl, extern꞉ "nos$1", tags꞉ [TimeEffect].@}
@end example
  sleeps @emph{milsecs} milliseconds.

@item getFileSize
  @findex proc getFileSize*(file꞉ string)꞉ BiggestInt @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect].@}
@example
proc getFileSize*(file꞉ string)꞉ BiggestInt @{.rtl, extern꞉ "nos$1",tags꞉ [ReadIOEffect].@}
@end example
  returns the file size of @emph{file}. Can raise @code{OSError}.

@item getFileInfo
  @findex proc getFileInfo*(handle꞉ FileHandle)꞉ FileInfo
@example
proc getFileInfo*(handle꞉ FileHandle)꞉ FileInfo
@end example
  Retrieves file information for the file object represented by the given handle.

If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.

@item getFileInfo
  @findex proc getFileInfo*(file꞉ File)꞉ FileInfo
@example
proc getFileInfo*(file꞉ File)꞉ FileInfo
@end example
  

@item getFileInfo
  @findex proc getFileInfo*(path꞉ string; followSymlink = true)꞉ FileInfo
@example
proc getFileInfo*(path꞉ string; followSymlink = true)꞉ FileInfo
@end example
  Retrieves file information for the file object pointed to by @emph{path}.

Due to intrinsic differences between operating systems, the information contained by the returned @emph{FileInfo} structure will be slightly different across platforms, and in some cases, incomplete or inaccurate.

When @emph{followSymlink} is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.

If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.

@item isHidden
  @findex proc isHidden*(path꞉ string)꞉ bool
@example
proc isHidden*(path꞉ string)꞉ bool
@end example
  Determines whether a given path is hidden or not. Returns false if the file doesn't exist. The given path must be accessible from the current working directory of the program.

On Windows, a file is hidden if the file's 'hidden' attribute is set. On Unix-like systems, a file is hidden if it starts with a '.' (period) and is not @emph{just} '.' or '..' ' ."
@end itemize





@chapter Iterators

@itemize


@item envPairs
  @itindex iterator envPairs*()꞉ tuple[key, value꞉ TaintedString] @{.tags꞉ [ReadEnvEffect].@}
@example
iterator envPairs*()꞉ tuple[key, value꞉ TaintedString] @{.tags꞉ [ReadEnvEffect].@}
@end example
  Iterate over all . In the first component of the tuple is the name of the current variable stored, in the second its value.

@item walkFiles
  @itindex iterator walkFiles*(pattern꞉ string)꞉ string @{.tags꞉ [ReadDirEffect].@}
@example
iterator walkFiles*(pattern꞉ string)꞉ string @{.tags꞉ [ReadDirEffect].@}
@end example
  Iterate over all the files that match the @emph{pattern}. On POSIX this uses the  call.

@emph{pattern} is OS dependent, but at least the "*.ext" notation is supported.

@item walkDir
  @itindex iterator walkDir*(dir꞉ string; relative = false)꞉ tuple[kind꞉ PathComponent,path꞉ string] @{.tags꞉ [ReadDirEffect].@}
@example
iterator walkDir*(dir꞉ string; relative = false)꞉ tuple[kind꞉ PathComponent,path꞉ string] @{.tags꞉ [ReadDirEffect].@}
@end example
  walks over the directory @emph{dir} and yields for each directory or file in @emph{dir}. The component type and full path for each item is returned. Walking is not recursive. If @code{relative} is true the resulting path is shortened to be relative to @code{dir}. Example: This directory structure:
@verbatim
dirA / dirB / fileB1.txt
     / dirC
     / fileA1.txt
     / fileA2.txt
@end verbatim


and this code:


@example
for kind, path in walkDir("dirA"):
  echo(path)
@end example
produces this output (but not necessarily in this order!):
@verbatim
dirA/dirB
dirA/dirC
dirA/fileA1.txt
dirA/fileA2.txt
@end verbatim

@item walkDirRec
  @itindex iterator walkDirRec*(dir꞉ string; filter = @{pcFile, pcDir@})꞉ string @{.tags꞉ [ReadDirEffect].@}
@example
iterator walkDirRec*(dir꞉ string; filter = @{pcFile, pcDir@})꞉ string @{.tags꞉ [ReadDirEffect].@}
@end example
  walks over the directory @emph{dir} and yields for each file in @emph{dir}. The full path for each file is returned. @strong{Warning}: Modifying the directory structure while the iterator is traversing may result in undefined behavior!

Walking is recursive. @emph{filter} controls the behaviour of the iterator:


@multitable @columnfractions  0.5 0.5
@item @b{filter}
@tab @b{meaning}
@item @code{pcFile}
@tab yield real files
@item @code{pcLinkToFile}
@tab yield symbolic links to files
@item @code{pcDir}
@tab follow real directories
@item @code{pcLinkToDir}
@tab follow symbolic links to directories


@end multitable
@end itemize

@node /pure/rationals, /pure/pegs , /pure/os, Top



@chapter Types

@itemize


@item Rational
  @tindex Rational*[T] = objectnum*, den*꞉ T
@example
Rational*[T] = objectnum*, den*꞉ T
@end example
  a rational number, consisting of a numerator and denominator
@end itemize

@chapter Procedures

@itemize


@item initRational
  @findex proc initRational*[T꞉ SomeInteger](num, den꞉ T)꞉ Rational[T]
@example
proc initRational*[T꞉ SomeInteger](num, den꞉ T)꞉ Rational[T]
@end example
  Create a new rational number.

@item `//`
  @findex proc `//`*[T](num, den꞉ T)꞉ Rational[T]
@example
proc `//`*[T](num, den꞉ T)꞉ Rational[T]
@end example
  A friendlier version of @emph{initRational}. Example usage:
@example
var x = 1//3 + 1//5
@end example

@item `$`
  @findex proc `$`*[T](x꞉ Rational[T])꞉ string
@example
proc `$`*[T](x꞉ Rational[T])꞉ string
@end example
  Turn a rational number into a string.

@item toRational
  @findex proc toRational*[T꞉ SomeInteger](x꞉ T)꞉ Rational[T]
@example
proc toRational*[T꞉ SomeInteger](x꞉ T)꞉ Rational[T]
@end example
  Convert some integer @emph{x} to a rational number.

@item toRational
  @findex proc toRational*(x꞉ float; n꞉ int = high(int))꞉ Rational[int]
@example
proc toRational*(x꞉ float; n꞉ int = high(int))꞉ Rational[int]
@end example
  Calculate the best rational numerator and denominator that approximates to @emph{x}, where the denominator is smaller than @emph{n} (default is the largest possible int to give maximum resolution)

The algorithm is based on the Farey sequence named after John Farey


@example
import math, rationals
for i in 1..10:
  let t = (10 ^ (i+3)).int
  let x = toRational(PI, t)
  let newPI = x.num / x.den
  echo x, " ", newPI, " error: ", PI - newPI, "  ", t
@end example

@item toFloat
  @findex proc toFloat*[T](x꞉ Rational[T])꞉ float
@example
proc toFloat*[T](x꞉ Rational[T])꞉ float
@end example
  Convert a rational number @emph{x} to a float.

@item toInt
  @findex proc toInt*[T](x꞉ Rational[T])꞉ int
@example
proc toInt*[T](x꞉ Rational[T])꞉ int
@end example
  Convert a rational number @emph{x} to an int. Conversion rounds towards 0 if @emph{x} does not contain an integer value.

@item reduce
  @findex proc reduce*[T꞉ SomeInteger](x꞉ var Rational[T])
@example
proc reduce*[T꞉ SomeInteger](x꞉ var Rational[T])
@end example
  Reduce rational @emph{x}.

@item `+`
  @findex proc `+`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@example
proc `+`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@end example
  Add two rational numbers.

@item `+`
  @findex proc `+`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@example
proc `+`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@end example
  Add rational @emph{x} to int @emph{y}.

@item `+`
  @findex proc `+`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@example
proc `+`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@end example
  Add int @emph{x} to rational @emph{y}.

@item `+=`
  @findex proc `+=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@example
proc `+=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@end example
  Add rational @emph{y} to rational @emph{x}.

@item `+=`
  @findex proc `+=`*[T](x꞉ var Rational[T]; y꞉ T)
@example
proc `+=`*[T](x꞉ var Rational[T]; y꞉ T)
@end example
  Add int @emph{y} to rational @emph{x}.

@item `-`
  @findex proc `-`*[T](x꞉ Rational[T])꞉ Rational[T]
@example
proc `-`*[T](x꞉ Rational[T])꞉ Rational[T]
@end example
  Unary minus for rational numbers.

@item `-`
  @findex proc `-`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@example
proc `-`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@end example
  Subtract two rational numbers.

@item `-`
  @findex proc `-`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@example
proc `-`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@end example
  Subtract int @emph{y} from rational @emph{x}.

@item `-`
  @findex proc `-`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@example
proc `-`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@end example
  Subtract rational @emph{y} from int @emph{x}.

@item `-=`
  @findex proc `-=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@example
proc `-=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@end example
  Subtract rational @emph{y} from rational @emph{x}.

@item `-=`
  @findex proc `-=`*[T](x꞉ var Rational[T]; y꞉ T)
@example
proc `-=`*[T](x꞉ var Rational[T]; y꞉ T)
@end example
  Subtract int @emph{y} from rational @emph{x}.

@item `*`
  @findex proc `*`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@example
proc `*`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@end example
  Multiply two rational numbers.

@item `*`
  @findex proc `*`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@example
proc `*`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@end example
  Multiply rational @emph{x} with int @emph{y}.

@item `*`
  @findex proc `*`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@example
proc `*`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@end example
  Multiply int @emph{x} with rational @emph{y}.

@item `*=`
  @findex proc `*=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@example
proc `*=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@end example
  Multiply rationals @emph{y} to @emph{x}.

@item `*=`
  @findex proc `*=`*[T](x꞉ var Rational[T]; y꞉ T)
@example
proc `*=`*[T](x꞉ var Rational[T]; y꞉ T)
@end example
  Multiply int @emph{y} to rational @emph{x}.

@item reciprocal
  @findex proc reciprocal*[T](x꞉ Rational[T])꞉ Rational[T]
@example
proc reciprocal*[T](x꞉ Rational[T])꞉ Rational[T]
@end example
  Calculate the reciprocal of @emph{x}. (1/x)

@item `/`
  @findex proc `/`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@example
proc `/`*[T](x, y꞉ Rational[T])꞉ Rational[T]
@end example
  Divide rationals @emph{x} by @emph{y}.

@item `/`
  @findex proc `/`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@example
proc `/`*[T](x꞉ Rational[T]; y꞉ T)꞉ Rational[T]
@end example
  Divide rational @emph{x} by int @emph{y}.

@item `/`
  @findex proc `/`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@example
proc `/`*[T](x꞉ T; y꞉ Rational[T])꞉ Rational[T]
@end example
  Divide int @emph{x} by Rational @emph{y}.

@item `/=`
  @findex proc `/=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@example
proc `/=`*[T](x꞉ var Rational[T]; y꞉ Rational[T])
@end example
  Divide rationals @emph{x} by @emph{y} in place.

@item `/=`
  @findex proc `/=`*[T](x꞉ var Rational[T]; y꞉ T)
@example
proc `/=`*[T](x꞉ var Rational[T]; y꞉ T)
@end example
  Divide rational @emph{x} by int @emph{y} in place.

@item cmp
  @findex proc cmp*(x, y꞉ Rational)꞉ int @{.procvar.@}
@example
proc cmp*(x, y꞉ Rational)꞉ int @{.procvar.@}
@end example
  Compares two rationals.

@item `<`
  @findex proc `<`*(x, y꞉ Rational)꞉ bool
@example
proc `<`*(x, y꞉ Rational)꞉ bool
@end example
  

@item `<=`
  @findex proc `<=`*(x, y꞉ Rational)꞉ bool
@example
proc `<=`*(x, y꞉ Rational)꞉ bool
@end example
  

@item `==`
  @findex proc `==`*(x, y꞉ Rational)꞉ bool
@example
proc `==`*(x, y꞉ Rational)꞉ bool
@end example
  

@item abs
  @findex proc abs*[T](x꞉ Rational[T])꞉ Rational[T]
@example
proc abs*[T](x꞉ Rational[T])꞉ Rational[T]
@end example
  

@item hash
  @findex proc hash*[T](x꞉ Rational[T])꞉ Hash
@example
proc hash*[T](x꞉ Rational[T])꞉ Hash
@end example
  Computes hash for rational @emph{x}
@end itemize






@node /pure/pegs, /pure/encodings , /pure/rationals, Top
@chapter Constant variables

@itemize


@item MaxSubpatterns
  @vindex MaxSubpatterns* = 20
@example
MaxSubpatterns* = 20
@end example
  defines the maximum number of subpatterns that can be captured. More subpatterns cannot be captured!
@end itemize



@chapter Types

@itemize


@item Peg
  @tindex Peg* = Node
@example
Peg* = Node
@end example
  type that represents a PEG

@item Captures
  @tindex Captures* = object
  matches: array[0 .. MaxSubpatterns - 1, tuple[first, last: int]]
  ml: int
  origStart: int

@example
Captures* = object
  matches: array[0 .. MaxSubpatterns - 1, tuple[first, last: int]]
  ml: int
  origStart: int

@end example
  contains the captured substrings.
@end itemize

@chapter Procedures

@itemize


@item term
  @findex proc term*(t꞉ string)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1Str".@}
@example
proc term*(t꞉ string)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1Str".@}
@end example
  constructs a PEG from a terminal string

@item termIgnoreCase
  @findex proc termIgnoreCase*(t꞉ string)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc termIgnoreCase*(t꞉ string)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  constructs a PEG from a terminal string; ignore case for matching

@item termIgnoreStyle
  @findex proc termIgnoreStyle*(t꞉ string)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc termIgnoreStyle*(t꞉ string)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  constructs a PEG from a terminal string; ignore style for matching

@item term
  @findex proc term*(t꞉ char)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1Char".@}
@example
proc term*(t꞉ char)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1Char".@}
@end example
  constructs a PEG from a terminal char

@item charSet
  @findex proc charSet*(s꞉ set[char])꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc charSet*(s꞉ set[char])꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  constructs a PEG from a character set @emph{s}

@item `/`
  @findex proc `/`*(a꞉ varargs[Peg])꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsOrderedChoice".@}
@example
proc `/`*(a꞉ varargs[Peg])꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsOrderedChoice".@}
@end example
  constructs an ordered choice with the PEGs in @emph{a}

@item sequence
  @findex proc sequence*(a꞉ varargs[Peg])꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc sequence*(a꞉ varargs[Peg])꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  constructs a sequence with all the PEGs from @emph{a}

@item `?`
  @findex proc `?`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsOptional".@}
@example
proc `?`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsOptional".@}
@end example
  constructs an optional for the PEG @emph{a}

@item `*`
  @findex proc `*`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsGreedyRep".@}
@example
proc `*`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsGreedyRep".@}
@end example
  constructs a "greedy repetition" for the PEG @emph{a}

@item `!*`
  @findex proc `!*`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsSearch".@}
@example
proc `!*`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsSearch".@}
@end example
  constructs a "search" for the PEG @emph{a}

@item `!*\`
  @findex proc `!*\`*(a꞉ Peg)꞉ Peg @{.noSideEffect, rtl, extern꞉ "npgegsCapturedSearch".@}
@example
proc `!*\`*(a꞉ Peg)꞉ Peg @{.noSideEffect, rtl, extern꞉ "npgegsCapturedSearch".@}
@end example
  constructs a "captured search" for the PEG @emph{a}

@item `+`
  @findex proc `+`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsGreedyPosRep".@}
@example
proc `+`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsGreedyPosRep".@}
@end example
  constructs a "greedy positive repetition" with the PEG @emph{a}

@item `&`
  @findex proc `&`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsAndPredicate".@}
@example
proc `&`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsAndPredicate".@}
@end example
  constructs an "and predicate" with the PEG @emph{a}

@item `!`
  @findex proc `!`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsNotPredicate".@}
@example
proc `!`*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsNotPredicate".@}
@end example
  constructs a "not predicate" with the PEG @emph{a}

@item any
  @findex proc any*()꞉ Peg @{.inline.@}
@example
proc any*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG  (@code{.})

@item anyRune
  @findex proc anyRune*()꞉ Peg @{.inline.@}
@example
proc anyRune*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG  (@code{_})

@item newLine
  @findex proc newLine*()꞉ Peg @{.inline.@}
@example
proc newLine*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG  (@code{\n})

@item unicodeLetter
  @findex proc unicodeLetter*()꞉ Peg @{.inline.@}
@example
proc unicodeLetter*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG @code{\letter} which matches any Unicode letter.

@item unicodeLower
  @findex proc unicodeLower*()꞉ Peg @{.inline.@}
@example
proc unicodeLower*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG @code{\lower} which matches any Unicode lowercase letter.

@item unicodeUpper
  @findex proc unicodeUpper*()꞉ Peg @{.inline.@}
@example
proc unicodeUpper*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG @code{\upper} which matches any Unicode uppercase letter.

@item unicodeTitle
  @findex proc unicodeTitle*()꞉ Peg @{.inline.@}
@example
proc unicodeTitle*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG @code{\title} which matches any Unicode title letter.

@item unicodeWhitespace
  @findex proc unicodeWhitespace*()꞉ Peg @{.inline.@}
@example
proc unicodeWhitespace*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG @code{\white} which matches any Unicode whitespace character.

@item startAnchor
  @findex proc startAnchor*()꞉ Peg @{.inline.@}
@example
proc startAnchor*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG @code{^} which matches the start of the input.

@item endAnchor
  @findex proc endAnchor*()꞉ Peg @{.inline.@}
@example
proc endAnchor*()꞉ Peg @{.inline.@}
@end example
  constructs the PEG @code{$} which matches the end of the input.

@item capture
  @findex proc capture*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsCapture".@}
@example
proc capture*(a꞉ Peg)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegsCapture".@}
@end example
  constructs a capture with the PEG @emph{a}

@item backref
  @findex proc backref*(index꞉ range[1 .. MaxSubpatterns])꞉ Peg @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc backref*(index꞉ range[1 .. MaxSubpatterns])꞉ Peg @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  constructs a back reference of the given @emph{index}. @emph{index} starts counting from 1.

@item backrefIgnoreCase
  @findex proc backrefIgnoreCase*(index꞉ range[1 .. MaxSubpatterns])꞉ Peg @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc backrefIgnoreCase*(index꞉ range[1 .. MaxSubpatterns])꞉ Peg @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  constructs a back reference of the given @emph{index}. @emph{index} starts counting from 1. Ignores case for matching.

@item backrefIgnoreStyle
  @findex proc backrefIgnoreStyle*(index꞉ range[1 .. MaxSubpatterns])꞉ Peg @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc backrefIgnoreStyle*(index꞉ range[1 .. MaxSubpatterns])꞉ Peg @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  constructs a back reference of the given @emph{index}. @emph{index} starts counting from 1. Ignores style for matching.

@item nonterminal
  @findex proc nonterminal*(n꞉ NonTerminal)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc nonterminal*(n꞉ NonTerminal)꞉ Peg @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  constructs a PEG that consists of the nonterminal symbol

@item newNonTerminal
  @findex proc newNonTerminal*(name꞉ string; line, column꞉ int)꞉ NonTerminal @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc newNonTerminal*(name꞉ string; line, column꞉ int)꞉ NonTerminal @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  constructs a nonterminal symbol

@item `$`
  @findex proc `$`*(r꞉ Peg)꞉ string @{.nosideEffect, rtl, extern꞉ "npegsToString".@}
@example
proc `$`*(r꞉ Peg)꞉ string @{.nosideEffect, rtl, extern꞉ "npegsToString".@}
@end example
  converts a PEG to its string representation

@item bounds
  @findex proc bounds*(c꞉ Captures; i꞉ range[0 .. MaxSubpatterns - 1])꞉ tuple[first, last꞉ int]
@example
proc bounds*(c꞉ Captures; i꞉ range[0 .. MaxSubpatterns - 1])꞉ tuple[first, last꞉ int]
@end example
  returns the bounds @code{[first..last]} of the @emph{i}'th capture.

@item rawMatch
  @findex proc rawMatch*(s꞉ string; p꞉ Peg; start꞉ int; c꞉ var Captures)꞉ int @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc rawMatch*(s꞉ string; p꞉ Peg; start꞉ int; c꞉ var Captures)꞉ int @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  low-level matching proc that implements the PEG interpreter. Use this for maximum efficiency (every other PEG operation ends up calling this proc). Returns -1 if it does not match, else the length of the match

@item matchLen
  @findex proc matchLen*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ int @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@example
proc matchLen*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ int @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@end example
  the same as @code{match}, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of @emph{s} remains that does not belong to the match.

@item matchLen
  @findex proc matchLen*(s꞉ string; pattern꞉ Peg; start = 0)꞉ int @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc matchLen*(s꞉ string; pattern꞉ Peg; start = 0)꞉ int @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  the same as @code{match}, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of @emph{s} remains that does not belong to the match.

@item match
  @findex proc match*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ bool @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@example
proc match*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ bool @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@end example
  returns @code{true} if @code{s[start..]} matches the @code{pattern} and the captured substrings in the array @code{matches}. If it does not match, nothing is written into @code{matches} and @code{false} is returned.

@item match
  @findex proc match*(s꞉ string; pattern꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc match*(s꞉ string; pattern꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  returns @code{true} if @code{s} matches the @code{pattern} beginning from @code{start}.

@item find
  @findex proc find*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ int @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@example
proc find*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ int @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@end example
  returns the starting position of @code{pattern} in @code{s} and the captured substrings in the array @code{matches}. If it does not match, nothing is written into @code{matches} and -1 is returned.

@item findBounds
  @findex proc findBounds*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ tuple[first, last꞉ int] @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@example
proc findBounds*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ tuple[first, last꞉ int] @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@end example
  returns the starting position and end position of @code{pattern} in @code{s} and the captured substrings in the array @code{matches}. If it does not match, nothing is written into @code{matches} and (-1,0) is returned.

@item find
  @findex proc find*(s꞉ string; pattern꞉ Peg; start = 0)꞉ int @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc find*(s꞉ string; pattern꞉ Peg; start = 0)꞉ int @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  returns the starting position of @code{pattern} in @code{s}. If it does not match, -1 is returned.

@item findAll
  @findex proc findAll*(s꞉ string; pattern꞉ Peg; start = 0)꞉ seq[string] @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc findAll*(s꞉ string; pattern꞉ Peg; start = 0)꞉ seq[string] @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  returns all matching @emph{substrings} of @emph{s} that match @emph{pattern}. If it does not match, @@[] is returned.

@item contains
  @findex proc contains*(s꞉ string; pattern꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc contains*(s꞉ string; pattern꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  same as @code{find(s, pattern, start) >= 0}

@item contains
  @findex proc contains*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ bool @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@example
proc contains*(s꞉ string; pattern꞉ Peg; matches꞉ var openArray[string]; start = 0)꞉ bool @{.nosideEffect, rtl, extern꞉ "npegs$1Capture".@}
@end example
  same as @code{find(s, pattern, matches, start) >= 0}

@item startsWith
  @findex proc startsWith*(s꞉ string; prefix꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc startsWith*(s꞉ string; prefix꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  returns true if @emph{s} starts with the pattern @emph{prefix}

@item endsWith
  @findex proc endsWith*(s꞉ string; suffix꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc endsWith*(s꞉ string; suffix꞉ Peg; start = 0)꞉ bool @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  returns true if @emph{s} ends with the pattern @emph{suffix}

@item replacef
  @findex proc replacef*(s꞉ string; sub꞉ Peg; by꞉ string)꞉ string @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@example
proc replacef*(s꞉ string; sub꞉ Peg; by꞉ string)꞉ string @{.nosideEffect, rtl,extern꞉ "npegs$1".@}
@end example
  Replaces @emph{sub} in @emph{s} by the string @emph{by}. Captures can be accessed in @emph{by} with the notation @code{$i} and @code{$#} (see strutils.`%`). Examples:
@example
"var1=key; var2=key2".replacef(peg"@{\ident@}'='@{\ident@}", "$1<-$2$2")
@end example
Results in:


@example

"var1<-keykey; val2<-key2key2"
@end example

@item replace
  @findex proc replace*(s꞉ string; sub꞉ Peg; by = "")꞉ string @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc replace*(s꞉ string; sub꞉ Peg; by = "")꞉ string @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  Replaces @emph{sub} in @emph{s} by the string @emph{by}. Captures cannot be accessed in @emph{by}.

@item parallelReplace
  @findex proc parallelReplace*(s꞉ string; subs꞉ varargs[tuple[pattern꞉ Peg, repl꞉ string]])꞉ string @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc parallelReplace*(s꞉ string; subs꞉ varargs[tuple[pattern꞉ Peg, repl꞉ string]])꞉ string @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  Returns a modified copy of @emph{s} with the substitutions in @emph{subs} applied in parallel.

@item transformFile
  @findex proc transformFile*(infile, outfile꞉ string;subs꞉ varargs[tuple[pattern꞉ Peg, repl꞉ string]]) @{.rtl,extern꞉ "npegs$1".@}
@example
proc transformFile*(infile, outfile꞉ string;subs꞉ varargs[tuple[pattern꞉ Peg, repl꞉ string]]) @{.rtl,extern꞉ "npegs$1".@}
@end example
  reads in the file @emph{infile}, performs a parallel replacement (calls @emph{parallelReplace}) and writes back to @emph{outfile}. Raises @code{EIO} if an error occurs. This is supposed to be used for quick scripting.

@item split
  @findex proc split*(s꞉ string; sep꞉ Peg)꞉ seq[string] @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@example
proc split*(s꞉ string; sep꞉ Peg)꞉ seq[string] @{.nosideEffect, rtl, extern꞉ "npegs$1".@}
@end example
  Splits the string @emph{s} into substrings.

@item parsePeg
  @findex proc parsePeg*(pattern꞉ string; filename = "pattern"; line = 1; col = 0)꞉ Peg
@example
proc parsePeg*(pattern꞉ string; filename = "pattern"; line = 1; col = 0)꞉ Peg
@end example
  constructs a Peg object from @emph{pattern}. @emph{filename}, @emph{line}, @emph{col} are used for error messages, but they only provide start offsets. @emph{parsePeg} keeps track of line and column numbers within @emph{pattern}.

@item peg
  @findex proc peg*(pattern꞉ string)꞉ Peg
@example
proc peg*(pattern꞉ string)꞉ Peg
@end example
  constructs a Peg object from the @emph{pattern}. The short name has been chosen to encourage its use as a raw string modifier:
@verbatim

peg"@{\ident@} \s* '=' \s* @{.*@}"
@end verbatim

@item escapePeg
  @findex proc escapePeg*(s꞉ string)꞉ string
@example
proc escapePeg*(s꞉ string)꞉ string
@end example
  escapes @emph{s} so that it is matched verbatim when used as a peg.
@end itemize

@chapter Templates

@itemize


@item letters
  @findex template letters*()꞉ expr
@example
template letters*()꞉ expr
@end example
  expands to @code{charset(@{'A'..'Z', 'a'..'z'@})}

@item digits
  @findex template digits*()꞉ expr
@example
template digits*()꞉ expr
@end example
  expands to @code{charset(@{'0'..'9'@})}

@item whitespace
  @findex template whitespace*()꞉ expr
@example
template whitespace*()꞉ expr
@end example
  expands to @code{charset(@{' ', '\9'..'\13'@})}

@item identChars
  @findex template identChars*()꞉ expr
@example
template identChars*()꞉ expr
@end example
  expands to @code{charset(@{'a'..'z', 'A'..'Z', '0'..'9', '_'@})}

@item identStartChars
  @findex template identStartChars*()꞉ expr
@example
template identStartChars*()꞉ expr
@end example
  expands to @code{charset(@{'A'..'Z', 'a'..'z', '_'@})}

@item ident
  @findex template ident*()꞉ expr
@example
template ident*()꞉ expr
@end example
  same as @code{[a-zA-Z_][a-zA-z_0-9]*}; standard identifier

@item natural
  @findex template natural*()꞉ expr
@example
template natural*()꞉ expr
@end example
  same as @code{\d+}

@item `=~`
  @findex template `=~`*(s꞉ string; pattern꞉ Peg)꞉ bool
@example
template `=~`*(s꞉ string; pattern꞉ Peg)꞉ bool
@end example
  This calls @code{match} with an implicit declared @code{matches} array that can be used in the scope of the @code{=~} call:
@example

if line =~ peg"\s* @{\w+@} \s* '=' \s* @{\w+@}":
  # matches a key=value pair:
  echo("Key: ", matches[0])
  echo("Value: ", matches[1])
elif line =~ peg"\s*@{'#'.*@}":
  # matches a comment
  # note that the implicit ``matches`` array is different from the
  # ``matches`` array of the first branch
  echo("comment: ", matches[0])
else:
  echo("syntax error")
@end example
@end itemize




@chapter Iterators

@itemize


@item findAll
  @itindex iterator findAll*(s꞉ string; pattern꞉ Peg; start = 0)꞉ string
@example
iterator findAll*(s꞉ string; pattern꞉ Peg; start = 0)꞉ string
@end example
  yields all matching @emph{substrings} of @emph{s} that match @emph{pattern}.

@item split
  @itindex iterator split*(s꞉ string; sep꞉ Peg)꞉ string
@example
iterator split*(s꞉ string; sep꞉ Peg)꞉ string
@end example
  Splits the string @emph{s} into substrings.

Substrings are separated by the PEG @emph{sep}. Examples:


@example
for word in split("00232this02939is39an22example111", peg"\d+"):
  writeLine(stdout, word)
@end example
Results in:


@example
"this"
"is"
"an"
"example"
@end example
@end itemize

@node /pure/encodings, /pure/mersenne , /pure/pegs, Top



@chapter Types

@itemize


@item EncodingConverter
  @tindex EncodingConverter* = ptr ConverterObj
@example
EncodingConverter* = ptr ConverterObj
@end example
  can convert between two character sets

@item EncodingError
  @tindex EncodingError* = object of ValueError
@example
EncodingError* = object of ValueError
@end example
  exception that is raised for encoding errors
@end itemize

@chapter Procedures

@itemize


@item getCurrentEncoding
  @findex proc getCurrentEncoding*()꞉ string
@example
proc getCurrentEncoding*()꞉ string
@end example
  retrieves the current encoding. On Unix, always "UTF-8" is returned.

@item open
  @findex proc open*(destEncoding = "UTF-8"; srcEncoding = "CP1252")꞉ EncodingConverter
@example
proc open*(destEncoding = "UTF-8"; srcEncoding = "CP1252")꞉ EncodingConverter
@end example
  opens a converter that can convert from @emph{srcEncoding} to @emph{destEncoding}. Raises @emph{EIO} if it cannot fulfill the request.

@item close
  @findex proc close*(c꞉ EncodingConverter)
@example
proc close*(c꞉ EncodingConverter)
@end example
  frees the resources the converter @emph{c} holds.

@item convert
  @findex proc convert*(c꞉ EncodingConverter; s꞉ string)꞉ string
@example
proc convert*(c꞉ EncodingConverter; s꞉ string)꞉ string
@end example
  converts @emph{s} to @emph{destEncoding} that was given to the converter @emph{c}. It assumed that @emph{s} is in @emph{srcEncoding}.

@item convert
  @findex proc convert*(s꞉ string; destEncoding = "UTF-8"; srcEncoding = "CP1252")꞉ string
@example
proc convert*(s꞉ string; destEncoding = "UTF-8"; srcEncoding = "CP1252")꞉ string
@end example
  converts @emph{s} to @emph{destEncoding}. It assumed that @emph{s} is in @emph{srcEncoding}. This opens a converter, uses it and closes it again and is thus more convienent but also likely less efficient than re-using a converter.
@end itemize






@node /pure/mersenne, /pure/htmlgen , /pure/encodings, Top



@chapter Types

@itemize


@item MersenneTwister
  @tindex MersenneTwister* = object
  mt: array[0 .. 623, uint32]
  index: int

@example
MersenneTwister* = object
  mt: array[0 .. 623, uint32]
  index: int

@end example
  
@end itemize

@chapter Procedures

@itemize


@item newMersenneTwister
  @findex proc newMersenneTwister*(seed꞉ int)꞉ MersenneTwister
@example
proc newMersenneTwister*(seed꞉ int)꞉ MersenneTwister
@end example
  

@item getNum
  @findex proc getNum*(m꞉ var MersenneTwister)꞉ int
@example
proc getNum*(m꞉ var MersenneTwister)꞉ int
@end example
  
@end itemize






@node /pure/htmlgen, /pure/endians , /pure/mersenne, Top
@chapter Constant variables

@itemize


@item commonAttr
  @vindex commonAttr* = coreAttr & eventAttr
@example
commonAttr* = coreAttr & eventAttr
@end example
  
@end itemize




@chapter Procedures

@itemize


@item xmlCheckedTag
  @findex proc xmlCheckedTag*(e꞉ NimNode; tag꞉ string; optAttr = ""; reqAttr = ""; isLeaf = false)꞉ NimNode @{.compileTime.@}
@example
proc xmlCheckedTag*(e꞉ NimNode; tag꞉ string; optAttr = ""; reqAttr = ""; isLeaf = false)꞉ NimNode @{.compileTime.@}
@end example
  use this procedure to define a new XML tag
@end itemize


@chapter Macros

@itemize


@item a
  @findex macro a*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro a*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{a} element.

@item acronym
  @findex macro acronym*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro acronym*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{acronym} element.

@item address
  @findex macro address*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro address*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{address} element.

@item area
  @findex macro area*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro area*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{area} element.

@item b
  @findex macro b*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro b*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{b} element.

@item base
  @findex macro base*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro base*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{base} element.

@item big
  @findex macro big*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro big*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{big} element.

@item blockquote
  @findex macro blockquote*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro blockquote*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{blockquote} element.

@item body
  @findex macro body*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro body*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{body} element.

@item br
  @findex macro br*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro br*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{br} element.

@item button
  @findex macro button*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro button*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{button} element.

@item caption
  @findex macro caption*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro caption*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{caption} element.

@item cite
  @findex macro cite*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro cite*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{cite} element.

@item code
  @findex macro code*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro code*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{code} element.

@item col
  @findex macro col*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro col*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{col} element.

@item colgroup
  @findex macro colgroup*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro colgroup*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{colgroup} element.

@item dd
  @findex macro dd*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro dd*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{dd} element.

@item del
  @findex macro del*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro del*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{del} element.

@item dfn
  @findex macro dfn*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro dfn*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{dfn} element.

@item `div`
  @findex macro `div`*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro `div`*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{div} element.

@item dl
  @findex macro dl*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro dl*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{dl} element.

@item dt
  @findex macro dt*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro dt*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{dt} element.

@item em
  @findex macro em*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro em*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{em} element.

@item fieldset
  @findex macro fieldset*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro fieldset*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{fieldset} element.

@item form
  @findex macro form*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro form*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{form} element.

@item h1
  @findex macro h1*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro h1*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{h1} element.

@item h2
  @findex macro h2*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro h2*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{h2} element.

@item h3
  @findex macro h3*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro h3*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{h3} element.

@item h4
  @findex macro h4*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro h4*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{h4} element.

@item h5
  @findex macro h5*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro h5*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{h5} element.

@item h6
  @findex macro h6*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro h6*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{h6} element.

@item head
  @findex macro head*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro head*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{head} element.

@item html
  @findex macro html*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro html*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{html} element.

@item hr
  @findex macro hr*()꞉ expr @{.immediate.@}
@example
macro hr*()꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{hr} element.

@item i
  @findex macro i*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro i*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{i} element.

@item img
  @findex macro img*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro img*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{img} element.

@item input
  @findex macro input*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro input*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{input} element.

@item ins
  @findex macro ins*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro ins*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{ins} element.

@item kbd
  @findex macro kbd*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro kbd*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{kbd} element.

@item label
  @findex macro label*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro label*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{label} element.

@item legend
  @findex macro legend*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro legend*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{legend} element.

@item li
  @findex macro li*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro li*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{li} element.

@item link
  @findex macro link*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro link*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{link} element.

@item map
  @findex macro map*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro map*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{map} element.

@item meta
  @findex macro meta*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro meta*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{meta} element.

@item noscript
  @findex macro noscript*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro noscript*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{noscript} element.

@item `object`
  @findex macro `object`*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro `object`*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{object} element.

@item ol
  @findex macro ol*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro ol*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{ol} element.

@item optgroup
  @findex macro optgroup*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro optgroup*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{optgroup} element.

@item option
  @findex macro option*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro option*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{option} element.

@item p
  @findex macro p*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro p*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{p} element.

@item param
  @findex macro param*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro param*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{param} element.

@item pre
  @findex macro pre*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro pre*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{pre} element.

@item q
  @findex macro q*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro q*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{q} element.

@item samp
  @findex macro samp*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro samp*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{samp} element.

@item script
  @findex macro script*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro script*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{script} element.

@item select
  @findex macro select*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro select*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{select} element.

@item small
  @findex macro small*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro small*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{small} element.

@item span
  @findex macro span*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro span*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{span} element.

@item strong
  @findex macro strong*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro strong*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{strong} element.

@item style
  @findex macro style*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro style*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{style} element.

@item sub
  @findex macro sub*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro sub*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{sub} element.

@item sup
  @findex macro sup*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro sup*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{sup} element.

@item table
  @findex macro table*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro table*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{table} element.

@item tbody
  @findex macro tbody*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro tbody*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{tbody} element.

@item td
  @findex macro td*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro td*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{td} element.

@item textarea
  @findex macro textarea*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro textarea*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{textarea} element.

@item tfoot
  @findex macro tfoot*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro tfoot*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{tfoot} element.

@item th
  @findex macro th*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro th*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{th} element.

@item thead
  @findex macro thead*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro thead*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{thead} element.

@item title
  @findex macro title*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro title*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{title} element.

@item tr
  @findex macro tr*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro tr*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{tr} element.

@item tt
  @findex macro tt*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro tt*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{tt} element.

@item ul
  @findex macro ul*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro ul*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{ul} element.

@item `var`
  @findex macro `var`*(e꞉ expr)꞉ expr @{.immediate.@}
@example
macro `var`*(e꞉ expr)꞉ expr @{.immediate.@}
@end example
  generates the HTML @code{var} element.
@end itemize




@node /pure/endians, /pure/parseopt , /pure/htmlgen, Top




@chapter Procedures

@itemize


@item swapEndian64
  @findex proc swapEndian64*(outp, inp꞉ pointer)
@example
proc swapEndian64*(outp, inp꞉ pointer)
@end example
  copies @emph{inp} to @emph{outp} swapping bytes. Both buffers are supposed to contain at least 8 bytes.

@item swapEndian32
  @findex proc swapEndian32*(outp, inp꞉ pointer)
@example
proc swapEndian32*(outp, inp꞉ pointer)
@end example
  copies @emph{inp} to @emph{outp} swapping bytes. Both buffers are supposed to contain at least 4 bytes.

@item swapEndian16
  @findex proc swapEndian16*(outp, inp꞉ pointer)
@example
proc swapEndian16*(outp, inp꞉ pointer)
@end example
  copies @emph{inp} to @emph{outp} swapping bytes. Both buffers are supposed to contain at least 2 bytes.

@item littleEndian64
  @findex proc littleEndian64*(outp, inp꞉ pointer) @{.inline.@}
@example
proc littleEndian64*(outp, inp꞉ pointer) @{.inline.@}
@end example
  

@item littleEndian32
  @findex proc littleEndian32*(outp, inp꞉ pointer) @{.inline.@}
@example
proc littleEndian32*(outp, inp꞉ pointer) @{.inline.@}
@end example
  

@item littleEndian16
  @findex proc littleEndian16*(outp, inp꞉ pointer) @{.inline.@}
@example
proc littleEndian16*(outp, inp꞉ pointer) @{.inline.@}
@end example
  

@item bigEndian64
  @findex proc bigEndian64*(outp, inp꞉ pointer) @{.inline.@}
@example
proc bigEndian64*(outp, inp꞉ pointer) @{.inline.@}
@end example
  

@item bigEndian32
  @findex proc bigEndian32*(outp, inp꞉ pointer) @{.inline.@}
@example
proc bigEndian32*(outp, inp꞉ pointer) @{.inline.@}
@end example
  

@item bigEndian16
  @findex proc bigEndian16*(outp, inp꞉ pointer) @{.inline.@}
@example
proc bigEndian16*(outp, inp꞉ pointer) @{.inline.@}
@end example
  
@end itemize






@node /pure/parseopt, /pure/ropes , /pure/endians, Top



@chapter Types

@itemize


@item OptParser
  @tindex OptParser* = object of RootObj
  cmd: string
  pos: int
  inShortState: bool
  kind*: CmdLineKind           ## the dected command line token
  key*, val*: TaintedString     ## key and value pair; ``key`` is the option
                         ## or the argument, ``value`` is not "" if
                         ## the option was given a value
  
@example
OptParser* = object of RootObj
  cmd: string
  pos: int
  inShortState: bool
  kind*: CmdLineKind           ## the dected command line token
  key*, val*: TaintedString     ## key and value pair; ``key`` is the option
                         ## or the argument, ``value`` is not "" if
                         ## the option was given a value
  
@end example
  this object implements the command line parser
@end itemize

@chapter Procedures

@itemize


@item initOptParser
  @findex proc initOptParser*(cmdline = "")꞉ OptParser
@example
proc initOptParser*(cmdline = "")꞉ OptParser
@end example
  inits the option parser. If @code{cmdline == ""}, the real command line (as provided by the @code{OS} module) is taken.

@item next
  @findex proc next*(p꞉ var OptParser) @{.rtl, extern꞉ "npo$1".@}
@example
proc next*(p꞉ var OptParser) @{.rtl, extern꞉ "npo$1".@}
@end example
  parses the first or next option; @code{p.kind} describes what token has been parsed. @code{p.key} and @code{p.val} are set accordingly.

@item cmdLineRest
  @findex proc cmdLineRest*(p꞉ OptParser)꞉ TaintedString @{.rtl, extern꞉ "npo$1".@}
@example
proc cmdLineRest*(p꞉ OptParser)꞉ TaintedString @{.rtl, extern꞉ "npo$1".@}
@end example
  retrieves the rest of the command line that has not been parsed yet.
@end itemize





@chapter Iterators

@itemize


@item getopt
  @itindex iterator getopt*()꞉ tuple[kind꞉ CmdLineKind, key, val꞉ TaintedString]
@example
iterator getopt*()꞉ tuple[kind꞉ CmdLineKind, key, val꞉ TaintedString]
@end example
  This is an convenience iterator for iterating over the command line. This uses the OptParser object. Example:
@example
var
  filename = ""
for kind, key, val in getopt():
  case kind
  of cmdArgument:
    filename = key
  of cmdLongOption, cmdShortOption:
    case key
    of "help", "h": writeHelp()
    of "version", "v": writeVersion()
  of cmdEnd: assert(false) # cannot happen
if filename == "":
  # no filename has been given, so we show the help:
  writeHelp()
@end example
@end itemize

@node /pure/ropes, /pure/fsmonitor , /pure/parseopt, Top




@chapter Procedures

@itemize


@item len
  @findex proc len*(a꞉ Rope)꞉ int @{.rtl, extern꞉ "nro$1".@}
@example
proc len*(a꞉ Rope)꞉ int @{.rtl, extern꞉ "nro$1".@}
@end example
  the rope's length

@item rope
  @findex proc rope*(s꞉ string)꞉ Rope @{.rtl, extern꞉ "nro$1Str".@}
@example
proc rope*(s꞉ string)꞉ Rope @{.rtl, extern꞉ "nro$1Str".@}
@end example
  Converts a string to a rope.

@item rope
  @findex proc rope*(i꞉ BiggestInt)꞉ Rope @{.rtl, extern꞉ "nro$1BiggestInt".@}
@example
proc rope*(i꞉ BiggestInt)꞉ Rope @{.rtl, extern꞉ "nro$1BiggestInt".@}
@end example
  Converts an int to a rope.

@item rope
  @findex proc rope*(f꞉ BiggestFloat)꞉ Rope @{.rtl, extern꞉ "nro$1BiggestFloat".@}
@example
proc rope*(f꞉ BiggestFloat)꞉ Rope @{.rtl, extern꞉ "nro$1BiggestFloat".@}
@end example
  Converts a float to a rope.

@item enableCache
  @findex proc enableCache*() @{.rtl, extern꞉ "nro$1".@}
@example
proc enableCache*() @{.rtl, extern꞉ "nro$1".@}
@end example
  Enables the caching of leaves. This reduces the memory footprint at the cost of runtime efficiency.

@item disableCache
  @findex proc disableCache*() @{.rtl, extern꞉ "nro$1".@}
@example
proc disableCache*() @{.rtl, extern꞉ "nro$1".@}
@end example
  the cache is discarded and disabled. The GC will reuse its used memory.

@item `&`
  @findex proc `&`*(a, b꞉ Rope)꞉ Rope @{.rtl, extern꞉ "nroConcRopeRope".@}
@example
proc `&`*(a, b꞉ Rope)꞉ Rope @{.rtl, extern꞉ "nroConcRopeRope".@}
@end example
  the concatenation operator for ropes.

@item `&`
  @findex proc `&`*(a꞉ Rope; b꞉ string)꞉ Rope @{.rtl, extern꞉ "nroConcRopeStr".@}
@example
proc `&`*(a꞉ Rope; b꞉ string)꞉ Rope @{.rtl, extern꞉ "nroConcRopeStr".@}
@end example
  the concatenation operator for ropes.

@item `&`
  @findex proc `&`*(a꞉ string; b꞉ Rope)꞉ Rope @{.rtl, extern꞉ "nroConcStrRope".@}
@example
proc `&`*(a꞉ string; b꞉ Rope)꞉ Rope @{.rtl, extern꞉ "nroConcStrRope".@}
@end example
  the concatenation operator for ropes.

@item `&`
  @findex proc `&`*(a꞉ openArray[Rope])꞉ Rope @{.rtl, extern꞉ "nroConcOpenArray".@}
@example
proc `&`*(a꞉ openArray[Rope])꞉ Rope @{.rtl, extern꞉ "nroConcOpenArray".@}
@end example
  the concatenation operator for an openarray of ropes.

@item add
  @findex proc add*(a꞉ var Rope; b꞉ Rope) @{.rtl, extern꞉ "nro$1Rope".@}
@example
proc add*(a꞉ var Rope; b꞉ Rope) @{.rtl, extern꞉ "nro$1Rope".@}
@end example
  adds @emph{b} to the rope @emph{a}.

@item add
  @findex proc add*(a꞉ var Rope; b꞉ string) @{.rtl, extern꞉ "nro$1Str".@}
@example
proc add*(a꞉ var Rope; b꞉ string) @{.rtl, extern꞉ "nro$1Str".@}
@end example
  adds @emph{b} to the rope @emph{a}.

@item `[]`
  @findex proc `[]`*(r꞉ Rope; i꞉ int)꞉ char @{.rtl, extern꞉ "nroCharAt".@}
@example
proc `[]`*(r꞉ Rope; i꞉ int)꞉ char @{.rtl, extern꞉ "nroCharAt".@}
@end example
  returns the character at position @emph{i} in the rope @emph{r}. This is quite expensive! Worst-case: O(n). If @code{i >= r.len}, @code{\0} is returned.

@item write
  @findex proc write*(f꞉ File; r꞉ Rope) @{.rtl, extern꞉ "nro$1".@}
@example
proc write*(f꞉ File; r꞉ Rope) @{.rtl, extern꞉ "nro$1".@}
@end example
  writes a rope to a file.

@item `$`
  @findex proc `$`*(r꞉ Rope)꞉ string @{.rtl, extern꞉ "nroToString".@}
@example
proc `$`*(r꞉ Rope)꞉ string @{.rtl, extern꞉ "nroToString".@}
@end example
  converts a rope back to a string.

@item `%`
  @findex proc `%`*(frmt꞉ string; args꞉ openArray[Rope])꞉ Rope @{.rtl, extern꞉ "nroFormat".@}
@example
proc `%`*(frmt꞉ string; args꞉ openArray[Rope])꞉ Rope @{.rtl, extern꞉ "nroFormat".@}
@end example
  @emph{%} substitution operator for ropes. Does not support the @code{$identifier} nor @code{$@{identifier@}} notations.

@item addf
  @findex proc addf*(c꞉ var Rope; frmt꞉ string; args꞉ openArray[Rope]) @{.rtl, extern꞉ "nro$1".@}
@example
proc addf*(c꞉ var Rope; frmt꞉ string; args꞉ openArray[Rope]) @{.rtl, extern꞉ "nro$1".@}
@end example
  shortcut for @code{add(c, frmt % args)}.

@item equalsFile
  @findex proc equalsFile*(r꞉ Rope; f꞉ File)꞉ bool @{.rtl, extern꞉ "nro$1File".@}
@example
proc equalsFile*(r꞉ Rope; f꞉ File)꞉ bool @{.rtl, extern꞉ "nro$1File".@}
@end example
  returns true if the contents of the file @emph{f} equal @emph{r}.

@item equalsFile
  @findex proc equalsFile*(r꞉ Rope; filename꞉ string)꞉ bool @{.rtl, extern꞉ "nro$1Str".@}
@example
proc equalsFile*(r꞉ Rope; filename꞉ string)꞉ bool @{.rtl, extern꞉ "nro$1Str".@}
@end example
  returns true if the contents of the file @emph{f} equal @emph{r}. If @emph{f} does not exist, false is returned.
@end itemize





@chapter Iterators

@itemize


@item leaves
  @itindex iterator leaves*(r꞉ Rope)꞉ string
@example
iterator leaves*(r꞉ Rope)꞉ string
@end example
  iterates over any leaf string in the rope @emph{r}.

@item items
  @itindex iterator items*(r꞉ Rope)꞉ char
@example
iterator items*(r꞉ Rope)꞉ char
@end example
  iterates over any character in the rope @emph{r}.
@end itemize

@node /pure/fsmonitor, /pure/collections/queues , /pure/ropes, Top



@chapter Types

@itemize


@item MonitorEvent
  @tindex MonitorEvent* = object
  case kind*: MonitorEventType
  of MonitorMoveSelf, MonitorMoved:
      oldPath*: string         ## Old absolute location
      newPath*: string         ## New absolute location
    
  else:
      fullname*: string        ## Absolute filename of the file/directory affected.
    
  name*: string                ## Non absolute filepath of the file/directory
              ## affected relative to the directory watched.
              ## "" if this event refers to the file/directory
              ## watched.
  wd*: cint                    ## Watch descriptor.
  
@example
MonitorEvent* = object
  case kind*: MonitorEventType
  of MonitorMoveSelf, MonitorMoved:
      oldPath*: string         ## Old absolute location
      newPath*: string         ## New absolute location
    
  else:
      fullname*: string        ## Absolute filename of the file/directory affected.
    
  name*: string                ## Non absolute filepath of the file/directory
              ## affected relative to the directory watched.
              ## "" if this event refers to the file/directory
              ## watched.
  wd*: cint                    ## Watch descriptor.
  
@end example
  Type of the event.
@end itemize

@chapter Procedures

@itemize


@item newMonitor
  @findex proc newMonitor*()꞉ FSMonitor
@example
proc newMonitor*()꞉ FSMonitor
@end example
  Creates a new file system monitor.

@item add
  @findex proc add*(monitor꞉ FSMonitor; target꞉ string; filters = @{MonitorAll@})꞉ cint @{.discardable.@}
@example
proc add*(monitor꞉ FSMonitor; target꞉ string; filters = @{MonitorAll@})꞉ cint @{.discardable.@}
@end example
  Adds @code{target} which may be a directory or a file to the list of watched paths of @code{monitor}. You can specify the events to report using the @code{filters} parameter.

@item del
  @findex proc del*(monitor꞉ FSMonitor; wd꞉ cint)
@example
proc del*(monitor꞉ FSMonitor; wd꞉ cint)
@end example
  Removes watched directory or file as specified by @code{wd} from @code{monitor}.

If @code{wd} is not a part of @code{monitor} an EOS error is raised.

@item register
  @findex proc register*(d꞉ Dispatcher; monitor꞉ FSMonitor;handleEvent꞉ proc (m꞉ FSMonitor; ev꞉ MonitorEvent) @{.closure.@})
@example
proc register*(d꞉ Dispatcher; monitor꞉ FSMonitor;handleEvent꞉ proc (m꞉ FSMonitor; ev꞉ MonitorEvent) @{.closure.@})
@end example
  Registers @code{monitor} with dispatcher @code{d}.
@end itemize






@node /pure/collections/queues, /pure/collections/LockFreeHash , /pure/fsmonitor, Top



@chapter Types

@itemize


@item Queue
  @tindex Queue*[T] = object
  data: seq[T]
  rd, wr, count, mask: int

@example
Queue*[T] = object
  data: seq[T]
  rd, wr, count, mask: int

@end example
  a queue
@end itemize

@chapter Procedures

@itemize


@item initQueue
  @findex proc initQueue*[T](initialSize = 4)꞉ Queue[T]
@example
proc initQueue*[T](initialSize = 4)꞉ Queue[T]
@end example
  creates a new queue. @emph{initialSize} needs to be a power of 2.

@item len
  @findex proc len*[T](q꞉ Queue[T])꞉ int
@example
proc len*[T](q꞉ Queue[T])꞉ int
@end example
  returns the number of elements of @emph{q}.

@item add
  @findex proc add*[T](q꞉ var Queue[T]; item꞉ T)
@example
proc add*[T](q꞉ var Queue[T]; item꞉ T)
@end example
  adds an @emph{item} to the end of the queue @emph{q}.

@item enqueue
  @findex proc enqueue*[T](q꞉ var Queue[T]; item꞉ T)
@example
proc enqueue*[T](q꞉ var Queue[T]; item꞉ T)
@end example
  alias for the @code{add} operation.

@item dequeue
  @findex proc dequeue*[T](q꞉ var Queue[T])꞉ T
@example
proc dequeue*[T](q꞉ var Queue[T])꞉ T
@end example
  removes and returns the first element of the queue @emph{q}.

@item `$`
  @findex proc `$`*[T](q꞉ Queue[T])꞉ string
@example
proc `$`*[T](q꞉ Queue[T])꞉ string
@end example
  turns a queue into its string representation.
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*[T](q꞉ Queue[T])꞉ T
@example
iterator items*[T](q꞉ Queue[T])꞉ T
@end example
  yields every element of @emph{q}.

@item mitems
  @itindex iterator mitems*[T](q꞉ var Queue[T])꞉ var T
@example
iterator mitems*[T](q꞉ var Queue[T])꞉ var T
@end example
  yields every element of @emph{q}.
@end itemize

@node /pure/collections/LockFreeHash, /pure/collections/sequtils , /pure/collections/queues, Top




@chapter Procedures

@itemize


@item newHeap
  @findex proc newHeap*[T]()꞉ ptr T
@example
proc newHeap*[T]()꞉ ptr T
@end example
  

@item copyNew
  @findex proc copyNew*[T](x꞉ var T)꞉ ptr T
@example
proc copyNew*[T](x꞉ var T)꞉ ptr T
@end example
  

@item copyTo
  @findex proc copyTo*[T](val꞉ var T; dest꞉ int)
@example
proc copyTo*[T](val꞉ var T; dest꞉ int)
@end example
  

@item allocType
  @findex proc allocType*[T]()꞉ pointer
@example
proc allocType*[T]()꞉ pointer
@end example
  

@item newShared
  @findex proc newShared*[T]()꞉ ptr T
@example
proc newShared*[T]()꞉ ptr T
@end example
  

@item copyShared
  @findex proc copyShared*[T](x꞉ var T)꞉ ptr T
@example
proc copyShared*[T](x꞉ var T)꞉ ptr T
@end example
  

@item `+`
  @findex proc `+`*(p꞉ pointer; i꞉ int)꞉ pointer @{.inline.@}
@example
proc `+`*(p꞉ pointer; i꞉ int)꞉ pointer @{.inline.@}
@end example
  

@item newLFTable
  @findex proc newLFTable*[K, V](size꞉ int = minTableSize)꞉ PConcTable[K, V]
@example
proc newLFTable*[K, V](size꞉ int = minTableSize)꞉ PConcTable[K, V]
@end example
  

@item set
  @findex proc set*[K, V](table꞉ var PConcTable[K, V]; key꞉ var K; val꞉ var V)
@example
proc set*[K, V](table꞉ var PConcTable[K, V]; key꞉ var K; val꞉ var V)
@end example
  

@item get
  @findex proc get*[K, V](table꞉ var PConcTable[K, V]; key꞉ var K)꞉ V
@example
proc get*[K, V](table꞉ var PConcTable[K, V]; key꞉ var K)꞉ V
@end example
  
@end itemize






@node /pure/collections/sequtils, /pure/collections/sharedtables , /pure/collections/LockFreeHash, Top




@chapter Procedures

@itemize


@item concat
  @findex proc concat*[T](seqs꞉ varargs[seq[T]])꞉ seq[T]
@example
proc concat*[T](seqs꞉ varargs[seq[T]])꞉ seq[T]
@end example
  Takes several sequences' items and returns them inside a new sequence.

Example:


@example
let
  s1 = @@[1, 2, 3]
  s2 = @@[4, 5]
  s3 = @@[6, 7]
  total = concat(s1, s2, s3)
assert total == @@[1, 2, 3, 4, 5, 6, 7]
@end example

@item cycle
  @findex proc cycle*[T](s꞉ seq[T]; n꞉ Natural)꞉ seq[T]
@example
proc cycle*[T](s꞉ seq[T]; n꞉ Natural)꞉ seq[T]
@end example
  Returns a new sequence with the items of @emph{s} repeated @emph{n} times.

Example:


@quotation 
@itemize 
 @item let: s = @@[1, 2, 3] total = s.cycle(3)
 
@end itemize
assert total == @@[1, 2, 3, 1, 2, 3, 1, 2, 3]

 
@end quotation

@item repeat
  @findex proc repeat*[T](x꞉ T; n꞉ Natural)꞉ seq[T]
@example
proc repeat*[T](x꞉ T; n꞉ Natural)꞉ seq[T]
@end example
  Returns a new sequence with the item @emph{x} repeated @emph{n} times.

Example:


@quotation 
@itemize 
 @item let: total = repeat(5, 3)
 
@end itemize
assert total == @@[5, 5, 5]

 
@end quotation

@item deduplicate
  @findex proc deduplicate*[T](seq1꞉ seq[T])꞉ seq[T]
@example
proc deduplicate*[T](seq1꞉ seq[T])꞉ seq[T]
@end example
  Returns a new sequence without duplicates.
@example
let
  dup1 = @@[1, 1, 3, 4, 2, 2, 8, 1, 4]
  dup2 = @@["a", "a", "c", "d", "d"]
  unique1 = deduplicate(dup1)
  unique2 = deduplicate(dup2)
assert unique1 == @@[1, 3, 4, 2, 8]
assert unique2 == @@["a", "c", "d"]
@end example

@item zip
  @findex proc zip*[S, T](seq1꞉ seq[S]; seq2꞉ seq[T])꞉ seq[tuple[a꞉ S, b꞉ T]]
@example
proc zip*[S, T](seq1꞉ seq[S]; seq2꞉ seq[T])꞉ seq[tuple[a꞉ S, b꞉ T]]
@end example
  Returns a new sequence with a combination of the two input sequences.

For convenience you can access the returned tuples through the named fields @emph{a} and @emph{b}. If one sequence is shorter, the remaining items in the longer sequence are discarded. Example:


@example
let
  short = @@[1, 2, 3]
  long = @@[6, 5, 4, 3, 2, 1]
  words = @@["one", "two", "three"]
  zip1 = zip(short, long)
  zip2 = zip(short, words)
assert zip1 == @@[(1, 6), (2, 5), (3, 4)]
assert zip2 == @@[(1, "one"), (2, "two"), (3, "three")]
assert zip1[2].b == 4
assert zip2[2].b == "three"
@end example

@item distribute
  @findex proc distribute*[T](s꞉ seq[T]; num꞉ Positive; spread = true)꞉ seq[seq[T]]
@example
proc distribute*[T](s꞉ seq[T]; num꞉ Positive; spread = true)꞉ seq[seq[T]]
@end example
  Splits and distributes a sequence @emph{s} into @emph{num} sub sequences.

Returns a sequence of @emph{num} sequences. For some input values this is the inverse of the @uref{#concat, concat} proc.  The proc will assert in debug builds if @emph{s} is nil or @emph{num} is less than one, and will likely crash on release builds.  The input sequence @emph{s} can be empty, which will produce @emph{num} empty sequences.

If @emph{spread} is false and the length of @emph{s} is not a multiple of @emph{num}, the proc will max out the first sub sequences with @code{1 + len(s) div num} entries, leaving the remainder of elements to the last sequence.

On the other hand, if @emph{spread} is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.

Example:


@example
let numbers = @@[1, 2, 3, 4, 5, 6, 7]
assert numbers.distribute(3) == @@[@@[1, 2, 3], @@[4, 5], @@[6, 7]]
assert numbers.distribute(3, false)  == @@[@@[1, 2, 3], @@[4, 5, 6], @@[7]]
assert numbers.distribute(6)[0] == @@[1, 2]
assert numbers.distribute(6)[5] == @@[7]
@end example

@item map
  @findex proc map*[T, S](data꞉ openArray[T]; op꞉ proc (x꞉ T)꞉ S @{.closure.@})꞉ seq[S] @{.inline.@}
@example
proc map*[T, S](data꞉ openArray[T]; op꞉ proc (x꞉ T)꞉ S @{.closure.@})꞉ seq[S] @{.inline.@}
@end example
  Returns a new sequence with the results of @emph{op} applied to every item in @emph{data}.

Since the input is not modified you can use this version of @code{map} to transform the type of the elements in the input sequence. Example:


@example
let
  a = @@[1, 2, 3, 4]
  b = map(a, proc(x: int): string = $x)
assert b == @@["1", "2", "3", "4"]
@end example

@item map
  @findex proc map*[T](data꞉ var openArray[T]; op꞉ proc (x꞉ var T) @{.closure.@}) @{.deprecated.@}
@example
proc map*[T](data꞉ var openArray[T]; op꞉ proc (x꞉ var T) @{.closure.@}) @{.deprecated.@}
@end example
  Applies @emph{op} to every item in @emph{data} modifying it directly.

Note that this version of @code{map} requires your input and output types to be the same, since they are modified in-place. Example:


@example
var a = @@["1", "2", "3", "4"]
echo repr(a)
# --> ["1", "2", "3", "4"]
map(a, proc(x: var string) = x &= "42")
echo repr(a)
# --> ["142", "242", "342", "442"]
@end example
@strong{Deprecated since version 0.12.0:} Use the @code{apply} proc instead.

@item apply
  @findex proc apply*[T](data꞉ var seq[T]; op꞉ proc (x꞉ var T) @{.closure.@}) @{.inline.@}
@example
proc apply*[T](data꞉ var seq[T]; op꞉ proc (x꞉ var T) @{.closure.@}) @{.inline.@}
@end example
  Applies @emph{op} to every item in @emph{data} modifying it directly.

Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a @code{var T} type parameter. Example:


@example
var a = @@["1", "2", "3", "4"]
echo repr(a)
# --> ["1", "2", "3", "4"]
map(a, proc(x: var string) = x &= "42")
echo repr(a)
# --> ["142", "242", "342", "442"]
@end example

@item apply
  @findex proc apply*[T](data꞉ var seq[T]; op꞉ proc (x꞉ T)꞉ T @{.closure.@}) @{.inline.@}
@example
proc apply*[T](data꞉ var seq[T]; op꞉ proc (x꞉ T)꞉ T @{.closure.@}) @{.inline.@}
@end example
  Applies @emph{op} to every item in @emph{data} modifying it directly.

Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a @code{T} type variable. Example:


@example
var a = @@["1", "2", "3", "4"]
echo repr(a)
# --> ["1", "2", "3", "4"]
map(a, proc(x: string): string = x & "42")
echo repr(a)
# --> ["142", "242", "342", "442"]
@end example

@item filter
  @findex proc filter*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ seq[T] @{.inline.@}
@example
proc filter*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ seq[T] @{.inline.@}
@end example
  Returns a new sequence with all the items that fulfilled the predicate.

Example:


@example
let
  colors = @@["red", "yellow", "black"]
  f1 = filter(colors, proc(x: string): bool = x.len < 6)
  f2 = filter(colors) do (x: string) -> bool : x.len > 5
assert f1 == @@["red", "black"]
assert f2 == @@["yellow"]
@end example

@item keepIf
  @findex proc keepIf*[T](seq1꞉ var seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@}) @{.inline.@}
@example
proc keepIf*[T](seq1꞉ var seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@}) @{.inline.@}
@end example
  Keeps the items in the passed sequence if they fulfilled the predicate. Same as the @code{filter} proc, but modifies the sequence directly.

Example:


@example
var floats = @@[13.0, 12.5, 5.8, 2.0, 6.1, 9.9, 10.1]
keepIf(floats, proc(x: float): bool = x > 10)
assert floats == @@[13.0, 12.5, 10.1]
@end example

@item delete
  @findex proc delete*[T](s꞉ var seq[T]; first, last꞉ Natural)
@example
proc delete*[T](s꞉ var seq[T]; first, last꞉ Natural)
@end example
  Deletes in @emph{s} the items at position @emph{first} .. @emph{last}. This modifies @emph{s} itself, it does not return a copy.

Example:


@example
let outcome = @@[1,1,1,1,1,1,1,1]
var dest = @@[1,1,1,2,2,2,2,2,2,1,1,1,1,1]
dest.delete(3, 8)
assert outcome == dest
@end example

@item insert
  @findex proc insert*[T](dest꞉ var seq[T]; src꞉ openArray[T]; pos = 0)
@example
proc insert*[T](dest꞉ var seq[T]; src꞉ openArray[T]; pos = 0)
@end example
  Inserts items from @emph{src} into @emph{dest} at position @emph{pos}. This modifies @emph{dest} itself, it does not return a copy.

Example:


@example
var dest = @@[1,1,1,1,1,1,1,1]
let
  src = @@[2,2,2,2,2,2]
  outcome = @@[1,1,1,2,2,2,2,2,2,1,1,1,1,1]
dest.insert(src, 3)
assert dest == outcome
@end example

@item all
  @findex proc all*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ bool
@example
proc all*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ bool
@end example
  Iterates through a sequence and checks if every item fulfills the predicate.

Example:


@example
let numbers = @@[1, 4, 5, 8, 9, 7, 4]
assert all(numbers, proc (x: int): bool = return x < 10) == true
assert all(numbers, proc (x: int): bool = return x < 9) == false
@end example

@item any
  @findex proc any*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ bool
@example
proc any*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ bool
@end example
  Iterates through a sequence and checks if some item fulfills the predicate.

Example:


@example
let numbers = @@[1, 4, 5, 8, 9, 7, 4]
assert any(numbers, proc (x: int): bool = return x > 8) == true
assert any(numbers, proc (x: int): bool = return x > 9) == false
@end example
@end itemize

@chapter Templates

@itemize


@item filterIt
  @findex template filterIt*(seq1, pred꞉ expr)꞉ expr
@example
template filterIt*(seq1, pred꞉ expr)꞉ expr
@end example
  Returns a new sequence with all the items that fulfilled the predicate.

Unlike the @emph{proc} version, the predicate needs to be an expression using the @code{it} variable for testing, like: @code{filterIt("abcxyz", it == 'x')}. Example:


@example
let
  temperatures = @@[-272.15, -2.0, 24.5, 44.31, 99.9, -113.44]
  acceptable = filterIt(temperatures, it < 50 and it > -10)
  notAcceptable = filterIt(temperatures, it > 50 or it < -10)
assert acceptable == @@[-2.0, 24.5, 44.31]
assert notAcceptable == @@[-272.15, 99.9, -113.44]
@end example

@item keepItIf
  @findex template keepItIf*(varSeq꞉ seq; pred꞉ expr)
@example
template keepItIf*(varSeq꞉ seq; pred꞉ expr)
@end example
  Convenience template around the @code{keepIf} proc to reduce typing.

Unlike the @emph{proc} version, the predicate needs to be an expression using the @code{it} variable for testing, like: @code{keepItIf("abcxyz", it == 'x')}. Example:


@example
var candidates = @@["foo", "bar", "baz", "foobar"]
keepItIf(candidates, it.len == 3 and it[0] == 'b')
assert candidates == @@["bar", "baz"]
@end example

@item allIt
  @findex template allIt*(seq1, pred꞉ expr)꞉ bool @{.immediate.@}
@example
template allIt*(seq1, pred꞉ expr)꞉ bool @{.immediate.@}
@end example
  Checks if every item fulfills the predicate.

Example:


@example
let numbers = @@[1, 4, 5, 8, 9, 7, 4]
assert allIt(numbers, it < 10) == true
assert allIt(numbers, it < 9) == false
@end example

@item anyIt
  @findex template anyIt*(seq1, pred꞉ expr)꞉ bool @{.immediate.@}
@example
template anyIt*(seq1, pred꞉ expr)꞉ bool @{.immediate.@}
@end example
  Checks if some item fulfills the predicate.

Example:


@example
let numbers = @@[1, 4, 5, 8, 9, 7, 4]
assert anyIt(numbers, it > 8) == true
assert anyIt(numbers, it > 9) == false
@end example

@item toSeq
  @findex template toSeq*(iter꞉ expr)꞉ expr @{.immediate.@}
@example
template toSeq*(iter꞉ expr)꞉ expr @{.immediate.@}
@end example
  Transforms any iterator into a sequence.

Example:


@example
let
  numeric = @@[1, 2, 3, 4, 5, 6, 7, 8, 9]
  odd_numbers = toSeq(filter(numeric) do (x: int) -> bool:
    if x mod 2 == 1:
      result = true)
assert odd_numbers == @@[1, 3, 5, 7, 9]
@end example

@item foldl
  @findex template foldl*(sequence, operation꞉ expr)꞉ expr
@example
template foldl*(sequence, operation꞉ expr)꞉ expr
@end example
  Template to fold a sequence from left to right, returning the accumulation.

The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying @code{operation}.

The @code{operation} parameter should be an expression which uses the variables @code{a} and @code{b} for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).  Example:


@example
let
  numbers = @@[5, 9, 11]
  addition = foldl(numbers, a + b)
  subtraction = foldl(numbers, a - b)
  multiplication = foldl(numbers, a * b)
  words = @@["nim", "is", "cool"]
  concatenation = foldl(words, a & b)
assert addition == 25, "Addition is (((5)+9)+11)"
assert subtraction == -15, "Subtraction is (((5)-9)-11)"
assert multiplication == 495, "Multiplication is (((5)*9)*11)"
assert concatenation == "nimiscool"
@end example

@item foldr
  @findex template foldr*(sequence, operation꞉ expr)꞉ expr
@example
template foldr*(sequence, operation꞉ expr)꞉ expr
@end example
  Template to fold a sequence from right to left, returning the accumulation.

The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying @code{operation}.

The @code{operation} parameter should be an expression which uses the variables @code{a} and @code{b} for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))). Example:


@example
let
  numbers = @@[5, 9, 11]
  addition = foldr(numbers, a + b)
  subtraction = foldr(numbers, a - b)
  multiplication = foldr(numbers, a * b)
  words = @@["nim", "is", "cool"]
  concatenation = foldr(words, a & b)
assert addition == 25, "Addition is (5+(9+(11)))"
assert subtraction == 7, "Subtraction is (5-(9-(11)))"
assert multiplication == 495, "Multiplication is (5*(9*(11)))"
assert concatenation == "nimiscool"
@end example

@item mapIt
  @findex template mapIt*(seq1, typ, op꞉ expr)꞉ expr @{.deprecated.@}
@example
template mapIt*(seq1, typ, op꞉ expr)꞉ expr @{.deprecated.@}
@end example
  Convenience template around the @code{map} proc to reduce typing.

The template injects the @code{it} variable which you can use directly in an expression. You also need to pass as @emph{typ} the type of the expression, since the new returned sequence can have a different type than the original.  Example:


@example
let
  nums = @@[1, 2, 3, 4]
  strings = nums.mapIt(string, $(4 * it))
assert strings == @@["4", "8", "12", "16"]
@end example

@itemize 
 @item @strong{Deprecated since version 0.12.0:} Use the @code{mapIt(seq1, op)}: template instead.
 
@end itemize

@item mapIt
  @findex template mapIt*(seq1, op꞉ expr)꞉ expr
@example
template mapIt*(seq1, op꞉ expr)꞉ expr
@end example
  Convenience template around the @code{map} proc to reduce typing.

The template injects the @code{it} variable which you can use directly in an expression. Example:


@example
let
  nums = @@[1, 2, 3, 4]
  strings = nums.mapIt($(4 * it))
assert strings == @@["4", "8", "12", "16"]
@end example

@item applyIt
  @findex template applyIt*(varSeq, op꞉ expr)
@example
template applyIt*(varSeq, op꞉ expr)
@end example
  Convenience template around the mutable @code{apply} proc to reduce typing.

The template injects the @code{it} variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating. Example:


@example
var nums = @@[1, 2, 3, 4]
nums.applyIt(it * 3)
assert nums[0] + nums[3] == 15
@end example

@item newSeqWith
  @findex template newSeqWith*(len꞉ int; init꞉ expr)꞉ expr
@example
template newSeqWith*(len꞉ int; init꞉ expr)꞉ expr
@end example
  creates a new sequence, calling @emph{init} to initialize each value. Example:
@example
var seq2D = newSeqWith(20, newSeq[bool](10))
seq2D[0][0] = true
seq2D[1][0] = true
seq2D[0][1] = true

import math
var seqRand = newSeqWith(20, random(10))
echo seqRand
@end example
@end itemize




@chapter Iterators

@itemize


@item filter
  @itindex iterator filter*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ T
@example
iterator filter*[T](seq1꞉ seq[T]; pred꞉ proc (item꞉ T)꞉ bool @{.closure.@})꞉ T
@end example
  Iterates through a sequence and yields every item that fulfills the predicate.

Example:


@example
let numbers = @@[1, 4, 5, 8, 9, 7, 4]
for n in filter(numbers, proc (x: int): bool = x mod 2 == 0):
  echo($n)
# echoes 4, 8, 4 in separate lines
@end example
@end itemize

@node /pure/collections/sharedtables, /pure/collections/lists , /pure/collections/sequtils, Top



@chapter Types

@itemize


@item SharedTable
  @tindex SharedTable*[A, B] = object
  data: KeyValuePairSeq[A, B]
  counter, dataLen: int
  lock: Lock

@example
SharedTable*[A, B] = object
  data: KeyValuePairSeq[A, B]
  counter, dataLen: int
  lock: Lock

@end example
  generic hash SharedTable
@end itemize

@chapter Procedures

@itemize


@item mget
  @findex proc mget*[A, B](t꞉ var SharedTable[A, B]; key꞉ A)꞉ var B
@example
proc mget*[A, B](t꞉ var SharedTable[A, B]; key꞉ A)꞉ var B
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised.

@item mgetOrPut
  @findex proc mgetOrPut*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)꞉ var B
@example
proc mgetOrPut*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)꞉ var B
@end example
  retrieves value at @code{t[key]} or puts @code{val} if not present, either way returning a value which can be modified. @strong{Note}: This is inherently unsafe in the context of multi-threading since it returns a pointer to @code{B}.

@item hasKeyOrPut
  @findex proc hasKeyOrPut*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)꞉ bool
@example
proc hasKeyOrPut*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)꞉ bool
@end example
  returns true iff @emph{key} is in the table, otherwise inserts @emph{value}.

@item `[]=`
  @findex proc `[]=`*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)
@example
proc `[]=`*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)
@end example
  puts a (key, value)-pair into @emph{t}.

@item add
  @findex proc add*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)
@example
proc add*[A, B](t꞉ var SharedTable[A, B]; key꞉ A; val꞉ B)
@end example
  puts a new (key, value)-pair into @emph{t} even if @code{t[key]} already exists.

@item del
  @findex proc del*[A, B](t꞉ var SharedTable[A, B]; key꞉ A)
@example
proc del*[A, B](t꞉ var SharedTable[A, B]; key꞉ A)
@end example
  deletes @emph{key} from hash table @emph{t}.

@item initSharedTable
  @findex proc initSharedTable*[A, B](initialSize = 64)꞉ SharedTable[A, B]
@example
proc initSharedTable*[A, B](initialSize = 64)꞉ SharedTable[A, B]
@end example
  creates a new hash table that is empty.

@emph{initialSize} needs to be a power of two. If you need to accept runtime values for this you could use the @code{nextPowerOfTwo} proc from the @uref{math.html, math} module or the @code{rightSize} proc from this module.

@item deinitSharedTable
  @findex proc deinitSharedTable*[A, B](t꞉ var SharedTable[A, B])
@example
proc deinitSharedTable*[A, B](t꞉ var SharedTable[A, B])
@end example
  
@end itemize






@node /pure/collections/lists, /pure/collections/sharedstrings , /pure/collections/sharedtables, Top



@chapter Types

@itemize


@item DoublyLinkedRing
  @tindex DoublyLinkedRing*[T] = objecthead*꞉ DoublyLinkedNode[T]
@example
DoublyLinkedRing*[T] = objecthead*꞉ DoublyLinkedNode[T]
@end example
  a doubly linked ring
@end itemize

@chapter Procedures

@itemize


@item initSinglyLinkedList
  @findex proc initSinglyLinkedList*[T]()꞉ SinglyLinkedList[T]
@example
proc initSinglyLinkedList*[T]()꞉ SinglyLinkedList[T]
@end example
  creates a new singly linked list that is empty.

@item initDoublyLinkedList
  @findex proc initDoublyLinkedList*[T]()꞉ DoublyLinkedList[T]
@example
proc initDoublyLinkedList*[T]()꞉ DoublyLinkedList[T]
@end example
  creates a new doubly linked list that is empty.

@item initSinglyLinkedRing
  @findex proc initSinglyLinkedRing*[T]()꞉ SinglyLinkedRing[T]
@example
proc initSinglyLinkedRing*[T]()꞉ SinglyLinkedRing[T]
@end example
  creates a new singly linked ring that is empty.

@item initDoublyLinkedRing
  @findex proc initDoublyLinkedRing*[T]()꞉ DoublyLinkedRing[T]
@example
proc initDoublyLinkedRing*[T]()꞉ DoublyLinkedRing[T]
@end example
  creates a new doubly linked ring that is empty.

@item newDoublyLinkedNode
  @findex proc newDoublyLinkedNode*[T](value꞉ T)꞉ DoublyLinkedNode[T]
@example
proc newDoublyLinkedNode*[T](value꞉ T)꞉ DoublyLinkedNode[T]
@end example
  creates a new doubly linked node with the given @emph{value}.

@item newSinglyLinkedNode
  @findex proc newSinglyLinkedNode*[T](value꞉ T)꞉ SinglyLinkedNode[T]
@example
proc newSinglyLinkedNode*[T](value꞉ T)꞉ SinglyLinkedNode[T]
@end example
  creates a new singly linked node with the given @emph{value}.

@item `$`
  @findex proc `$`*[T](L꞉ SinglyLinkedList[T])꞉ string
@example
proc `$`*[T](L꞉ SinglyLinkedList[T])꞉ string
@end example
  turns a list into its string representation.

@item `$`
  @findex proc `$`*[T](L꞉ DoublyLinkedList[T])꞉ string
@example
proc `$`*[T](L꞉ DoublyLinkedList[T])꞉ string
@end example
  turns a list into its string representation.

@item `$`
  @findex proc `$`*[T](L꞉ SinglyLinkedRing[T])꞉ string
@example
proc `$`*[T](L꞉ SinglyLinkedRing[T])꞉ string
@end example
  turns a list into its string representation.

@item `$`
  @findex proc `$`*[T](L꞉ DoublyLinkedRing[T])꞉ string
@example
proc `$`*[T](L꞉ DoublyLinkedRing[T])꞉ string
@end example
  turns a list into its string representation.

@item find
  @findex proc find*[T](L꞉ SinglyLinkedList[T]; value꞉ T)꞉ SinglyLinkedNode[T]
@example
proc find*[T](L꞉ SinglyLinkedList[T]; value꞉ T)꞉ SinglyLinkedNode[T]
@end example
  searches in the list for a value. Returns nil if the value does not exist.

@item find
  @findex proc find*[T](L꞉ DoublyLinkedList[T]; value꞉ T)꞉ DoublyLinkedNode[T]
@example
proc find*[T](L꞉ DoublyLinkedList[T]; value꞉ T)꞉ DoublyLinkedNode[T]
@end example
  searches in the list for a value. Returns nil if the value does not exist.

@item find
  @findex proc find*[T](L꞉ SinglyLinkedRing[T]; value꞉ T)꞉ SinglyLinkedNode[T]
@example
proc find*[T](L꞉ SinglyLinkedRing[T]; value꞉ T)꞉ SinglyLinkedNode[T]
@end example
  searches in the list for a value. Returns nil if the value does not exist.

@item find
  @findex proc find*[T](L꞉ DoublyLinkedRing[T]; value꞉ T)꞉ DoublyLinkedNode[T]
@example
proc find*[T](L꞉ DoublyLinkedRing[T]; value꞉ T)꞉ DoublyLinkedNode[T]
@end example
  searches in the list for a value. Returns nil if the value does not exist.

@item contains
  @findex proc contains*[T](L꞉ SinglyLinkedList[T]; value꞉ T)꞉ bool @{.inline.@}
@example
proc contains*[T](L꞉ SinglyLinkedList[T]; value꞉ T)꞉ bool @{.inline.@}
@end example
  searches in the list for a value. Returns false if the value does not exist, true otherwise.

@item contains
  @findex proc contains*[T](L꞉ DoublyLinkedList[T]; value꞉ T)꞉ bool @{.inline.@}
@example
proc contains*[T](L꞉ DoublyLinkedList[T]; value꞉ T)꞉ bool @{.inline.@}
@end example
  searches in the list for a value. Returns false if the value does not exist, true otherwise.

@item contains
  @findex proc contains*[T](L꞉ SinglyLinkedRing[T]; value꞉ T)꞉ bool @{.inline.@}
@example
proc contains*[T](L꞉ SinglyLinkedRing[T]; value꞉ T)꞉ bool @{.inline.@}
@end example
  searches in the list for a value. Returns false if the value does not exist, true otherwise.

@item contains
  @findex proc contains*[T](L꞉ DoublyLinkedRing[T]; value꞉ T)꞉ bool @{.inline.@}
@example
proc contains*[T](L꞉ DoublyLinkedRing[T]; value꞉ T)꞉ bool @{.inline.@}
@end example
  searches in the list for a value. Returns false if the value does not exist, true otherwise.

@item prepend
  @findex proc prepend*[T](L꞉ var SinglyLinkedList[T]; n꞉ SinglyLinkedNode[T]) @{.inline.@}
@example
proc prepend*[T](L꞉ var SinglyLinkedList[T]; n꞉ SinglyLinkedNode[T]) @{.inline.@}
@end example
  prepends a node to @emph{L}. Efficiency: O(1).

@item prepend
  @findex proc prepend*[T](L꞉ var SinglyLinkedList[T]; value꞉ T) @{.inline.@}
@example
proc prepend*[T](L꞉ var SinglyLinkedList[T]; value꞉ T) @{.inline.@}
@end example
  prepends a node to @emph{L}. Efficiency: O(1).

@item append
  @findex proc append*[T](L꞉ var DoublyLinkedList[T]; n꞉ DoublyLinkedNode[T])
@example
proc append*[T](L꞉ var DoublyLinkedList[T]; n꞉ DoublyLinkedNode[T])
@end example
  appends a node @emph{n} to @emph{L}. Efficiency: O(1).

@item append
  @findex proc append*[T](L꞉ var DoublyLinkedList[T]; value꞉ T)
@example
proc append*[T](L꞉ var DoublyLinkedList[T]; value꞉ T)
@end example
  appends a value to @emph{L}. Efficiency: O(1).

@item prepend
  @findex proc prepend*[T](L꞉ var DoublyLinkedList[T]; n꞉ DoublyLinkedNode[T])
@example
proc prepend*[T](L꞉ var DoublyLinkedList[T]; n꞉ DoublyLinkedNode[T])
@end example
  prepends a node @emph{n} to @emph{L}. Efficiency: O(1).

@item prepend
  @findex proc prepend*[T](L꞉ var DoublyLinkedList[T]; value꞉ T)
@example
proc prepend*[T](L꞉ var DoublyLinkedList[T]; value꞉ T)
@end example
  prepends a value to @emph{L}. Efficiency: O(1).

@item remove
  @findex proc remove*[T](L꞉ var DoublyLinkedList[T]; n꞉ DoublyLinkedNode[T])
@example
proc remove*[T](L꞉ var DoublyLinkedList[T]; n꞉ DoublyLinkedNode[T])
@end example
  removes @emph{n} from @emph{L}. Efficiency: O(1).

@item append
  @findex proc append*[T](L꞉ var SinglyLinkedRing[T]; n꞉ SinglyLinkedNode[T])
@example
proc append*[T](L꞉ var SinglyLinkedRing[T]; n꞉ SinglyLinkedNode[T])
@end example
  appends a node @emph{n} to @emph{L}. Efficiency: O(1).

@item append
  @findex proc append*[T](L꞉ var SinglyLinkedRing[T]; value꞉ T)
@example
proc append*[T](L꞉ var SinglyLinkedRing[T]; value꞉ T)
@end example
  appends a value to @emph{L}. Efficiency: O(1).

@item prepend
  @findex proc prepend*[T](L꞉ var SinglyLinkedRing[T]; n꞉ SinglyLinkedNode[T])
@example
proc prepend*[T](L꞉ var SinglyLinkedRing[T]; n꞉ SinglyLinkedNode[T])
@end example
  prepends a node @emph{n} to @emph{L}. Efficiency: O(1).

@item prepend
  @findex proc prepend*[T](L꞉ var SinglyLinkedRing[T]; value꞉ T)
@example
proc prepend*[T](L꞉ var SinglyLinkedRing[T]; value꞉ T)
@end example
  prepends a value to @emph{L}. Efficiency: O(1).

@item append
  @findex proc append*[T](L꞉ var DoublyLinkedRing[T]; n꞉ DoublyLinkedNode[T])
@example
proc append*[T](L꞉ var DoublyLinkedRing[T]; n꞉ DoublyLinkedNode[T])
@end example
  appends a node @emph{n} to @emph{L}. Efficiency: O(1).

@item append
  @findex proc append*[T](L꞉ var DoublyLinkedRing[T]; value꞉ T)
@example
proc append*[T](L꞉ var DoublyLinkedRing[T]; value꞉ T)
@end example
  appends a value to @emph{L}. Efficiency: O(1).

@item prepend
  @findex proc prepend*[T](L꞉ var DoublyLinkedRing[T]; n꞉ DoublyLinkedNode[T])
@example
proc prepend*[T](L꞉ var DoublyLinkedRing[T]; n꞉ DoublyLinkedNode[T])
@end example
  prepends a node @emph{n} to @emph{L}. Efficiency: O(1).

@item prepend
  @findex proc prepend*[T](L꞉ var DoublyLinkedRing[T]; value꞉ T)
@example
proc prepend*[T](L꞉ var DoublyLinkedRing[T]; value꞉ T)
@end example
  prepends a value to @emph{L}. Efficiency: O(1).

@item remove
  @findex proc remove*[T](L꞉ var DoublyLinkedRing[T]; n꞉ DoublyLinkedNode[T])
@example
proc remove*[T](L꞉ var DoublyLinkedRing[T]; n꞉ DoublyLinkedNode[T])
@end example
  removes @emph{n} from @emph{L}. Efficiency: O(1).
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*[T](L꞉ DoublyLinkedList[T])꞉ T
@example
iterator items*[T](L꞉ DoublyLinkedList[T])꞉ T
@end example
  yields every value of @emph{L}.

@item items
  @itindex iterator items*[T](L꞉ SinglyLinkedList[T])꞉ T
@example
iterator items*[T](L꞉ SinglyLinkedList[T])꞉ T
@end example
  yields every value of @emph{L}.

@item items
  @itindex iterator items*[T](L꞉ SinglyLinkedRing[T])꞉ T
@example
iterator items*[T](L꞉ SinglyLinkedRing[T])꞉ T
@end example
  yields every value of @emph{L}.

@item items
  @itindex iterator items*[T](L꞉ DoublyLinkedRing[T])꞉ T
@example
iterator items*[T](L꞉ DoublyLinkedRing[T])꞉ T
@end example
  yields every value of @emph{L}.

@item mitems
  @itindex iterator mitems*[T](L꞉ var DoublyLinkedList[T])꞉ var T
@example
iterator mitems*[T](L꞉ var DoublyLinkedList[T])꞉ var T
@end example
  yields every value of @emph{L} so that you can modify it.

@item mitems
  @itindex iterator mitems*[T](L꞉ var SinglyLinkedList[T])꞉ var T
@example
iterator mitems*[T](L꞉ var SinglyLinkedList[T])꞉ var T
@end example
  yields every value of @emph{L} so that you can modify it.

@item mitems
  @itindex iterator mitems*[T](L꞉ var SinglyLinkedRing[T])꞉ var T
@example
iterator mitems*[T](L꞉ var SinglyLinkedRing[T])꞉ var T
@end example
  yields every value of @emph{L} so that you can modify it.

@item mitems
  @itindex iterator mitems*[T](L꞉ var DoublyLinkedRing[T])꞉ var T
@example
iterator mitems*[T](L꞉ var DoublyLinkedRing[T])꞉ var T
@end example
  yields every value of @emph{L} so that you can modify it.

@item nodes
  @itindex iterator nodes*[T](L꞉ SinglyLinkedList[T])꞉ SinglyLinkedNode[T]
@example
iterator nodes*[T](L꞉ SinglyLinkedList[T])꞉ SinglyLinkedNode[T]
@end example
  iterates over every node of @emph{x}. Removing the current node from the list during traversal is supported.

@item nodes
  @itindex iterator nodes*[T](L꞉ DoublyLinkedList[T])꞉ DoublyLinkedNode[T]
@example
iterator nodes*[T](L꞉ DoublyLinkedList[T])꞉ DoublyLinkedNode[T]
@end example
  iterates over every node of @emph{x}. Removing the current node from the list during traversal is supported.

@item nodes
  @itindex iterator nodes*[T](L꞉ SinglyLinkedRing[T])꞉ SinglyLinkedNode[T]
@example
iterator nodes*[T](L꞉ SinglyLinkedRing[T])꞉ SinglyLinkedNode[T]
@end example
  iterates over every node of @emph{x}. Removing the current node from the list during traversal is supported.

@item nodes
  @itindex iterator nodes*[T](L꞉ DoublyLinkedRing[T])꞉ DoublyLinkedNode[T]
@example
iterator nodes*[T](L꞉ DoublyLinkedRing[T])꞉ DoublyLinkedNode[T]
@end example
  iterates over every node of @emph{x}. Removing the current node from the list during traversal is supported.
@end itemize

@node /pure/collections/sharedstrings, /pure/collections/critbits , /pure/collections/lists, Top



@chapter Types

@itemize


@item SharedString
  @tindex SharedString* = object
  buffer: Buffer
  first, len: int

@example
SharedString* = object
  buffer: Buffer
  first, len: int

@end example
  A string that can be shared. Slicing is O(1).
@end itemize

@chapter Procedures

@itemize


@item `=destroy`
  @findex proc `= destroy`*(s꞉ SharedString)
@example
proc `= destroy`*(s꞉ SharedString)
@end example
  

@item len
  @findex proc len*(s꞉ SharedString)꞉ int
@example
proc len*(s꞉ SharedString)꞉ int
@end example
  

@item `[]`
  @findex proc `[]`*(s꞉ SharedString; i꞉ Natural)꞉ char
@example
proc `[]`*(s꞉ SharedString; i꞉ Natural)꞉ char
@end example
  

@item `[]=`
  @findex proc `[]=`*(s꞉ var SharedString; i꞉ Natural; value꞉ char)
@example
proc `[]=`*(s꞉ var SharedString; i꞉ Natural; value꞉ char)
@end example
  

@item `[]`
  @findex proc `[]`*(s꞉ SharedString; ab꞉ Slice[int])꞉ SharedString
@example
proc `[]`*(s꞉ SharedString; ab꞉ Slice[int])꞉ SharedString
@end example
  

@item newSharedString
  @findex proc newSharedString*(len꞉ Natural)꞉ SharedString
@example
proc newSharedString*(len꞉ Natural)꞉ SharedString
@end example
  

@item newSharedString
  @findex proc newSharedString*(s꞉ string)꞉ SharedString
@example
proc newSharedString*(s꞉ string)꞉ SharedString
@end example
  

@item add
  @findex proc add*(s꞉ var SharedString; t꞉ cstring; len꞉ Natural)
@example
proc add*(s꞉ var SharedString; t꞉ cstring; len꞉ Natural)
@end example
  

@item add
  @findex proc add*(s꞉ var SharedString; t꞉ string)
@example
proc add*(s꞉ var SharedString; t꞉ string)
@end example
  

@item rawData
  @findex proc rawData*(s꞉ var SharedString)꞉ pointer
@example
proc rawData*(s꞉ var SharedString)꞉ pointer
@end example
  

@item add
  @findex proc add*(s꞉ var SharedString; t꞉ SharedString)
@example
proc add*(s꞉ var SharedString; t꞉ SharedString)
@end example
  

@item `$`
  @findex proc `$`*(s꞉ SharedString)꞉ string
@example
proc `$`*(s꞉ SharedString)꞉ string
@end example
  

@item `==`
  @findex proc `==`*(s꞉ SharedString; t꞉ string)꞉ bool
@example
proc `==`*(s꞉ SharedString; t꞉ string)꞉ bool
@end example
  

@item `==`
  @findex proc `==`*(s, t꞉ SharedString)꞉ bool
@example
proc `==`*(s, t꞉ SharedString)꞉ bool
@end example
  

@item hash
  @findex proc hash*(s꞉ SharedString)꞉ THash
@example
proc hash*(s꞉ SharedString)꞉ THash
@end example
  
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*(s꞉ SharedString)꞉ char
@example
iterator items*(s꞉ SharedString)꞉ char
@end example
  
@end itemize

@node /pure/collections/critbits, /pure/collections/intsets , /pure/collections/sharedstrings, Top



@chapter Types

@itemize


@item CritBitTree
  @tindex CritBitTree*[T] = object
  root: Node[T]
  count: int

@example
CritBitTree*[T] = object
  root: Node[T]
  count: int

@end example
  The crit bit tree can either be used as a mapping from strings to some type @code{T} or as a set of strings if @code{T} is void.
@end itemize

@chapter Procedures

@itemize


@item len
  @findex proc len*[T](c꞉ CritBitTree[T])꞉ int
@example
proc len*[T](c꞉ CritBitTree[T])꞉ int
@end example
  returns the number of elements in @emph{c} in O(1).

@item contains
  @findex proc contains*[T](c꞉ CritBitTree[T]; key꞉ string)꞉ bool @{.inline.@}
@example
proc contains*[T](c꞉ CritBitTree[T]; key꞉ string)꞉ bool @{.inline.@}
@end example
  returns true iff @emph{c} contains the given @emph{key}.

@item hasKey
  @findex proc hasKey*[T](c꞉ CritBitTree[T]; key꞉ string)꞉ bool @{.inline.@}
@example
proc hasKey*[T](c꞉ CritBitTree[T]; key꞉ string)꞉ bool @{.inline.@}
@end example
  alias for @emph{contains}.

@item containsOrIncl
  @findex proc containsOrIncl*[T](c꞉ var CritBitTree[T]; key꞉ string; val꞉ T)꞉ bool
@example
proc containsOrIncl*[T](c꞉ var CritBitTree[T]; key꞉ string; val꞉ T)꞉ bool
@end example
  returns true iff @emph{c} contains the given @emph{key}. If the key does not exist @code{c[key] = val} is performed.

@item containsOrIncl
  @findex proc containsOrIncl*(c꞉ var CritBitTree[void]; key꞉ string)꞉ bool
@example
proc containsOrIncl*(c꞉ var CritBitTree[void]; key꞉ string)꞉ bool
@end example
  returns true iff @emph{c} contains the given @emph{key}. If the key does not exist it is inserted into @emph{c}.

@item inc
  @findex proc inc*(c꞉ var CritBitTree[int]; key꞉ string)
@example
proc inc*(c꞉ var CritBitTree[int]; key꞉ string)
@end example
  counts the 'key'.

@item incl
  @findex proc incl*(c꞉ var CritBitTree[void]; key꞉ string)
@example
proc incl*(c꞉ var CritBitTree[void]; key꞉ string)
@end example
  includes @emph{key} in @emph{c}.

@item `[]=`
  @findex proc `[]=`*[T](c꞉ var CritBitTree[T]; key꞉ string; val꞉ T)
@example
proc `[]=`*[T](c꞉ var CritBitTree[T]; key꞉ string; val꞉ T)
@end example
  puts a (key, value)-pair into @emph{t}.

@item `[]`
  @findex proc `[]`*[T](c꞉ CritBitTree[T]; key꞉ string)꞉ T @{.inline, deprecatedGet.@}
@example
proc `[]`*[T](c꞉ CritBitTree[T]; key꞉ string)꞉ T @{.inline, deprecatedGet.@}
@end example
  retrieves the value at @code{c[key]}. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. One can check with @code{hasKey} whether the key exists.

@item `[]`
  @findex proc `[]`*[T](c꞉ var CritBitTree[T]; key꞉ string)꞉ var T @{.inline, deprecatedGet.@}
@example
proc `[]`*[T](c꞉ var CritBitTree[T]; key꞉ string)꞉ var T @{.inline, deprecatedGet.@}
@end example
  retrieves the value at @code{c[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised.

@item mget
  @findex proc mget*[T](c꞉ var CritBitTree[T]; key꞉ string)꞉ var T @{.inline, deprecated.@}
@example
proc mget*[T](c꞉ var CritBitTree[T]; key꞉ string)꞉ var T @{.inline, deprecated.@}
@end example
  retrieves the value at @code{c[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item excl
  @findex proc excl*[T](c꞉ var CritBitTree[T]; key꞉ string)
@example
proc excl*[T](c꞉ var CritBitTree[T]; key꞉ string)
@end example
  removes @emph{key} (and its associated value) from the set @emph{c}. If the @emph{key} does not exist, nothing happens.

@item `$`
  @findex proc `$`*[T](c꞉ CritBitTree[T])꞉ string
@example
proc `$`*[T](c꞉ CritBitTree[T])꞉ string
@end example
  turns @emph{c} into a string representation. Example outputs: @code{@{keyA: value, keyB: value@}}, @code{@{:@}} If @emph{T} is void the outputs look like: @code{@{keyA, keyB@}}, @code{@{@}}.
@end itemize





@chapter Iterators

@itemize


@item keys
  @itindex iterator keys*[T](c꞉ CritBitTree[T])꞉ string
@example
iterator keys*[T](c꞉ CritBitTree[T])꞉ string
@end example
  yields all keys in lexicographical order.

@item values
  @itindex iterator values*[T](c꞉ CritBitTree[T])꞉ T
@example
iterator values*[T](c꞉ CritBitTree[T])꞉ T
@end example
  yields all values of @emph{c} in the lexicographical order of the corresponding keys.

@item mvalues
  @itindex iterator mvalues*[T](c꞉ var CritBitTree[T])꞉ var T
@example
iterator mvalues*[T](c꞉ var CritBitTree[T])꞉ var T
@end example
  yields all values of @emph{c} in the lexicographical order of the corresponding keys. The values can be modified.

@item items
  @itindex iterator items*[T](c꞉ CritBitTree[T])꞉ string
@example
iterator items*[T](c꞉ CritBitTree[T])꞉ string
@end example
  yields all keys in lexicographical order.

@item pairs
  @itindex iterator pairs*[T](c꞉ CritBitTree[T])꞉ tuple[key꞉ string, val꞉ T]
@example
iterator pairs*[T](c꞉ CritBitTree[T])꞉ tuple[key꞉ string, val꞉ T]
@end example
  yields all (key, value)-pairs of @emph{c}.

@item mpairs
  @itindex iterator mpairs*[T](c꞉ var CritBitTree[T])꞉ tuple[key꞉ string, val꞉ var T]
@example
iterator mpairs*[T](c꞉ var CritBitTree[T])꞉ tuple[key꞉ string, val꞉ var T]
@end example
  yields all (key, value)-pairs of @emph{c}. The yielded values can be modified.

@item itemsWithPrefix
  @itindex iterator itemsWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ string
@example
iterator itemsWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ string
@end example
  yields all keys starting with @emph{prefix}. If @emph{longestMatch} is true, the longest match is returned, it doesn't have to be a complete match then.

@item keysWithPrefix
  @itindex iterator keysWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ string
@example
iterator keysWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ string
@end example
  yields all keys starting with @emph{prefix}.

@item valuesWithPrefix
  @itindex iterator valuesWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ T
@example
iterator valuesWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ T
@end example
  yields all values of @emph{c} starting with @emph{prefix} of the corresponding keys.

@item mvaluesWithPrefix
  @itindex iterator mvaluesWithPrefix*[T](c꞉ var CritBitTree[T]; prefix꞉ string;longestMatch = false)꞉ var T
@example
iterator mvaluesWithPrefix*[T](c꞉ var CritBitTree[T]; prefix꞉ string;longestMatch = false)꞉ var T
@end example
  yields all values of @emph{c} starting with @emph{prefix} of the corresponding keys. The values can be modified.

@item pairsWithPrefix
  @itindex iterator pairsWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ tuple[key꞉ string, val꞉ T]
@example
iterator pairsWithPrefix*[T](c꞉ CritBitTree[T]; prefix꞉ string; longestMatch = false)꞉ tuple[key꞉ string, val꞉ T]
@end example
  yields all (key, value)-pairs of @emph{c} starting with @emph{prefix}.

@item mpairsWithPrefix
  @itindex iterator mpairsWithPrefix*[T](c꞉ var CritBitTree[T]; prefix꞉ string;longestMatch = false)꞉ tuple[key꞉ string, val꞉ var T]
@example
iterator mpairsWithPrefix*[T](c꞉ var CritBitTree[T]; prefix꞉ string;longestMatch = false)꞉ tuple[key꞉ string, val꞉ var T]
@end example
  yields all (key, value)-pairs of @emph{c} starting with @emph{prefix}. The yielded values can be modified.
@end itemize

@node /pure/collections/intsets, /pure/collections/sets , /pure/collections/critbits, Top



@chapter Types

@itemize


@item IntSet
  @tindex IntSet* = object
  counter, max: int
  head: PTrunk
  data: TrunkSeq

@example
IntSet* = object
  counter, max: int
  head: PTrunk
  data: TrunkSeq

@end example
  an efficient set of 'int' implemented as a sparse bit set
@end itemize

@chapter Procedures

@itemize


@item contains
  @findex proc contains*(s꞉ IntSet; key꞉ int)꞉ bool
@example
proc contains*(s꞉ IntSet; key꞉ int)꞉ bool
@end example
  returns true iff @emph{key} is in @emph{s}.

@item incl
  @findex proc incl*(s꞉ var IntSet; key꞉ int)
@example
proc incl*(s꞉ var IntSet; key꞉ int)
@end example
  includes an element @emph{key} in @emph{s}.

@item excl
  @findex proc excl*(s꞉ var IntSet; key꞉ int)
@example
proc excl*(s꞉ var IntSet; key꞉ int)
@end example
  excludes @emph{key} from the set @emph{s}.

@item containsOrIncl
  @findex proc containsOrIncl*(s꞉ var IntSet; key꞉ int)꞉ bool
@example
proc containsOrIncl*(s꞉ var IntSet; key꞉ int)꞉ bool
@end example
  returns true if @emph{s} contains @emph{key}, otherwise @emph{key} is included in @emph{s} and false is returned.

@item initIntSet
  @findex proc initIntSet*()꞉ IntSet
@example
proc initIntSet*()꞉ IntSet
@end example
  creates a new int set that is empty.

@item isNil
  @findex proc isNil*(x꞉ IntSet)꞉ bool @{.inline.@}
@example
proc isNil*(x꞉ IntSet)꞉ bool @{.inline.@}
@end example
  

@item assign
  @findex proc assign*(dest꞉ var IntSet; src꞉ IntSet)
@example
proc assign*(dest꞉ var IntSet; src꞉ IntSet)
@end example
  copies @emph{src} to @emph{dest}. @emph{dest} does not need to be initialized by @emph{initIntSet}.

@item `$`
  @findex proc `$`*(s꞉ IntSet)꞉ string
@example
proc `$`*(s꞉ IntSet)꞉ string
@end example
  The @emph{$} operator for int sets.

@item empty
  @findex proc empty*(s꞉ IntSet)꞉ bool @{.inline, deprecated.@}
@example
proc empty*(s꞉ IntSet)꞉ bool @{.inline, deprecated.@}
@end example
  returns true if @emph{s} is empty. This is safe to call even before the set has been initialized with @emph{initIntSet}. Note this never worked reliably and so is deprecated.
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*(s꞉ IntSet)꞉ int @{.inline.@}
@example
iterator items*(s꞉ IntSet)꞉ int @{.inline.@}
@end example
  iterates over any included element of @emph{s}.
@end itemize

@node /pure/collections/sets, /pure/collections/rtarrays , /pure/collections/intsets, Top



@chapter Types

@itemize


@item HashSet
  @tindex HashSet* @{.myShallow.@}[A] = object
  data: KeyValuePairSeq[A]
  counter: int

@example
HashSet* @{.myShallow.@}[A] = object
  data: KeyValuePairSeq[A]
  counter: int

@end example
  A generic hash set.

Use @uref{#init,HashSet[A],int, init()} or @uref{#initSet, initSet[type]()} before calling other procs on it.

@item OrderedSet
  @tindex OrderedSet* @{.myShallow.@}[A] = object
  data: OrderedKeyValuePairSeq[A]
  counter, first, last: int

@example
OrderedSet* @{.myShallow.@}[A] = object
  data: OrderedKeyValuePairSeq[A]
  counter, first, last: int

@end example
  A generic hash set that remembers insertion order.

Use @uref{#init,OrderedSet[A],int, init()} or @uref{#initOrderedSet, initOrderedSet[type]()} before calling other procs on it.
@end itemize

@chapter Procedures

@itemize


@item isValid
  @findex proc isValid*[A](s꞉ HashSet[A])꞉ bool
@example
proc isValid*[A](s꞉ HashSet[A])꞉ bool
@end example
  Returns @emph{true} if the set has been initialized with @uref{#initSet, initSet}.

Most operations over an uninitialized set will crash at runtime and @uref{system.html#assert, assert} in debug builds. You can use this proc in your own procs to verify that sets passed to your procs are correctly initialized. Example:


@example
proc savePreferences(options: Set[string]) =
  assert options.isValid, "Pass an initialized set!"
  # Do stuff here, may crash in release builds!
@end example

@item len
  @findex proc len*[A](s꞉ HashSet[A])꞉ int
@example
proc len*[A](s꞉ HashSet[A])꞉ int
@end example
  Returns the number of keys in @emph{s}.

Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then. Example:


@example

var values: Set[int]
assert(not values.isValid)
assert values.len == 0
@end example

@item card
  @findex proc card*[A](s꞉ HashSet[A])꞉ int
@example
proc card*[A](s꞉ HashSet[A])꞉ int
@end example
  Alias for @uref{#len,TSet[A], len()}.

Card stands for the @uref{http://en.wikipedia.org/wiki/Cardinality, cardinality} of a set.

@item rightSize
  @findex proc rightSize*(count꞉ Natural)꞉ int @{.inline.@}
@example
proc rightSize*(count꞉ Natural)꞉ int @{.inline.@}
@end example
  Return the value of @emph{initialSize} to support @emph{count} items.

If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.

Internally, we want mustRehash(rightSize(x), x) == false.

@item `[]`
  @findex proc `[]`*[A](s꞉ var HashSet[A]; key꞉ A)꞉ var A
@example
proc `[]`*[A](s꞉ var HashSet[A]; key꞉ A)꞉ var A
@end example
  returns the element that is actually stored in 's' which has the same value as 'key' or raises the @code{KeyError} exception. This is useful when one overloaded 'hash' and '==' but still needs reference semantics for sharing.

@item mget
  @findex proc mget*[A](s꞉ var HashSet[A]; key꞉ A)꞉ var A @{.deprecated.@}
@example
proc mget*[A](s꞉ var HashSet[A]; key꞉ A)꞉ var A @{.deprecated.@}
@end example
  returns the element that is actually stored in 's' which has the same value as 'key' or raises the @code{KeyError} exception. This is useful when one overloaded 'hash' and '==' but still needs reference semantics for sharing. Use ```[]``` instead.

@item contains
  @findex proc contains*[A](s꞉ HashSet[A]; key꞉ A)꞉ bool
@example
proc contains*[A](s꞉ HashSet[A]; key꞉ A)꞉ bool
@end example
  Returns true iff @emph{key} is in @emph{s}.

Example:


@example
var values = initSet[int]()
assert(not values.contains(2))
values.incl(2)
assert values.contains(2)
values.excl(2)
assert(not values.contains(2))
@end example

@item incl
  @findex proc incl*[A](s꞉ var HashSet[A]; key꞉ A)
@example
proc incl*[A](s꞉ var HashSet[A]; key꞉ A)
@end example
  Includes an element @emph{key} in @emph{s}.

This doesn't do anything if @emph{key} is already in @emph{s}. Example:


@example
var values = initSet[int]()
values.incl(2)
values.incl(2)
assert values.len == 1
@end example

@item incl
  @findex proc incl*[A](s꞉ var HashSet[A]; other꞉ HashSet[A])
@example
proc incl*[A](s꞉ var HashSet[A]; other꞉ HashSet[A])
@end example
  Includes all elements from @emph{other} into @emph{s}.

Example:


@example
var values = initSet[int]()
values.incl(2)
var others = toSet([6, 7])
values.incl(others)
assert values.len == 3
@end example

@item excl
  @findex proc excl*[A](s꞉ var HashSet[A]; key꞉ A)
@example
proc excl*[A](s꞉ var HashSet[A]; key꞉ A)
@end example
  Excludes @emph{key} from the set @emph{s}.

This doesn't do anything if @emph{key} is not found in @emph{s}. Example:


@example
var s = toSet([2, 3, 6, 7])
s.excl(2)
s.excl(2)
assert s.len == 3
@end example

@item excl
  @findex proc excl*[A](s꞉ var HashSet[A]; other꞉ HashSet[A])
@example
proc excl*[A](s꞉ var HashSet[A]; other꞉ HashSet[A])
@end example
  Excludes everything in @emph{other} from @emph{s}.

Example:


@example
var
  numbers = toSet([1, 2, 3, 4, 5])
  even = toSet([2, 4, 6, 8])
numbers.excl(even)
echo numbers
# --> @{1, 3, 5@}
@end example

@item containsOrIncl
  @findex proc containsOrIncl*[A](s꞉ var HashSet[A]; key꞉ A)꞉ bool
@example
proc containsOrIncl*[A](s꞉ var HashSet[A]; key꞉ A)꞉ bool
@end example
  Includes @emph{key} in the set @emph{s} and tells if @emph{key} was added to @emph{s}.

The difference with regards to the @uref{#incl,TSet[A],A, incl()} proc is that this proc returns @emph{true} if @emph{key} was already present in @emph{s}. The proc will return false if @emph{key} was added as a new value to @emph{s} during this call. Example:


@example
var values = initSet[int]()
assert values.containsOrIncl(2) == false
assert values.containsOrIncl(2) == true
@end example

@item init
  @findex proc init*[A](s꞉ var HashSet[A]; initialSize = 64)
@example
proc init*[A](s꞉ var HashSet[A]; initialSize = 64)
@end example
  Initializes a hash set.

The @emph{initialSize} parameter needs to be a power of two. You can use @uref{math.html#nextPowerOfTwo, math.nextPowerOfTwo()} or @emph{rightSize} to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of @uref{#isValid,TSet[A], isValid()} and @uref{#len,TSet[A], len()}.

You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling @uref{#excl,TSet[A],A, excl()} on them. Example:


@example
var a: Set[int]
a.init(4)
a.incl(2)
a.init
assert a.len == 0 and a.isValid
@end example

@item initSet
  @findex proc initSet*[A](initialSize = 64)꞉ HashSet[A]
@example
proc initSet*[A](initialSize = 64)꞉ HashSet[A]
@end example
  Wrapper around @uref{#init,TSet[A],int, init()} for initialization of hash sets.

Returns an empty hash set you can assign directly in @code{var} blocks in a single line. Example:


@example
var a = initSet[int](4)
a.incl(2)
@end example

@item toSet
  @findex proc toSet*[A](keys꞉ openArray[A])꞉ HashSet[A]
@example
proc toSet*[A](keys꞉ openArray[A])꞉ HashSet[A]
@end example
  Creates a new hash set that contains the given @emph{keys}.

Example:


@example
var numbers = toSet([1, 2, 3, 4, 5])
assert numbers.contains(2)
assert numbers.contains(4)
@end example

@item `$`
  @findex proc `$`*[A](s꞉ HashSet[A])꞉ string
@example
proc `$`*[A](s꞉ HashSet[A])꞉ string
@end example
  Converts the set @emph{s} to a string, mostly for logging purposes.

Don't use this proc for serialization, the representation may change at any moment and values are not escaped. Example:

Example:


@example
echo toSet([2, 4, 5])
# --> @{2, 4, 5@}
echo toSet(["no", "esc'aping", "is \" provided"])
# --> @{no, esc'aping, is " provided@}
@end example

@item union
  @findex proc union*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@example
proc union*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@end example
  Returns the union of the sets @emph{s1} and @emph{s2}.

The union of two sets is represented mathematically as @emph{A ∪ B} and is the set of all objects that are members of @emph{s1}, @emph{s2} or both. Example:


@example
var
  a = toSet(["a", "b"])
  b = toSet(["b", "c"])
  c = union(a, b)
assert c == toSet(["a", "b", "c"])
@end example

@item intersection
  @findex proc intersection*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@example
proc intersection*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@end example
  Returns the intersection of the sets @emph{s1} and @emph{s2}.

The intersection of two sets is represented mathematically as @emph{A ∩ B} and is the set of all objects that are members of @emph{s1} and @emph{s2} at the same time. Example:


@example
var
  a = toSet(["a", "b"])
  b = toSet(["b", "c"])
  c = intersection(a, b)
assert c == toSet(["b"])
@end example

@item difference
  @findex proc difference*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@example
proc difference*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@end example
  Returns the difference of the sets @emph{s1} and @emph{s2}.

The difference of two sets is represented mathematically as @emph{A B} and is the set of all objects that are members of @emph{s1} and not members of @emph{s2}. Example:


@example
var
  a = toSet(["a", "b"])
  b = toSet(["b", "c"])
  c = difference(a, b)
assert c == toSet(["a"])
@end example

@item symmetricDifference
  @findex proc symmetricDifference*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@example
proc symmetricDifference*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A]
@end example
  Returns the symmetric difference of the sets @emph{s1} and @emph{s2}.

The symmetric difference of two sets is represented mathematically as @emph{A △ B} or @emph{A ⊖ B} and is the set of all objects that are members of @emph{s1} or @emph{s2} but not both at the same time. Example:


@example
var
  a = toSet(["a", "b"])
  b = toSet(["b", "c"])
  c = symmetricDifference(a, b)
assert c == toSet(["a", "c"])
@end example

@item `+`
  @findex proc `+`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@example
proc `+`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@end example
  Alias for @uref{#union, union(s1, s2)}.

@item `*`
  @findex proc `*`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@example
proc `*`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@end example
  Alias for @uref{#intersection, intersection(s1, s2)}.

@item `-`
  @findex proc `-`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@example
proc `-`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@end example
  Alias for @uref{#difference, difference(s1, s2)}.

@item `-+-`
  @findex proc `-+-`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@example
proc `-+-`*[A](s1, s2꞉ HashSet[A])꞉ HashSet[A] @{.inline.@}
@end example
  Alias for @uref{#symmetricDifference, symmetricDifference(s1, s2)}.

@item disjoint
  @findex proc disjoint*[A](s1, s2꞉ HashSet[A])꞉ bool
@example
proc disjoint*[A](s1, s2꞉ HashSet[A])꞉ bool
@end example
  Returns true iff the sets @emph{s1} and @emph{s2} have no items in common.

Example:


@example
var
  a = toSet(["a", "b"])
  b = toSet(["b", "c"])
assert disjoint(a, b) == false
assert disjoint(a, b - a) == true
@end example

@item `<`
  @findex proc `<`*[A](s, t꞉ HashSet[A])꞉ bool
@example
proc `<`*[A](s, t꞉ HashSet[A])꞉ bool
@end example
  Returns true if @emph{s} is a strict or proper subset of @emph{t}.

A strict or proper subset @emph{s} has all of its members in @emph{t} but @emph{t} has more elements than @emph{s}. Example:


@example
var
  a = toSet(["a", "b"])
  b = toSet(["b", "c"])
  c = intersection(a, b)
assert c < a and c < b
assert((a < a) == false)
@end example

@item `<=`
  @findex proc `<=`*[A](s, t꞉ HashSet[A])꞉ bool
@example
proc `<=`*[A](s, t꞉ HashSet[A])꞉ bool
@end example
  Returns true if @emph{s} is subset of @emph{t}.

A subset @emph{s} has all of its members in @emph{t} and @emph{t} doesn't necessarily have more members than @emph{s}. That is, @emph{s} can be equal to @emph{t}. Example:


@example
var
  a = toSet(["a", "b"])
  b = toSet(["b", "c"])
  c = intersection(a, b)
assert c <= a and c <= b
assert((a <= a))
@end example

@item `==`
  @findex proc `==`*[A](s, t꞉ HashSet[A])꞉ bool
@example
proc `==`*[A](s, t꞉ HashSet[A])꞉ bool
@end example
  Returns true if both @emph{s} and @emph{t} have the same members and set size.

Example:


@example
var
  a = toSet([1, 2])
  b = toSet([1])
b.incl(2)
assert a == b
@end example

@item map
  @findex proc map*[A, B](data꞉ HashSet[A]; op꞉ proc (x꞉ A)꞉ B @{.closure.@})꞉ HashSet[B]
@example
proc map*[A, B](data꞉ HashSet[A]; op꞉ proc (x꞉ A)꞉ B @{.closure.@})꞉ HashSet[B]
@end example
  Returns a new set after applying @emph{op} on each of the elements of @emph{data}.

You can use this proc to transform the elements from a set. Example:


@example
var a = toSet([1, 2, 3])
var b = a.map(proc (x: int): string = $x)
assert b == toSet(["1", "2", "3"])
@end example

@item isValid
  @findex proc isValid*[A](s꞉ OrderedSet[A])꞉ bool
@example
proc isValid*[A](s꞉ OrderedSet[A])꞉ bool
@end example
  Returns @emph{true} if the ordered set has been initialized with @uref{#initOrderedSet, initSet}.

Most operations over an uninitialized ordered set will crash at runtime and @uref{system.html#assert, assert} in debug builds. You can use this proc in your own procs to verify that ordered sets passed to your procs are correctly initialized. Example:


@example
proc saveTarotCards(cards: OrderedSet[int]) =
  assert cards.isValid, "Pass an initialized set!"
  # Do stuff here, may crash in release builds!
@end example

@item len
  @findex proc len*[A](s꞉ OrderedSet[A])꞉ int @{.inline.@}
@example
proc len*[A](s꞉ OrderedSet[A])꞉ int @{.inline.@}
@end example
  Returns the number of keys in @emph{s}.

Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then. Example:


@example

var values: OrderedSet[int]
assert(not values.isValid)
assert values.len == 0
@end example

@item card
  @findex proc card*[A](s꞉ OrderedSet[A])꞉ int @{.inline.@}
@example
proc card*[A](s꞉ OrderedSet[A])꞉ int @{.inline.@}
@end example
  Alias for @uref{#len,TOrderedSet[A], len()}.

Card stands for the @uref{http://en.wikipedia.org/wiki/Cardinality, cardinality} of a set.

@item contains
  @findex proc contains*[A](s꞉ OrderedSet[A]; key꞉ A)꞉ bool
@example
proc contains*[A](s꞉ OrderedSet[A]; key꞉ A)꞉ bool
@end example
  Returns true iff @emph{key} is in @emph{s}.

Example:


@example
var values = initOrderedSet[int]()
assert(not values.contains(2))
values.incl(2)
assert values.contains(2)
@end example

@item incl
  @findex proc incl*[A](s꞉ var OrderedSet[A]; key꞉ A)
@example
proc incl*[A](s꞉ var OrderedSet[A]; key꞉ A)
@end example
  Includes an element @emph{key} in @emph{s}.

This doesn't do anything if @emph{key} is already in @emph{s}. Example:


@example
var values = initOrderedSet[int]()
values.incl(2)
values.incl(2)
assert values.len == 1
@end example

@item incl
  @findex proc incl*[A](s꞉ var HashSet[A]; other꞉ OrderedSet[A])
@example
proc incl*[A](s꞉ var HashSet[A]; other꞉ OrderedSet[A])
@end example
  Includes all elements from @emph{other} into @emph{s}.

Example:


@example
var values = initOrderedSet[int]()
values.incl(2)
var others = toOrderedSet([6, 7])
values.incl(others)
assert values.len == 3
@end example

@item containsOrIncl
  @findex proc containsOrIncl*[A](s꞉ var OrderedSet[A]; key꞉ A)꞉ bool
@example
proc containsOrIncl*[A](s꞉ var OrderedSet[A]; key꞉ A)꞉ bool
@end example
  Includes @emph{key} in the set @emph{s} and tells if @emph{key} was added to @emph{s}.

The difference with regards to the @uref{#incl,TOrderedSet[A],A, incl()} proc is that this proc returns @emph{true} if @emph{key} was already present in @emph{s}. The proc will return false if @emph{key} was added as a new value to @emph{s} during this call. Example:


@example
var values = initOrderedSet[int]()
assert values.containsOrIncl(2) == false
assert values.containsOrIncl(2) == true
@end example

@item init
  @findex proc init*[A](s꞉ var OrderedSet[A]; initialSize = 64)
@example
proc init*[A](s꞉ var OrderedSet[A]; initialSize = 64)
@end example
  Initializes an ordered hash set.

The @emph{initialSize} parameter needs to be a power of two. You can use @uref{math.html#nextPowerOfTwo, math.nextPowerOfTwo()} or @emph{rightSize} to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of @uref{#isValid,TOrderedSet[A], isValid()} and @uref{#len,TOrderedSet[A], len()}.

You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:


@example
var a: OrderedSet[int]
a.init(4)
a.incl(2)
a.init
assert a.len == 0 and a.isValid
@end example

@item initOrderedSet
  @findex proc initOrderedSet*[A](initialSize = 64)꞉ OrderedSet[A]
@example
proc initOrderedSet*[A](initialSize = 64)꞉ OrderedSet[A]
@end example
  Wrapper around @uref{#init,TOrderedSet[A],int, init()} for initialization of ordered hash sets.

Returns an empty ordered hash set you can assign directly in @code{var} blocks in a single line. Example:


@example
var a = initOrderedSet[int](4)
a.incl(2)
@end example

@item toOrderedSet
  @findex proc toOrderedSet*[A](keys꞉ openArray[A])꞉ OrderedSet[A]
@example
proc toOrderedSet*[A](keys꞉ openArray[A])꞉ OrderedSet[A]
@end example
  Creates a new ordered hash set that contains the given @emph{keys}.

Example:


@example
var numbers = toOrderedSet([1, 2, 3, 4, 5])
assert numbers.contains(2)
assert numbers.contains(4)
@end example

@item `$`
  @findex proc `$`*[A](s꞉ OrderedSet[A])꞉ string
@example
proc `$`*[A](s꞉ OrderedSet[A])꞉ string
@end example
  Converts the ordered hash set @emph{s} to a string, mostly for logging purposes.

Don't use this proc for serialization, the representation may change at any moment and values are not escaped. Example:

Example:


@example
echo toOrderedSet([2, 4, 5])
# --> @{2, 4, 5@}
echo toOrderedSet(["no", "esc'aping", "is \" provided"])
# --> @{no, esc'aping, is " provided@}
@end example

@item `==`
  @findex proc `==`*[A](s, t꞉ OrderedSet[A])꞉ bool
@example
proc `==`*[A](s, t꞉ OrderedSet[A])꞉ bool
@end example
  Equality for ordered sets.
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*[A](s꞉ HashSet[A])꞉ A
@example
iterator items*[A](s꞉ HashSet[A])꞉ A
@end example
  Iterates over keys in the set @emph{s}.

If you need a sequence with the keys you can use @uref{sequtils.html#toSeq, sequtils.toSeq()} on the iterator. Usage example:


@example
type
  pair = tuple[a, b: int]
var
  a, b = initSet[pair]()
a.incl((2, 3))
a.incl((3, 2))
a.incl((2, 3))
for x, y in a.items:
  b.incl((x - 2, y + 1))
assert a.len == 2
echo b
# --> @{(a: 1, b: 3), (a: 0, b: 4)@}
@end example

@item items
  @itindex iterator items*[A](s꞉ OrderedSet[A])꞉ A
@example
iterator items*[A](s꞉ OrderedSet[A])꞉ A
@end example
  Iterates over keys in the ordered set @emph{s} in insertion order.

If you need a sequence with the keys you can use @uref{sequtils.html#toSeq, sequtils.toSeq()} on the iterator. Usage example:


@example
var a = initOrderedSet[int]()
for value in [9, 2, 1, 5, 1, 8, 4, 2]:
  a.incl(value)
for value in a.items:
  echo "Got ", value
# --> Got 9
# --> Got 2
# --> Got 1
# --> Got 5
# --> Got 8
# --> Got 4
@end example
@end itemize

@node /pure/collections/rtarrays, /pure/collections/tables , /pure/collections/sets, Top



@chapter Types

@itemize


@item UncheckedArray
  @tindex UncheckedArray* @{.unchecked.@}[T] = array[0 .. 100000000, T]
@example
UncheckedArray* @{.unchecked.@}[T] = array[0 .. 100000000, T]
@end example
  
@end itemize

@chapter Procedures

@itemize


@item initRtArray
  @findex proc initRtArray*[T](len꞉ Natural)꞉ RtArray[T]
@example
proc initRtArray*[T](len꞉ Natural)꞉ RtArray[T]
@end example
  

@item getRawData
  @findex proc getRawData*[T](x꞉ var RtArray[T])꞉ ptr UncheckedArray[T]
@example
proc getRawData*[T](x꞉ var RtArray[T])꞉ ptr UncheckedArray[T]
@end example
  
@end itemize






@node /pure/collections/tables, /pure/collections/sharedlist , /pure/collections/rtarrays, Top



@chapter Types

@itemize


@item TableRef
  @tindex TableRef*[A, B] = ref Table[A, B]
@example
TableRef*[A, B] = ref Table[A, B]
@end example
  

@item OrderedTableRef
  @tindex OrderedTableRef*[A, B] = ref OrderedTable[A, B]
@example
OrderedTableRef*[A, B] = ref OrderedTable[A, B]
@end example
  

@item CountTableRef
  @tindex CountTableRef*[A] = ref CountTable[A]
@example
CountTableRef*[A] = ref CountTable[A]
@end example
  
@end itemize

@chapter Procedures

@itemize


@item rightSize
  @findex proc rightSize*(count꞉ Natural)꞉ int @{.inline.@}
@example
proc rightSize*(count꞉ Natural)꞉ int @{.inline.@}
@end example
  Return the value of @emph{initialSize} to support @emph{count} items.

If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.

Internally, we want mustRehash(rightSize(x), x) == false.

@item len
  @findex proc len*[A, B](t꞉ Table[A, B])꞉ int
@example
proc len*[A, B](t꞉ Table[A, B])꞉ int
@end example
  returns the number of keys in @emph{t}.

@item `[]`
  @findex proc `[]`*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ B @{.deprecatedGet.@}
@example
proc `[]`*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ B @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. One can check with @code{hasKey} whether the key exists.

@item `[]`
  @findex proc `[]`*[A, B](t꞉ var Table[A, B]; key꞉ A)꞉ var B @{.deprecatedGet.@}
@example
proc `[]`*[A, B](t꞉ var Table[A, B]; key꞉ A)꞉ var B @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised.

@item mget
  @findex proc mget*[A, B](t꞉ var Table[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@example
proc mget*[A, B](t꞉ var Table[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item getOrDefault
  @findex proc getOrDefault*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ B
@example
proc getOrDefault*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ B
@end example
  

@item hasKey
  @findex proc hasKey*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ bool
@example
proc hasKey*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ bool
@end example
  returns true iff @emph{key} is in the table @emph{t}.

@item contains
  @findex proc contains*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ bool
@example
proc contains*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ bool
@end example
  alias of @emph{hasKey} for use with the @emph{in} operator.

@item del
  @findex proc del*[A, B](t꞉ var Table[A, B]; key꞉ A)
@example
proc del*[A, B](t꞉ var Table[A, B]; key꞉ A)
@end example
  deletes @emph{key} from hash table @emph{t}.

@item mgetOrPut
  @findex proc mgetOrPut*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)꞉ var B
@example
proc mgetOrPut*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)꞉ var B
@end example
  retrieves value at @code{t[key]} or puts @code{val} if not present, either way returning a value which can be modified.

@item hasKeyOrPut
  @findex proc hasKeyOrPut*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)꞉ bool
@example
proc hasKeyOrPut*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)꞉ bool
@end example
  returns true iff @emph{key} is in the table, otherwise inserts @emph{value}.

@item `[]=`
  @findex proc `[]=`*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)
@example
proc `[]=`*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)
@end example
  puts a (key, value)-pair into @emph{t}.

@item add
  @findex proc add*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)
@example
proc add*[A, B](t꞉ var Table[A, B]; key꞉ A; val꞉ B)
@end example
  puts a new (key, value)-pair into @emph{t} even if @code{t[key]} already exists.

@item len
  @findex proc len*[A, B](t꞉ TableRef[A, B])꞉ int
@example
proc len*[A, B](t꞉ TableRef[A, B])꞉ int
@end example
  returns the number of keys in @emph{t}.

@item initTable
  @findex proc initTable*[A, B](initialSize = 64)꞉ Table[A, B]
@example
proc initTable*[A, B](initialSize = 64)꞉ Table[A, B]
@end example
  creates a new hash table that is empty.

@emph{initialSize} needs to be a power of two. If you need to accept runtime values for this you could use the @code{nextPowerOfTwo} proc from the @uref{math.html, math} module or the @code{rightSize} proc from this module.

@item toTable
  @findex proc toTable*[A, B](pairs꞉ openArray[(A, B)])꞉ Table[A, B]
@example
proc toTable*[A, B](pairs꞉ openArray[(A, B)])꞉ Table[A, B]
@end example
  creates a new hash table that contains the given @emph{pairs}.

@item `$`
  @findex proc `$`*[A, B](t꞉ Table[A, B])꞉ string
@example
proc `$`*[A, B](t꞉ Table[A, B])꞉ string
@end example
  The @emph{$} operator for hash tables.

@item hasKey
  @findex proc hasKey*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ bool
@example
proc hasKey*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ bool
@end example
  returns true iff @emph{key} is in the table @emph{t}.

@item `==`
  @findex proc `==`*[A, B](s, t꞉ Table[A, B])꞉ bool
@example
proc `==`*[A, B](s, t꞉ Table[A, B])꞉ bool
@end example
  

@item indexBy
  @findex proc indexBy*[A, B, C](collection꞉ A; index꞉ proc (x꞉ B)꞉ C)꞉ Table[C, B]
@example
proc indexBy*[A, B, C](collection꞉ A; index꞉ proc (x꞉ B)꞉ C)꞉ Table[C, B]
@end example
  Index the collection with the proc provided.

@item `[]`
  @findex proc `[]`*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ var B @{.deprecatedGet.@}
@example
proc `[]`*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ var B @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}.  If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. One can check with @code{hasKey} whether the key exists.

@item mget
  @findex proc mget*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@example
proc mget*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item getOrDefault
  @findex proc getOrDefault*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ B
@example
proc getOrDefault*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ B
@end example
  

@item mgetOrPut
  @findex proc mgetOrPut*[A, B](t꞉ TableRef[A, B]; key꞉ A; val꞉ B)꞉ var B
@example
proc mgetOrPut*[A, B](t꞉ TableRef[A, B]; key꞉ A; val꞉ B)꞉ var B
@end example
  retrieves value at @code{t[key]} or puts @code{val} if not present, either way returning a value which can be modified.

@item hasKeyOrPut
  @findex proc hasKeyOrPut*[A, B](t꞉ var TableRef[A, B]; key꞉ A; val꞉ B)꞉ bool
@example
proc hasKeyOrPut*[A, B](t꞉ var TableRef[A, B]; key꞉ A; val꞉ B)꞉ bool
@end example
  returns true iff @emph{key} is in the table, otherwise inserts @emph{value}.

@item contains
  @findex proc contains*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ bool
@example
proc contains*[A, B](t꞉ TableRef[A, B]; key꞉ A)꞉ bool
@end example
  alias of @emph{hasKey} for use with the @emph{in} operator.

@item `[]=`
  @findex proc `[]=`*[A, B](t꞉ TableRef[A, B]; key꞉ A; val꞉ B)
@example
proc `[]=`*[A, B](t꞉ TableRef[A, B]; key꞉ A; val꞉ B)
@end example
  puts a (key, value)-pair into @emph{t}.

@item add
  @findex proc add*[A, B](t꞉ TableRef[A, B]; key꞉ A; val꞉ B)
@example
proc add*[A, B](t꞉ TableRef[A, B]; key꞉ A; val꞉ B)
@end example
  puts a new (key, value)-pair into @emph{t} even if @code{t[key]} already exists.

@item del
  @findex proc del*[A, B](t꞉ TableRef[A, B]; key꞉ A)
@example
proc del*[A, B](t꞉ TableRef[A, B]; key꞉ A)
@end example
  deletes @emph{key} from hash table @emph{t}.

@item newTable
  @findex proc newTable*[A, B](initialSize = 64)꞉ TableRef[A, B]
@example
proc newTable*[A, B](initialSize = 64)꞉ TableRef[A, B]
@end example
  

@item newTable
  @findex proc newTable*[A, B](pairs꞉ openArray[(A, B)])꞉ TableRef[A, B]
@example
proc newTable*[A, B](pairs꞉ openArray[(A, B)])꞉ TableRef[A, B]
@end example
  creates a new hash table that contains the given @emph{pairs}.

@item `$`
  @findex proc `$`*[A, B](t꞉ TableRef[A, B])꞉ string
@example
proc `$`*[A, B](t꞉ TableRef[A, B])꞉ string
@end example
  The @emph{$} operator for hash tables.

@item `==`
  @findex proc `==`*[A, B](s, t꞉ TableRef[A, B])꞉ bool
@example
proc `==`*[A, B](s, t꞉ TableRef[A, B])꞉ bool
@end example
  

@item newTableFrom
  @findex proc newTableFrom*[A, B, C](collection꞉ A; index꞉ proc (x꞉ B)꞉ C)꞉ TableRef[C, B]
@example
proc newTableFrom*[A, B, C](collection꞉ A; index꞉ proc (x꞉ B)꞉ C)꞉ TableRef[C, B]
@end example
  Index the collection with the proc provided.

@item len
  @findex proc len*[A, B](t꞉ OrderedTable[A, B])꞉ int @{.inline.@}
@example
proc len*[A, B](t꞉ OrderedTable[A, B])꞉ int @{.inline.@}
@end example
  returns the number of keys in @emph{t}.

@item `[]`
  @findex proc `[]`*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ B @{.deprecatedGet.@}
@example
proc `[]`*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ B @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. One can check with @code{hasKey} whether the key exists.

@item `[]`
  @findex proc `[]`*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A)꞉ var B @{.deprecatedGet.@}
@example
proc `[]`*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A)꞉ var B @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised.

@item mget
  @findex proc mget*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@example
proc mget*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item getOrDefault
  @findex proc getOrDefault*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ B
@example
proc getOrDefault*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ B
@end example
  

@item hasKey
  @findex proc hasKey*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ bool
@example
proc hasKey*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ bool
@end example
  returns true iff @emph{key} is in the table @emph{t}.

@item contains
  @findex proc contains*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ bool
@example
proc contains*[A, B](t꞉ OrderedTable[A, B]; key꞉ A)꞉ bool
@end example
  alias of @emph{hasKey} for use with the @emph{in} operator.

@item `[]=`
  @findex proc `[]=`*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)
@example
proc `[]=`*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)
@end example
  puts a (key, value)-pair into @emph{t}.

@item add
  @findex proc add*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)
@example
proc add*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)
@end example
  puts a new (key, value)-pair into @emph{t} even if @code{t[key]} already exists.

@item mgetOrPut
  @findex proc mgetOrPut*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)꞉ var B
@example
proc mgetOrPut*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)꞉ var B
@end example
  retrieves value at @code{t[key]} or puts @code{value} if not present, either way returning a value which can be modified.

@item hasKeyOrPut
  @findex proc hasKeyOrPut*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)꞉ bool
@example
proc hasKeyOrPut*[A, B](t꞉ var OrderedTable[A, B]; key꞉ A; val꞉ B)꞉ bool
@end example
  returns true iff @emph{key} is in the table, otherwise inserts @emph{value}.

@item initOrderedTable
  @findex proc initOrderedTable*[A, B](initialSize = 64)꞉ OrderedTable[A, B]
@example
proc initOrderedTable*[A, B](initialSize = 64)꞉ OrderedTable[A, B]
@end example
  creates a new ordered hash table that is empty.

@emph{initialSize} needs to be a power of two. If you need to accept runtime values for this you could use the @code{nextPowerOfTwo} proc from the @uref{math.html, math} module or the @code{rightSize} proc from this module.

@item toOrderedTable
  @findex proc toOrderedTable*[A, B](pairs꞉ openArray[(A, B)])꞉ OrderedTable[A, B]
@example
proc toOrderedTable*[A, B](pairs꞉ openArray[(A, B)])꞉ OrderedTable[A, B]
@end example
  creates a new ordered hash table that contains the given @emph{pairs}.

@item `$`
  @findex proc `$`*[A, B](t꞉ OrderedTable[A, B])꞉ string
@example
proc `$`*[A, B](t꞉ OrderedTable[A, B])꞉ string
@end example
  The @emph{$} operator for ordered hash tables.

@item sort
  @findex proc sort*[A, B](t꞉ var OrderedTable[A, B]; cmp꞉ proc (x, y꞉ (A, B))꞉ int)
@example
proc sort*[A, B](t꞉ var OrderedTable[A, B]; cmp꞉ proc (x, y꞉ (A, B))꞉ int)
@end example
  sorts @emph{t} according to @emph{cmp}. This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after @emph{sort} (in contrast to the @emph{sort} for count tables).

@item len
  @findex proc len*[A, B](t꞉ OrderedTableRef[A, B])꞉ int @{.inline.@}
@example
proc len*[A, B](t꞉ OrderedTableRef[A, B])꞉ int @{.inline.@}
@end example
  returns the number of keys in @emph{t}.

@item `[]`
  @findex proc `[]`*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ var B
@example
proc `[]`*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ var B
@end example
  retrieves the value at @code{t[key]}. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. One can check with @code{hasKey} whether the key exists.

@item mget
  @findex proc mget*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@example
proc mget*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ var B @{.deprecated.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item getOrDefault
  @findex proc getOrDefault*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ B
@example
proc getOrDefault*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ B
@end example
  

@item mgetOrPut
  @findex proc mgetOrPut*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A; val꞉ B)꞉ var B
@example
proc mgetOrPut*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A; val꞉ B)꞉ var B
@end example
  retrieves value at @code{t[key]} or puts @code{val} if not present, either way returning a value which can be modified.

@item hasKeyOrPut
  @findex proc hasKeyOrPut*[A, B](t꞉ var OrderedTableRef[A, B]; key꞉ A; val꞉ B)꞉ bool
@example
proc hasKeyOrPut*[A, B](t꞉ var OrderedTableRef[A, B]; key꞉ A; val꞉ B)꞉ bool
@end example
  returns true iff @emph{key} is in the table, otherwise inserts @emph{val}.

@item hasKey
  @findex proc hasKey*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ bool
@example
proc hasKey*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ bool
@end example
  returns true iff @emph{key} is in the table @emph{t}.

@item contains
  @findex proc contains*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ bool
@example
proc contains*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A)꞉ bool
@end example
  alias of @emph{hasKey} for use with the @emph{in} operator.

@item `[]=`
  @findex proc `[]=`*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A; val꞉ B)
@example
proc `[]=`*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A; val꞉ B)
@end example
  puts a (key, value)-pair into @emph{t}.

@item add
  @findex proc add*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A; val꞉ B)
@example
proc add*[A, B](t꞉ OrderedTableRef[A, B]; key꞉ A; val꞉ B)
@end example
  puts a new (key, value)-pair into @emph{t} even if @code{t[key]} already exists.

@item newOrderedTable
  @findex proc newOrderedTable*[A, B](initialSize = 64)꞉ OrderedTableRef[A, B]
@example
proc newOrderedTable*[A, B](initialSize = 64)꞉ OrderedTableRef[A, B]
@end example
  creates a new ordered hash table that is empty.

@emph{initialSize} needs to be a power of two. If you need to accept runtime values for this you could use the @code{nextPowerOfTwo} proc from the @uref{math.html, math} module or the @code{rightSize} proc from this module.

@item newOrderedTable
  @findex proc newOrderedTable*[A, B](pairs꞉ openArray[(A, B)])꞉ OrderedTableRef[A, B]
@example
proc newOrderedTable*[A, B](pairs꞉ openArray[(A, B)])꞉ OrderedTableRef[A, B]
@end example
  creates a new ordered hash table that contains the given @emph{pairs}.

@item `$`
  @findex proc `$`*[A, B](t꞉ OrderedTableRef[A, B])꞉ string
@example
proc `$`*[A, B](t꞉ OrderedTableRef[A, B])꞉ string
@end example
  The @emph{$} operator for ordered hash tables.

@item sort
  @findex proc sort*[A, B](t꞉ OrderedTableRef[A, B]; cmp꞉ proc (x, y꞉ (A, B))꞉ int)
@example
proc sort*[A, B](t꞉ OrderedTableRef[A, B]; cmp꞉ proc (x, y꞉ (A, B))꞉ int)
@end example
  sorts @emph{t} according to @emph{cmp}. This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after @emph{sort} (in contrast to the @emph{sort} for count tables).

@item len
  @findex proc len*[A](t꞉ CountTable[A])꞉ int
@example
proc len*[A](t꞉ CountTable[A])꞉ int
@end example
  returns the number of keys in @emph{t}.

@item `[]`
  @findex proc `[]`*[A](t꞉ CountTable[A]; key꞉ A)꞉ int @{.deprecatedGet.@}
@example
proc `[]`*[A](t꞉ CountTable[A]; key꞉ A)꞉ int @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. One can check with @code{hasKey} whether the key exists.

@item `[]`
  @findex proc `[]`*[A](t꞉ var CountTable[A]; key꞉ A)꞉ var int @{.deprecatedGet.@}
@example
proc `[]`*[A](t꞉ var CountTable[A]; key꞉ A)꞉ var int @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised.

@item mget
  @findex proc mget*[A](t꞉ var CountTable[A]; key꞉ A)꞉ var int @{.deprecated.@}
@example
proc mget*[A](t꞉ var CountTable[A]; key꞉ A)꞉ var int @{.deprecated.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item getOrDefault
  @findex proc getOrDefault*[A](t꞉ CountTable[A]; key꞉ A)꞉ int
@example
proc getOrDefault*[A](t꞉ CountTable[A]; key꞉ A)꞉ int
@end example
  

@item hasKey
  @findex proc hasKey*[A](t꞉ CountTable[A]; key꞉ A)꞉ bool
@example
proc hasKey*[A](t꞉ CountTable[A]; key꞉ A)꞉ bool
@end example
  returns true iff @emph{key} is in the table @emph{t}.

@item contains
  @findex proc contains*[A](t꞉ CountTable[A]; key꞉ A)꞉ bool
@example
proc contains*[A](t꞉ CountTable[A]; key꞉ A)꞉ bool
@end example
  alias of @emph{hasKey} for use with the @emph{in} operator.

@item `[]=`
  @findex proc `[]=`*[A](t꞉ var CountTable[A]; key꞉ A; val꞉ int)
@example
proc `[]=`*[A](t꞉ var CountTable[A]; key꞉ A; val꞉ int)
@end example
  puts a (key, value)-pair into @emph{t}.

@item initCountTable
  @findex proc initCountTable*[A](initialSize = 64)꞉ CountTable[A]
@example
proc initCountTable*[A](initialSize = 64)꞉ CountTable[A]
@end example
  creates a new count table that is empty.

@emph{initialSize} needs to be a power of two. If you need to accept runtime values for this you could use the @code{nextPowerOfTwo} proc from the @uref{math.html, math} module or the @code{rightSize} proc in this module.

@item toCountTable
  @findex proc toCountTable*[A](keys꞉ openArray[A])꞉ CountTable[A]
@example
proc toCountTable*[A](keys꞉ openArray[A])꞉ CountTable[A]
@end example
  creates a new count table with every key in @emph{keys} having a count of 1.

@item `$`
  @findex proc `$`*[A](t꞉ CountTable[A])꞉ string
@example
proc `$`*[A](t꞉ CountTable[A])꞉ string
@end example
  The @emph{$} operator for count tables.

@item inc
  @findex proc inc*[A](t꞉ var CountTable[A]; key꞉ A; val = 1)
@example
proc inc*[A](t꞉ var CountTable[A]; key꞉ A; val = 1)
@end example
  increments @emph{t[key]} by @emph{val}.

@item smallest
  @findex proc smallest*[A](t꞉ CountTable[A])꞉ tuple[key꞉ A, val꞉ int]
@example
proc smallest*[A](t꞉ CountTable[A])꞉ tuple[key꞉ A, val꞉ int]
@end example
  returns the largest (key,val)-pair. Efficiency: O(n)

@item largest
  @findex proc largest*[A](t꞉ CountTable[A])꞉ tuple[key꞉ A, val꞉ int]
@example
proc largest*[A](t꞉ CountTable[A])꞉ tuple[key꞉ A, val꞉ int]
@end example
  returns the (key,val)-pair with the largest @emph{val}. Efficiency: O(n)

@item sort
  @findex proc sort*[A](t꞉ var CountTable[A])
@example
proc sort*[A](t꞉ var CountTable[A])
@end example
  sorts the count table so that the entry with the highest counter comes first. This is destructive! You must not modify @emph{t} afterwards! You can use the iterators @emph{pairs},  @emph{keys}, and @emph{values} to iterate over @emph{t} in the sorted order.

@item len
  @findex proc len*[A](t꞉ CountTableRef[A])꞉ int
@example
proc len*[A](t꞉ CountTableRef[A])꞉ int
@end example
  returns the number of keys in @emph{t}.

@item `[]`
  @findex proc `[]`*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ var int @{.deprecatedGet.@}
@example
proc `[]`*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ var int @{.deprecatedGet.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised.

@item mget
  @findex proc mget*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ var int @{.deprecated.@}
@example
proc mget*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ var int @{.deprecated.@}
@end example
  retrieves the value at @code{t[key]}. The value can be modified. If @emph{key} is not in @emph{t}, the @code{KeyError} exception is raised. Use ```[]``` instead.

@item getOrDefault
  @findex proc getOrDefault*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ int
@example
proc getOrDefault*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ int
@end example
  

@item hasKey
  @findex proc hasKey*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ bool
@example
proc hasKey*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ bool
@end example
  returns true iff @emph{key} is in the table @emph{t}.

@item contains
  @findex proc contains*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ bool
@example
proc contains*[A](t꞉ CountTableRef[A]; key꞉ A)꞉ bool
@end example
  alias of @emph{hasKey} for use with the @emph{in} operator.

@item `[]=`
  @findex proc `[]=`*[A](t꞉ CountTableRef[A]; key꞉ A; val꞉ int)
@example
proc `[]=`*[A](t꞉ CountTableRef[A]; key꞉ A; val꞉ int)
@end example
  puts a (key, value)-pair into @emph{t}. @emph{val} has to be positive.

@item newCountTable
  @findex proc newCountTable*[A](initialSize = 64)꞉ CountTableRef[A]
@example
proc newCountTable*[A](initialSize = 64)꞉ CountTableRef[A]
@end example
  creates a new count table that is empty.

@emph{initialSize} needs to be a power of two. If you need to accept runtime values for this you could use the @code{nextPowerOfTwo} proc from the @uref{math.html, math} module or the @code{rightSize} method in this module.

@item newCountTable
  @findex proc newCountTable*[A](keys꞉ openArray[A])꞉ CountTableRef[A]
@example
proc newCountTable*[A](keys꞉ openArray[A])꞉ CountTableRef[A]
@end example
  creates a new count table with every key in @emph{keys} having a count of 1.

@item `$`
  @findex proc `$`*[A](t꞉ CountTableRef[A])꞉ string
@example
proc `$`*[A](t꞉ CountTableRef[A])꞉ string
@end example
  The @emph{$} operator for count tables.

@item inc
  @findex proc inc*[A](t꞉ CountTableRef[A]; key꞉ A; val = 1)
@example
proc inc*[A](t꞉ CountTableRef[A]; key꞉ A; val = 1)
@end example
  increments @emph{t[key]} by @emph{val}.

@item smallest
  @findex proc smallest*[A](t꞉ CountTableRef[A])꞉ (A, int)
@example
proc smallest*[A](t꞉ CountTableRef[A])꞉ (A, int)
@end example
  returns the largest (key,val)-pair. Efficiency: O(n)

@item largest
  @findex proc largest*[A](t꞉ CountTableRef[A])꞉ (A, int)
@example
proc largest*[A](t꞉ CountTableRef[A])꞉ (A, int)
@end example
  returns the (key,val)-pair with the largest @emph{val}. Efficiency: O(n)

@item sort
  @findex proc sort*[A](t꞉ CountTableRef[A])
@example
proc sort*[A](t꞉ CountTableRef[A])
@end example
  sorts the count table so that the entry with the highest counter comes first. This is destructive! You must not modify @emph{t} afterwards! You can use the iterators @emph{pairs},  @emph{keys}, and @emph{values} to iterate over @emph{t} in the sorted order.

@item merge
  @findex proc merge*[A](s꞉ var CountTable[A]; t꞉ CountTable[A])
@example
proc merge*[A](s꞉ var CountTable[A]; t꞉ CountTable[A])
@end example
  merges the second table into the first one

@item merge
  @findex proc merge*[A](s, t꞉ CountTable[A])꞉ CountTable[A]
@example
proc merge*[A](s, t꞉ CountTable[A])꞉ CountTable[A]
@end example
  merges the two tables into a new one

@item merge
  @findex proc merge*[A](s, t꞉ CountTableRef[A])
@example
proc merge*[A](s, t꞉ CountTableRef[A])
@end example
  merges the second table into the first one
@end itemize





@chapter Iterators

@itemize


@item allValues
  @itindex iterator allValues*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ B
@example
iterator allValues*[A, B](t꞉ Table[A, B]; key꞉ A)꞉ B
@end example
  iterates over any value in the table @emph{t} that belongs to the given @emph{key}.

@item pairs
  @itindex iterator pairs*[A, B](t꞉ Table[A, B])꞉ (A, B)
@example
iterator pairs*[A, B](t꞉ Table[A, B])꞉ (A, B)
@end example
  iterates over any (key, value) pair in the table @emph{t}.

@item mpairs
  @itindex iterator mpairs*[A, B](t꞉ var Table[A, B])꞉ (A, var B)
@example
iterator mpairs*[A, B](t꞉ var Table[A, B])꞉ (A, var B)
@end example
  iterates over any (key, value) pair in the table @emph{t}. The values can be modified.

@item keys
  @itindex iterator keys*[A, B](t꞉ Table[A, B])꞉ A
@example
iterator keys*[A, B](t꞉ Table[A, B])꞉ A
@end example
  iterates over any key in the table @emph{t}.

@item values
  @itindex iterator values*[A, B](t꞉ Table[A, B])꞉ B
@example
iterator values*[A, B](t꞉ Table[A, B])꞉ B
@end example
  iterates over any value in the table @emph{t}.

@item mvalues
  @itindex iterator mvalues*[A, B](t꞉ var Table[A, B])꞉ var B
@example
iterator mvalues*[A, B](t꞉ var Table[A, B])꞉ var B
@end example
  iterates over any value in the table @emph{t}. The values can be modified.

@item pairs
  @itindex iterator pairs*[A, B](t꞉ TableRef[A, B])꞉ (A, B)
@example
iterator pairs*[A, B](t꞉ TableRef[A, B])꞉ (A, B)
@end example
  iterates over any (key, value) pair in the table @emph{t}.

@item mpairs
  @itindex iterator mpairs*[A, B](t꞉ TableRef[A, B])꞉ (A, var B)
@example
iterator mpairs*[A, B](t꞉ TableRef[A, B])꞉ (A, var B)
@end example
  iterates over any (key, value) pair in the table @emph{t}. The values can be modified.

@item keys
  @itindex iterator keys*[A, B](t꞉ TableRef[A, B])꞉ A
@example
iterator keys*[A, B](t꞉ TableRef[A, B])꞉ A
@end example
  iterates over any key in the table @emph{t}.

@item values
  @itindex iterator values*[A, B](t꞉ TableRef[A, B])꞉ B
@example
iterator values*[A, B](t꞉ TableRef[A, B])꞉ B
@end example
  iterates over any value in the table @emph{t}.

@item mvalues
  @itindex iterator mvalues*[A, B](t꞉ TableRef[A, B])꞉ var B
@example
iterator mvalues*[A, B](t꞉ TableRef[A, B])꞉ var B
@end example
  iterates over any value in the table @emph{t}. The values can be modified.

@item pairs
  @itindex iterator pairs*[A, B](t꞉ OrderedTable[A, B])꞉ (A, B)
@example
iterator pairs*[A, B](t꞉ OrderedTable[A, B])꞉ (A, B)
@end example
  iterates over any (key, value) pair in the table @emph{t} in insertion order.

@item mpairs
  @itindex iterator mpairs*[A, B](t꞉ var OrderedTable[A, B])꞉ (A, var B)
@example
iterator mpairs*[A, B](t꞉ var OrderedTable[A, B])꞉ (A, var B)
@end example
  iterates over any (key, value) pair in the table @emph{t} in insertion order. The values can be modified.

@item keys
  @itindex iterator keys*[A, B](t꞉ OrderedTable[A, B])꞉ A
@example
iterator keys*[A, B](t꞉ OrderedTable[A, B])꞉ A
@end example
  iterates over any key in the table @emph{t} in insertion order.

@item values
  @itindex iterator values*[A, B](t꞉ OrderedTable[A, B])꞉ B
@example
iterator values*[A, B](t꞉ OrderedTable[A, B])꞉ B
@end example
  iterates over any value in the table @emph{t} in insertion order.

@item mvalues
  @itindex iterator mvalues*[A, B](t꞉ var OrderedTable[A, B])꞉ var B
@example
iterator mvalues*[A, B](t꞉ var OrderedTable[A, B])꞉ var B
@end example
  iterates over any value in the table @emph{t} in insertion order. The values can be modified.

@item pairs
  @itindex iterator pairs*[A, B](t꞉ OrderedTableRef[A, B])꞉ (A, B)
@example
iterator pairs*[A, B](t꞉ OrderedTableRef[A, B])꞉ (A, B)
@end example
  iterates over any (key, value) pair in the table @emph{t} in insertion order.

@item mpairs
  @itindex iterator mpairs*[A, B](t꞉ OrderedTableRef[A, B])꞉ (A, var B)
@example
iterator mpairs*[A, B](t꞉ OrderedTableRef[A, B])꞉ (A, var B)
@end example
  iterates over any (key, value) pair in the table @emph{t} in insertion order. The values can be modified.

@item keys
  @itindex iterator keys*[A, B](t꞉ OrderedTableRef[A, B])꞉ A
@example
iterator keys*[A, B](t꞉ OrderedTableRef[A, B])꞉ A
@end example
  iterates over any key in the table @emph{t} in insertion order.

@item values
  @itindex iterator values*[A, B](t꞉ OrderedTableRef[A, B])꞉ B
@example
iterator values*[A, B](t꞉ OrderedTableRef[A, B])꞉ B
@end example
  iterates over any value in the table @emph{t} in insertion order.

@item mvalues
  @itindex iterator mvalues*[A, B](t꞉ OrderedTableRef[A, B])꞉ var B
@example
iterator mvalues*[A, B](t꞉ OrderedTableRef[A, B])꞉ var B
@end example
  iterates over any value in the table @emph{t} in insertion order. The values can be modified.

@item pairs
  @itindex iterator pairs*[A](t꞉ CountTable[A])꞉ (A, int)
@example
iterator pairs*[A](t꞉ CountTable[A])꞉ (A, int)
@end example
  iterates over any (key, value) pair in the table @emph{t}.

@item mpairs
  @itindex iterator mpairs*[A](t꞉ var CountTable[A])꞉ (A, var int)
@example
iterator mpairs*[A](t꞉ var CountTable[A])꞉ (A, var int)
@end example
  iterates over any (key, value) pair in the table @emph{t}. The values can be modified.

@item keys
  @itindex iterator keys*[A](t꞉ CountTable[A])꞉ A
@example
iterator keys*[A](t꞉ CountTable[A])꞉ A
@end example
  iterates over any key in the table @emph{t}.

@item values
  @itindex iterator values*[A](t꞉ CountTable[A])꞉ int
@example
iterator values*[A](t꞉ CountTable[A])꞉ int
@end example
  iterates over any value in the table @emph{t}.

@item mvalues
  @itindex iterator mvalues*[A](t꞉ CountTable[A])꞉ var int
@example
iterator mvalues*[A](t꞉ CountTable[A])꞉ var int
@end example
  iterates over any value in the table @emph{t}. The values can be modified.

@item pairs
  @itindex iterator pairs*[A](t꞉ CountTableRef[A])꞉ (A, int)
@example
iterator pairs*[A](t꞉ CountTableRef[A])꞉ (A, int)
@end example
  iterates over any (key, value) pair in the table @emph{t}.

@item mpairs
  @itindex iterator mpairs*[A](t꞉ CountTableRef[A])꞉ (A, var int)
@example
iterator mpairs*[A](t꞉ CountTableRef[A])꞉ (A, var int)
@end example
  iterates over any (key, value) pair in the table @emph{t}. The values can be modified.

@item keys
  @itindex iterator keys*[A](t꞉ CountTableRef[A])꞉ A
@example
iterator keys*[A](t꞉ CountTableRef[A])꞉ A
@end example
  iterates over any key in the table @emph{t}.

@item values
  @itindex iterator values*[A](t꞉ CountTableRef[A])꞉ int
@example
iterator values*[A](t꞉ CountTableRef[A])꞉ int
@end example
  iterates over any value in the table @emph{t}.

@item mvalues
  @itindex iterator mvalues*[A](t꞉ CountTableRef[A])꞉ var int
@example
iterator mvalues*[A](t꞉ CountTableRef[A])꞉ var int
@end example
  iterates over any value in the table @emph{t}. The values can be modified.
@end itemize

@node /pure/collections/sharedlist, /pure/concurrency/cpuinfo , /pure/collections/tables, Top



@chapter Types

@itemize


@item SharedList
  @tindex SharedList*[A] = object
  head, tail: SharedListNode[A]
  lock: Lock

@example
SharedList*[A] = object
  head, tail: SharedListNode[A]
  lock: Lock

@end example
  generic shared list
@end itemize

@chapter Procedures

@itemize


@item add
  @findex proc add*[A](x꞉ var SharedList[A]; y꞉ A)
@example
proc add*[A](x꞉ var SharedList[A]; y꞉ A)
@end example
  

@item initSharedList
  @findex proc initSharedList*[A]()꞉ SharedList[A]
@example
proc initSharedList*[A]()꞉ SharedList[A]
@end example
  

@item clear
  @findex proc clear*[A](t꞉ var SharedList[A])
@example
proc clear*[A](t꞉ var SharedList[A])
@end example
  

@item deinitSharedList
  @findex proc deinitSharedList*[A](t꞉ var SharedList[A])
@example
proc deinitSharedList*[A](t꞉ var SharedList[A])
@end example
  
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*[A](x꞉ var SharedList[A])꞉ A
@example
iterator items*[A](x꞉ var SharedList[A])꞉ A
@end example
  
@end itemize

@node /pure/concurrency/cpuinfo, /pure/concurrency/cpuload , /pure/collections/sharedlist, Top




@chapter Procedures

@itemize


@item countProcessors
  @findex proc countProcessors*()꞉ int @{.rtl, extern꞉ "ncpi$1".@}
@example
proc countProcessors*()꞉ int @{.rtl, extern꞉ "ncpi$1".@}
@end example
  returns the numer of the processors/cores the machine has. Returns 0 if it cannot be detected.
@end itemize






@node /pure/concurrency/cpuload, /pure/concurrency/threadpool , /pure/concurrency/cpuinfo, Top



@chapter Types

@itemize


@item ThreadPoolState
  @tindex ThreadPoolState* = object
  when defined(windows):
      prevSysKernel, prevSysUser, prevProcKernel, prevProcUser: FILETIME

  calls*: int

@example
ThreadPoolState* = object
  when defined(windows):
      prevSysKernel, prevSysUser, prevProcKernel, prevProcUser: FILETIME

  calls*: int

@end example
  
@end itemize

@chapter Procedures

@itemize


@item advice
  @findex proc advice*(s꞉ var ThreadPoolState)꞉ ThreadPoolAdvice
@example
proc advice*(s꞉ var ThreadPoolState)꞉ ThreadPoolAdvice
@end example
  
@end itemize






@node /pure/concurrency/threadpool, /pure/unidecode/unidecode , /pure/concurrency/cpuload, Top
@chapter Constant variables

@itemize


@item MaxDistinguishedThread
  @vindex MaxDistinguishedThread* = 32
@example
MaxDistinguishedThread* = 32
@end example
  maximal number of "distinguished" threads.
@end itemize



@chapter Types

@itemize


@item ThreadId
  @tindex ThreadId* = range[0 .. MaxDistinguishedThread - 1]
@example
ThreadId* = range[0 .. MaxDistinguishedThread - 1]
@end example
  
@end itemize

@chapter Procedures

@itemize


@item await
  @findex proc await*(fv꞉ FlowVarBase)
@example
proc await*(fv꞉ FlowVarBase)
@end example
  waits until the value for the flowVar arrives. Usually it is not necessary to call this explicitly.

@item awaitAndThen
  @findex proc awaitAndThen*[T](fv꞉ FlowVar[T]; action꞉ proc (x꞉ T) @{.closure.@})
@example
proc awaitAndThen*[T](fv꞉ FlowVar[T]; action꞉ proc (x꞉ T) @{.closure.@})
@end example
  blocks until the @code{fv} is available and then passes its value to @code{action}. Note that due to Nim's parameter passing semantics this means that @code{T} doesn't need to be copied and so @code{awaitAndThen} can sometimes be more efficient than @code{^}.

@item unsafeRead
  @findex proc unsafeRead*[T](fv꞉ FlowVar[ref T])꞉ foreign ptr T
@example
proc unsafeRead*[T](fv꞉ FlowVar[ref T])꞉ foreign ptr T
@end example
  blocks until the value is available and then returns this value.

@item `^`
  @findex proc `^`*[T](fv꞉ FlowVar[ref T])꞉ ref T
@example
proc `^`*[T](fv꞉ FlowVar[ref T])꞉ ref T
@end example
  blocks until the value is available and then returns this value.

@item `^`
  @findex proc `^`*[T](fv꞉ FlowVar[T])꞉ T
@example
proc `^`*[T](fv꞉ FlowVar[T])꞉ T
@end example
  blocks until the value is available and then returns this value.

@item awaitAny
  @findex proc awaitAny*(flowVars꞉ openArray[FlowVarBase])꞉ int
@example
proc awaitAny*(flowVars꞉ openArray[FlowVarBase])꞉ int
@end example
  awaits any of the given flowVars. Returns the index of one flowVar for which a value arrived. A flowVar only supports one call to 'awaitAny' at the same time. That means if you await([a,b]) and await([b,c]) the second call will only await 'c'. If there is no flowVar left to be able to wait on, -1 is returned. @strong{Note}: This results in non-deterministic behaviour and so should be avoided.

@item isReady
  @findex proc isReady*(fv꞉ FlowVarBase)꞉ bool
@example
proc isReady*(fv꞉ FlowVarBase)꞉ bool
@end example
  Determines whether the specified @code{FlowVarBase}'s value is available.

If @code{true} awaiting @code{fv} will not block.

@item setMinPoolSize
  @findex proc setMinPoolSize*(size꞉ range[1 .. MaxThreadPoolSize])
@example
proc setMinPoolSize*(size꞉ range[1 .. MaxThreadPoolSize])
@end example
  sets the minimal thread pool size. The default value of this is 4.

@item setMaxPoolSize
  @findex proc setMaxPoolSize*(size꞉ range[1 .. MaxThreadPoolSize])
@example
proc setMaxPoolSize*(size꞉ range[1 .. MaxThreadPoolSize])
@end example
  sets the maximal thread pool size. The default value of this is @code{MaxThreadPoolSize}.

@item preferSpawn
  @findex proc preferSpawn*()꞉ bool
@example
proc preferSpawn*()꞉ bool
@end example
  Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead.

@item spawn
  @findex proc spawn*(call꞉ expr)꞉ expr @{.magic꞉ "Spawn".@}
@example
proc spawn*(call꞉ expr)꞉ expr @{.magic꞉ "Spawn".@}
@end example
  always spawns a new task, so that the 'call' is never executed on the calling thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with @code{FlowVar[T]}.

@item pinnedSpawn
  @findex proc pinnedSpawn*(id꞉ ThreadId; call꞉ expr)꞉ expr @{.magic꞉ "Spawn".@}
@example
proc pinnedSpawn*(id꞉ ThreadId; call꞉ expr)꞉ expr @{.magic꞉ "Spawn".@}
@end example
  always spawns a new task on the worker thread with @code{id}, so that the 'call' is @strong{always} executed on the this thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with @code{FlowVar[T]}.

@item parallel
  @findex proc parallel*(body꞉ stmt) @{.magic꞉ "Parallel".@}
@example
proc parallel*(body꞉ stmt) @{.magic꞉ "Parallel".@}
@end example
  a parallel section can be used to execute a block in parallel. @code{body} has to be in a DSL that is a particular subset of the language. Please refer to the manual for further information.

@item sync
  @findex proc sync*()
@example
proc sync*()
@end example
  a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier.
@end itemize

@chapter Templates

@itemize


@item spawnX
  @findex template spawnX*(call꞉ expr)꞉ expr
@example
template spawnX*(call꞉ expr)꞉ expr
@end example
  spawns a new task if a CPU core is ready, otherwise executes the call in the calling thread. Usually it is advised to use 'spawn' in order to not block the producer for an unknown amount of time. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with @code{FlowVar[T]}.
@end itemize





@node /pure/unidecode/unidecode, /impure/db_postgres , /pure/concurrency/threadpool, Top




@chapter Procedures

@itemize


@item loadUnidecodeTable
  @findex proc loadUnidecodeTable*(datafile = "unidecode.dat")
@example
proc loadUnidecodeTable*(datafile = "unidecode.dat")
@end example
  loads the datafile that @emph{unidecode} to work. Unless this module is compiled with the @code{embedUnidecodeTable} symbol defined, this needs to be called by the main thread before any thread can make a call to @emph{unidecode}.

@item unidecode
  @findex proc unidecode*(s꞉ string)꞉ string
@example
proc unidecode*(s꞉ string)꞉ string
@end example
  Finds the sequence of ASCII characters that is the closest approximation to the UTF-8 string @emph{s}.

Example:


@quotation unidecode("x53x17x4ExB0") 
@end quotation
Results in: "Bei Jing"
@end itemize






@node /impure/db_postgres, /impure/rdstdin , /pure/unidecode/unidecode, Top



@chapter Types

@itemize


@item SqlPrepared
  @tindex SqlPrepared* = distinct string
@example
SqlPrepared* = distinct string
@end example
  a identifier for the prepared queries
@end itemize

@chapter Procedures

@itemize


@item dbError
  @findex proc dbError*(db꞉ DbConn) @{.noreturn.@}
@example
proc dbError*(db꞉ DbConn) @{.noreturn.@}
@end example
  raises a DbError exception.

@item dbQuote
  @findex proc dbQuote*(s꞉ string)꞉ string
@example
proc dbQuote*(s꞉ string)꞉ string
@end example
  DB quotes the string.

@item tryExec
  @findex proc tryExec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc tryExec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  tries to execute the query and returns true if successful, false otherwise.

@item tryExec
  @findex proc tryExec*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc tryExec*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  tries to execute the query and returns true if successful, false otherwise.

@item exec
  @findex proc exec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc exec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  executes the query and raises EDB if not successful.

@item exec
  @findex proc exec*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc exec*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  

@item prepare
  @findex proc prepare*(db꞉ DbConn; stmtName꞉ string; query꞉ SqlQuery; nParams꞉ int)꞉ SqlPrepared
@example
proc prepare*(db꞉ DbConn; stmtName꞉ string; query꞉ SqlQuery; nParams꞉ int)꞉ SqlPrepared
@end example
  Creates a new @code{SqlPrepared} statement. Parameter substitution is done via @code{$1}, @code{$2}, @code{$3}, etc.

@item `[]`
  @findex proc `[]`*(row꞉ InstantRow; col꞉ int32)꞉ string @{.inline.@}
@example
proc `[]`*(row꞉ InstantRow; col꞉ int32)꞉ string @{.inline.@}
@end example
  returns text for given column of the row

@item len
  @findex proc len*(row꞉ InstantRow)꞉ int32 @{.inline.@}
@example
proc len*(row꞉ InstantRow)꞉ int32 @{.inline.@}
@end example
  returns number of columns in the row

@item getRow
  @findex proc getRow*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
proc getRow*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

@item getRow
  @findex proc getRow*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
proc getRow*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  

@item getAllRows
  @findex proc getAllRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@example
proc getAllRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and returns the whole result dataset.

@item getAllRows
  @findex proc getAllRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@example
proc getAllRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the prepared query and returns the whole result dataset.

@item getValue
  @findex proc getValue*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@example
proc getValue*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

@item getValue
  @findex proc getValue*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@example
proc getValue*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

@item tryInsertID
  @findex proc tryInsertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@example
proc tryInsertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@end example
  executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error. For Postgre this adds @code{RETURNING id} to the query, so it only works if your primary key is named @code{id}.

@item insertID
  @findex proc insertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@example
proc insertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@end example
  executes the query (typically "INSERT") and returns the generated ID for the row. For Postgre this adds @code{RETURNING id} to the query, so it only works if your primary key is named @code{id}.

@item execAffectedRows
  @findex proc execAffectedRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc execAffectedRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  executes the query (typically "UPDATE") and returns the number of affected rows.

@item execAffectedRows
  @findex proc execAffectedRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc execAffectedRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  executes the query (typically "UPDATE") and returns the number of affected rows.

@item close
  @findex proc close*(db꞉ DbConn) @{.tags꞉ [DbEffect].@}
@example
proc close*(db꞉ DbConn) @{.tags꞉ [DbEffect].@}
@end example
  closes the database connection.

@item open
  @findex proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [DbEffect].@}
@example
proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [DbEffect].@}
@end example
  opens a database connection. Raises @emph{EDb} if the connection could not be established.

Clients can also use Postgres keyword/value connection strings to connect.

Example:


@example

con = open("", "", "", "host=localhost port=5432 dbname=mydb")
@end example
See @uref{http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING, http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING} for more information.

Note that the connection parameter is not used but exists to maintain the nim db api.

@item setEncoding
  @findex proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [DbEffect].@}
@example
proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [DbEffect].@}
@end example
  sets the encoding of a database connection, returns true for success, false for failure.
@end itemize





@chapter Iterators

@itemize


@item fastRows
  @itindex iterator fastRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator fastRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and iterates over the result dataset. This is very fast, but potenially dangerous: If the for-loop-body executes another query, the results can be undefined. For Postgres it is safe though.

@item fastRows
  @itindex iterator fastRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator fastRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the prepared query and iterates over the result dataset.

@item instantRows
  @itindex iterator instantRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@example
iterator instantRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@end example
  same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within iterator body.

@item instantRows
  @itindex iterator instantRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@example
iterator instantRows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@end example
  same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within iterator body.

@item rows
  @itindex iterator rows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator rows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  same as @emph{fastRows}, but slower and safe.

@item rows
  @itindex iterator rows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator rows*(db꞉ DbConn; stmtName꞉ SqlPrepared; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  same as @emph{fastRows}, but slower and safe.
@end itemize

@node /impure/rdstdin, /impure/db_odbc , /impure/db_postgres, Top
@chapter Constant variables

@itemize


@item KEY_EVENT
  @vindex KEY_EVENT* = 1
@example
KEY_EVENT* = 1
@end example
  
@end itemize




@chapter Procedures

@itemize


@item readLineFromStdin
  @findex proc readLineFromStdin*(prompt꞉ string)꞉ TaintedString @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc readLineFromStdin*(prompt꞉ string)꞉ TaintedString @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  Reads a line from stdin.

@item readLineFromStdin
  @findex proc readLineFromStdin*(prompt꞉ string; line꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc readLineFromStdin*(prompt꞉ string; line꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  Reads a @emph{line} from stdin. @emph{line} must not be @code{nil}! May throw an IO exception. A line of text may be delimited by @code{CR}, @code{LF} or @code{CRLF}. The newline character(s) are not part of the returned string. Returns @code{false} if the end of the file has been reached, @code{true} otherwise. If @code{false} is returned @emph{line} contains no new data.

@item readConsoleInputW
  @findex proc readConsoleInputW*(hConsoleInput꞉ THANDLE; lpBuffer꞉ var INPUTRECORD;nLength꞉ uint32; lpNumberOfEventsRead꞉ var uint32)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "ReadConsoleInputW".@}
@example
proc readConsoleInputW*(hConsoleInput꞉ THANDLE; lpBuffer꞉ var INPUTRECORD;nLength꞉ uint32; lpNumberOfEventsRead꞉ var uint32)꞉ WINBOOL @{.stdcall, dynlib꞉ "kernel32", importc꞉ "ReadConsoleInputW".@}
@end example
  

@item readPasswordFromStdin
  @findex proc readPasswordFromStdin*(prompt꞉ string; password꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@example
proc readPasswordFromStdin*(prompt꞉ string; password꞉ var TaintedString)꞉ bool @{.tags꞉ [ReadIOEffect, WriteIOEffect].@}
@end example
  Reads a @emph{password} from stdin without printing it. @emph{password} must not be @code{nil}! Returns @code{false} if the end of the file has been reached, @code{true} otherwise.

@item readPasswordFromStdin
  @findex proc readPasswordFromStdin*(prompt꞉ string)꞉ TaintedString
@example
proc readPasswordFromStdin*(prompt꞉ string)꞉ TaintedString
@end example
  Reads a password from stdin without printing it.
@end itemize






@node /impure/db_odbc, /impure/nre , /impure/rdstdin, Top



@chapter Types

@itemize


@item InstantRow
  @tindex InstantRow* = tuple[row꞉ seq[string], len꞉ int]
@example
InstantRow* = tuple[row꞉ seq[string], len꞉ int]
@end example
  a handle that can be used to get a row's column text on demand
@end itemize

@chapter Procedures

@itemize


@item dbError
  @findex proc dbError*(db꞉ var DbConn) @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc dbError*(db꞉ var DbConn) @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Raises an @emph{[DbError]} exception with ODBC error information

@item dbQuote
  @findex proc dbQuote*(s꞉ string)꞉ string @{.noSideEffect.@}
@example
proc dbQuote*(s꞉ string)꞉ string @{.noSideEffect.@}
@end example
  DB quotes the string.

@item tryExec
  @findex proc tryExec*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [].@}
@example
proc tryExec*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [].@}
@end example
  Tries to execute the query and returns true if successful, false otherwise.

@item exec
  @findex proc exec*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc exec*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Executes the query and raises EDB if not successful.

@item `[]`
  @findex proc `[]`*(row꞉ InstantRow; col꞉ int)꞉ string @{.inline.@}
@example
proc `[]`*(row꞉ InstantRow; col꞉ int)꞉ string @{.inline.@}
@end example
  Returns text for given column of the row

@item len
  @findex proc len*(row꞉ InstantRow)꞉ int @{.inline.@}
@example
proc len*(row꞉ InstantRow)꞉ int @{.inline.@}
@end example
  Returns number of columns in the row

@item getRow
  @findex proc getRow*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc getRow*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

@item getAllRows
  @findex proc getAllRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc getAllRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Executes the query and returns the whole result dataset.

@item getValue
  @findex proc getValue*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [].@}
@example
proc getValue*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [].@}
@end example
  Executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

@item tryInsertId
  @findex proc tryInsertId*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [].@}
@example
proc tryInsertId*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [].@}
@end example
  Executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error.

@item insertId
  @findex proc insertId*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc insertId*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Executes the query (typically "INSERT") and returns the generated ID for the row.

@item execAffectedRows
  @findex proc execAffectedRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc execAffectedRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Runs the query (typically "UPDATE") and returns the number of affected rows

@item close
  @findex proc close*(db꞉ var DbConn) @{.tags꞉ [WriteDbEffect], raises꞉ [].@}
@example
proc close*(db꞉ var DbConn) @{.tags꞉ [WriteDbEffect], raises꞉ [].@}
@end example
  Closes the database connection.

@item open
  @findex proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Opens a database connection.

Raises @emph{EDb} if the connection could not be established.

Currently the database parameter is ignored, but included to match @code{open()} in the other db_xxxxx library modules.

@item setEncoding
  @findex proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Currently not implemented for ODBC.

Sets the encoding of a database connection, returns true for success, false for failure.
@end itemize





@chapter Iterators

@itemize


@item fastRows
  @itindex iterator fastRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
iterator fastRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Executes the query and iterates over the result dataset.

This is very fast, but potentially dangerous.  Use this iterator only if you require @strong{ALL} the rows.

Breaking the fastRows() iterator during a loop may cause a driver error for subsequenct queries

Rows are retrieved from the server at each iteration.

@item instantRows
  @itindex iterator instantRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
iterator instantRows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  Same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the interator body.

@item rows
  @itindex iterator rows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@example
iterator rows*(db꞉ var DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect, WriteDbEffect], raises꞉ [DbError].@}
@end example
  Same as @emph{fastRows}, but slower and safe.

This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.
@end itemize

@node /impure/nre, /impure/ssl , /impure/db_odbc, Top



@chapter Types

@itemize


@item StudyError
  @tindex StudyError* = ref object of RegexError
@example
StudyError* = ref object of RegexError
@end example
  Thrown when studying the regular expression failes for whatever reason. The message contains the error code.
@end itemize

@chapter Procedures

@itemize


@item captureCount
  @findex proc captureCount*(pattern꞉ Regex)꞉ int
@example
proc captureCount*(pattern꞉ Regex)꞉ int
@end example
  

@item captureNameId
  @findex proc captureNameId*(pattern꞉ Regex)꞉ Table[string, int]
@example
proc captureNameId*(pattern꞉ Regex)꞉ Table[string, int]
@end example
  

@item captureBounds
  @findex proc captureBounds*(pattern꞉ RegexMatch)꞉ CaptureBounds
@example
proc captureBounds*(pattern꞉ RegexMatch)꞉ CaptureBounds
@end example
  

@item captures
  @findex proc captures*(pattern꞉ RegexMatch)꞉ Captures
@example
proc captures*(pattern꞉ RegexMatch)꞉ Captures
@end example
  

@item `[]`
  @findex proc `[]`*(pattern꞉ CaptureBounds; i꞉ int)꞉ Option[Slice[int]]
@example
proc `[]`*(pattern꞉ CaptureBounds; i꞉ int)꞉ Option[Slice[int]]
@end example
  

@item `[]`
  @findex proc `[]`*(pattern꞉ Captures; i꞉ int)꞉ string
@example
proc `[]`*(pattern꞉ Captures; i꞉ int)꞉ string
@end example
  

@item match
  @findex proc match*(pattern꞉ RegexMatch)꞉ string
@example
proc match*(pattern꞉ RegexMatch)꞉ string
@end example
  

@item matchBounds
  @findex proc matchBounds*(pattern꞉ RegexMatch)꞉ Slice[int]
@example
proc matchBounds*(pattern꞉ RegexMatch)꞉ Slice[int]
@end example
  

@item `[]`
  @findex proc `[]`*(pattern꞉ CaptureBounds; name꞉ string)꞉ Option[Slice[int]]
@example
proc `[]`*(pattern꞉ CaptureBounds; name꞉ string)꞉ Option[Slice[int]]
@end example
  

@item `[]`
  @findex proc `[]`*(pattern꞉ Captures; name꞉ string)꞉ string
@example
proc `[]`*(pattern꞉ Captures; name꞉ string)꞉ string
@end example
  

@item toTable
  @findex proc toTable*(pattern꞉ Captures; default꞉ string = nil)꞉ Table[string, string]
@example
proc toTable*(pattern꞉ Captures; default꞉ string = nil)꞉ Table[string, string]
@end example
  

@item toTable
  @findex proc toTable*(pattern꞉ CaptureBounds; default = none(Slice[int]))꞉ Table[string,Option[Slice[int]]]
@example
proc toTable*(pattern꞉ CaptureBounds; default = none(Slice[int]))꞉ Table[string,Option[Slice[int]]]
@end example
  

@item toSeq
  @findex proc toSeq*(pattern꞉ CaptureBounds; default = none(Slice[int]))꞉ seq[Option[Slice[int]]]
@example
proc toSeq*(pattern꞉ CaptureBounds; default = none(Slice[int]))꞉ seq[Option[Slice[int]]]
@end example
  

@item toSeq
  @findex proc toSeq*(pattern꞉ Captures; default꞉ string = nil)꞉ seq[string]
@example
proc toSeq*(pattern꞉ Captures; default꞉ string = nil)꞉ seq[string]
@end example
  

@item `$`
  @findex proc `$`*(pattern꞉ RegexMatch)꞉ string
@example
proc `$`*(pattern꞉ RegexMatch)꞉ string
@end example
  

@item `==`
  @findex proc `==`*(a, b꞉ Regex)꞉ bool
@example
proc `==`*(a, b꞉ Regex)꞉ bool
@end example
  

@item `==`
  @findex proc `==`*(a, b꞉ RegexMatch)꞉ bool
@example
proc `==`*(a, b꞉ RegexMatch)꞉ bool
@end example
  

@item re
  @findex proc re*(pattern꞉ string)꞉ Regex
@example
proc re*(pattern꞉ string)꞉ Regex
@end example
  

@item match
  @findex proc match*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ Option[RegexMatch]
@example
proc match*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ Option[RegexMatch]
@end example
  Like ```find(...)`` <#proc-find>`__, but anchored to the start of the string. This means that @code{"foo".match(re"f") == true}, but @code{"foo".match(re"o") == false}.

@item find
  @findex proc find*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ Option[RegexMatch]
@example
proc find*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ Option[RegexMatch]
@end example
  Finds the given pattern in the string between the end and start positions.
@itemize 
 @item @code{start}: The start point at which to start matching. @code{|abc} is @code{0}; @code{a|bc} is @code{1}
@item @code{endpos}: The maximum index for a match; @code{int.high} means the end of the string, otherwise it’s an inclusive upper bound.
 
@end itemize

@item findAll
  @findex proc findAll*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ seq[string]
@example
proc findAll*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ seq[string]
@end example
  

@item split
  @findex proc split*(str꞉ string; pattern꞉ Regex; maxSplit = - 1; start = 0)꞉ seq[string]
@example
proc split*(str꞉ string; pattern꞉ Regex; maxSplit = - 1; start = 0)꞉ seq[string]
@end example
  Splits the string with the given regex. This works according to the rules that Perl and Javascript use:
@itemize 
 @item If the match is zero-width, then the string is still split: @code{"123".split(r"") == @@["1", "2", "3"]}.
@item If the pattern has a capture in it, it is added after the string split: @code{"12".split(re"(\d)") == @@["", "1", "", "2", ""]}.
@item If @code{maxsplit != -1}, then the string will only be split @code{maxsplit - 1} times. This means that there will be @code{maxsplit} strings in the output seq. @code{"1.2.3".split(re"\.", maxsplit = 2) == @@["1", "2.3"]}
 
@end itemize
@code{start} behaves the same as in ```find(...)`` <#proc-find>`__.

@item replace
  @findex proc replace*(str꞉ string; pattern꞉ Regex; subproc꞉ proc (match꞉ RegexMatch)꞉ string)꞉ string
@example
proc replace*(str꞉ string; pattern꞉ Regex; subproc꞉ proc (match꞉ RegexMatch)꞉ string)꞉ string
@end example
  Replaces each match of Regex in the string with @code{sub}, which should never be or return @code{nil}.

If @code{sub} is a @code{proc (RegexMatch): string}, then it is executed with each match and the return value is the replacement value.

If @code{sub} is a @code{proc (string): string}, then it is executed with the full text of the match and and the return value is the replacement value.

If @code{sub} is a string, the syntax is as follows:


@itemize 
 @item @code{$$} - literal @code{$}
@item @code{$123} - capture number @code{123}
@item @code{$foo} - named capture @code{foo}
@item @code{$@{foo@}} - same as above
@item @code{$1$#} - first and second captures
@item @code{$#} - first capture
@item @code{$0} - full match
 
@end itemize
If a given capture is missing, a @code{ValueError} exception is thrown.

@item replace
  @findex proc replace*(str꞉ string; pattern꞉ Regex; subproc꞉ proc (match꞉ string)꞉ string)꞉ string
@example
proc replace*(str꞉ string; pattern꞉ Regex; subproc꞉ proc (match꞉ string)꞉ string)꞉ string
@end example
  

@item replace
  @findex proc replace*(str꞉ string; pattern꞉ Regex; sub꞉ string)꞉ string
@example
proc replace*(str꞉ string; pattern꞉ Regex; sub꞉ string)꞉ string
@end example
  

@item escapeRe
  @findex proc escapeRe*(str꞉ string)꞉ string
@example
proc escapeRe*(str꞉ string)꞉ string
@end example
  Escapes the string so it doesn’t match any special characters. Incompatible with the Extra flag (@code{X}).
@end itemize





@chapter Iterators

@itemize


@item items
  @itindex iterator items*(pattern꞉ CaptureBounds; default = none(Slice[int]))꞉ Option[Slice[int]]
@example
iterator items*(pattern꞉ CaptureBounds; default = none(Slice[int]))꞉ Option[Slice[int]]
@end example
  

@item items
  @itindex iterator items*(pattern꞉ Captures; default꞉ string = nil)꞉ string
@example
iterator items*(pattern꞉ Captures; default꞉ string = nil)꞉ string
@end example
  

@item findIter
  @itindex iterator findIter*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ RegexMatch
@example
iterator findIter*(str꞉ string; pattern꞉ Regex; start = 0; endpos = int.high)꞉ RegexMatch
@end example
  Works the same as ```find(...)`` <#proc-find>`__, but finds every non-overlapping match. @code{"2222".find(re"22")} is @code{"22", "22"}, not @code{"22", "22", "22"}.

Arguments are the same as ```find(...)`` <#proc-find>`__

Variants:


@itemize 
 @item @code{proc findAll(...)} returns a @code{seq[string]}
 
@end itemize
@end itemize

@node /impure/ssl, /impure/db_sqlite , /impure/nre, Top



@chapter Types

@itemize


@item SecureSocket
  @tindex SecureSocket* = object
  ssl: SslPtr
  bio: BIO

@example
SecureSocket* = object
  ssl: SslPtr
  bio: BIO

@end example
  
@end itemize

@chapter Procedures

@itemize


@item connect
  @findex proc connect*(sock꞉ var SecureSocket; address꞉ string; port꞉ int)꞉ int
@example
proc connect*(sock꞉ var SecureSocket; address꞉ string; port꞉ int)꞉ int
@end example
  Connects to the specified @emph{address} on the specified @emph{port}. Returns the result of the certificate validation.

@item recvLine
  @findex proc recvLine*(sock꞉ SecureSocket; line꞉ var TaintedString)꞉ bool
@example
proc recvLine*(sock꞉ SecureSocket; line꞉ var TaintedString)꞉ bool
@end example
  Acts in a similar fashion to the @emph{recvLine} in the sockets module. Returns false when no data is available to be read. @emph{Line} must be initialized and not nil!

@item send
  @findex proc send*(sock꞉ SecureSocket; data꞉ string)
@example
proc send*(sock꞉ SecureSocket; data꞉ string)
@end example
  Writes @emph{data} to the socket.

@item close
  @findex proc close*(sock꞉ SecureSocket)
@example
proc close*(sock꞉ SecureSocket)
@end example
  Closes the socket
@end itemize






@node /impure/db_sqlite, /impure/re , /impure/ssl, Top



@chapter Types

@itemize


@item InstantRow
  @tindex InstantRow* = Pstmt
@example
InstantRow* = Pstmt
@end example
  a handle that can be used to get a row's column text on demand
@end itemize

@chapter Procedures

@itemize


@item dbError
  @findex proc dbError*(db꞉ DbConn) @{.noreturn.@}
@example
proc dbError*(db꞉ DbConn) @{.noreturn.@}
@end example
  raises a DbError exception.

@item dbQuote
  @findex proc dbQuote*(s꞉ string)꞉ string
@example
proc dbQuote*(s꞉ string)꞉ string
@end example
  DB quotes the string.

@item tryExec
  @findex proc tryExec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc tryExec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  tries to execute the query and returns true if successful, false otherwise.

@item exec
  @findex proc exec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc exec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  executes the query and raises DbError if not successful.

@item `[]`
  @findex proc `[]`*(row꞉ InstantRow; col꞉ int32)꞉ string @{.inline.@}
@example
proc `[]`*(row꞉ InstantRow; col꞉ int32)꞉ string @{.inline.@}
@end example
  returns text for given column of the row

@item len
  @findex proc len*(row꞉ InstantRow)꞉ int32 @{.inline.@}
@example
proc len*(row꞉ InstantRow)꞉ int32 @{.inline.@}
@end example
  returns number of columns in the row

@item getRow
  @findex proc getRow*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
proc getRow*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

@item getAllRows
  @findex proc getAllRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@example
proc getAllRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and returns the whole result dataset.

@item getValue
  @findex proc getValue*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@example
proc getValue*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

@item tryInsertID
  @findex proc tryInsertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect], raises꞉ [].@}
@example
proc tryInsertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect], raises꞉ [].@}
@end example
  executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error.

@item insertID
  @findex proc insertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@example
proc insertID*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@end example
  executes the query (typically "INSERT") and returns the generated ID for the row. For Postgre this adds @code{RETURNING id} to the query, so it only works if your primary key is named @code{id}.

@item execAffectedRows
  @findex proc execAffectedRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc execAffectedRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  executes the query (typically "UPDATE") and returns the number of affected rows.

@item close
  @findex proc close*(db꞉ DbConn) @{.tags꞉ [DbEffect].@}
@example
proc close*(db꞉ DbConn) @{.tags꞉ [DbEffect].@}
@end example
  closes the database connection.

@item open
  @findex proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [DbEffect].@}
@example
proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [DbEffect].@}
@end example
  opens a database connection. Raises @emph{EDb} if the connection could not be established. Only the @code{connection} parameter is used for @code{sqlite}.

@item setEncoding
  @findex proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [DbEffect].@}
@example
proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [DbEffect].@}
@end example
  sets the encoding of a database connection, returns true for success, false for failure.

Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.
@end itemize





@chapter Iterators

@itemize


@item fastRows
  @itindex iterator fastRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator fastRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  Executes the query and iterates over the result dataset.

This is very fast, but potentially dangerous.  Use this iterator only if you require @strong{ALL} the rows.

Breaking the fastRows() iterator during a loop will cause the next database query to raise a DbError exception @code{unable to close due to ...}.

@item instantRows
  @itindex iterator instantRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@example
iterator instantRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@end example
  same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

@item instantRows
  @itindex iterator instantRows*(db꞉ DbConn; columns꞉ var DbColumns; query꞉ SqlQuery;args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@example
iterator instantRows*(db꞉ DbConn; columns꞉ var DbColumns; query꞉ SqlQuery;args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@end example
  same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

@item rows
  @itindex iterator rows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator rows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  same as @emph{FastRows}, but slower and safe.
@end itemize

@node /impure/re, /impure/db_mysql , /impure/db_sqlite, Top
@chapter Constant variables

@itemize


@item MaxSubpatterns
  @vindex MaxSubpatterns* = 20
@example
MaxSubpatterns* = 20
@end example
  defines the maximum number of subpatterns that can be captured. This limit still exists for @code{replacef} and @code{parallelReplace}.

@item reURL
  @vindex reURL* @{.deprecated.@} = r"\b(http(s)?|ftp|gopher|telnet|file|notes|ms-help)" &r"꞉((//)|(\\\\))+[\w\d꞉#@@%/;$()~_?\+\-\=\\\.\&]*\b"
@example
reURL* @{.deprecated.@} = r"\b(http(s)?|ftp|gopher|telnet|file|notes|ms-help)" &r"꞉((//)|(\\\\))+[\w\d꞉#@@%/;$()~_?\+\-\=\\\.\&]*\b"
@end example
  describes an URL
@end itemize



@chapter Types

@itemize


@item RegexError
  @tindex RegexError* = object of ValueError
@example
RegexError* = object of ValueError
@end example
  is raised if the pattern is no valid regular expression.
@end itemize

@chapter Procedures

@itemize


@item re
  @findex proc re*(s꞉ string; flags = @{reExtended, reStudy@})꞉ Regex @{.deprecated.@}
@example
proc re*(s꞉ string; flags = @{reExtended, reStudy@})꞉ Regex @{.deprecated.@}
@end example
  Constructor of regular expressions. Note that Nim's extended raw string literals support this syntax @code{re"[abc]"} as a short form for @code{re(r"[abc]")}.

@item findBounds
  @findex proc findBounds*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ tuple[first, last꞉ int]
@example
proc findBounds*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ tuple[first, last꞉ int]
@end example
  returns the starting position and end position of @emph{pattern} in @emph{s} and the captured substrings in the array @emph{matches}. If it does not match, nothing is written into @emph{matches} and @code{(-1,0)} is returned.

@item findBounds
  @findex proc findBounds*(s꞉ string; pattern꞉ Regex;matches꞉ var openArray[tuple[first, last꞉ int]]; start = 0)꞉ tuple[first, last꞉ int]
@example
proc findBounds*(s꞉ string; pattern꞉ Regex;matches꞉ var openArray[tuple[first, last꞉ int]]; start = 0)꞉ tuple[first, last꞉ int]
@end example
  returns the starting position and end position of @code{pattern} in @code{s} and the captured substrings in the array @emph{matches}. If it does not match, nothing is written into @emph{matches} and @code{(-1,0)} is returned.

@item findBounds
  @findex proc findBounds*(s꞉ string; pattern꞉ Regex; start = 0)꞉ tuple[first, last꞉ int]
@example
proc findBounds*(s꞉ string; pattern꞉ Regex; start = 0)꞉ tuple[first, last꞉ int]
@end example
  returns the starting position and end position of @code{pattern} in @code{s}. If it does not match, @code{(-1,0)} is returned.

@item matchLen
  @findex proc matchLen*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ int
@example
proc matchLen*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ int
@end example
  the same as @code{match}, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen.

@item matchLen
  @findex proc matchLen*(s꞉ string; pattern꞉ Regex; start = 0)꞉ int
@example
proc matchLen*(s꞉ string; pattern꞉ Regex; start = 0)꞉ int
@end example
  the same as @code{match}, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen.

@item match
  @findex proc match*(s꞉ string; pattern꞉ Regex; start = 0)꞉ bool
@example
proc match*(s꞉ string; pattern꞉ Regex; start = 0)꞉ bool
@end example
  returns @code{true} if @code{s[start..]} matches the @code{pattern}.

@item match
  @findex proc match*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ bool
@example
proc match*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ bool
@end example
  returns @code{true} if @code{s[start..]} matches the @code{pattern} and the captured substrings in the array @code{matches}. If it does not match, nothing is written into @code{matches} and @code{false} is returned.

@item find
  @findex proc find*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ int
@example
proc find*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ int
@end example
  returns the starting position of @code{pattern} in @code{s} and the captured substrings in the array @code{matches}. If it does not match, nothing is written into @code{matches} and -1 is returned.

@item find
  @findex proc find*(s꞉ string; pattern꞉ Regex; start = 0)꞉ int
@example
proc find*(s꞉ string; pattern꞉ Regex; start = 0)꞉ int
@end example
  returns the starting position of @code{pattern} in @code{s}. If it does not match, -1 is returned.

@item findAll
  @findex proc findAll*(s꞉ string; pattern꞉ Regex; start = 0)꞉ seq[string]
@example
proc findAll*(s꞉ string; pattern꞉ Regex; start = 0)꞉ seq[string]
@end example
  returns all matching @emph{substrings} of @emph{s} that match @emph{pattern}. If it does not match, @@[] is returned.

@item contains
  @findex proc contains*(s꞉ string; pattern꞉ Regex; start = 0)꞉ bool
@example
proc contains*(s꞉ string; pattern꞉ Regex; start = 0)꞉ bool
@end example
  same as @code{find(s, pattern, start) >= 0}

@item contains
  @findex proc contains*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ bool
@example
proc contains*(s꞉ string; pattern꞉ Regex; matches꞉ var openArray[string]; start = 0)꞉ bool
@end example
  same as @code{find(s, pattern, matches, start) >= 0}

@item startsWith
  @findex proc startsWith*(s꞉ string; prefix꞉ Regex)꞉ bool
@example
proc startsWith*(s꞉ string; prefix꞉ Regex)꞉ bool
@end example
  returns true if @emph{s} starts with the pattern @emph{prefix}

@item endsWith
  @findex proc endsWith*(s꞉ string; suffix꞉ Regex)꞉ bool
@example
proc endsWith*(s꞉ string; suffix꞉ Regex)꞉ bool
@end example
  returns true if @emph{s} ends with the pattern @emph{prefix}

@item replace
  @findex proc replace*(s꞉ string; sub꞉ Regex; by = "")꞉ string
@example
proc replace*(s꞉ string; sub꞉ Regex; by = "")꞉ string
@end example
  Replaces @emph{sub} in @emph{s} by the string @emph{by}. Captures cannot be accessed in @emph{by}. Examples:
@example
"var1=key; var2=key2".replace(re"(\w+)=(\w+)")
@end example
Results in:


@example

"; "
@end example

@item replacef
  @findex proc replacef*(s꞉ string; sub꞉ Regex; by꞉ string)꞉ string
@example
proc replacef*(s꞉ string; sub꞉ Regex; by꞉ string)꞉ string
@end example
  Replaces @emph{sub} in @emph{s} by the string @emph{by}. Captures can be accessed in @emph{by} with the notation @code{$i} and @code{$#} (see strutils.`%`). Examples:
@example
"var1=key; var2=key2".replacef(re"(\w+)=(\w+)", "$1<-$2$2")
@end example
Results in:

"var1<-keykey; val2<-key2key2"

@item parallelReplace
  @findex proc parallelReplace*(s꞉ string;subs꞉ openArray[tuple[pattern꞉ Regex, repl꞉ string]])꞉ string
@example
proc parallelReplace*(s꞉ string;subs꞉ openArray[tuple[pattern꞉ Regex, repl꞉ string]])꞉ string
@end example
  Returns a modified copy of @emph{s} with the substitutions in @emph{subs} applied in parallel.

@item transformFile
  @findex proc transformFile*(infile, outfile꞉ string;subs꞉ openArray[tuple[pattern꞉ Regex, repl꞉ string]])
@example
proc transformFile*(infile, outfile꞉ string;subs꞉ openArray[tuple[pattern꞉ Regex, repl꞉ string]])
@end example
  reads in the file @emph{infile}, performs a parallel replacement (calls @emph{parallelReplace}) and writes back to @emph{outfile}. Raises @code{EIO} if an error occurs. This is supposed to be used for quick scripting.

@item split
  @findex proc split*(s꞉ string; sep꞉ Regex)꞉ seq[string]
@example
proc split*(s꞉ string; sep꞉ Regex)꞉ seq[string]
@end example
  Splits the string @emph{s} into substrings.

@item escapeRe
  @findex proc escapeRe*(s꞉ string)꞉ string
@example
proc escapeRe*(s꞉ string)꞉ string
@end example
  escapes @emph{s} so that it is matched verbatim when used as a regular expression.
@end itemize

@chapter Templates

@itemize


@item `=~`
  @findex template `=~`*(s꞉ string; pattern꞉ Regex)꞉ expr
@example
template `=~`*(s꞉ string; pattern꞉ Regex)꞉ expr
@end example
  This calls @code{match} with an implicit declared @code{matches} array that can be used in the scope of the @code{=~} call:
@example

if line =~ re"\s*(\w+)\s*\=\s*(\w+)":
  # matches a key=value pair:
  echo("Key: ", matches[0])
  echo("Value: ", matches[1])
elif line =~ re"\s*(\#.*)":
  # matches a comment
  # note that the implicit ``matches`` array is different from the
  # ``matches`` array of the first branch
  echo("comment: ", matches[0])
else:
  echo("syntax error")
@end example
@end itemize




@chapter Iterators

@itemize


@item findAll
  @itindex iterator findAll*(s꞉ string; pattern꞉ Regex; start = 0)꞉ string
@example
iterator findAll*(s꞉ string; pattern꞉ Regex; start = 0)꞉ string
@end example
  Yields all matching @emph{substrings} of @emph{s} that match @emph{pattern}.

Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.

@item split
  @itindex iterator split*(s꞉ string; sep꞉ Regex)꞉ string
@example
iterator split*(s꞉ string; sep꞉ Regex)꞉ string
@end example
  Splits the string @emph{s} into substrings.

Substrings are separated by the regular expression @emph{sep}. Examples:


@example
for word in split("00232this02939is39an22example111", re"\d+"):
  writeLine(stdout, word)
@end example
Results in:


@example
""
"this"
"is"
"an"
"example"
""
@end example
@end itemize

@node /impure/db_mysql, /impure/nre/private/util , /impure/re, Top



@chapter Types

@itemize


@item InstantRow
  @tindex InstantRow* = object
  row: cstringArray
  len: int

@example
InstantRow* = object
  row: cstringArray
  len: int

@end example
  a handle that can be used to get a row's column text on demand
@end itemize

@chapter Procedures

@itemize


@item dbError
  @findex proc dbError*(db꞉ DbConn) @{.noreturn.@}
@example
proc dbError*(db꞉ DbConn) @{.noreturn.@}
@end example
  raises a DbError exception.

@item dbQuote
  @findex proc dbQuote*(s꞉ string)꞉ string
@example
proc dbQuote*(s꞉ string)꞉ string
@end example
  DB quotes the string.

@item tryExec
  @findex proc tryExec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc tryExec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ bool @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  tries to execute the query and returns true if successful, false otherwise.

@item exec
  @findex proc exec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc exec*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`]) @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  executes the query and raises EDB if not successful.

@item `[]`
  @findex proc `[]`*(row꞉ InstantRow; col꞉ int)꞉ string @{.inline.@}
@example
proc `[]`*(row꞉ InstantRow; col꞉ int)꞉ string @{.inline.@}
@end example
  Returns text for given column of the row.

@item len
  @findex proc len*(row꞉ InstantRow)꞉ int @{.inline.@}
@example
proc len*(row꞉ InstantRow)꞉ int @{.inline.@}
@end example
  Returns number of columns in the row.

@item getRow
  @findex proc getRow*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
proc getRow*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  Retrieves a single row. If the query doesn't return any rows, this proc will return a Row with empty strings for each column.

@item getAllRows
  @findex proc getAllRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@example
proc getAllRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ seq[Row] @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and returns the whole result dataset.

@item getValue
  @findex proc getValue*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@example
proc getValue*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ string @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and returns the first column of the first row of the result dataset. Returns "" if the dataset contains no rows or the database value is NULL.

@item tryInsertId
  @findex proc tryInsertId*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@example
proc tryInsertId*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@end example
  executes the query (typically "INSERT") and returns the generated ID for the row or -1 in case of an error.

@item insertId
  @findex proc insertId*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@example
proc insertId*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [WriteDbEffect].@}
@end example
  executes the query (typically "INSERT") and returns the generated ID for the row.

@item execAffectedRows
  @findex proc execAffectedRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@example
proc execAffectedRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ int64 @{.tags꞉ [ReadDbEffect, WriteDbEffect].@}
@end example
  runs the query (typically "UPDATE") and returns the number of affected rows

@item close
  @findex proc close*(db꞉ DbConn) @{.tags꞉ [DbEffect].@}
@example
proc close*(db꞉ DbConn) @{.tags꞉ [DbEffect].@}
@end example
  closes the database connection.

@item open
  @findex proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [DbEffect].@}
@example
proc open*(connection, user, password, database꞉ string)꞉ DbConn @{.tags꞉ [DbEffect].@}
@end example
  opens a database connection. Raises @emph{EDb} if the connection could not be established.

@item setEncoding
  @findex proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [DbEffect].@}
@example
proc setEncoding*(connection꞉ DbConn; encoding꞉ string)꞉ bool @{.tags꞉ [DbEffect].@}
@end example
  sets the encoding of a database connection, returns true for success, false for failure.
@end itemize





@chapter Iterators

@itemize


@item fastRows
  @itindex iterator fastRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator fastRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  executes the query and iterates over the result dataset.

This is very fast, but potentially dangerous.  Use this iterator only if you require @strong{ALL} the rows.

Breaking the fastRows() iterator during a loop will cause the next database query to raise an [EDb] exception @code{Commands out of sync}.

@item instantRows
  @itindex iterator instantRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@example
iterator instantRows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ InstantRow @{.tags꞉ [ReadDbEffect].@}
@end example
  Same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

@item instantRows
  @itindex iterator instantRows*(db꞉ DbConn; columns꞉ var DbColumns; query꞉ SqlQuery;args꞉ varargs[string, `$`])꞉ InstantRow
@example
iterator instantRows*(db꞉ DbConn; columns꞉ var DbColumns; query꞉ SqlQuery;args꞉ varargs[string, `$`])꞉ InstantRow
@end example
  Same as fastRows but returns a handle that can be used to get column text on demand using []. Returned handle is valid only within the iterator body.

@item rows
  @itindex iterator rows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@example
iterator rows*(db꞉ DbConn; query꞉ SqlQuery; args꞉ varargs[string, `$`])꞉ Row @{.tags꞉ [ReadDbEffect].@}
@end example
  same as @emph{fastRows}, but slower and safe.
@end itemize

@node /impure/nre/private/util, Variable Index, /impure/db_mysql, Top




@chapter Procedures

@itemize


@item fget
  @findex proc fget*[K, V](self꞉ Table[K, V]; key꞉ K)꞉ V
@example
proc fget*[K, V](self꞉ Table[K, V]; key꞉ K)꞉ V
@end example
  
@end itemize

@chapter Templates

@itemize


@item formatStr
  @findex template formatStr*(howExpr, namegetter, idgetter꞉ expr)꞉ expr
@example
template formatStr*(howExpr, namegetter, idgetter꞉ expr)꞉ expr
@end example
  
@end itemize





@node Variable Index, Type Index, /impure/nre/private/util, Top
@unnumbered Variable Index

@printindex vr


@node Type Index, Procedures Index, Variable Index, Top
@unnumbered Type Index

@printindex tp


@node Procedures Index, Iterator Index, Type Index, Top
@unnumbered Procedures Index

@printindex fn


@node Iterator Index, , Procedures Index, Top
@unnumbered Iterator Index

@printindex it


